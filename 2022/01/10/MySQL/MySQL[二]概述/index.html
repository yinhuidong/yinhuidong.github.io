<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL[二]概述 | 二十</title><meta name="keywords" content="MySQL"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL知识路线图">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL[二]概述">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[%E4%BA%8C]%E6%A6%82%E8%BF%B0/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="MySQL知识路线图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2022-01-10T13:58:17.078Z">
<meta property="article:modified_time" content="2022-01-11T03:14:31.883Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[%E4%BA%8C]%E6%A6%82%E8%BF%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL[二]概述',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 11:14:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL[二]概述</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-10T13:58:17.078Z" title="发表于 2022-01-10 21:58:17">2022-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T03:14:31.883Z" title="更新于 2022-01-11 11:14:31">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL[二]概述"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一，一条SQL的查询流程"><a href="#一，一条SQL的查询流程" class="headerlink" title="一，一条SQL的查询流程"></a>一，一条SQL的查询流程</h1><ol>
<li><p>去连接池获取连接</p>
</li>
<li><p>查询缓存，命中返回，否则继续向下</p>
</li>
<li><p>词法解析&amp;预处理</p>
<blockquote>
<p>词法解析拆分SQL，语法分析检查SQL的正确性生成一颗解析树，预处理检查表名，列名，生成一颗解析树。</p>
</blockquote>
</li>
<li><p>优化器优化，优化计划，查询计划</p>
</li>
<li><p>执行引擎生成执行计划</p>
</li>
<li><p>存储引擎查询SQL，加入缓存，返回结果。</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641449666256-21382ea1-bf47-4ce3-b1ea-5cb8e82965f1.png" alt="image.png"></p>
<h2 id="1-获取连接"><a href="#1-获取连接" class="headerlink" title="1.获取连接"></a>1.获取连接</h2><p>MySQL支持多种通信协议，可以使用同步/异步的方式，支持长连接，短连接。<br>​</p>
<h3 id="1-1-通信类型"><a href="#1-1-通信类型" class="headerlink" title="1.1 通信类型"></a>1.1 通信类型</h3><p>​</p>
<p>一般来说，<strong>连接数据库都是同步连接</strong>。<br>​</p>
<blockquote>
<ol>
<li>同步连接：依赖于被调用方，受限制于被调用方的性能；一般只能一对一。</li>
<li>异步连接：避免阻塞，但不能节省SQL的执行时间，并发情况下，每个SQL的执行都要单独建立连接，占用大量CPU资源；异步连接必须使用连接池减少线程创建销毁的开销。</li>
</ol>
</blockquote>
<h3 id="1-2-连接方式"><a href="#1-2-连接方式" class="headerlink" title="1.2 连接方式"></a>1.2 连接方式</h3><p>MySQL长短连接都支持，一般我们会在连接池中使用长连接。保持长连接会消耗内存，长时间不活动的连接，MySQL服务器会断开。<br>​</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">-- 非交互式超时时间，如 JDBC 程序</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;interactive_timeout&#x27;</span>; <span class="comment">-- 交互式超时时间，如数据库工具</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认长连接断开时间是8小时。</p>
</blockquote>
<p>可以使用 <code>show status;</code>查看当前MySQL有多少个连接。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Threads_cached</th>
<th>缓存中的线程连接数</th>
</tr>
</thead>
<tbody><tr>
<td>Threads_connected</td>
<td>当前打开的连接数</td>
</tr>
<tr>
<td>Threads_created</td>
<td>为处理连接创建的线程数</td>
</tr>
<tr>
<td>Threads_running</td>
<td>非睡眠状态的连接数，通常指并发连接数</td>
</tr>
</tbody></table>
<p>每产生一个连接或者会话，服务端就会创建一个线程来处理。杀死会话本质就是kill 线程。<br>​</p>
<blockquote>
<p>可以使用<code>SHOW PROCESSLIST; </code>（root 用户）查看 SQL 的执行状态。<br>​</p>
</blockquote>
<blockquote>
<p>+—-+——+———–+——+———+——+———-+<br>| Id | User | Host      | db   | Command | Time | State    | Info             |<br>+—-+——+———–+——+———+——+———-+<br>| 11 | root | localhost | NULL | Query   |    0 | starting | show processlist |<br>+—-+——+———–+——+———+——+———-+</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Sleep</td>
<td>线程正在等待客户端，以向它发送一个新语句</td>
</tr>
<tr>
<td>Query</td>
<td>线程正在执行查询或往客户端发送数据</td>
</tr>
<tr>
<td>Locked</td>
<td>该查询被其它查询锁定</td>
</tr>
<tr>
<td>Copying to tmp table on disk</td>
<td>临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器</td>
</tr>
<tr>
<td>Sending data</td>
<td>线程正在为 SELECT 语句处理行，同时正在向客户端发送数据</td>
</tr>
<tr>
<td>Sorting for group</td>
<td>线程正在进行分类，以满足 GROUP BY 要求</td>
</tr>
<tr>
<td>Sorting for order</td>
<td>线程正在进行分类，以满足 ORDER BY 要求</td>
</tr>
</tbody></table>
<p>在5.7版本，MySQL的默认连接数是151个，我们最大可以修改为16384个 （214）。<br>​</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> [<span class="keyword">global</span> <span class="operator">|</span> session] max_connections <span class="operator">=</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-3-通信协议"><a href="#1-3-通信协议" class="headerlink" title="1.3 通信协议"></a>1.3 通信协议</h3><p>​</p>
<ol>
<li>编程语言的连接模块都是用 TCP 协议连接到 MySQL 服务器的，比如mysql-connector-java-x.x.xx.jar。</li>
<li>类unix系统上，支持 Socket套接字文件进行进程间通信。<code>/tmp/mysql.sock</code></li>
<li>windows系统上还支持命名管道和共享内存。</li>
</ol>
<p>​</p>
<h3 id="1-4-通信方式"><a href="#1-4-通信方式" class="headerlink" title="1.4 通信方式"></a>1.4 通信方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641431698698-e3b38143-26dc-439d-8a75-feff85dbc973.png" alt="image.png"><br>MySQL使用了半双工通信，所以客户端发送SQL语句给服务端的时候，不管SQL有多大，都是一次发过去的。<br>​</p>
<blockquote>
<p>比如我们用MyBatis动态SQL生成了一个批量插入的语句，插入10万条数据，values后面跟了一长串的内容，或者 where 条件 in 里面的值太多，会出现问题。这个时候我们必须要调整 MySQL 服务器配置 max_allowed_packet 参数的值（默认是 4M），把它调大，否则就会报错。</p>
</blockquote>
<p>对于服务端来说，也是一次性发送所有的数据，不能因为你已经取到了想要的数据就中断操作，这个时候会对网络和内存产生大量消耗。在程序里面避免不带 limit 的这种操作，比如一次把所有满足条件的数据全部查出来，一定要先 count 一下。如果数据量的话，可以分批查询。</p>
<hr>
<h2 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h2><p>MySQL 的缓存默认是关闭的。<br>​</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>MySQL不推荐使用自带的缓存，命中条件过于苛刻。且表里数据发生变化，整张表的缓存全部失效，MySQL8移除掉了缓存。</p>
<hr>
<h2 id="3-语法解析-amp-预处理"><a href="#3-语法解析-amp-预处理" class="headerlink" title="3.语法解析&amp;预处理"></a>3.语法解析&amp;预处理</h2><h3 id="3-1-词法解析"><a href="#3-1-词法解析" class="headerlink" title="3.1 词法解析"></a>3.1 词法解析</h3><p>词法分析就是把一个完整的 SQL 语句打碎成一个个的单词。<br>​</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>它会打碎成 8 个符号，每个符号是什么类型，从哪里开始到哪里结束。<br>​</p>
<h3 id="3-2-语法解析"><a href="#3-2-语法解析" class="headerlink" title="3.2 语法解析"></a>3.2 语法解析</h3><p>语法分析会对 SQL 做一些语法检查，比如单引号有没有闭合，然后根据 MySQL 定义的语法规则，根据 SQL 语句生成一个数据结构。这个数据结构我们把它叫做解析树（select_lex）。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641432113376-2499bc3f-6277-49aa-8a99-eb135ce35507.png" alt="image.png"></p>
<blockquote>
<p>任何数据库的中间件，比如 Mycat，Sharding-JDBC（用到了 Druid Parser），都必须要有词法和语法分析功能。</p>
</blockquote>
<h3 id="3-3-预处理"><a href="#3-3-预处理" class="headerlink" title="3.3 预处理"></a>3.3 预处理</h3><p>​</p>
<p>如果写了一个词法和语法都正确的 SQL，但是表名或者字段不存在，会在哪里报错？是在数据库的执行层还是解析器？<br>​</p>
<p>实际上还是在解析的时候报错，解析 SQL 的环节里面有个预处理器。它会检查生成的解析树，解决解析器无法解析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理之后得到一个新的解析树。<br>​</p>
<hr>
<h2 id="4-查询优化-amp-查询执行计划"><a href="#4-查询优化-amp-查询执行计划" class="headerlink" title="4.查询优化&amp;查询执行计划"></a>4.查询优化&amp;查询执行计划</h2><p>一条SQL语句的执行方式有很多种，但是最终返回的结果都是相同的。查询优化器的目的就是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，那种执行计划开销最小，就用哪种。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看查询的开销</span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-优化器的作用"><a href="#4-1-优化器的作用" class="headerlink" title="4.1 优化器的作用"></a>4.1 优化器的作用</h3><ol>
<li>多表联查，以哪张表为基准表</li>
<li>用不用索引，用哪个索引</li>
<li>。。。。</li>
</ol>
<p>​</p>
<h3 id="4-2-优化器是怎么得到执行计划的"><a href="#4-2-优化器是怎么得到执行计划的" class="headerlink" title="4.2 优化器是怎么得到执行计划的"></a>4.2 优化器是怎么得到执行计划的</h3><ol>
<li>首先我们要启用优化器的追踪（默认是关闭的）。</li>
</ol>
<blockquote>
<p>开启这开关是会消耗性能的，因为它要把优化分析的结果写到表里面，所以不要轻易开启，或者查看完之后关闭它（改成 off）。</p>
</blockquote>
<ol start="2">
<li>接着执行一个 SQL 语句，优化器会生成执行计划：</li>
</ol>
<ol start="3">
<li>这个时候优化器分析的过程已经记录到系统表里面了，我们可以查询：</li>
</ol>
<blockquote>
<p>它是一个 JSON 类型的数据，主要分成三部分，准备阶段、优化阶段和执行阶段。</p>
</blockquote>
<blockquote>
<p>expanded_query 是优化后的 SQL 语句。</p>
</blockquote>
<blockquote>
<p>considered_execution_plans 里面列出了所有的执行计划。</p>
</blockquote>
<ol start="4">
<li>分析完记得关掉它</li>
</ol>
<blockquote>
<p>通过追踪优化器，可以看到优化器对sql的初始优化，表的读取顺序，为什么采用了这种读取顺序。为什么采用了某个索引或者采用了全表查询。</p>
</blockquote>
<h3 id="4-3-优化器得到的结果"><a href="#4-3-优化器得到的结果" class="headerlink" title="4.3 优化器得到的结果"></a>4.3 优化器得到的结果</h3><p>​</p>
<p>优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。</p>
<p>当然，这个执行计划是不是一定是最优的执行计划呢？不一定，因为 MySQL 也有可能覆盖不到所有的执行计划。<br>​</p>
<p>MySQL 提供了一个执行计划的工具。我们在 SQL 语句前面加上 EXPLAIN，就可以看到执行计划的信息。<br>​</p>
<p><strong>Explain 的结果也不一定最终执行的方式。</strong><br><strong>​</strong></p>
<h3 id="4-4-选错索引"><a href="#4-4-选错索引" class="headerlink" title="4.4 选错索引"></a>4.4 选错索引</h3><p>这里错误决定分两类，第一，彻底错误。第二，基于成本最低，但执行速度不是最快。</p>
<ol>
<li><p>由于InnoDB的 MVCC 功能和随机采样方式，默认随机采取几个数据页，当做总体数据。以部分代表整体，本来就有错误的风险。加上数据不断地添加过程中，索引树可能会分裂，结果更加不准确。 </p>
<blockquote>
<ol>
<li>执行 ANALYZE TABLE ,可以重新构建索引，使索引树不过于分裂。</li>
<li>调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。</li>
</ol>
</blockquote>
</li>
<li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。 </p>
<blockquote>
<ol>
<li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li>
<li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。 </li>
</ol>
</blockquote>
</li>
</ol>
<hr>
<h2 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5. 存储引擎"></a>5. 存储引擎</h2><p>得到执行计划以后，SQL 语句是不是终于可以执行了？</p>
<ol>
<li>从逻辑的角度来说，我们的数据是放在哪里的，或者说放在一个什么结构里面？</li>
</ol>
<ol start="2">
<li>执行计划在哪里执行？是谁去执行？</li>
</ol>
<p>表在存储数据的同时，还要组织数据的存储结构，这个存储结构就是由存储引擎决定的，所以也可以把存储引擎叫做表类型。</p>
<p>在 MySQL 里面，支持多种存储引擎，他们是可以替换的，所以叫做插件式的存储引擎。<br>​</p>
<h3 id="5-1-查看存储引擎"><a href="#5-1-查看存储引擎" class="headerlink" title="5.1 查看存储引擎"></a>5.1 查看存储引擎</h3><p>我们数据库里面已经存在的表，我们怎么查看它们的存储引擎呢？<br>​</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> `数据库名`;</span><br></pre></td></tr></table></figure>
<p>或者通过 DDL 建表语句来查看。<br>​</p>
<p>在 MySQL 里面，我们创建的每一张表都可以指定它的存储引擎，而不是一个数据库只能使用一个存储引擎。存储引擎的使用是以表为单位的。而且，创建表之后还可以修改存储引擎。<br>​</p>
<p>一张表使用的存储引擎决定存储数据的结构，那在服务器上它们是怎么存储的呢？先要找到数据库存放数据的路径：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434256832-de450340-7be5-41be-845e-61c79f6b4f82.png" alt="image.png"><br>默认情况下，每个数据库有一个自己文件夹，以 yhd数据库为例。任何一个存储引擎都有一个 frm 文件，这个是表结构定义文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434747584-0e54ae84-325f-48ba-9586-59d5b480aa92.png" alt="image.png"><br>不同的存储引擎存放数据的方式不一样，产生的文件也不一样，innodb 是 1 个，memory 没有，myisam 是两个。</p>
<h3 id="5-2-存储引擎比较"><a href="#5-2-存储引擎比较" class="headerlink" title="5.2 存储引擎比较"></a>5.2 存储引擎比较</h3><h4 id="①常见存储引擎"><a href="#①常见存储引擎" class="headerlink" title="①常见存储引擎"></a>①常见存储引擎</h4><p>MyISAM 和 InnoDB 是我们用得最多的两个存储引擎，在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，它是 MySQL 自带的。</p>
<p>5.5 版本之后默认的存储引擎改成了 InnoDB，最主要的原因还是 InnoDB 支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。</p>
<h4 id="②数据库支持的存储引擎"><a href="#②数据库支持的存储引擎" class="headerlink" title="②数据库支持的存储引擎"></a>②数据库支持的存储引擎</h4><p>可以用这个命令查看数据库对存储引擎的支持情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines ;</span><br></pre></td></tr></table></figure>


<p>其中有存储引擎的描述和对事务、XA 协议和 Savepoints 的支持。</p>
<p>XA 协议用来实现分布式事务（分为本地资源管理器，事务管理器）。</p>
<p>Savepoints 用来实现子事务（嵌套事务）。创建了一个 Savepoints 之后，事务就可以回滚到这个点，不会影响到创建 Savepoints 之前的操作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641435383199-5ae5e040-4df5-4a35-94ba-e8e13b19fe54.png" alt="image.png"></p>
<h4 id="③MyISAM（3-个文件）"><a href="#③MyISAM（3-个文件）" class="headerlink" title="③MyISAM（3  个文件）"></a>③MyISAM（3  个文件）</h4><p>应用范围比较小。表级锁定限制了读/写的性能，因此在 Web 和数据仓库配置中，它通常用于只读或以读为主的工作。</p>
<p><strong>特点</strong></p>
<ol>
<li>支持表级别的锁（插入和更新会锁表）。不支持事务。</li>
</ol>
<ol start="2">
<li>拥有较高的插入（insert）和查询（select）速度。</li>
</ol>
<ol start="3">
<li>存储了表的行数（count 速度更快）。</li>
</ol>
<p>适合：只读之类的数据分析的项目。</p>
<h4 id="④InnoDB（2个文件）"><a href="#④InnoDB（2个文件）" class="headerlink" title="④InnoDB（2个文件）"></a>④InnoDB（2个文件）</h4><p>mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全（与 ACID 兼容）的 MySQL存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB 行级锁（不升级为更粗粒度的锁）和 Oracle 风格的一致非锁读提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中，以减少基于主键的常见查询的 I/O。为了保持数据完整性，InnoDB 还支持外键引用完整性约束。</p>
<p><strong>特点</strong></p>
<ol>
<li>支持事务，支持外键，因此数据的完整性、一致性更高。</li>
</ol>
<ol start="2">
<li>支持行级别的锁和表级别的锁。</li>
</ol>
<ol start="3">
<li>支持读写并发，写不阻塞读（MVCC）。</li>
</ol>
<ol start="4">
<li>特殊的索引存放方式，可以减少 IO，提升查询效率。</li>
</ol>
<p>适合：经常更新的表，存在并发读写或者有事务处理的业务系统。</p>
<h4 id="⑤Memory-1个文件"><a href="#⑤Memory-1个文件" class="headerlink" title="⑤Memory(1个文件)"></a>⑤Memory(1个文件)</h4><p>基于内存的存储引擎。</p>
<p>特征：</p>
<ul>
<li>基于内存的表，服务器重启后，表结构会被保留，但表中的数据会被清空。</li>
<li>不需要进行磁盘IO，比 MYISAM 快了一个数量级。</li>
<li>表级锁，故并发插入性能较低。</li>
<li>每一行是固定的，VARCHAR 列在 memory 存储引擎中会变成 CHAR，可能导致内存浪费。</li>
<li>不支持 BLOB 或 TEXT 列，如果sql返回的结果列中包含 BLOB 或 TEXT，就直接采用 MYISAM 存储引擎，在磁盘上建临时表</li>
<li>支持哈希索引，B+树索引</li>
</ul>
<p>MEMORY 存储引擎在很多地方可以发挥很好的作用：</p>
<ul>
<li>用于查找或映射表，例如邮编和州名的映射表</li>
<li>用于缓存周期性聚合数据的结果</li>
<li>用于保存数据分析中产生的中间结果。即SQL执行过程中用到的临时表</li>
<li>监控MySQL内存中的执行情况，例如：information_schema 库下的表基本都是 memory 存储引擎，监控InnoDB缓冲池中page(INNODB_BUFFER_PAGE表)，InnoDB缓冲池状态(INNODB_BUFFER_POOL_STATS表)、InnoDB缓存页淘汰记录(INNODB_BUFFER_PAGE_LRU表)、InnoDB锁等待(INNODB_LOCK_WAITS表)、InnoDB锁信息(INNODB_LOCKS表)、InnoDB中正在执行的事务(INNODB_TRX表)等。</li>
</ul>
<p><strong>MEMORY 存储引擎默认 hash 索引，故等值查询特别快。同时也支持B+树索引。虽然查询速度特别快，但依旧无法取代传统的磁盘建表。</strong></p>
<h4 id="⑥CSV-3个文件"><a href="#⑥CSV-3个文件" class="headerlink" title="⑥CSV(3个文件)"></a>⑥CSV(3个文件)</h4><p>它的表实际上是带有逗号分隔值的文本文件。csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据。因为 csv 表没有索引，所以通常在正常操作期间将数据保存在 innodb 表中，并且只在导入或导出阶段使用 csv 表。</p>
<p><strong>特点</strong></p>
<p>不允许空行，不支持索引。格式通用，可以直接编辑，适合在不同数据库之间导入导出。<br>​</p>
<h3 id="5-3-如何选择存储引擎"><a href="#5-3-如何选择存储引擎" class="headerlink" title="5.3 如何选择存储引擎"></a>5.3 如何选择存储引擎</h3><ol>
<li>如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。</li>
</ol>
<ol start="2">
<li>如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。</li>
</ol>
<ol start="3">
<li>如果需要一个用于查询的临时表，可以选择 Memory。</li>
</ol>
<p>​</p>
<hr>
<h2 id="6-执行引擎"><a href="#6-执行引擎" class="headerlink" title="6.执行引擎"></a>6.执行引擎</h2><p>执行引擎，它利用存储引擎提供的相应的 API 来完成操作。</p>
<p>为什么我们修改了表的存储引擎，操作方式不需要做任何改变？因为不同功能的存储引擎实现的 API 是相同的。</p>
<p>最后把数据返回给客户端，即使没有结果也要返回。<br>​</p>
<hr>
<h1 id="二，一条SQL的更新流程"><a href="#二，一条SQL的更新流程" class="headerlink" title="二，一条SQL的更新流程"></a>二，一条SQL的更新流程</h1><p>更新和查询很多地方并没有区别，仅仅在于拿到数据之后的操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641458151710-45fe3a24-a127-401d-abec-75f52f953f3d.png" alt="image.png"></p>
<h2 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1.内存结构"></a>1.内存结构</h2><p>InnnoDB 的数据都是放在磁盘上的，InnoDB 操作数据有一个最小的逻辑单位，叫做页（索引页和数据页）。我们对于数据的操作，不是每次都直接操作磁盘，因为磁盘的速度太慢了。InnoDB 使用了一种缓冲池的技术，也就是把磁盘读到的页放到一块内存区域里面。这个内存区域就叫 Buffer Pool。<br>​</p>
<p>下一次读取相同的页，先判断是不是在缓冲池里面，如果是，就直接读取，不用再次访问磁盘。</p>
<p>修改数据的时候，先修改缓冲池里面的页。内存的数据页和磁盘数据不一致的时候，我们把它叫做脏页。InnoDB 里面有专门的后台线程把 Buffer Pool 的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p>
<p>Buffer Pool 是 InnoDB 里面非常重要的一个结构，主要分为 3 个部分： Buffer Pool、Change Buffer、Adaptive HashIndex，另外还有一个（redo）log buffer。<br>​</p>
<h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>Buffer Pool 缓存的是页信息，包括数据页、索引页，默认大小是 128M（134217728 字节），可以调整。</p>
<p>查看服务器状态，里面有很多跟 Buffer Pool 相关的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure>


<p>查看参数（系统变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES like &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure>


<p>内存的缓冲池写满了怎么办？（Redis 设置的内存满了怎么办？）InnoDB 用 LRU算法来管理缓冲池（链表实现，不是传统的 LRU，分成了 young 和 old），经过淘汰的数据就是热点数据。</p>
<p>内存缓冲区对于提升读写性能有很大的作用。当需要更新一个数据页时，如果数据页在 Buffer Pool 中存在，那么就直接更新好了。否则的话就需要从磁盘加载到内存，再对内存的数据页进行操作。也就是说，如果没有命中缓冲池，至少要产生一次磁盘 IO。<br>​</p>
<h3 id="1-2-ChangeBuffer写缓冲"><a href="#1-2-ChangeBuffer写缓冲" class="headerlink" title="1.2 ChangeBuffer写缓冲"></a>1.2 ChangeBuffer写缓冲</h3><p>如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓冲池中，从而提升更新语句（Insert、Delete、Update）的执行速度。</p>
<p>这一块区域就是 Change Buffer。5.5 之前叫 Insert Buffer 插入缓冲，现在也能支持 delete 和 update。</p>
<p>最后把 Change Buffer 记录到数据页的操作叫做 merge。什么时候发生 merge？有几种情况：在访问这个数据页的时候，或者通过后台线程、或者数据库 shut down、redo log 写满时触发。</p>
<p>如果数据库大部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以使用 Change Buffer（写缓冲）。写多读少的业务，调大这个值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_change_buffer_max_size&#x27;;</span><br></pre></td></tr></table></figure>


<p>代表 Change Buffer 占 Buffer Pool 的比例，默认 25%。<br>​</p>
<h3 id="1-3-Adaptive-Hash-Index"><a href="#1-3-Adaptive-Hash-Index" class="headerlink" title="1.3 Adaptive Hash Index"></a>1.3 Adaptive Hash Index</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？</p>
<p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p>
<p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。<br>​</p>
<h3 id="1-4-（redo）Log-Buffer"><a href="#1-4-（redo）Log-Buffer" class="headerlink" title="1.4 （redo）Log Buffer"></a>1.4 （redo）Log Buffer</h3><p>​</p>
<p>如果 Buffer Pool 里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据丢失。如果写操作写到一半，甚至可能会破坏数据文件导致数据库不可用。为了避免这个问题，InnoDB 把所有对页面的修改操作专门写入一个日志文件，并且在数据库启动时从这个文件进行恢复操作（实现 crash-safe）——用它来实现事务的持久性。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478367975-c4e017fe-92ed-440a-8fb3-3efc4c310546.png" alt="image.png"><br>这个文件就是磁盘的 redo log（叫做重做日志），对应于/var/lib/mysql/目录下的ib_logfile0 和 ib_logfile1，每个 48M。这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里 的 WAL 技 术（Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log%&#x27;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>innodb_log_file_size</td>
<td>指定每个文件的大小，默认 48M</td>
</tr>
<tr>
<td>innodb_log_files_in_group</td>
<td>指定文件的数量，默认为 2</td>
</tr>
<tr>
<td>innodb_log_group_home_dir</td>
<td>指定文件所在路径，相对或绝对。如果不指定，则为datadir 路径。</td>
</tr>
</tbody></table>
<p><strong>同样是写磁盘，为什么不直接写到 db file 里面去？为什么先写日志再写磁盘？</strong></p>
<p>磁盘的最小组成单元是扇区，通常是 512 个字节。操作系统和内存打交道，最小的单位是页 Page。操作系统和磁盘打交道，读写磁盘，最小的单位是块 Block。<br>​</p>
<p>如果我们所需要的数据是随机分散在不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们所需要的一块数据，依次进行此过程直到找完所有数据，这个就是随机 IO，读取数据速度较慢。</p>
<p>假设我们已经找到了第一块数据，并且其他所需的数据就在这一块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序 IO。</p>
<p>刷盘是随机 I/O，而记录日志是顺序 I/O，顺序 I/O 效率更高。因此先把修改写入日志，可以延迟刷盘时机，进而提升系统吞吐。</p>
<p>当然 redo log 也不是每一次都直接写入磁盘，在 Buffer Pool 里面有一块内存区域（Log Buffer）专门用来保存即将要写入日志文件的数据，默认 16M，它一样可以节省磁盘 IO。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478572344-fc83dc25-3a96-42fd-8017-03423f4d9f49.png" alt="image.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>redo log 的内容主要是用于崩溃恢复。磁盘的数据文件，数据来自 buffer pool。redo log 写入磁盘，不是写入数据文件。</p>
</blockquote>
<p>那么，Log Buffer 什么时候写入 log file？</p>
<p>在我们写入数据到磁盘的时候，操作系统本身是有缓存的。flush 就是把操作系统缓冲区写入到磁盘。</p>
<p>log buffer 写入磁盘的时机，由一个参数控制，默认是 1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_flush_log_at_trx_commit&#x27;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0（延迟写）</td>
<td>log buffer 将每秒一次地写入 log file 中，并且 log file 的 flush 操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。</td>
</tr>
<tr>
<td>1（默认，实时写，实时刷）</td>
<td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，并且刷到磁盘中去。</td>
</tr>
<tr>
<td>2（实时写，延迟刷）</td>
<td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file。但是 flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次 flush 操作。</td>
</tr>
</tbody></table>
<p>redo log，它又分成内存和磁盘两部分。redo log 有什么特点？</p>
<ol>
<li>redo log 是 InnoDB 存储引擎实现的，并不是所有存储引擎都有。</li>
</ol>
<ol start="2">
<li>不是记录数据页更新之后的状态，而是记录这个页做了什么改动，属于物理日志。（redo log 记录的是执行的结果）</li>
</ol>
<ol start="3">
<li>redo log 的大小是固定的，前面的内容会被覆盖。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478994184-25e740bb-80a0-48fe-9327-bc4bb7da7192.png" alt="image.png"><br>check point 是当前要覆盖的位置。如果 write pos 跟 check point 重叠，说明 redolog 已经写满，这时候需要同步 redo log 到磁盘中。</p>
<p>这是 MySQL 的内存结构，总结一下，分为：Buffer pool、change buffer、Adaptive Hash Index、 log buffer。</p>
<blockquote>
<p>磁盘结构里面主要是各种各样的表空间，叫做 Table space。</p>
</blockquote>
<h3 id="1-5-缓存的疑问"><a href="#1-5-缓存的疑问" class="headerlink" title="1.5 缓存的疑问"></a>1.5 缓存的疑问</h3><p><strong>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</strong></p>
<p>然后，InnoDB架构中，有非常重要的一个部分——<strong>缓冲池</strong>。该缓冲池需要占用服务器内存，且<strong>专用于MySQL的服务器，建议把80%的内存交给MySQL。</strong></p>
<p>缓冲池有一个缓存的功能。这个缓存，是InnoDB自带的，而且经常会用到。该缓存功能并不是MySQL架构中的缓存组件。这是两者最大的区别。</p>
<ul>
<li>MySQL组件中的缓存 <ol>
<li>所处位置：MySQL架构中的缓存组件</li>
<li>缓存内容：缓存的是SQL 和 该SQL的查询结果。如果SQL的大小写，格式，注释不一致，则被认为是不同的SQL，重新查询数据库，并缓存一份数据。</li>
<li>可否关闭：是可以手动关闭，并卸载该组件的。</li>
</ol>
</li>
<li>InnoDB中的缓存 <ol>
<li>所处位置：InnoDB架构中的缓冲池</li>
<li>缓存内容：缓存的是所有需要查找的数据，所在的数据页。</li>
<li>可否关闭：是InnoDB缓冲池自带的功能，<strong>无法关闭，无法卸载</strong>。如果InnoDB的缓冲池被关闭或卸载，则InnoDB直接瘫痪。所以说缓冲池是InnoDB的最重要的一部分。</li>
</ol>
</li>
</ul>
<p>不建议使用MySQL的缓存是指，不建议使用MySQL架构中的缓存组件，并不是同时否定了InnoDB中的缓存功能。<br>​</p>
<hr>
<h2 id="2-磁盘结构"><a href="#2-磁盘结构" class="headerlink" title="2.磁盘结构"></a>2.磁盘结构</h2><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB 的表空间分为 5 大类。<br>​</p>
<h3 id="2-1-系统表空间"><a href="#2-1-系统表空间" class="headerlink" title="2.1 系统表空间"></a>2.1 系统表空间</h3><p>在默认情况下 InnoDB 存储引擎有一个共享表空间（对应文件/var/lib/mysql/ibdata1），也叫系统表空间。</p>
<p>InnoDB 系统表空间包含 InnoDB 数据字典和双写缓冲区，（Change Buffer 和 UndoLogs），如果没有指定 file-per-table，也包含用户创建的表和索引数据。</p>
<ol>
<li>undo 在后面介绍，因为有独立的表空间。</li>
</ol>
<ol start="2">
<li>数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）。</li>
</ol>
<ol start="3">
<li>双写缓冲（InnoDB 的一大特性）</li>
</ol>
<p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641479261038-52879c45-835e-4fae-abcd-1ca4ac1f9c66.png" alt="image.png"></p>
<p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_doublewrite&#x27;;</span><br></pre></td></tr></table></figure>


<p>如果这个页本身已经损坏了，用它来做崩溃恢复是没有意义的。所以在对于应用 redo log 之前，需要一个页的副本。如果出现了写入失效，就用页的副本来还原这个页，然后再应用 redo log。这个页的副本就是 double write，InnoDB 的双写技术。通过它实现了数据页的可靠性。</p>
<p>跟 redo log 一样，double write 由两部分组成，一部分是内存的 double write，一个部分是磁盘上的 double write。因为 double write 是顺序写入的，不会带来很大的开销。</p>
<p>在MySQL5.7之前，所有的表共享一个系统表空间，这个文件会越来越大，而且它的空间不会收缩。<br>​</p>
<h3 id="2-2-独占表空间"><a href="#2-2-独占表空间" class="headerlink" title="2.2 独占表空间"></a>2.2 独占表空间</h3><p>我们可以让每张表独占一个表空间。这个开关通过 innodb_file_per_table 设置，默认开启。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure>


<p>开启后，则每张表会开辟一个表空间，这个文件就是数据目录下的 ibd 文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间内。<br>​</p>
<h3 id="2-3-通用表空间"><a href="#2-3-通用表空间" class="headerlink" title="2.3 通用表空间"></a>2.3 通用表空间</h3><p>通用表空间也是一种共享的表空间，跟 ibdata1 类似。</p>
<p>可以创建一个通用的表空间，用来存储不同数据库的表，数据路径和文件可以自定义。语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace ts2673 add datafile &#x27;/var/lib/mysql/ts2673.ibd&#x27; file_block_size=16K engine=innodb;</span><br></pre></td></tr></table></figure>


<p>在创建表的时候可以指定表空间，用 ALTER 修改表空间可以转移表空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2673(id integer) tablespace ts2673;</span><br></pre></td></tr></table></figure>


<p>不同表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table t2673;</span><br><span class="line">drop tablespace ts2673;</span><br></pre></td></tr></table></figure>


<h3 id="2-4-临时表空间"><a href="#2-4-临时表空间" class="headerlink" title="2.4 临时表空间"></a>2.4 临时表空间</h3><p>存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的 ibtmp1 文件。当数据服务器正常关闭时，该表空间被删除，下次重新产生。</p>
<p><strong>memory向template的过渡，还有磁盘上简历临时表用的什么存储引擎？</strong></p>
<p>8.0之前，内存临时表用Memory引擎创建，但假如字段中有BLOB或TEXT,或结果太大，就会转用MYISM在磁盘上建表，8.0之后内存临时表由MEMORY引擎更改为TempTable引擎，相比于前者，后者支持以变长方式存储VARCHAR，VARBINARY等变长字段。从MySQL 8.0.13开始，TempTable引擎支持BLOB字段。如果超过内存表大小，则用InnoDB建表。</p>
<h3 id="2-5-redo-log"><a href="#2-5-redo-log" class="headerlink" title="2.5 redo log"></a>2.5 redo log</h3><h3 id="2-6-undo-log-表空间"><a href="#2-6-undo-log-表空间" class="headerlink" title="2.6 undo log 表空间"></a>2.6 undo log 表空间</h3><p>undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态（不包括 select）。</p>
<p>如果修改数据时出现异常，可以用 undo log 来实现回滚操作（保持原子性）。</p>
<p>在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，属于逻辑格式的日志(记录操作)。</p>
<p>redo Log 和 undo Log 与事务密切相关，统称为事务日志。</p>
<p>undo Log 的数据默认在系统表空间 ibdata1 文件中，因为共享表空间不会自动收缩，也可以单独创建一个 undo 表空间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%undo%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h3 id="2-7-一条SQL的更新流程"><a href="#2-7-一条SQL的更新流程" class="headerlink" title="2.7 一条SQL的更新流程"></a>2.7 一条SQL的更新流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<ol>
<li>事务开始，从内存或者磁盘取到这条数据，返回给server的执行器</li>
<li>执行器修改这一行数据的值为二十</li>
<li>记录name =yhd 到undo log</li>
<li>记录name = 二十 到redo log</li>
<li>调用存储引擎接口，在buffer pool 中修改 name =二十</li>
<li>事务提交</li>
</ol>
<p>​</p>
<blockquote>
<p>内存和磁盘之间，工作着很多后台线程。</p>
</blockquote>
<hr>
<h2 id="3-后台线程"><a href="#3-后台线程" class="headerlink" title="3.后台线程"></a>3.后台线程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641480352645-ff2557dd-b622-49e2-829c-d058bbe6d559.png" alt="image.png"><br>后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master线程，IO 线程，purge 线程，page cleaner 线程。<br>​</p>
<h3 id="3-1-Master-线程"><a href="#3-1-Master-线程" class="headerlink" title="3.1 Master 线程"></a>3.1 Master 线程</h3><p>Master Thread是InnoDB存储引擎非常核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。<br>​</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    thread_sleep(<span class="number">1</span>);							<span class="comment">// sleep 1秒</span></span><br><span class="line">        <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">        <span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">        <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)	</span><br><span class="line">        									  <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct(默认是75时)</span></span><br><span class="line">            <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;	<span class="comment">// 刷新100脏页到磁盘</span></span><br><span class="line">        <span class="keyword">if</span>(no user activity)</span><br><span class="line">            <span class="keyword">goto</span> backgroud loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>) 	<span class="comment">// 如果过去10内磁盘IO次数小于设置的innodb_io_capacity的值（默认是200）</span></span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer; 	<span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">    <span class="keyword">do</span> full purge;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; <span class="number">70</span>%)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer pool flush <span class="number">10</span> dirty page;</span><br><span class="line"></span><br><span class="line">    backgroud loop：	<span class="comment">// 后台循环</span></span><br><span class="line">    <span class="keyword">do</span> full purge	<span class="comment">// 删除无用的undo页 （总是）</span></span><br><span class="line">    <span class="keyword">do</span> merge <span class="number">20</span> insert buffer;	<span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idle					<span class="comment">// 如果不空闲，就跳回主循环，如果空闲就跳入flush loop</span></span><br><span class="line">        <span class="keyword">goto</span> loop:				<span class="comment">// 跳到主循环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop</span><br><span class="line"></span><br><span class="line">    flush loop:					<span class="comment">// 刷新循环</span></span><br><span class="line">    <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)	</span><br><span class="line">    							<span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct的值（默认75%）</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop;		<span class="comment">// 跳到刷新循环，不断刷新脏页，直到符合条件</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">goto</span> suspend loop;		<span class="comment">// 完成刷新脏页的任务后，跳入suspend loop</span></span><br><span class="line"></span><br><span class="line">    suspend loop:</span><br><span class="line">    suspend_thread();			<span class="comment">//master线程挂起，等待事件发生</span></span><br><span class="line">    waiting event;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Master Thread具有<strong>最高的线程优先级别</strong>。内部由多个循环组成：<strong>主循环（loop）</strong>、<strong>后台循环</strong>（backgroup loop）、<strong>刷新循环</strong>（flush loop）、<strong>暂停循环</strong>（suspend loop）。Master Thread会<strong>根据数据库运行的状态</strong>在loop、backgroup loop、flush loop和suspend loop中<strong>进行切换</strong>。loop是主循环，大多数的操作都在这个循环中，主要有两大部分的操作——每秒钟的操作和每10秒钟的操作。<br>​</p>
<h4 id="①每秒钟的操作"><a href="#①每秒钟的操作" class="headerlink" title="①每秒钟的操作"></a>①每秒钟的操作</h4><p>​</p>
<ol>
<li>​<strong>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）</strong>；<br>即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这也解释了为什么再大的事务提交的时间也是很短的。 </li>
<li> <strong>合并插入缓冲（可能）</strong>；<br>合并插入缓冲并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB存储引擎认为当前的IO压力很小，可以执行合并插入缓冲的操作； </li>
<li> <strong>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</strong>； 刷新100个脏页也不是每秒都会发生的，InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_get_modified_ratio_pct)是否超过了配置文件中 innodb_max_dirty_pages_pct这个参数（默认是75，代表75%），如果超过了这个值，InnoDB存储引擎则认为需要做磁盘同步的操作，将100个脏页写入磁盘中。 </li>
<li> <strong>如果当前没有用户活动，则切换到background loop(可能)。</strong></li>
</ol>
<p><strong>​</strong></p>
<h4 id="②每十秒的操作"><a href="#②每十秒的操作" class="headerlink" title="②每十秒的操作"></a>②每十秒的操作</h4><ol>
<li> <strong>刷新100个脏页到磁盘（可能）</strong> InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO能力，因此将100个脏页刷新到磁盘。 </li>
<li> <strong>合并至多5个插入缓冲（总是）</strong> </li>
<li> <strong>将日志缓冲刷新到磁盘（总是）</strong> </li>
<li> <strong>删除无用的Undo页（总是）</strong> </li>
<li> <strong>刷新100个或者10个脏页到磁盘（总是）</strong> InnoDB存储引擎会执行full purge操作，即删除无用的Undo页。对表进行update，delete这类的操作时，原先的行被标记为删除，但是因为一致性读的关系，需要保留这些行版本的信息。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB存储引擎会立即将其删除。从源代码中可以看出，InnoDB存储引擎在执行full purge 操作时，每次最多尝试回收20个undo页。<br>然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf_get_modified_ratio_pct）,如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%,则只需刷新10%的脏页到磁盘。</li>
</ol>
<p>​</p>
<hr>
<p>如果当前没有用户活动（数据库空闲）或者数据库关系，就会切换到backgroud loop这个循环。 backgroud loop会执行以下操作：</p>
<ol>
<li><strong>删除无用的Undo页（总是）</strong></li>
<li><strong>合并20个插入缓冲（总是）</strong></li>
<li><strong>跳回到主循环（总是）</strong></li>
<li><strong>不断刷新100个页直到符合条件（可能，需要跳转到flush loop中完成）</strong></li>
</ol>
<p>如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。<br>​</p>
<p>1.0.x版本中，InnoDB存储引擎最多只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，那么可能会来不及刷新所有的脏页以及合并插入缓冲。后来，InnoDB存储引擎提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。<br>​</p>
<p>对于刷新到磁盘的页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p>
<ol>
<li>在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%;</li>
<li>在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity;</li>
</ol>
<p>如果用户使用的是SSD类的磁盘，可以将innodb_io_capacity的值调高，直到符合磁盘IO的吞吐量为止；</p>
<p>另一个问题是参数innodb_max_dirty_pages_pct的默认值，在1.0.x版本之前，该值的默认值是90，意味着脏页占缓冲池的90%。InnoDB存储引擎在每秒刷新缓冲池和flush loop时会判断这个值，如果该值大于innodb_max_dirty_pages_pct,才会刷新100个脏页，如果有很大的内存，或者数据库服务器的压力很大，这时刷新脏页的速度反而会降低。 后来将innodb_max_dirty_pages_pct的默认值改为了75。这样既可以加快刷新脏页的频率，又能够保证磁盘IO的负载。<br>​</p>
<p>还有一个新的参数是innodb_adaptive_flushing(自适应地刷新)，该值影响每秒刷新脏页的数量。原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页；大于innodb_max_dirty_pages_pct时，刷新100个脏页。随着innodb_adaptive_flushing参数的引入，InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新脏页最合适的数量。buf_flush_get_desired_flush_rate函数通过判断产生重做日志的速率来决定最合适的刷新脏页数量。</p>
<p>之前每次进行full purge 操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size,该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改。<br>​</p>
<p>1.2.x版本中再次对Master Thread进行了优化，对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。<br><strong>​</strong></p>
<h3 id="3-2-IO-线程"><a href="#3-2-IO-线程" class="headerlink" title="3.2 IO 线程"></a>3.2 IO 线程</h3><p>InnoDB中大量使用<strong>AIO (Async IO)</strong> 来处理IO请求。IO Thread的作用，是负责这些 IO 请求的回调（call back）。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641481073193-6d2bbd4e-ffaa-49b5-9c2e-c591b8690872." alt="image.png"></p>
<h3 id="3-3-Purge-线程"><a href="#3-3-Purge-线程" class="headerlink" title="3.3 Purge 线程"></a>3.3 Purge 线程</h3><p>事务被提交后，其所使用的undo log可能不在需要。因此，需要purge thread来回收已经使用并分配的undo页。以前Master Thread来完成释放undo log，InnoDB1.1独立出来，分担主线程压力。<br>​</p>
<h3 id="3-4-Page-Cleaner-线程"><a href="#3-4-Page-Cleaner-线程" class="headerlink" title="3.4 Page Cleaner 线程"></a>3.4 Page Cleaner 线程</h3><p><strong>​</strong></p>
<p>负责将脏页刷新到磁盘。以前Master Thread来刷新脏页，InnoDB1.2独立出来，分担主线程压力。<br>​</p>
<blockquote>
<p>除了 InnoDB 架构中的日志文件，MySQL 的 Server 层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p>
</blockquote>
<hr>
<h2 id="4-binlog"><a href="#4-binlog" class="headerlink" title="4.binlog"></a>4.binlog</h2><p>binlog 以事件的形式记录了所有的DDL 和DML 语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不一样，它的文件内容是可以追加的，没有固定大小限制。在开启了 binlog 功能的情况下，我们可以把 binlog 导出成 SQL 语句，把所有的操作重放一遍，来实现数据的恢复。binlog 的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的 binlog，然后执行一遍。<br>​</p>
<p>有了这两个日志之后，来看一下一条更新语句是怎么执行的：<br>​</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>​</p>
<ol>
<li>事务开始，从内存或者磁盘取到这条数据所在的数据页，返回给server的执行器</li>
<li>执行器修改这一行数据的值为二十</li>
<li>记录name =yhd 到undo log</li>
<li>在buffer pool 中修改 name =二十，此时该页变成脏页</li>
<li>记录name = 二十 到redo log buffer，redo log buffer每秒刷盘。</li>
<li>redo log 进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</li>
<li>写入binlog</li>
<li>事务提交，并回写最终状态到redo log里，代表该事务已经提交</li>
</ol>
<p>​</p>
<blockquote>
<p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便不断写入redo log文件中。一般情况下，每次事务commit时，必须调用 fsync 操作，将redo日志缓冲同步写到磁盘。另外，每次事务提交时同步写到磁盘bin log中。</p>
</blockquote>
<blockquote>
<p>那么就有了一个谁先谁后的问题：redo log 先，bin log 后。</p>
</blockquote>
<blockquote>
<p>两阶段提交的内容：**事务提交时，redo log处于 pre状态 -&gt; 写入bin log -&gt; 事务真正提交。 **</p>
</blockquote>
<blockquote>
<p>当发生崩溃恢复时，查看的是bin log是否完整，如果bin log完整，则代表事务已经提交。</p>
</blockquote>
<blockquote>
<p>如果在两阶段提交过程中，bin log写入失败，则事务无法终止提交，崩溃恢复时就不需要重做。如果bin log写完的一瞬间，服务器宕机了，事务都来不及提交，此时bin log并不是完整的，缺少了最终的commit标记。因此也是提交失败。</p>
</blockquote>
<blockquote>
<p>简单说，redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641482848254-19b6e1b2-0fa7-411d-924b-0c6cb48f511f.png" alt="1.png"></p>
<hr>
<h1 id="三，MySQL中支持的字符集和排序规则"><a href="#三，MySQL中支持的字符集和排序规则" class="headerlink" title="三，MySQL中支持的字符集和排序规则"></a>三，MySQL中支持的字符集和排序规则</h1><h2 id="1-MySQL中的utf8和utf8mb4"><a href="#1-MySQL中的utf8和utf8mb4" class="headerlink" title="1.MySQL中的utf8和utf8mb4"></a>1.MySQL中的utf8和utf8mb4</h2><p>utf8字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计MySQL的大叔偷偷的定义了两个概念：</p>
<ul>
<li>utf8mb3：阉割过的utf8字符集，只使用1～3个字节表示字符。</li>
<li>utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符。</li>
</ul>
<p>在MySQL中utf8是utf8mb3的别名，所以之后在MySQL中提到utf8就意味着使用1~3个字节来表示一个字符，如果有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4。</p>
<p>查看字符集：<code>SHOW (CHARACTER SET|CHARSET)</code>。</p>
<h2 id="2-字符集-amp-比较规则的应用"><a href="#2-字符集-amp-比较规则的应用" class="headerlink" title="2.字符集&amp;比较规则的应用"></a>2.字符集&amp;比较规则的应用</h2><h3 id="2-1-各级别的字符集和比较规则"><a href="#2-1-各级别的字符集和比较规则" class="headerlink" title="2.1 各级别的字符集和比较规则"></a>2.1 各级别的字符集和比较规则</h3><p>MySQL有4个级别的字符集和比较规则，分别是：</p>
<ul>
<li>服务器级别</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ul>
<p>接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p>
<h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;</span>;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure>


<p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用SET语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure>


<p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p>
<h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure>


<p>其中的DEFAULT可以省略，并不影响语句的语义。比方说我们新创建一个名叫charset_demo_db的数据库，在创建的时候指定它使用的字符集为gb2312，比较规则为gb2312_chinese_ci：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE charset_demo_db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| character_set_database | gb2312 |</span><br><span class="line">+------------------------+--------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;</span>;</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| Variable_name      | Value             |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| collation_database | gb2312_chinese_ci |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure>


<p>可以看到这个charset_demo_db数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 _<strong>collation_database</strong>_ 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p>
<h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure>


<p>比方说我们在刚刚创建的charset_demo_db数据库中创建一个名为t的表，并指定这个表的字符集和比较规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">CREATE TABLE <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    -&gt;     col VARCHAR(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.03</span> sec)</span></span></span><br></pre></td></tr></table></figure>


<p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</p>
<h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure>


<p>比如我们修改一下表t中列col的字符集和比较规则可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">ALTER TABLE t MODIFY col <span class="title">VARCHAR</span><span class="params">(<span class="number">10</span>)</span> CHARACTER SET gbk COLLATE gbk_chinese_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 0  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure>


<p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。</p>
<blockquote>
<p>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。 </p>
</blockquote>
<h3 id="2-2-客户端和服务器通信中的字符集"><a href="#2-2-客户端和服务器通信中的字符集" class="headerlink" title="2.2 客户端和服务器通信中的字符集"></a>2.2 客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果"><a href="#编码和解码使用的字符集不一致的后果" class="headerlink" title="编码和解码使用的字符集不一致的后果"></a>编码和解码使用的字符集不一致的后果</h4><p>如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p>
<h4 id="从发送请求到接收结果过程中发生的字符集转换"><a href="#从发送请求到接收结果过程中发生的字符集转换" class="headerlink" title="从发送请求到接收结果过程中发生的字符集转换"></a>从发送请求到接收结果过程中发生的字符集转换</h4><ul>
<li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li>
<li>服务器将客户端发送来的字节串采用character_set_client代表的字符集进行解码，将解码后的字符串再按照character_set_connection代表的字符集进行编码。</li>
<li>如果character_set_connection代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li>
<li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results代表的字符集后发送到客户端。</li>
<li>客户端使用操作系统的字符集解析收到的结果集字节串。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639999607440-c7181f59-0354-43bd-b896-d3bd722cadc4.png" alt="image.png"></p>
<p>在这个过程中各个系统变量的含义如下：</p>
<table>
<thead>
<tr>
<th>系统变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>character_set_client</td>
<td>服务器解码请求时使用的字符集</td>
</tr>
<tr>
<td>character_set_connection</td>
<td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td>
</tr>
<tr>
<td>character_set_results</td>
<td>服务器向客户端返回数据时使用的字符集</td>
</tr>
</tbody></table>
<p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p>
<p><strong>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</strong><br>​</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[%E4%BA%8C]%E6%A6%82%E8%BF%B0/">https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[二]概述/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL[一]入门</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"><img class="next-cover" src="/images/cover/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ConcurrentHashMap源码解读</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/" title="MySQL[一]入门"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[一]入门</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/" title="MySQL[七]基于成本的优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[七]基于成本的优化</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/" title="MySQL[八]InnoDB统计数据收集原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[八]InnoDB统计数据收集原理</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%BA%94%5DInnoDb%E8%A1%A8%E7%A9%BA%E9%97%B4/" title="MySQL[五]InnoDb表空间"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[五]InnoDb表空间</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/" title="MySQL[三]InnoDB索引结构"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[三]InnoDB索引结构</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL[九]基于规则的优化&子查询优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[九]基于规则的优化&子查询优化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客卷....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B"><span class="toc-text">一，一条SQL的查询流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">1.获取连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%80%9A%E4%BF%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.1 通信类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2 连接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">1.3 通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">1.4 通信方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">2.查询缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90-amp-%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">3.语法解析&amp;预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">3.1 词法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">3.2 语法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">3.3 预处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-amp-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">4.查询优化&amp;查询执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">4.1 优化器的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BC%98%E5%8C%96%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%BE%97%E5%88%B0%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84"><span class="toc-text">4.2 优化器是怎么得到执行计划的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BC%98%E5%8C%96%E5%99%A8%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">4.3 优化器得到的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="toc-text">4.4 选错索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">5. 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">5.1 查看存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%AF%94%E8%BE%83"><span class="toc-text">5.2 存储引擎比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">①常见存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">②数据库支持的存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2MyISAM%EF%BC%883-%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-text">③MyISAM（3  个文件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3InnoDB%EF%BC%882%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-text">④InnoDB（2个文件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4Memory-1%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-text">⑤Memory(1个文件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5CSV-3%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-text">⑥CSV(3个文件)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-text">5.3 如何选择存储引擎</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">6.执行引擎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">二，一条SQL的更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">1.内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-buffer-pool"><span class="toc-text">1.1 buffer pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-ChangeBuffer%E5%86%99%E7%BC%93%E5%86%B2"><span class="toc-text">1.2 ChangeBuffer写缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Adaptive-Hash-Index"><span class="toc-text">1.3 Adaptive Hash Index</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%EF%BC%88redo%EF%BC%89Log-Buffer"><span class="toc-text">1.4 （redo）Log Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E7%BC%93%E5%AD%98%E7%9A%84%E7%96%91%E9%97%AE"><span class="toc-text">1.5 缓存的疑问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-text">2.磁盘结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">2.1 系统表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%8B%AC%E5%8D%A0%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">2.2 独占表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%80%9A%E7%94%A8%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">2.3 通用表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">2.4 临时表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-redo-log"><span class="toc-text">2.5 redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-undo-log-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-text">2.6 undo log 表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">2.7 一条SQL的更新流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Master-%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.1 Master 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%AF%8F%E7%A7%92%E9%92%9F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">①每秒钟的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%AF%8F%E5%8D%81%E7%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">②每十秒的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-IO-%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.2 IO 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Purge-%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.3 Purge 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Page-Cleaner-%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.4 Page Cleaner 线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-binlog"><span class="toc-text">4.binlog</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CMySQL%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="toc-text">三，MySQL中支持的字符集和排序规则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MySQL%E4%B8%AD%E7%9A%84utf8%E5%92%8Cutf8mb4"><span class="toc-text">1.MySQL中的utf8和utf8mb4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E9%9B%86-amp-%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">2.字符集&amp;比较规则的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%90%84%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="toc-text">2.1 各级别的字符集和比较规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BA%A7%E5%88%AB"><span class="toc-text">服务器级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A7%E5%88%AB"><span class="toc-text">数据库级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E5%88%AB"><span class="toc-text">表级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E7%BA%A7%E5%88%AB"><span class="toc-text">列级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">2.2 客户端和服务器通信中的字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="toc-text">编码和解码使用的字符集不一致的后果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%88%B0%E6%8E%A5%E6%94%B6%E7%BB%93%E6%9E%9C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E8%BD%AC%E6%8D%A2"><span class="toc-text">从发送请求到接收结果过程中发生的字符集转换</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/" title="软件设计概述"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件设计概述"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/" title="软件设计概述">软件设计概述</a><time datetime="2022-01-11T12:02:25.638Z" title="发表于 2022-01-11 20:02:25">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件架构的基本原则"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则">软件架构的基本原则</a><time datetime="2022-01-11T12:02:16.665Z" title="发表于 2022-01-11 20:02:16">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9/" title="设计模式概览"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式概览"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9/" title="设计模式概览">设计模式概览</a><time datetime="2022-01-11T12:02:08.137Z" title="发表于 2022-01-11 20:02:08">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a><time datetime="2022-01-11T12:02:00.546Z" title="发表于 2022-01-11 20:02:00">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="原型模式"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="原型模式"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="原型模式">原型模式</a><time datetime="2022-01-11T12:01:51.844Z" title="发表于 2022-01-11 20:01:51">2022-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十,二十二十二十二十二十二十,二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>