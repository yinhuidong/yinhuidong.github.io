<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL[十]Explain&amp;optimizer trace | 二十</title><meta name="keywords" content="MySQL"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Explain&amp;optimizer trace">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL[十]Explain&amp;optimizer trace">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[%E5%8D%81]Explain&optimizer%20trace/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="Explain&amp;optimizer trace">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2022-01-09T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-12T00:42:16.008Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[%E5%8D%81]Explain&amp;optimizer%20trace/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL[十]Explain&optimizer trace',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-12 08:42:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL[十]Explain&amp;optimizer trace</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-09T16:00:00.000Z" title="发表于 2022-01-10 00:00:00">2022-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-12T00:42:16.008Z" title="更新于 2022-01-12 08:42:16">2022-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL[十]Explain&amp;optimizer trace"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一，Explain"><a href="#一，Explain" class="headerlink" title="一，Explain"></a>一，Explain</h1><p>一条查询语句在经过<code>MySQL</code>查询优化器的各种基于成本和规则的优化会后生成一个所谓的<code>执行计划</code>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个<code>EXPLAIN</code>，就像这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280260945-c936b3bf-33bc-4f56-8d2c-3b3a37fe7a08.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63d468a1&margin=%5Bobject%20Object%5D&name=1.png&originHeight=112&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3820&status=done&style=none&taskId=u13c516c3-ac6f-4988-8981-5ccc1136386&title=" alt="1.png"></p>
<p>其实除了以<code>SELECT</code>开头的查询语句，其余的<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>以及<code>UPDATE</code>语句前边都可以加上<code>EXPLAIN</code>这个词儿，用来查看这些语句的执行计划，不过我们这里对<code>SELECT</code>语句更感兴趣，所以后边只会以<code>SELECT</code>语句为例来描述<code>EXPLAIN</code>语句的用法。我们先把<code>EXPLAIN</code>语句输出的各个列的作用先大致罗列一下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td>
</tr>
<tr>
<td><code>select_type</code></td>
<td><code>SELECT</code>关键字对应的那个查询的类型</td>
</tr>
<tr>
<td><code>table</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>partitions</code></td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td><code>type</code></td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td><code>possible_keys</code></td>
<td>可能用到的索引</td>
</tr>
<tr>
<td><code>key</code></td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td><code>key_len</code></td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td><code>ref</code></td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td><code>rows</code></td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td><code>filtered</code></td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td><code>Extra</code></td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<p>我们前面创建过一张<code>single_table</code>表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>


<h2 id="1-执行计划输出中各列详解"><a href="#1-执行计划输出中各列详解" class="headerlink" title="1.执行计划输出中各列详解"></a>1.执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。所以我们看一条比较简单的查询语句：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280274365-43dda4af-2f66-465c-abfb-647b465bc8b3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u078f92e2&margin=%5Bobject%20Object%5D&name=2.png&originHeight=121&originWidth=950&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4213&status=done&style=none&taskId=ue1f9160c-2764-48a6-9c06-4df370be589&title=" alt="2.png"></p>
<p>这个查询语句只涉及对<code>s1</code>表的单表查询，所以<code>EXPLAIN</code>输出中只有一条记录，其中的<code>table</code>列的值是<code>s1</code>，表明这条记录是用来说明对<code>s1</code>表的单表访问方法的。</p>
<p>下边我们看一下一个连接查询的执行计划：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280282078-c817d0b7-eec8-4fac-b9ee-bfcde6afb3ff.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u198071a8&margin=%5Bobject%20Object%5D&name=3.png&originHeight=129&originWidth=1199&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5766&status=done&style=none&taskId=ufd1691fc-bc9e-4bf2-b272-a981164853f&title=" alt="3.png"></p>
<p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的<code>table</code>列分别是<code>s1</code>和<code>s2</code>，这两条记录用来分别说明对<code>s1</code>表和<code>s2</code>表的访问方法是什么。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>我们知道我们写的查询语句一般都以<code>SELECT</code>关键字开头，比较简单的查询语句里只有一个<code>SELECT</code>关键字，比如下边这个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>


<p>稍微复杂一点的连接查询中也只有一个<code>SELECT</code>关键字，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>


<p>但是下边两种情况下在一条查询语句中会出现多个<code>SELECT</code>关键字：</p>
<ul>
<li><p> 查询中包含子查询的情况<br>比如下边这个查询语句中就包含2个<code>SELECT</code>关键字：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT key3 FROM s2);</span><br></pre></td></tr></table></figure></li>
<li><p> 查询中包含<code>UNION</code>语句的情况<br>比如下边这个查询语句中也包含2个<code>SELECT</code>关键字：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1  UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查询语句中每出现一个<code>SELECT</code>关键字，<code>MySQL</code>就会为它分配一个唯一的<code>id</code>值。这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下边这个查询中只有一个<code>SELECT</code>关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280291489-d6fd669d-dbf3-4054-a672-8352fce214a2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4dfdf582&margin=%5Bobject%20Object%5D&name=4.png&originHeight=122&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9275&status=done&style=none&taskId=u460df76a-a444-4d5b-a7ca-7d7a5c7026b&title=" alt="4.png"></p>
<p>对于连接查询来说，一个<code>SELECT</code>关键字后边的<code>FROM</code>子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280298828-57ae0bb0-9f11-4fc1-a716-dcd5b9fb003b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue0905b12&margin=%5Bobject%20Object%5D&name=5.png&originHeight=141&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12198&status=done&style=none&taskId=u9124e447-4620-4012-9fbc-82044c4a955&title=" alt="5.png"></p>
<p>可以看到，上述连接查询中参与连接的<code>s1</code>和<code>s2</code>表分别对应一条记录，但是这两条记录对应的<code>id</code>值都是<code>1</code>。在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，<strong>出现在前边的表表示驱动表，出现在后边的表表示被驱动表</strong>。所以从上边的<code>EXPLAIN</code>输出中我们可以看出，查询优化器准备让<code>s1</code>表作为驱动表，让<code>s2</code>表作为被驱动表来执行查询。</p>
<p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值，比如这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280305890-e78bef80-48fd-4ace-805c-cb03ea315780.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u515a991c&margin=%5Bobject%20Object%5D&name=6.png&originHeight=137&originWidth=1276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13575&status=done&style=none&taskId=ub9ed2c7d-641b-4e47-ba2e-ed467048a13&title=" alt="6.png"></p>
<p>从输出结果中我们可以看到，<code>s1</code>表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是<code>1</code>，<code>s2</code>表在子查询中，子查询有一个独立的<code>SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p>
<p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280313651-8d89c1be-d533-4331-bbb7-e2d48b436318.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u776fd7cc&margin=%5Bobject%20Object%5D&name=7.png&originHeight=158&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16676&status=done&style=none&taskId=ub79395b5-7ac6-4798-a418-550eee0aadc&title=" alt="7.png"></p>
<p>虽然我们的查询语句是一个子查询，但是执行计划中<code>s1</code>和<code>s2</code>表对应的记录的<code>id</code>值全部是<code>1</code>，这就表明了查询优化器将子查询转换为了连接查询。</p>
<p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别，比方说下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280321427-124e6217-466a-41c2-9363-d807856fadb7.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6436d0a7&margin=%5Bobject%20Object%5D&name=8.png&originHeight=176&originWidth=1360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14950&status=done&style=none&taskId=u50a3e117-c91d-420f-a8b4-31af4e2b3c2&title=" alt="8.png"></p>
<p>这个语句的执行计划的第三条记录是个什么？为什么<code>id</code>值是<code>NULL</code>，而且<code>table</code>名也不大对？<code>UNION</code>子句会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？<code>MySQL</code>使用的是内部的临时表。正如上边的查询计划中所示，<code>UNION</code>子句是为了把<code>id</code>为<code>1</code>的查询和<code>id</code>为<code>2</code>的查询的结果集合并起来并去重，所以在内部创建了一个临时表（就是执行计划第三条记录的<code>table</code>列的名称），<code>id</code>为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<p>跟<code>UNION</code>对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个<code>id</code>为<code>NULL</code>的记录，如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280329103-1d10728f-1cb6-424c-afc2-a6998f2ba02d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9423ac3e&margin=%5Bobject%20Object%5D&name=9.png&originHeight=146&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10897&status=done&style=none&taskId=u493e7dd0-542c-4a70-9c7b-7298631abd7&title=" alt="9.png"></p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>通过上边的内容我们知道，一条大的查询语句里边可以包含若干个<code>SELECT</code>关键字，每个<code>SELECT</code>关键字代表着一个小的查询语句，而每个<code>SELECT</code>关键字的<code>FROM</code>子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个<code>SELECT</code>关键字中的表来说，它们的<code>id</code>值是相同的。</p>
<p><code>MySQL</code>为每一个<code>SELECT</code>关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中有什么作用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SIMPLE</code></td>
<td>Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td><code>PRIMARY</code></td>
<td>Outermost SELECT</td>
</tr>
<tr>
<td><code>UNION</code></td>
<td>Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td><code>UNION RESULT</code></td>
<td>Result of a UNION</td>
</tr>
<tr>
<td><code>SUBQUERY</code></td>
<td>First SELECT in subquery</td>
</tr>
<tr>
<td><code>DEPENDENT SUBQUERY</code></td>
<td>First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td><code>DEPENDENT UNION</code></td>
<td>Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td><code>DERIVED</code></td>
<td>Derived table</td>
</tr>
<tr>
<td><code>MATERIALIZED</code></td>
<td>Materialized subquery</td>
</tr>
<tr>
<td><code>UNCACHEABLE SUBQUERY</code></td>
<td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td><code>UNCACHEABLE UNION</code></td>
<td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<ul>
<li> <code>SIMPLE</code><br>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询的<code>select_type</code>的值就是<code>SIMPLE</code>：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280337218-078fa344-d1da-4a52-857b-352ecb12cddc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufffa3027&margin=%5Bobject%20Object%5D&name=10.png&originHeight=146&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9907&status=done&style=none&taskId=u2df9f156-ab20-4e89-8136-9585d85cba1&title=" alt="10.png"><br>当然，连接查询也算是<code>SIMPLE</code>类型，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280343184-8c2e7e4c-f85b-4bb0-b45f-4325497a7ebd.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63b97864&margin=%5Bobject%20Object%5D&name=11.png&originHeight=158&originWidth=1512&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14164&status=done&style=none&taskId=ud077b5f1-886a-44b5-abcd-76bdbfe08d7&title=" alt="11.png"> </li>
<li> <code>PRIMARY</code><br>对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280350857-4dfa730e-2b7c-4e94-825e-742a49f2b9e3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3fe99956&margin=%5Bobject%20Object%5D&name=12.png&originHeight=173&originWidth=1331&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14928&status=done&style=none&taskId=u8c6000b8-3cf9-48d9-9447-09224347660&title=" alt="12.png"><br>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是<code>PRIMARY</code>。 </li>
<li> <code>UNION</code><br>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>，可以对比上一个例子的效果，这就不多举例子了。 </li>
<li> <code>UNION RESULT</code><br><code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上边有，就不赘述了。 </li>
<li> <code>SUBQUERY</code><br>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280358319-9d411906-99c1-4214-a731-b31a6fa6487b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udf5c0430&margin=%5Bobject%20Object%5D&name=13.png&originHeight=154&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14997&status=done&style=none&taskId=u59a4d22d-11c4-4b80-b1d8-042fb9c3db7&title=" alt="13.png"><br>可以看到，外层查询的<code>select_type</code>就是<code>PRIMARY</code>，子查询的<code>select_type</code>就是<code>SUBQUERY</code>。由于select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。 </li>
<li> <code>DEPENDENT SUBQUERY</code><br>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280367090-997cc1b5-ef45-43b8-a298-68a707d7fcac.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b271730&margin=%5Bobject%20Object%5D&name=14.png&originHeight=154&originWidth=1433&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15238&status=done&style=none&taskId=uc46092db-b61b-4abe-b1e5-fdd03ca496e&title=" alt="14.png"></li>
</ul>
<p><strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次。</strong> </p>
<ul>
<li><p> <code>DEPENDENT UNION</code><br>在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。说的有些绕哈，比方说下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280375650-6efa28fa-5b07-4b2b-a936-51dc06e0687e.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub4c42a77&margin=%5Bobject%20Object%5D&name=15.png&originHeight=176&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21604&status=done&style=none&taskId=u977e1294-949c-4a21-a61e-32deb74d580&title=" alt="15.png"><br>这个查询比较复杂，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = &#39;a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = &#39;b&#39;</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。 </p>
</li>
<li><p> <code>DERIVED</code><br>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280385622-887431a3-4aed-4d36-829d-508ee28a1baa.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua247020c&margin=%5Bobject%20Object%5D&name=16.png&originHeight=163&originWidth=1336&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15817&status=done&style=none&taskId=u8f8c12bc-ad97-4e22-aac9-53a038d858f&title=" alt="16.png"><br>从执行计划中可以看出，<code>id</code>为<code>2</code>的记录就代表子查询的执行方式，它的<code>select_type</code>是<code>DERIVED</code>，说明该子查询是以物化的方式执行的。<code>id</code>为<code>1</code>的记录代表外层查询，它的<code>table</code>列显示的是``，表示该查询是针对将派生表物化之后的表进行查询的。  </p>
<blockquote>
<p>如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象。</p>
</blockquote>
</li>
<li><p> <code>MATERIALIZED</code><br>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280393291-f5462583-d221-4f0e-962a-a44c8ce95477.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u38a01fd0&margin=%5Bobject%20Object%5D&name=17.png&originHeight=170&originWidth=1455&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17733&status=done&style=none&taskId=u66eebaeb-7470-4f0c-a238-d04e43892d3&title=" alt="17.png"><br>执行计划的第三条记录的<code>id</code>值为<code>2</code>，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为<code>MATERIALIZED</code>可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的<code>id</code>值都为<code>1</code>，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是``，说明该表其实就是<code>id</code>为<code>2</code>对应的子查询执行之后产生的物化表，然后将<code>s1</code>和该物化表进行连接查询。 </p>
</li>
<li><p> <code>UNCACHEABLE SUBQUERY</code><br>不常用 </p>
</li>
<li><p> <code>UNCACHEABLE UNION</code><br>不常用 </p>
</li>
</ul>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>一般情况下我们的查询语句的执行计划的<code>partitions</code>列的值都是<code>NULL</code>。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>执行计划的一条记录就代表着<code>MySQL</code>对某个表的执行查询时的访问方法，其中的<code>type</code>列就表明了这个访问方法是什么，比方说下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280402792-2ed1ee54-de24-42de-8f8d-4ec2f861dcd5.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubaa6a847&margin=%5Bobject%20Object%5D&name=18.png&originHeight=141&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10843&status=done&style=none&taskId=u694e9953-97ca-4705-9136-ec6a7dc3196&title=" alt="18.png"></p>
<p>可以看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。但是我们之前只分析过对使用<code>InnoDB</code>存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。接下来我们详细看一下：</p>
<ul>
<li><p> <code>system</code><br>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：<br>然后我们看一下查询这个表的执行计划：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280410379-02b98490-4259-4af4-bd20-c465d0b6bebd.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u85f77e9b&margin=%5Bobject%20Object%5D&name=19.png&originHeight=130&originWidth=1179&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8957&status=done&style=none&taskId=u998b055a-ccec-41f7-8e2e-097010b188d&title=" alt="19.png"><br>可以看到<code>type</code>列的值就是<code>system</code>了。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>把表改成使用InnoDB存储引擎，执行计划的type列是ALL。</p>
</blockquote>
</li>
<li><p> <code>const</code><br>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280418708-2e9e505a-c985-45fa-8518-44c27fc83979.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7438f4f7&margin=%5Bobject%20Object%5D&name=20.png&originHeight=133&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10419&status=done&style=none&taskId=ubcd36136-b889-4eac-aefb-c68f5da874a&title=" alt="20.png"> </p>
</li>
<li><p> <code>eq_ref</code><br>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280456161-049d60a4-d6da-46b2-91fe-9b2661fa1d36.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0c6b2463&margin=%5Bobject%20Object%5D&name=21.png&originHeight=158&originWidth=1264&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13498&status=done&style=none&taskId=ue5cce22c-1ad7-46d1-82c7-559db693de7&title=" alt="21.png"><br>从执行计划的结果中可以看出，<code>MySQL</code>打算将<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表，重点关注<code>s2</code>的访问方法是<code>eq_ref</code>，表明在访问<code>s2</code>表的时候可以通过主键的等值匹配来进行访问。 </p>
</li>
<li><p> <code>ref</code><br>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>。 </p>
</li>
<li><p> <code>fulltext</code><br>全文索引,意义不大。 </p>
</li>
<li><p> <code>ref_or_null</code><br>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280463125-26170cb7-ba4b-4933-a004-8c346961b5da.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufa9a4774&margin=%5Bobject%20Object%5D&name=22.png&originHeight=141&originWidth=1422&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12130&status=done&style=none&taskId=u6b7b7747-acae-4a15-adf5-d446fbbb6c0&title=" alt="22.png"> </p>
</li>
<li><p> <code>index_merge</code><br>在某些场景下可以使用<code>Intersection</code>、<code>Union</code>、<code>Sort-Union</code>这三种索引合并的方式来执行查询，我们看一下执行计划中是怎么体现<code>MySQL</code>使用索引合并的方式来对某个表执行查询的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280470378-3882e0be-f91d-44c0-a7b9-a979adc93085.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue18487eb&margin=%5Bobject%20Object%5D&name=23.png&originHeight=130&originWidth=1806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18097&status=done&style=none&taskId=u3aaf69a0-df90-4b3e-a75d-7f161bc37f0&title=" alt="23.png"><br>从执行计划的<code>type</code>列的值是<code>index_merge</code>就可以看出，<code>MySQL</code>打算使用索引合并的方式来执行对<code>s1</code>表的查询。 </p>
</li>
<li><p> <code>unique_subquery</code><br>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280477014-ddc7ace3-5261-47a3-956c-3acce84f20dc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0d35569a&margin=%5Bobject%20Object%5D&name=24.png&originHeight=138&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15149&status=done&style=none&taskId=ub0da4c73-db17-427c-b87b-e059de96b1b&title=" alt="24.png"><br>可以看到执行计划的第二条记录的<code>type</code>值就是<code>unique_subquery</code>，说明在执行子查询时会使用到<code>id</code>列的索引。 </p>
</li>
<li><p> <code>index_subquery</code><br><code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280483868-ff7a1815-8c05-4a2f-94e7-79b880cea954.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue020d52f&margin=%5Bobject%20Object%5D&name=25.png&originHeight=148&originWidth=1457&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16363&status=done&style=none&taskId=u2782b719-e96b-4afa-bb75-8eb977622af&title=" alt="25.png"> </p>
</li>
<li><p> <code>range</code><br>如果使用索引获取某些<code>范围区间</code>的记录，那么就可能使用到<code>range</code>访问方法，比如下边的这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280490568-7cef7a7c-7acf-4be1-9c08-5b6da950acfc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08f05ea8&margin=%5Bobject%20Object%5D&name=26.png&originHeight=143&originWidth=1371&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11837&status=done&style=none&taskId=u99904bc8-68ad-4658-a5fc-b5851815429&title=" alt="26.png"><br>或者：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280496929-e1318302-934b-4bda-b7a4-8a858c278403.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u14fae300&margin=%5Bobject%20Object%5D&name=27.png&originHeight=117&originWidth=1355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10119&status=done&style=none&taskId=u13e335fa-04ea-4d0e-861b-045a44df8c6&title=" alt="27.png"> </p>
</li>
<li><p> <code>index</code><br>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280502811-c5c73a14-cb70-410e-9997-eb5296fe7ead.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9d0bfa53&margin=%5Bobject%20Object%5D&name=28.png&originHeight=129&originWidth=1445&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11338&status=done&style=none&taskId=u8ea5271b-21e8-4dfe-b21f-f9b7cce2e5a&title=" alt="28.png"><br>上述查询中的搜索列表中只有<code>key_part2</code>一个列，而且搜索条件中也只有<code>key_part3</code>一个列，这两个列又恰好包含在<code>idx_key_part</code>这个索引中，可是搜索条件<code>key_part3</code>不能直接使用该索引进行<code>ref</code>或者<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。  </p>
<blockquote>
<p>对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p>
</blockquote>
</li>
<li><p> <code>ALL</code><br>最熟悉的全表扫描直接看例子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280509611-e1909546-52e6-44eb-a2ad-bc9422cf1521.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8e1ce447&margin=%5Bobject%20Object%5D&name=29.png&originHeight=136&originWidth=1172&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9873&status=done&style=none&taskId=ucadc9702-0049-4b37-bcc0-a6e180d38b3&title=" alt="29.png"> </p>
</li>
</ul>
<p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引。</p>
<h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p>在<code>EXPLAIN</code>语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些，比方说下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280516466-778cee1a-3912-45ce-b8b0-961fde6131b2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8c4c0e4c&margin=%5Bobject%20Object%5D&name=30.png&originHeight=135&originWidth=1311&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11553&status=done&style=none&taskId=u20dfc39d-6030-42fa-8480-2d27b8ab68a&title=" alt="30.png"></p>
<p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1,idx_key3</code>，表示该查询可能使用到<code>idx_key1,idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code>来执行查询比较划算。</p>
<p>不过有一点比较特别，就是在使用<code>index</code>访问方法来查询某个表时，<code>possible_keys</code>列是空的，而<code>key</code>列展示的是实际使用到的索引，比如这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280523465-50db2fcf-3aab-459d-bd56-9fe94cfef62d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u709cacbf&margin=%5Bobject%20Object%5D&name=31.png&originHeight=133&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11806&status=done&style=none&taskId=u7d4f3316-a2df-450a-82f1-e9dc395c5d1&title=" alt="31.png"></p>
<p>另外需要注意的一点是，possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ol>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</li>
<li>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ol>
<p>比如下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280530011-7d5e65ca-3e73-4ce5-9cd7-30e30fca150d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u37395cf6&margin=%5Bobject%20Object%5D&name=32.png&originHeight=126&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10064&status=done&style=none&taskId=u620f6e76-7540-4994-b49b-8ecb5d6c62a&title=" alt="32.png"></p>
<p>由于<code>id</code>列的类型是<code>INT</code>，并且不可以存储<code>NULL</code>值，所以在使用该列的索引时<code>key_len</code>大小就是<code>4</code>。当索引列可以存储<code>NULL</code>值时，比如：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280536833-34a98995-bbb1-4f5b-9c65-cd883418fbd2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u91c8ee45&margin=%5Bobject%20Object%5D&name=33.png&originHeight=132&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10328&status=done&style=none&taskId=uf7c83065-c654-47e4-886d-3e1fc98b6e8&title=" alt="33.png"></p>
<p>可以看到<code>key_len</code>列就变成了<code>5</code>，比使用<code>id</code>列的索引时多了<code>1</code>。</p>
<p>对于可变长度的索引列来说，比如下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280547140-fea8d226-3465-4e13-b93d-0e74882cf422.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc8b9f40b&margin=%5Bobject%20Object%5D&name=34.png&originHeight=137&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10837&status=done&style=none&taskId=ubc579fb7-242e-4242-844b-50635088a6d&title=" alt="34.png"></p>
<p>由于<code>key1</code>列的类型是<code>VARCHAR(100)</code>，所以该列实际最多占用的存储空间就是<code>300</code>字节，又因为该列允许存储<code>NULL</code>值，所以<code>key_len</code>需要加<code>1</code>，又因为该列是可变长度列，所以<code>key_len</code>需要加<code>2</code>，所以最后<code>ken_len</code>的值就是<code>303</code>。</p>
<p>这里需要强调的一点是，执行计划的生成是在<code>MySQL server</code>层中的功能，并不是针对具体某个存储引擎的功能，<code>MySQL</code>在执行计划中输出<code>key_len</code>列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列，而不是为了准确的说明针对某个具体存储引擎存储变长字段的实际长度占用的空间到底是占用1个字节还是2个字节。比方说下边这个使用到联合索引<code>idx_key_part</code>的查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280574627-423abda2-7282-4686-850d-158ee23ceef0.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue80e815d&margin=%5Bobject%20Object%5D&name=35.png&originHeight=135&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11390&status=done&style=none&taskId=ua1103849-bb46-4d1e-bfe7-d43baa19357&title=" alt="35.png"></p>
<p>我们可以从执行计划的<code>key_len</code>列中看到值是<code>303</code>，这意味着<code>MySQL</code>在执行上述查询中只能用到<code>idx_key_part</code>索引的一个索引列，而下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280584178-4d046ed5-9399-46e8-acf8-c4dba1e88a44.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufe6bdb41&margin=%5Bobject%20Object%5D&name=36.png&originHeight=148&originWidth=1310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11956&status=done&style=none&taskId=u5a6a7a9e-56f9-4f90-b3e3-3ccce6aeeb1&title=" alt="36.png"></p>
<p>这个查询的执行计划的<code>ken_len</code>列的值是<code>606</code>，说明执行这个查询的时候可以用到联合索引<code>idx_key_part</code>的两个索引列。</p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280639189-65511db0-6781-43a2-a189-da56d4a39d06.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3e0a564f&margin=%5Bobject%20Object%5D&name=37.png&originHeight=137&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10813&status=done&style=none&taskId=ubf40913d-f7f9-48b6-a1bc-22be2439bce&title=" alt="37.png"></p>
<p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280647362-c56ac11e-c810-49b1-b6ef-74142632a2f3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2efc95bd&margin=%5Bobject%20Object%5D&name=38.png&originHeight=151&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13438&status=done&style=none&taskId=u78dba58c-d2a6-4a38-8342-d8829ff9213&title=" alt="38.png"></p>
<p>可以看到对被驱动表<code>s2</code>的访问方法是<code>eq_ref</code>，而对应的<code>ref</code>列的值是<code>yhd.s1.id</code>，这说明在对被驱动表进行访问时会用到<code>PRIMARY</code>索引，也就是聚簇索引与一个列进行等值匹配的条件，于<code>s2</code>表的<code>id</code>作等值匹配的对象就是<code>yhd.s1.id</code>列（注意这里把数据库名也写出来了）。</p>
<p>有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280654511-c4a8f217-0578-4a32-b78c-1b61a2160364.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u11c13c47&margin=%5Bobject%20Object%5D&name=39.png&originHeight=152&originWidth=1372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14314&status=done&style=none&taskId=u9c0c9cba-8fec-41c7-82d0-9469e60fcc2&title=" alt="39.png"></p>
<p>我们看执行计划的第二条记录，可以看到对<code>s2</code>表采用<code>ref</code>访问方法执行查询，然后在查询计划的<code>ref</code>列里输出的是<code>func</code>，说明与<code>s2</code>表的<code>key1</code>列进行等值匹配的对象是一个函数。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。比如下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280662371-b8621d39-7404-4335-8b6f-6ac3bf020927.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubdf57c66&margin=%5Bobject%20Object%5D&name=40.png&originHeight=144&originWidth=1362&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11525&status=done&style=none&taskId=u502bf400-c9d0-4d98-a90c-01d6e656856&title=" alt="40.png"></p>
<p>我们看到执行计划的<code>rows</code>列的值是<code>1</code>，这意味着查询优化器在经过分析使用<code>idx_key1</code>进行查询的成本之后，觉得满足<code>key1 &gt; &#39;z&#39;</code>这个条件的记录只有<code>1</code>条。</p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>之前在分析连接查询的成本时提出过一个<code>condition filtering</code>的概念，就是<code>MySQL</code>在计算驱动表扇出时采用的一个策略：</p>
<ul>
<li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li>
<li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li>
</ul>
<p>比方说下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280695851-4f237801-1121-4cce-935d-8d124f691b30.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08ebf4a7&margin=%5Bobject%20Object%5D&name=41.png&originHeight=139&originWidth=1507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12747&status=done&style=none&taskId=uef9d60d8-c348-4d80-a2f2-29ebce41900&title=" alt="41.png"></p>
<p>从执行计划的<code>key</code>列中可以看出来，该查询使用<code>idx_key1</code>索引来执行查询，从<code>rows</code>列可以看出满足<code>key1 &gt; &#39;z&#39;</code>的记录有<code>1</code>条。执行计划的<code>filtered</code>列就代表查询优化器预测在这<code>1</code>条记录中，有多少条记录满足其余的搜索条件，也就是<code>common_field = &#39;a&#39;</code>这个条件的百分比。此处<code>filtered</code>列的值是<code>10.00</code>，说明查询优化器预测在<code>1</code>条记录中有<code>10.00%</code>的记录满足<code>common_field = &#39;a&#39;</code>这个条件。</p>
<p>对于单表查询来说，这个<code>filtered</code>列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的<code>filtered</code>值，比方说下边这个查询：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280702717-5e6276df-2775-4dd9-9068-168632a6e891.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua075a642&margin=%5Bobject%20Object%5D&name=42.png&originHeight=159&originWidth=1359&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15418&status=done&style=none&taskId=u2ce577e9-11ca-4213-8c24-e76cc816cc0&title=" alt="42.png"></p>
<p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>当作驱动表，<code>s2</code>当作被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>997219</code>， <code>filtered</code>列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>997219 × 10.00% = 99721.9</code>，这说明还要对被驱动表执行大约<code>99721.9</code>次查询。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解<code>MySQL</code>到底将如何执行给定的查询语句。</p>
<ul>
<li><p> <code>No tables used</code><br>当查询语句的没有<code>FROM</code>子句时将会提示该额外信息，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280709963-b0a3875e-f1e9-4112-928c-5a2509c69a1c.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0af38ec6&margin=%5Bobject%20Object%5D&name=43.png&originHeight=137&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8351&status=done&style=none&taskId=ub8c0c8c7-6dd1-436a-a457-2a8f3fd0a43&title=" alt="43.png"> </p>
</li>
<li><p> <code>Impossible WHERE</code><br>查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280716070-b375d8db-fab7-411f-b6c3-fdb1cb8a2b68.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u62a56c70&margin=%5Bobject%20Object%5D&name=44.png&originHeight=140&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10429&status=done&style=none&taskId=u3592d4c4-8b55-4c36-ab4c-19bfcb10f2a&title=" alt="44.png"> </p>
</li>
<li><p> <code>No matching min/max row</code><br>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚集函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280722423-8f00c35d-e352-4e4f-9ad0-06344f87d7be.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uae911a2d&margin=%5Bobject%20Object%5D&name=45.png&originHeight=133&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10632&status=done&style=none&taskId=uc25dd0ec-cd40-4efa-b32b-289e0c6a293&title=" alt="45.png"> </p>
</li>
<li><p> <code>Using index</code><br>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280729248-e8d19929-5057-4e2b-92b5-4f0815d42951.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uca03b967&margin=%5Bobject%20Object%5D&name=46.png&originHeight=137&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10748&status=done&style=none&taskId=u4ef056f1-92c6-4c14-8947-39aa551837d&title=" alt="46.png"> </p>
</li>
<li><p><code>Using index condition</code><br>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：<br>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的<code>MySQL</code>中，是按照下边步骤来执行这个查询的： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</li>
<li>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</li>
</ul>
</li>
</ul>
<p>但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以<code>MySQL</code>把上边的步骤改进了一下： </p>
<ul>
<li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</li>
<li>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</li>
<li>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</li>
</ul>
<p>我们说回表操作其实是一个随机<code>IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。<code>MySQL</code>把他们的这个改进称之为<code>索引条件下推</code>（英文名：<code>Index Condition Pushdown</code>）。<br>如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在<code>Extra</code>列中将会显示<code>Using index condition</code>，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280739039-b867ce7b-7772-4c60-ad85-de88f84dfc95.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5f7b5a5f&margin=%5Bobject%20Object%5D&name=47.png&originHeight=150&originWidth=1355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12096&status=done&style=none&taskId=u108c9eb7-bb19-4820-a2c3-34bdae80479&title=" alt="47.png"></p>
<ul>
<li><p> <code>Using where</code><br>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280745116-15cf2e92-4bc6-4896-a114-a08fd4f149f1.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue69355bd&margin=%5Bobject%20Object%5D&name=48.png&originHeight=142&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11283&status=done&style=none&taskId=u5bca1059-5304-4173-a759-fe3383de92f&title=" alt="48.png"><br>当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在<code>Extra</code>列中也会提示上述额外信息。比如下边这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1 = &#39;a&#39;</code>，还有包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280750980-0af4ffa5-7801-40ed-b434-60cf04e53c39.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6328631b&margin=%5Bobject%20Object%5D&name=49.png&originHeight=139&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11868&status=done&style=none&taskId=u78e29b4d-4d4a-49e1-85b3-0469f52cbfc&title=" alt="49.png"> </p>
</li>
<li><p><code>Using join buffer (Block Nested Loop)</code><br>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>，比如下边这个查询语句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280756935-cbffc56a-f033-486c-bc9e-2a4b45faffc3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u66ccbdd4&margin=%5Bobject%20Object%5D&name=50.png&originHeight=197&originWidth=1615&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16002&status=done&style=none&taskId=u33176016-e036-4aa1-a1e2-fb9469510e0&title=" alt="50.png"><br>可以在对<code>s2</code>表的执行计划的<code>Extra</code>列显示了两个提示： </p>
<ul>
<li><code>Using join buffer (Block Nested Loop)</code>：这是因为对表<code>s2</code>的访问不能有效利用索引，只好退而求其次，使用<code>join buffer</code>来减少对<code>s2</code>表的访问次数，从而提高性能。</li>
<li><code>Using where</code>：可以看到查询语句中有一个<code>s1.common_field = s2.common_field</code>条件，因为<code>s1</code>是驱动表，<code>s2</code>是被驱动表，所以在访问<code>s2</code>表时，<code>s1.common_field</code>的值已经确定下来了，所以实际上查询<code>s2</code>表的条件就是<code>s2.common_field = 一个常数</code>，所以提示了<code>Using where</code>额外信息。</li>
</ul>
</li>
<li><p> <code>Not exists</code><br>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的<code>Extra</code>列就会提示<code>Not exists</code>额外信息，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280765248-adc53a64-08e5-4047-9282-dedf49c0ba53.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud66d86bd&margin=%5Bobject%20Object%5D&name=51.png&originHeight=168&originWidth=1735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20626&status=done&style=none&taskId=ue194205d-192b-4293-96ba-cbbb11125a2&title=" alt="51.png"><br>上述查询中<code>s1</code>表是驱动表，<code>s2</code>表是被驱动表，<code>s2.id</code>列是不允许存储<code>NULL</code>值的，而<code>WHERE</code>子句中又包含<code>s2.id IS NULL</code>的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配<code>ON</code>子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合<code>ON</code>子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们没有必要到被驱动表中找到全部符合ON子句条件的记录，这样可以稍微节省一点性能。  </p>
<blockquote>
<p>右（外）连接可以被转换为左（外）连接，所以就不提右（外）连接的情况了。</p>
</blockquote>
</li>
<li><p> <code>Using intersect(...)</code>、<code>Using union(...)</code>和<code>Using sort_union(...)</code><br>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。比如这个查询的执行计划：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280772463-3a90c8d1-6545-4018-b8d7-5025f232d7ee.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ueda5799e&margin=%5Bobject%20Object%5D&name=52.png&originHeight=143&originWidth=1303&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11849&status=done&style=none&taskId=u894c398e-c275-41a7-8968-5e3e310bd43&title=" alt="52.png"><br>其中<code>Extra</code>列就显示了<code>Using intersect(idx_key3,idx_key1)</code>，表明<code>MySQL</code>即将使用<code>idx_key3</code>和<code>idx_key1</code>这两个索引进行<code>Intersect</code>索引合并的方式执行查询。 </p>
</li>
<li><p> <code>Zero limit</code><br>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示不打算从表中读出任何记录，将会提示该额外信息，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280778887-9254ccb9-15d2-4dca-ae74-454146fcd5bc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u805e1066&margin=%5Bobject%20Object%5D&name=53.png&originHeight=153&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9929&status=done&style=none&taskId=ud78823f5-06ba-40ce-b3b7-d471c6eb90f&title=" alt="53.png"> </p>
</li>
<li><p> <code>Using filesort</code><br>有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280785452-754d9c90-0fa1-49ec-889c-dc8cf142399b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u231ab400&margin=%5Bobject%20Object%5D&name=54.png&originHeight=154&originWidth=1214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11063&status=done&style=none&taskId=u9983daa3-8d15-47c4-aeea-15b73d0dcc1&title=" alt="54.png"><br>这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，<code>MySQL</code>把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280791344-a71710e6-a915-4788-bc09-688eec1a399b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7aa08f31&margin=%5Bobject%20Object%5D&name=55.png&originHeight=148&originWidth=1290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11614&status=done&style=none&taskId=u5f2f6bce-bad5-4b54-8664-8d144260c1a&title=" alt="55.png"><br>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用<code>文件排序</code>的执行方式改为使用索引进行排序。 </p>
</li>
<li><p> <code>Using temporary</code><br>在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280797689-75d2cb3d-3866-480c-bf4e-8a69e479536f.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u286716ac&margin=%5Bobject%20Object%5D&name=56.png&originHeight=151&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11377&status=done&style=none&taskId=u4ce60cde-24ba-4663-aadd-a4e68b73f0d&title=" alt="56.png"><br>再比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280803837-7d795aa0-fd17-4d87-9ab0-07c295f5e7c9.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue7b2c60b&margin=%5Bobject%20Object%5D&name=57.png&originHeight=149&originWidth=1425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12625&status=done&style=none&taskId=ub9d1b398-3b4f-4f73-a1ee-342d85bf749&title=" alt="57.png"><br>不知道大家注意到没有，上述执行计划的<code>Extra</code>列不仅仅包含<code>Using temporary</code>提示，还包含<code>Using filesort</code>提示，可是我们的查询语句中明明没有写<code>ORDER BY</code>子句呀？这是因为<code>MySQL</code>会在包含<code>GROUP BY</code>子句的查询中默认添加上<code>ORDER BY</code>子句，也就是说上述查询其实和下边这个查询等价：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY common_field;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果我们并不想为包含GROUP BY子句的查询进行排序，需要我们显式的写上ORDER BY NULL，就像这样：<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280846631-90d86605-c8b9-4548-b10d-b44be5d9335f.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u822663e5&margin=%5Bobject%20Object%5D&name=58.png&originHeight=150&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12514&status=done&style=none&taskId=u61a5fe59-aa4c-4df4-b86a-5d5c7d5c8fe&title=" alt="58.png"><br>​</p>
<p>这回执行计划中就没有Using filesort的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。<br>​</p>
<p>另外，执行计划中出现Using temporary并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含GROUP BY子句的查询就不需要使用临时表：<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280856295-6e72f854-6076-48fe-9766-4b8dd70a434c.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uaf5517ea&margin=%5Bobject%20Object%5D&name=59.png&originHeight=136&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11837&status=done&style=none&taskId=ucb545596-9525-4ce1-ab15-e96493d37f6&title=" alt="59.png"><br>​</p>
<p>从Extra的Using index的提示里我们可以看出，上述查询只需要扫描idx_key1索引就可以搞定了，不再需要临时表了。</p>
<ul>
<li> <code>Start temporary, End temporary</code><br>查询优化器会优先尝试将<code>IN</code>子查询转换成<code>semi-join</code>，而<code>semi-join</code>又有好多种执行策略，当执行策略为<code>DuplicateWeedout</code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的<code>Extra</code>列将显示<code>Start temporary</code>提示，被驱动表查询执行计划的<code>Extra</code>列将显示<code>End temporary</code>提示，就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280870260-d8109158-d388-4665-87a3-fbc3393cb1e6.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u40bf656b&margin=%5Bobject%20Object%5D&name=60.png&originHeight=180&originWidth=1443&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18905&status=done&style=none&taskId=u60106558-b64a-4cad-8c4c-7e89266b735&title=" alt="60.png"></li>
<li> <code>LooseScan</code><br>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>LooseScan</code>执行策略，则在驱动表执行计划的<code>Extra</code>列就是显示<code>LooseScan</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280878656-f9849a88-d738-4e61-92fe-71e8fb4b8097.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud020c3be&margin=%5Bobject%20Object%5D&name=61.png&originHeight=182&originWidth=1553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18884&status=done&style=none&taskId=u48e16db1-823b-481d-93b1-641580ba363&title=" alt="61.png"> </li>
<li> <code>FirstMatch(tbl_name)</code><br>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>FirstMatch</code>执行策略，则在被驱动表执行计划的<code>Extra</code>列就是显示<code>FirstMatch(tbl_name)</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280886946-4cee061e-db5d-429b-9f77-887af2159190.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue6d1ea12&margin=%5Bobject%20Object%5D&name=62.png&originHeight=171&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17585&status=done&style=none&taskId=ue1333208-0342-496e-bc90-8215638090b&title=" alt="62.png"> </li>
</ul>
<h2 id="2-Json格式的执行计划"><a href="#2-Json格式的执行计划" class="headerlink" title="2.Json格式的执行计划"></a>2.Json格式的执行计划</h2><p>我们上边介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行计划好坏的重要属性 —— 成本。不过<code>MySQL</code>贴心的为我们提供了一种查看某个执行计划花费的成本的方式：</p>
<ul>
<li>在<code>EXPLAIN</code>单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。</li>
</ul>
<p>这样我们就可以得到一个<code>json</code>格式的执行计划，里边儿包含该计划花费的成本，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: 1,     # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;3197.16&quot;   # 整个查询的执行成本预计为3197.16</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [    # 几个表之间采用嵌套循环连接算法执行</span><br><span class="line">    </span><br><span class="line">    # 以下是参与嵌套循环连接算法的各个表的信息</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,   # s1表是驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,     # 访问方法为ALL，意味着使用全表扫描访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 9688,   # 查询一次s1表大致需要扫描9688条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 驱动表s1的扇出是968</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,  # condition filtering代表的百分比</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;1840.84&quot;,     # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;2034.60&quot;,   # 单次查询s1表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          </span><br><span class="line">          # 对s1表访问时针对单表查询的条件</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`xiaohaizi`.`s1`.`common_field` = &#x27;a&#x27;) and (`xiaohaizi`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,   # s2表是被驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ref&quot;,     # 访问方法为ref，意味着使用索引等值匹配的方式访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,    # 实际使用的索引</span><br><span class="line">          &quot;used_key_parts&quot;: [   # 使用到的索引列</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,    # key_len</span><br><span class="line">          &quot;ref&quot;: [      # 与key2列进行等值匹配的对象</span><br><span class="line">            &quot;xiaohaizi.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 1,  # 查询一次s2表大致需要扫描1条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,     # condition filtering代表的百分比</span><br><span class="line">          </span><br><span class="line">          # s2表使用索引进行查询的搜索条件</span><br><span class="line">          &quot;index_condition&quot;: &quot;(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;968.80&quot;,      # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;3197.16&quot;,   # 单次查询s1、多次查询s2表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>


<p><code>&quot;cost_info&quot;</code>里边的成本是怎么计算出来的？先看<code>s1</code>表的<code>&quot;cost_info&quot;</code>部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p><code>read_cost</code>是由下边这两部分组成的： </p>
<ul>
<li><code>IO</code>成本</li>
<li>检测<code>rows × (1 - filter)</code>条记录的<code>CPU</code>成本<blockquote>
<p>rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</p>
</blockquote>
</li>
</ul>
</li>
<li><p> <code>eval_cost</code>是这样计算的：<br>检测 <code>rows × filter</code>条记录的成本。 </p>
</li>
<li><p> <code>prefix_cost</code>就是单独查询<code>s1</code>表的成本，也就是：<br><code>read_cost + eval_cost</code> </p>
</li>
<li><p> <code>data_read_per_join</code>表示在此次查询中需要读取的数据量，我们就不多唠叨这个了。 </p>
</li>
</ul>
<blockquote>
<p>其实没必要关注MySQL为啥使用这么古怪的方式计算出read_cost和eval_cost，关注prefix_cost是查询s1表的成本就好了。</p>
</blockquote>
<p>对于<code>s2</code>表的<code>&quot;cost_info&quot;</code>部分是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;968.80&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;3197.16&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于<code>s2</code>表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code>和<code>eval_cost</code>是访问多次<code>s2</code>表后累加起来的值，主要关注里边儿的<code>prefix_cost</code>的值代表的是整个连接查询预计的成本，也就是单次查询<code>s1</code>表和多次查询<code>s2</code>表后的成本的和，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure>


<h2 id="3-Extented-EXPLAIN"><a href="#3-Extented-EXPLAIN" class="headerlink" title="3.Extented EXPLAIN"></a>3.Extented EXPLAIN</h2><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280900493-ef323458-9ed7-4213-a1bd-1b1a606384aa.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf7584cec&margin=%5Bobject%20Object%5D&name=63.png&originHeight=308&originWidth=1560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27815&status=done&style=none&taskId=ub7ecd933-32ca-458a-8f52-efe2fb29519&title=" alt="63.png"></p>
<p>可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level</code>、<code>Code</code>、<code>Message</code>。我们最常见的就是<code>Code</code>为<code>1003</code>的信息，当<code>Code</code>值为<code>1003</code>时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左（外）连接查询，但是有一个<code>s2.common_field IS NOT NULL</code>的条件，着就会导致查询优化器把左（外）连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的<code>LEFT JOIN</code>已经变成了<code>JOIN</code>。</p>
<p>我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接运行，它只能作为帮助我们理解查<code>MySQL</code>将如何执行查询语句的一个参考依据而已。</p>
<h1 id="二，optimizer-trace"><a href="#二，optimizer-trace" class="headerlink" title="二，optimizer trace"></a>二，optimizer trace</h1><p>对于<code>MySQL 5.6</code>以及之前的版本来说，查询优化器就像是一个黑盒子一样，只能通过<code>EXPLAIN</code>语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。</p>
<p>在<code>MySQL 5.6</code>以及之后的版本中，<code>MySQL</code>提出了一个<code>optimizer trace</code>的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量<code>optimizer_trace</code>决定，我们看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;optimizer_trace&#x27;;</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name   | Value                    |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled=off,one_line=off |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>


<p>可以看到<code>enabled</code>值为<code>off</code>，表明这个功能默认是关闭的。</p>
<blockquote>
<p>one_line的值是控制输出格式的，如果为on那么所有输出都将在一行中展示，不适合人阅读，所以我们就保持其默认值为off吧。</p>
</blockquote>
<p>如果想打开这个功能，必须首先把<code>enabled</code>的值改为<code>on</code>，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>


<p>然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。这个<code>OPTIMIZER_TRACE</code>表有4个列，分别是：</p>
<ul>
<li><code>QUERY</code>：表示我们的查询语句。</li>
<li><code>TRACE</code>：表示优化过程的JSON格式文本。</li>
<li><code>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</code>：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li>
<li><code>INSUFFICIENT_PRIVILEGES</code>：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是<code>1</code>，我们暂时不关心这个字段的值。</li>
</ul>
<p>完整的使用<code>optimizer trace</code>功能的步骤总结如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1. 打开optimizer trace功能 (默认情况下它是关闭的):</span><br><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line"># 2. 这里输入查询语句</span><br><span class="line">SELECT ...; </span><br><span class="line"></span><br><span class="line"># 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程</span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span><br><span class="line"></span><br><span class="line"># 4. 可能还要观察其他语句执行的优化过程，重复上边的第2、3步</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 5. 当停止查看语句的优化过程时，把optimizer trace功能关闭</span><br><span class="line">SET optimizer_trace=&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure>


<p>现在我们有一个搜索条件比较多的查询语句，它的执行计划如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280913355-faf51846-5a6c-457f-8c09-ef9a61f1e7f0.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua3d01893&margin=%5Bobject%20Object%5D&name=64.png&originHeight=133&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13872&status=done&style=none&taskId=u3f87397a-3e3c-45de-8b02-c7efbc04957&title=" alt="64.png"></p>
<p>可以看到该查询可能使用到的索引有3个，那么为什么优化器最终选择了<code>idx_key2</code>而不选择其他的索引或者直接全表扫描呢？这时候就可以通过<code>otpimzer trace</code>功能来查看优化器的具体工作过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND </span><br><span class="line">    key2 &lt; 1000000 AND </span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    common_field = &#x27;abc&#x27;;</span><br><span class="line">    </span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure>


<p>直接看一下通过查询<code>OPTIMIZER_TRACE</code>表得到的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line"># 分析的查询语句是什么</span><br><span class="line">QUERY: SELECT * FROM s1 WHERE</span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND</span><br><span class="line">    key2 &lt; 1000000 AND</span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">    common_field = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line"># 优化的具体过程</span><br><span class="line">TRACE: &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123;     # prepare阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;IN_uses_bisection&quot;: true</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `s1`.`id` AS `id`,`s1`.`key1` AS `key1`,`s1`.`key2` AS `key2`,`s1`.`key3` AS `key3`,`s1`.`key_part1` AS `key_part1`,`s1`.`key_part2` AS `key_part2`,`s1`.`key_part3` AS `key_part3`,`s1`.`common_field` AS `common_field` from `s1` where ((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_preparation */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;    # optimize阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;   # 处理搜索条件</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              # 原始搜索条件</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  # 等值传递转换</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 常量传递转换    </span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 去除没用的条件</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* steps */</span><br><span class="line">            &#125; /* condition_processing */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 替换虚拟生成列</span><br><span class="line">            &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">            &#125; /* substitute_generated_columns */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 表的依赖信息</span><br><span class="line">            &quot;table_dependencies&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                &quot;map_bit&quot;: 0,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ] /* depends_on_map_bits */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* table_dependencies */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">            ] /* ref_optimizer_key_uses */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">          </span><br><span class="line">            # 预估不同单表访问方法的访问成本</span><br><span class="line">            &quot;rows_estimation&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                  &quot;table_scan&quot;: &#123;   # 全表扫描的行数以及成本</span><br><span class="line">                    &quot;rows&quot;: 9688,</span><br><span class="line">                    &quot;cost&quot;: 2036.7</span><br><span class="line">                  &#125; /* table_scan */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析可能使用的索引</span><br><span class="line">                  &quot;potential_range_indexes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,   # 主键不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,  # idx_key2可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key2&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key1&quot;,  # idx_key1可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key1&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key3&quot;,  # idx_key3可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key3&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key_part&quot;,  # idx_keypart不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* potential_range_indexes */,</span><br><span class="line">                  &quot;setup_range_conditions&quot;: [</span><br><span class="line">                  ] /* setup_range_conditions */,</span><br><span class="line">                  &quot;group_index_range&quot;: &#123;</span><br><span class="line">                    &quot;chosen&quot;: false,</span><br><span class="line">                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                  &#125; /* group_index_range */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析各种可能使用的索引的成本</span><br><span class="line">                  &quot;analyzing_range_alternatives&quot;: &#123;</span><br><span class="line">                    &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key2的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                        # 使用idx_key2的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 是否使用index dive</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,     # 使用该索引获取的记录是否按照主键排序</span><br><span class="line">                        &quot;using_mrr&quot;: false,     # 是否使用mrr</span><br><span class="line">                        &quot;index_only&quot;: false,    # 是否是索引覆盖访问</span><br><span class="line">                        &quot;rows&quot;: 12,     # 使用该索引获取的记录条数</span><br><span class="line">                        &quot;cost&quot;: 15.41,  # 使用该索引的成本</span><br><span class="line">                        &quot;chosen&quot;: true  # 是否选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key1的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key1&quot;,</span><br><span class="line">                        # 使用idx_key1的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;z &lt; key1&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 266,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 320.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 因为成本太大所以不选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key3的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key3&quot;,</span><br><span class="line">                        # 使用idx_key3的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;a &lt;= key3 &lt;= a&quot;,</span><br><span class="line">                          &quot;b &lt;= key3 &lt;= b&quot;,</span><br><span class="line">                          &quot;c &lt;= key3 &lt;= c&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 21,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 28.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 同上</span><br><span class="line">                      &#125;</span><br><span class="line">                    ] /* range_scan_alternatives */,</span><br><span class="line">                    </span><br><span class="line">                    # 分析使用索引合并的成本</span><br><span class="line">                    &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                    &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                  &#125; /* analyzing_range_alternatives */,</span><br><span class="line">                  </span><br><span class="line">                  # 对于上述单表查询s1最优的访问方法</span><br><span class="line">                  &quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">                    &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                      &quot;rows&quot;: 12,</span><br><span class="line">                      &quot;ranges&quot;: [</span><br><span class="line">                        &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                      ] /* ranges */</span><br><span class="line">                    &#125; /* range_access_plan */,</span><br><span class="line">                    &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                    &quot;cost_for_plan&quot;: 15.41,</span><br><span class="line">                    &quot;chosen&quot;: true</span><br><span class="line">                  &#125; /* chosen_range_access_summary */</span><br><span class="line">                &#125; /* range_analysis */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* rows_estimation */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            </span><br><span class="line">            # 分析各种可能的执行计划</span><br><span class="line">            #（对多表查询这可能有很多种不同的方案，单表查询的方案上边已经分析过了，直接选取idx_key2就好）</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ] /* plan_prefix */,</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: 12,</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;range_details&quot;: &#123;</span><br><span class="line">                        &quot;used_index&quot;: &quot;idx_key2&quot;</span><br><span class="line">                      &#125; /* range_details */,</span><br><span class="line">                      &quot;resulting_rows&quot;: 12,</span><br><span class="line">                      &quot;cost&quot;: 17.81,</span><br><span class="line">                      &quot;chosen&quot;: true</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* considered_access_paths */</span><br><span class="line">                &#125; /* best_access_path */,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                &quot;cost_for_plan&quot;: 17.81,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* considered_execution_plans */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 尝试给查询添加一些其他的查询条件</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ] /* attached_conditions_computation */,</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* attached_conditions_summary */</span><br><span class="line">            &#125; /* attaching_conditions_to_tables */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 再稍稍的改进一下执行计划</span><br><span class="line">            &quot;refine_plan&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;pushed_index_condition&quot;: &quot;(`s1`.`key2` &lt; 1000000)&quot;,</span><br><span class="line">                &quot;table_condition_attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* refine_plan */</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_optimization */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123;    # execute阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_execution */</span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 因优化过程文本太多而丢弃的文本字节大小，值为0时表示并没有丢弃</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0</span><br><span class="line"></span><br><span class="line"># 权限字段</span><br><span class="line">INSUFFICIENT_PRIVILEGES: 0</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>


<p>这只是优化器执行过程中的一小部分，<code>MySQL</code>可能会在之后的版本中添加更多的优化过程信息。不过杂乱之中其实还是蛮有规律的，优化过程大致分为了三个阶段：</p>
<ul>
<li><code>prepare</code>阶段</li>
<li><code>optimize</code>阶段</li>
<li><code>execute</code>阶段</li>
</ul>
<p>我们所说的基于成本的优化主要集中在<code>optimize</code>阶段，对于单表查询来说，我们主要关注<code>optimize</code>阶段的<code>&quot;rows_estimation&quot;</code>这个过程，这个过程深入分析了对单表查询的各种执行方案的成本；对于多表连接查询来说，我们更多需要关注<code>&quot;considered_execution_plans&quot;</code>这个过程，这个过程里会写明各种不同的连接方式所对应的成本。反正优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用<code>EXPLAIN</code>语句所展现出的那种方案。</p>
<p>如果对使用<code>EXPLAIN</code>语句展示出的对某个查询的执行计划很不理解，可以尝试使用<code>optimizer trace</code>功能来详细了解每一种执行方案对应的成本。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[%E5%8D%81]Explain&amp;optimizer%20trace/">https://yinhuidong.github.io/2022/01/10/MySQL/MySQL[十]Explain&amp;optimizer trace/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%80%5D%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/"><img class="prev-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL[十一]高性能MySQL调优实战</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/09/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"><img class="next-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL[九]基于规则的优化&amp;子查询优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/01/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/" title="MySQL[一]入门"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-01</div><div class="title">MySQL[一]入门</div></div></a></div><div><a href="/2022/01/09/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL[九]基于规则的优化&子查询优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-09</div><div class="title">MySQL[九]基于规则的优化&子查询优化</div></div></a></div><div><a href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-20</div><div class="title">MySQL[二十]海量数据处理</div></div></a></div><div><a href="/2022/01/07/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/" title="MySQL[七]基于成本的优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-07</div><div class="title">MySQL[七]基于成本的优化</div></div></a></div><div><a href="/2022/01/03/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/" title="MySQL[三]InnoDB索引结构"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-03</div><div class="title">MySQL[三]InnoDB索引结构</div></div></a></div><div><a href="/2022/01/08/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/" title="MySQL[八]InnoDB统计数据收集原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-08</div><div class="title">MySQL[八]InnoDB统计数据收集原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8CExplain"><span class="toc-text">一，Explain</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%BE%93%E5%87%BA%E4%B8%AD%E5%90%84%E5%88%97%E8%AF%A6%E8%A7%A3"><span class="toc-text">1.执行计划输出中各列详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#table"><span class="toc-text">table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id"><span class="toc-text">id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-type"><span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partitions"><span class="toc-text">partitions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-text">type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#possible-keys%E5%92%8Ckey"><span class="toc-text">possible_keys和key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-len"><span class="toc-text">key_len</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rows"><span class="toc-text">rows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filtered"><span class="toc-text">filtered</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra"><span class="toc-text">Extra</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-text">2.Json格式的执行计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Extented-EXPLAIN"><span class="toc-text">3.Extented EXPLAIN</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8Coptimizer-trace"><span class="toc-text">二，optimizer trace</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十]海量数据处理"/></a><div class="content"><a class="title" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理">MySQL[二十]海量数据处理</a><time datetime="2022-01-19T16:00:00.000Z" title="发表于 2022-01-20 00:00:00">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/MySQL/MySQL%5B%E5%8D%81%E4%B8%83%5D%E9%94%81%E6%A6%82%E8%BF%B0/" title="MySQL[十七]锁概述"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十七]锁概述"/></a><div class="content"><a class="title" href="/2022/01/17/MySQL/MySQL%5B%E5%8D%81%E4%B8%83%5D%E9%94%81%E6%A6%82%E8%BF%B0/" title="MySQL[十七]锁概述">MySQL[十七]锁概述</a><time datetime="2022-01-16T16:00:00.000Z" title="发表于 2022-01-17 00:00:00">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/16/MySQL/MySQL%5B%E5%8D%81%E5%85%AD%5D%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-MVCC/" title="MySQL[十六]并发版本控制-MVCC"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十六]并发版本控制-MVCC"/></a><div class="content"><a class="title" href="/2022/01/16/MySQL/MySQL%5B%E5%8D%81%E5%85%AD%5D%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-MVCC/" title="MySQL[十六]并发版本控制-MVCC">MySQL[十六]并发版本控制-MVCC</a><time datetime="2022-01-15T16:00:00.000Z" title="发表于 2022-01-16 00:00:00">2022-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/MySQL/MySQL%5B%E5%8D%81%E4%BA%94%5Dundo%E6%97%A5%E5%BF%97/" title="MySQL[十五]undo日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十五]undo日志"/></a><div class="content"><a class="title" href="/2022/01/15/MySQL/MySQL%5B%E5%8D%81%E4%BA%94%5Dundo%E6%97%A5%E5%BF%97/" title="MySQL[十五]undo日志">MySQL[十五]undo日志</a><time datetime="2022-01-14T16:00:00.000Z" title="发表于 2022-01-15 00:00:00">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/" title="MySQL[十四]redo日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十四]redo日志"/></a><div class="content"><a class="title" href="/2022/01/14/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/" title="MySQL[十四]redo日志">MySQL[十四]redo日志</a><time datetime="2022-01-13T16:00:00.000Z" title="发表于 2022-01-14 00:00:00">2022-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>