<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>高并发设计模式 | huidong.yin</title><meta name="keywords" content="并发编程"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高并发设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="高并发设计模式">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/11/JUC/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="huidong.yin">
<meta property="og:description" content="高并发设计模式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/juc.png">
<meta property="article:published_time" content="2022-01-11T11:04:33.684Z">
<meta property="article:modified_time" content="2022-01-11T11:23:00.096Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/juc.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/11/JUC/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高并发设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 19:23:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">132</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/AboutMe/"><i class="fa-fw fas fa-user"></i><span> AboutMe</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/juc.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">huidong.yin</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/AboutMe/"><i class="fa-fw fas fa-user"></i><span> AboutMe</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高并发设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-11T11:04:33.684Z" title="发表于 2022-01-11 19:04:33">2022-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T11:23:00.096Z" title="更新于 2022-01-11 19:23:00">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC/">JUC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高并发设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>并发场景下，常见的设计模式可能存在线程安全问题，比如单例模式就是一个典型。另外，为了充分发挥多核的优势，高并发程序通常会将大的任务分割成一些规模比较小的任务，分而治之，这就出现了高并发下特有的一些设计模式，比如ForkJoin模式等等。</p>
</blockquote>
<h1 id="一，线程安全的单例模式"><a href="#一，线程安全的单例模式" class="headerlink" title="一，线程安全的单例模式"></a>一，线程安全的单例模式</h1><h2 id="1-双重检查锁"><a href="#1-双重检查锁" class="headerlink" title="1.双重检查锁"></a>1.双重检查锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonTestA instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTestA <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**判断对象是否已经初始化，如果已经初始化，直接返回。如果尚未初始化，加锁*/</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTestA.class) &#123;</span><br><span class="line">                <span class="comment">/**再次判断是否已经初始化，通过第一层判断的线程可能有很多，但是能够获得锁的线程只有一个。*/</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    分配一块内存M</span></span><br><span class="line"><span class="comment">                    在内存M上初始化Singleton对象</span></span><br><span class="line"><span class="comment">                    M的地址赋值给instance变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    指令重排后可能会出现问题</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTestA();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a>2.静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonTestA instance = <span class="keyword">new</span> SingletonTestA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有在方法被调用的时候，才会去加载内部类并且初始化单例。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTestA <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二，Master-Worder模式"><a href="#二，Master-Worder模式" class="headerlink" title="二，Master-Worder模式"></a>二，Master-Worder模式</h1><p>Master-Worker模式是一种常见的高并发模式，它的核心思想是任务的调度和执行分离，调度任务的角包五为Master，执行任务的角色为 Worker，Master负责接收、分配任务务和合并(Merge)任务结果， Worker负责执行任务。Master-Work er模式是一种归并类型的模式。</p>
<p>举一个例子，在TCP服务端的请青求处理过程中，大量的客户端连接相当于大量的任务，Master需要将这些任务存储在一个任务队列中，然后分发给各个Worker，每个Worker是一个工作线程，负责完成连接的传输处理。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631626357023-3921dab5-ee48-4cfb-a46d-eea74c389794.png#align=left&display=inline&height=1032&id=u8efe776e&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1032&originWidth=1864&size=661008&status=done&style=none&width=1864" alt="1.png"><br>假设一个场景，需要执行N个任务，将这些任务的结果进行累加求和，如果任务太多，就可以采用Master-Worker模式来实现。Master持有workerCount个Worker，并且负责接收任务，然后分发给Worker，最后在回调函数中对Worker的结果进行归并求和。</p>
<h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 二十</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/9/14 9:52 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterWorkerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTask</span> <span class="keyword">extends</span> <span class="title">Task</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">doExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;task &quot;</span> + getId() + <span class="string">&quot; is done !&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建master，包含4个worker，并启动master的执行线程</span></span><br><span class="line">        Master&lt;SimpleTask, Integer&gt; master = <span class="keyword">new</span> Master&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//定期向master提交任务</span></span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; master.submit(<span class="keyword">new</span> SimpleTask()), <span class="number">2L</span>, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//定期从master提取结果</span></span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; master.printResult(), <span class="number">5</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步任务类在执行子类任务的doExecute()之后，</span></span><br><span class="line"><span class="comment"> * 回调一下Master传递过来的回调函数，</span></span><br><span class="line"><span class="comment"> * 将执行完成后的任务进行回填。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//任务的回调函数</span></span><br><span class="line">    <span class="keyword">public</span> Consumer&lt;Task&lt;R&gt;&gt; resultAction;</span><br><span class="line">    <span class="comment">//任务的id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//worker id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerId;</span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    R result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = index.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">this</span>.doExecute();</span><br><span class="line">        resultAction.accept(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//钩子方法，交给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> R <span class="title">doExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Master 负责接收客户端提交额任务，然后通过阻塞队列对任务进行缓存。</span></span><br><span class="line"><span class="comment"> * Master所拥有的线程作为阻塞队列的消费者，不断从阻塞队列获取任务并轮流分给Worker。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//worker集合</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Worker&lt;T, R&gt;&gt; workers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//任务集合</span></span><br><span class="line">    <span class="keyword">protected</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//任务处理结果集合</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, R&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//Master的任务调度线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//保持最终的和</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong sum = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(<span class="keyword">int</span> workerCount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每一个worker对象都需要持有队列的引用，用于领取任务和提交结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) &#123;</span><br><span class="line">            Worker&lt;T, R&gt; worker = <span class="keyword">new</span> Worker&lt;&gt;();</span><br><span class="line">            workers.put(<span class="string">&quot;子节点：&quot;</span> + i, worker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.execute());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">        taskQueue.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取worker结果处理的回调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resultCallback</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Task&lt;R&gt; task = (Task&lt;R&gt;) o;</span><br><span class="line">        String taskName = <span class="string">&quot;Worker:&quot;</span> + task.getWorkerId() + <span class="string">&quot;-&quot;</span> + <span class="string">&quot;Task:&quot;</span> + task.getId();</span><br><span class="line">        R result = task.getResult();</span><br><span class="line">        resultMap.put(taskName, result);</span><br><span class="line">        sum.getAndAdd((Integer) result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动所有的子任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Worker&lt;T, R&gt;&gt; entry : workers.entrySet()) &#123;</span><br><span class="line">                T task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取任务</span></span><br><span class="line">                    task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line">                    <span class="comment">//获取节点</span></span><br><span class="line">                    Worker worker = entry.getValue();</span><br><span class="line">                    <span class="comment">//分配任务</span></span><br><span class="line">                    worker.submit(task, <span class="keyword">this</span>::resultCallback);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最终结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sum is : &quot;</span> + sum.get());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, R&gt; entry : resultMap.entrySet())</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Worker接收Master分配的任务，同样也通过阻塞队列对局部任务进行缓存。</span></span><br><span class="line"><span class="comment"> * Worker所拥有的的线程作为拒不任务的阻塞队列的消费者，</span></span><br><span class="line"><span class="comment"> * 不断从阻塞队列获取任务并执行，执行完成后回调Master传递过来的回调函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Task</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//接受任务的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; taskQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//Worker的编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerId = index.getAndIncrement();</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(() -&gt; <span class="keyword">this</span>.run());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//轮训执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//轮训启动任务</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从阻塞队列提取任务</span></span><br><span class="line">                T task = <span class="keyword">this</span>.taskQueue.take();</span><br><span class="line">                task.setWorkerId(workerId);</span><br><span class="line">                task.execute();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收任务到异步队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(T task, Consumer&lt;R&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置任务的回调方法</span></span><br><span class="line">        task.resultAction = action;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.taskQueue.put(task);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Netty中Master-Worker模式的实现"><a href="#2-Netty中Master-Worker模式的实现" class="headerlink" title="2.Netty中Master-Worker模式的实现"></a>2.Netty中Master-Worker模式的实现</h2><p>Master-Worker模式的核心思想是分而治之，Master角色负责接收和分配任务，Worker角色负责执行任务和结果回填。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631633623624-ebdf7008-8803-4dfd-b530-8b1d722dfa5f.png#align=left&display=inline&height=746&id=u6fd379a4&margin=%5Bobject%20Object%5D&name=1.png&originHeight=746&originWidth=1770&size=502563&status=done&style=none&width=1770" alt="1.png"><br>实际上，高性能传输模式Reactor模式就是Master-Worker模式在传输领域的一种应用。基于Java的NIO技术，Nettv设计了一套优秀的、高性能Reactor(反应器)模式的具体实现。在Netty中，EventLoop反应器内部有一个线程负责JavaNIO选择器的事件轮询，然后进行对应的事件分发。事件分发的目标就是Netty的Handler处理程序(含用户定义的业务处理程序)。</p>
<p>Netty服务器程序中需要设置两个EventLoopGroup轮询组，一个组负责新连接的监听和接收，另一个组负责IO传输事件的轮询与分发，两个轮询组的职责具体如下:</p>
<p>(1)负责新连接的监听和接收的EventLoopGroup轮询组中的反应器完成查询通道的新连接IO事件查询，这些反应器有点像负责招工的包工头，因此该轮询组可以形象地称为“包工头”(Boss)轮询组。</p>
<p>(2)另一个轮询组中的反应器完成查询所有子通道的IO事件，并且执行对应的Handler处理程序完成I0处理，例如数据的输入和输出(有点像搬砖)，这个轮询组可以形象地称为“工人”(Worker)轮询组。</p>
<p>Netty是基于Reactor模式的具体实现，体现了Master-Worker模式的思想。Netty的EventLoop(Reactor角色)可以对应到Master-Worker模式的Worker角色，而Netty的EventLoopGroup轮询组则可以对应到Master-Worker模式的Master角色。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631633822912-b55a05f1-9a1f-420a-bdf5-0daf13360fc5.png#align=left&display=inline&height=1030&id=ua19acc3e&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1030&originWidth=1836&size=594995&status=done&style=none&width=1836" alt="1.png"></p>
<h2 id="3-Nginx中Master-Worker模式的实现"><a href="#3-Nginx中Master-Worker模式的实现" class="headerlink" title="3.Nginx中Master-Worker模式的实现"></a>3.Nginx中Master-Worker模式的实现</h2><p>大名鼎鼎的Nginx服务器是Master-Worker模式(更准确地说是Reactor模式)在高性能服务器领域的一种应用。Nginx是一个高性能的 HTTP和反向代理Web服务器，是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Ramblerru站点开发的Web服务器。Nginx源代码以类BSD许可证的形式发布，它的第一个公开版本010发布于2004年10月4日，2011年6月1日发布了1.0.4版本。Nginx因其高稳定性、丰富的功能集、内存消耗少、并发能力强而闻名全球，目前得到非常广泛的使用，比如百度、京东、新浪、网易、腾讯、淘宝等都是它的用户。</p>
<p>Nginx在启动后会以daemon方式在后台运行，它的后台进程有两类:一类称为Master进程(相当于管理进程)，另一类称为Worker进程(工作进程)。Nginx的进程结构图如图。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631633960822-16876c3e-e7e1-433f-8918-e55b76d2c23e.png#align=left&display=inline&height=736&id=ue689805d&margin=%5Bobject%20Object%5D&name=1.png&originHeight=736&originWidth=1746&size=137510&status=done&style=none&width=1746" alt="1.png"></p>
<p>Nginx的Master进程主要负责调度Worker进程，比如加载配置、启动工作进程、接收来自外界的信号、向各Worker进程发送信号、监控 Worker进程的运行状态等。Master进程负责创建监听套接口，交由Worker进程进行连接监听。Worker进程主要用来处理网络事件，当一个 Worker进程在接收一条连接通道之后，就开始读取请求、解析请求、处理请求，处理完成产生的数据后，再返回给客户端，最后断开连接通道。</p>
<p>Nginx的架构非常直观地体现了Master-Worker模式的思想。Nginx的 Master进程可以对应到Master-Worker模式的Master角色，Nginx的 Worker进程可以对应到Master-Worker模式的Worker角色。</p>
<h1 id="三，ForkJoin模式"><a href="#三，ForkJoin模式" class="headerlink" title="三，ForkJoin模式"></a>三，ForkJoin模式</h1><p>“分而治之”是一种思想，所谓“分而治之”，就是把一个复杂的算法问题按一定的“分解”方法分为规模较小的若干部分，然后逐个解决，分别找出各部分的解，最后把各部分的解组成整个问题的解。“分而治之”思想在软件体系结构设计、模块化设计、基础算法中得到了非常广泛的应用。许多基础算法都运用了“分而治之”的思想，比如二分查找、快速排序等。</p>
<p>Master-Worker模式是“分而治之”思想的一种应用，ForkJoin模式则是“分而治之”思想的另一种应用。与Master-Worker模式不同，ForkJoin模式没有Master角色，其所有的角色都是Worker,ForkJoin模式中的Worker将大的任务分割成小的任务，一直到任务的规模足够小，可以使用很简单、直接的方式来完成。</p>
<h2 id="1-ForkJoin模式的原理"><a href="#1-ForkJoin模式的原理" class="headerlink" title="1.ForkJoin模式的原理"></a>1.ForkJoin模式的原理</h2><p>ForkJoin模式先把一个大任务分解成许多个独立的子任务，然后开启多个线程并行去处理这些子任务。有可能子任务还是很大而需要进一步分解，最终得到足够小的任务。ForkJoin模式的任务分解和执行过程如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631668146779-1b77b9a4-d85c-4432-b85e-41d456a7fcb9.png#align=left&display=inline&height=1046&id=ud6b8ad00&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1046&originWidth=1766&size=323384&status=done&style=none&width=1766" alt="1.png"><br>ForkJoin模式借助了现代计算机多核的优势并行处理数据。通常情况下，ForkJoin模式将分解出来的子任务放入双端队列中，然后几个启动线程从双端队列中获取任务并执行。子任务执行的结果放到一个队列中，各个线程从队列中获取数据，然后进行局部结果的合并，得到最终结果。</p>
<h2 id="2-ForkJoin框架"><a href="#2-ForkJoin框架" class="headerlink" title="2.ForkJoin框架"></a>2.ForkJoin框架</h2><p>JUC包提供了一套ForkJoin框架的实现，具体以ForkJoinPool线程池的形式提供，并且该线程池在Java8的Lambda并行流框架中充当着底层框架的角色。JUC包的ForkJoin框架包含如下组件:</p>
<p>(1)ForkJoinPool:执行任务的线程池，继承了 AbstractExecutorService类。</p>
<p>(2)ForkJoinWorkerThread:执行任务的工作线程(ForkJoinPool线程池中的线程)。每个线程都维护着一个内部队列，用于存放“内部任务”该类继承了Thread类。</p>
<p>(3)ForkJoinTask:用于ForkJoinPool的任务抽象类，实现了Future接口。</p>
<p>(4)RecursiveTask:带返回结果的递归执行任务，是ForkJoinTask的子类，在子任务带返回结果时使用。</p>
<p>(5)RecursiveAction:不返回结果的递归执行任务，是 ForkJoinTask的子类，在子任务不带返回结果时使用。</p>
<p>因为ForkJoinTask比较复杂，并日其抽象方法比较多，故在日常使用时一般不会直接继承ForkJoinTask来实现自定义的任务类，而是通过继承ForkJoinTask两个子类RecursiveTask或者RecursiveAction之一趋势线自定义任务类，自定义任务类需要实现这些子类的compute(),改方法的执行流程一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 任务足够小</span><br><span class="line">	直接返回结果</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	分割成N个子任务</span><br><span class="line">    依次调用每个子任务的fork方法执行子任务</span><br><span class="line">    依次调用每个子任务的join方法，等待子任务完成，然后合并执行结果</span><br></pre></td></tr></table></figure>
<h2 id="3-ForkJoin框架使用"><a href="#3-ForkJoin框架使用" class="headerlink" title="3.ForkJoin框架使用"></a>3.ForkJoin框架使用</h2><p>假设需要计算0-100的累加求和，可以使用ForkJoin框架完成。首先需要设计一个可以递归执行的异步任务子类。</p>
<h3 id="3-1-可递归执行的异步任务类AccumulateTask"><a href="#3-1-可递归执行的异步任务类AccumulateTask" class="headerlink" title="3.1 可递归执行的异步任务类AccumulateTask"></a>3.1 可递归执行的异步任务类AccumulateTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccumulateTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccumulateTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断任务的规模：若规模小可以直接计算</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        <span class="comment">//若任务已经足够小，则可以直接计算</span></span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="comment">//直接计算并返回结果，Recursive结束</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) sum += i;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;执行任务，计算：&quot;</span> + start + <span class="string">&quot;到&quot;</span> + end + <span class="string">&quot;的和，结果是： &quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//任务过大，需要切割，Recursive 递归计算</span></span><br><span class="line">            System.out.println(<span class="string">&quot;切割任务：将&quot;</span> + start + <span class="string">&quot;到&quot;</span> + end + <span class="string">&quot;的和一分为二&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//切割成2个子任务</span></span><br><span class="line">            AccumulateTask lTask = <span class="keyword">new</span> AccumulateTask(start, mid);</span><br><span class="line">            AccumulateTask rTask = <span class="keyword">new</span> AccumulateTask(mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//依次调用每个子任务的fork方法执行子任务</span></span><br><span class="line">            lTask.fork();</span><br><span class="line">            rTask.fork();</span><br><span class="line">            <span class="comment">//等待子任务完成，依次调用每个子任务的join()合并执行结果</span></span><br><span class="line">            <span class="keyword">int</span> lResult = lTask.join();</span><br><span class="line">            <span class="keyword">int</span> rResult = rTask.join();</span><br><span class="line">            <span class="comment">//合并子任务的执行结果</span></span><br><span class="line">            sum = lResult + rResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义的异步任务子类AccumulateTask继承自RecursiveTask，每一次执行可以携带返回值。AccumulateTask通过THRESHOLD常量设置子任务分解的阈值，并在它的computeO方法中进行阈值判断，判断的逻辑如下:</p>
<p>(1)若当前的计算规模(这里为求和的数字个数)大于THRESHOLD，就当前子任务需要进一步分解，若当前的计算规模没有大于THRESHOLD，则直接计算(这里为求和)。</p>
<p>(2)如果子任务可以直接执行，就进行求和操作，并返回结果。如果任务进行了分解，就需要等待所有的子任务执行完毕、然后对各个分解结果求和。如果一个任务分解为多个子任务(含两个)，就依次调用每个子任务的fork方法执行子任务，然后依次调用每个子任务的join方法合并执行结果。</p>
<h3 id="3-2-使用ForkJoinPool调度AccmulateTask"><a href="#3-2-使用ForkJoinPool调度AccmulateTask" class="headerlink" title="3.2 使用ForkJoinPool调度AccmulateTask()"></a>3.2 使用ForkJoinPool调度AccmulateTask()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAccumulateTask</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//创建一个累加任务，计算从1 到 10</span></span><br><span class="line">    AccumulateTask countTask = <span class="keyword">new</span> AccumulateTask(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">    Future&lt;Integer&gt; future = forkJoinPool.submit(countTask);</span><br><span class="line">    Integer sum = future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终计算结果是：&quot;</span>+sum);</span><br><span class="line">    Assert.assertTrue(sum==<span class="number">5050</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>切割任务：将1到100的和一分为二<br>切割任务：将51到100的和一分为二<br>切割任务：将1到50的和一分为二<br>切割任务：将1到25的和一分为二<br>切割任务：将1到13的和一分为二<br>切割任务：将1到7的和一分为二<br>切割任务：将1到4的和一分为二<br>执行任务，计算：1到2的和，结果是： 3<br>执行任务，计算：3到4的和，结果是： 7<br>执行任务，计算：5到7的和，结果是： 18<br>切割任务：将8到13的和一分为二<br>执行任务，计算：8到10的和，结果是： 27<br>执行任务，计算：11到13的和，结果是： 36<br>切割任务：将26到50的和一分为二<br>切割任务：将26到38的和一分为二<br>切割任务：将26到32的和一分为二<br>切割任务：将26到29的和一分为二<br>执行任务，计算：26到27的和，结果是： 53<br>执行任务，计算：28到29的和，结果是： 57<br>执行任务，计算：30到32的和，结果是： 93<br>切割任务：将33到38的和一分为二<br>执行任务，计算：33到35的和，结果是： 102<br>执行任务，计算：36到38的和，结果是： 111<br>切割任务：将39到50的和一分为二<br>切割任务：将39到44的和一分为二<br>执行任务，计算：39到41的和，结果是： 120<br>执行任务，计算：42到44的和，结果是： 129<br>切割任务：将45到50的和一分为二<br>执行任务，计算：45到47的和，结果是： 138<br>执行任务，计算：48到50的和，结果是： 147<br>切割任务：将76到100的和一分为二<br>切割任务：将76到88的和一分为二<br>切割任务：将76到82的和一分为二<br>切割任务：将76到79的和一分为二<br>执行任务，计算：76到77的和，结果是： 153<br>执行任务，计算：78到79的和，结果是： 157<br>执行任务，计算：80到82的和，结果是： 243<br>切割任务：将83到88的和一分为二<br>执行任务，计算：83到85的和，结果是： 252<br>执行任务，计算：86到88的和，结果是： 261<br>切割任务：将89到100的和一分为二<br>切割任务：将89到94的和一分为二<br>执行任务，计算：89到91的和，结果是： 270<br>执行任务，计算：92到94的和，结果是： 279<br>切割任务：将95到100的和一分为二<br>执行任务，计算：95到97的和，结果是： 288<br>执行任务，计算：98到100的和，结果是： 297<br>切割任务：将51到75的和一分为二<br>切割任务：将51到63的和一分为二<br>切割任务：将51到57的和一分为二<br>切割任务：将51到54的和一分为二<br>执行任务，计算：51到52的和，结果是： 103<br>执行任务，计算：53到54的和，结果是： 107<br>执行任务，计算：55到57的和，结果是： 168<br>切割任务：将58到63的和一分为二<br>执行任务，计算：58到60的和，结果是： 177<br>执行任务，计算：61到63的和，结果是： 186<br>切割任务：将64到75的和一分为二<br>切割任务：将64到69的和一分为二<br>执行任务，计算：64到66的和，结果是： 195<br>执行任务，计算：67到69的和，结果是： 204<br>切割任务：将70到75的和一分为二<br>执行任务，计算：70到72的和，结果是： 213<br>执行任务，计算：73到75的和，结果是： 222<br>切割任务：将14到25的和一分为二<br>切割任务：将14到19的和一分为二<br>执行任务，计算：14到16的和，结果是： 45<br>执行任务，计算：17到19的和，结果是： 54<br>切割任务：将20到25的和一分为二<br>执行任务，计算：20到22的和，结果是： 63<br>执行任务，计算：23到25的和，结果是： 72<br>最终计算结果是：5050</p>
</blockquote>
<h2 id="4-ForkJoin框架的核心API"><a href="#4-ForkJoin框架的核心API" class="headerlink" title="4.ForkJoin框架的核心API"></a>4.ForkJoin框架的核心API</h2><p>ForkJoin框架的核心是ForkJoinPool线程池。该线程池使用一个无锁的栈来管理空闲线程，如果一个工作线程暂时取不到可用的任务，则可能被挂起，而挂起的线程将被压入由ForkJoinPool维护的栈中，等到有新的任务到来的时候，再从栈中唤醒这些线程。</p>
<h3 id="4-1-构造器"><a href="#4-1-构造器" class="headerlink" title="4.1 构造器"></a>4.1 构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism, //并行度，默认为cpu数，最小为<span class="number">1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     ForkJoinWorkerThreadFactory factory, //线程创建工厂</span></span></span><br><span class="line"><span class="params"><span class="function">                     UncaughtExceptionHandler handler, //异常处理程序</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) parallelism:可并行级别</p>
<p>ForkJoin框架将依据parallelism设定的级别决定框架内并行执行的线程数量。并行的每一个任务都会有一个线程进行处理，但parallelism属性并不是ForkJoin框架中最大的线程数量，该属性和ThreadPoolExecutor线程池中的corePoolSize、maximumPoolSize属性有区别，因为 ForkJoinPool的结构和工作方式与ThreadPoolExecutor完全不一样。</p>
<p>ForkJoin框架中可存在的线程数量和parallelism参数值并不是绝对关联的。</p>
<p>(2)factory:线程创建工厂</p>
<p>当ForkJoin框架创建一个新的线程时，同样会用到线程创建工厂。只不过这个线程工厂不再需要实现ThreadFactorv接口，而是需要实现ForkJoinWorkerThreadFactory接口。后者是一个函数式接口，只需要实现一个名叫newThreadO的方法。在ForkJoin框架中有一个默认的ForkJoinWorkerThreadFactory接口实现 DefaultForkJoinWorkerThreadFactory。</p>
<p>(3)handler:异常捕获处理程序</p>
<p>当执行的任务中出现异常，并从任务中被抛出时，就会被handler捕获。</p>
<p>(4)asyncMode:异步模式</p>
<p>asyncMode参数表示任务是否为异步模式，其默认值为false。如果 asyncMode为true，就表示子任务的执行遵循FIFO(先进先出)顺序，并且子任务不能被合并;如果asyncMode为false，就表示子任务的执行遵循FIFO(后进先!)顺序，并日子任务可以被合并。虽然从字面意思来看asyncMode是指异步模式，它并不是指ForkJoin框架的调度模式采用是同步模式还是异步模式工作，仅仅指任务的调度方式。ForkJoin框架中为每一个独立工作的线程准备了对应的待执行任务队列，这个任务队列是使用数组进行组合的双向队列。asyncMode模式的主要意思指的是待执行任务可以使用FIFO(先进先出)的工作模式，也可以使用 FIFO(后进先出)的工作模式，工作模式为FIFO(先进先出)的任务适用于工作线程只负责运行异步事件，不需要合并结果的异步任务。</p>
<p>ForkJoinPool无参数的，默认的构造器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAP  = <span class="number">0x7fff</span>;        <span class="comment">// max #workers - 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">         defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该构造器的parallelism值为CPU核心数，factory值为defaultForkJoinWorkerThreadFactory默认的线程工厂，异常捕获处理程序handler值为null；表示不进行异常处理；异步模式asyncMode值为false，使用LIFO的，可以合并子任务的模式。</p>
<h3 id="4-2-common通用池"><a href="#4-2-common通用池" class="headerlink" title="4.2 common通用池"></a>4.2 common通用池</h3><p>很多场景可以直接使用ForkJoinPool定义的common通用池，调用ForkJoinPool.commonPool()可以获取该ForkJoin线程池，该线程池通过makeCommonPool()来构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">//并行度</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">            (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>);</span><br><span class="line">        <span class="comment">//线程工厂</span></span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">            (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;</span>);</span><br><span class="line">        <span class="comment">//异常处理类</span></span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">            (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = <span class="keyword">new</span> DefaultCommonPoolForkJoinWorkerThreadFactory();</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认并行度为cores-1</span></span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">&quot;ForkJoinPool.commonPool-worker-&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用common池子的优点是可以通过指定系统属性的方式定义”并行度，线程工厂和异常处理类“，并且common池使用的是同步模式，也就是说可以支持任务合并。</p>
<p>通过系统属性的方式指定parallellism的值得示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setPropert(<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>,<span class="string">&quot;8&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>除此之外，还可以通过Java指令的选项的方式指定parallellism值，具体的选项为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=<span class="number">8</span></span><br></pre></td></tr></table></figure>


<p>其他的参数值如异常处理程序handler，都可以通过以上两种方式指定。</p>
<h3 id="4-3-向线程池提交任务的方式"><a href="#4-3-向线程池提交任务的方式" class="headerlink" title="4.3 向线程池提交任务的方式"></a>4.3 向线程池提交任务的方式</h3><p>可以向ForkJoinPool线程池提交一下两类任务：</p>
<ol>
<li>外部任务（External/Submissions Task）</li>
</ol>
<p>向ForkJoinPool提交外部任务有三种方式:方式一是调用invoke()方法，该方法提交任务后线程会等待，等到任务计算完毕返回结果;方式二是调用execute方法提交一个任务来异步执行，无返回结果;方式三是调用submit方法提交一个任务，并且会返回一个ForkJoinTask实例，之后适当的时候可通过ForkJoinTask实例获取执行结果。</p>
<ol start="2">
<li>子任务（Worker Task）提交</li>
</ol>
<p>向ForkJoinPool提交子任务的方法相对比较简单，由任务实例的 fork方法完成。当任务被分割之后，内部会调用ForkJoinPool.WorkQueuepush()方法直接把任务放到内部队列中等待被执行。</p>
<h2 id="5-工作窃取算法"><a href="#5-工作窃取算法" class="headerlink" title="5.工作窃取算法"></a>5.工作窃取算法</h2><p>ForkJoinPool线程池的任务分为“外部任务”和“内部任务”，两种任务的存放位置不同:</p>
<p>(1)外部任务存放在ForkJoinPool的全局队列中。</p>
<p>(2)子任务会作为“内部任务”放到内部队列中，ForkJoinPool池中的每个线程都维护着一个内部队列，用于存放这些“内部任务”。</p>
<p>由于ForkJoinPool线程池通常有多个工作线程，与之相对应的就会有多个任务队列，这就会出现任务分配不均衡的问题:有的队列任务多，忙得不停，有的队列没有任务，一直空闲。那么有没有一种机制帮忙将任务从繁忙的线程分摊给空闲的线程呢?答案是使用工作窃取算法。</p>
<p>工作窃取算法的核心思想是:工作线程自己的活干完了之后，会去看看别人有没有没干完的活，如果有就拿过来帮忙干。工作窃取算法的主要逻辑:每个线程拥有一个双端队列(本地队列)，用于存放需要执行的任务，当自己的队列没有任务时，可以从其他线程的任务队列中获得一个任务继续执行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631688122436-09659862-8981-407b-9396-abc5a6dfcad0.png#align=left&display=inline&height=702&id=ub740a9e4&margin=%5Bobject%20Object%5D&name=1.png&originHeight=702&originWidth=1546&size=220003&status=done&style=none&width=1546" alt="1.png"><br>在实际进行任务窃取操作的时候，操作线程会进行其他线程的任务队列的扫描和任务的出队尝试。为什么说是尝试?因为完全有可能操作失败，主要原因是并行执行肯定涉及线程安全的问题，假如在窃取过程中该任务已经开始执行，那么任务的窃取操作就会失败。</p>
<p>如何尽量避免在任务窃取中发生的线程安全问题呢?一种简单的优化方法是:在线程自己的本地队列采取LIFO(后进先出)策略，窃取其他任务队列的任务时采用FIFO(先进先出)策略。简单来说，获取自己队列的任务时从头开始，窃取其他队列的任务时从尾开始。由于窃取的动作十分快速，会大量降低这种冲突，也是一种优化方式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631688296612-b65fea3a-4e88-4e9d-a60d-3b0059f3a121.png#align=left&display=inline&height=918&id=uace6ea4c&margin=%5Bobject%20Object%5D&name=1.png&originHeight=918&originWidth=1404&size=150874&status=done&style=none&width=1404" alt="1.png"></p>
<h2 id="6-ForkJoin框架的原理"><a href="#6-ForkJoin框架的原理" class="headerlink" title="6.ForkJoin框架的原理"></a>6.ForkJoin框架的原理</h2><p><strong>核心原理大致如下：</strong></p>
<p>(1)ForkJoin框架的线程池ForkJoinPool的任务分为“外部任务”和“内部任务”。</p>
<p>(2)“外部任务”放在ForkJoinPool的全局队列中。</p>
<p>(3)ForkJoinPool池中的每个线程都维护着一个任务队列，用于存放“内部任务”，线程切割任务得到的子任务会作为“内部任务”放到内部队列中。</p>
<p>(4)当工作线程想要拿到子任务的计算结果时，先判断子任务有没有完成，如果没有完成，再判断子任务有没有被其他线程“窃取”，如果子任务没有被窃取，就由本线程来完成;一旦子任务被窃取了，就去执行本线程“内部队列”的其他任务，或者扫描其他的任务队列并窃取任务。</p>
<p>(5)当工作线程完成其“内部任务”，处于空闲状态时，就会扫描其他的任务队列窃取任务，尽可能不会阻塞等待。</p>
<p>总之，ForkJoin线程在等待一个任务完成时，要么自己来完成这个任务，要么在其他线程窃取了这个任务的情况下，去执行其他任务，是不会阻塞等待的，从而避免资源浪费，除非所有任务队列都为空。</p>
<p><strong>工作窃取算法的优点：</strong></p>
<p>(1)线程是不会因为等待某个子任务的执行或者没有内部任务要执行而被阻塞等待、挂起的，而是会扫描所有的队列窃取任务，直到所有队列都为空时才会被挂起。</p>
<p>(2)ForkJoin框架为每个线程维护着一个内部任务队列以及一个全局的任务队列，而且任务队列都是双向队列，可从首尾两端来获取任务，极大地减少了竞争的可能性，提高并行的性能。</p>
<p>ForkJoinPool适合需要“分而治之”的场景，特别是分治之后递归调用的函数，例如快速排序、二分搜索、大整数乘法、矩阵乘法、棋盘覆盖、归并排序、线性时间选择、汉诺塔问题等。ForkJoinPool适合调度的任务为CPU密集型任务，如果任务存在I/0操作、线程同步操作、sleep睡眠等较长时间阻塞的情况，最好配合使用ManagedBlocker进行阻塞管理。总体来说，ForkJoinPool不适合进行I0密集型、混合型的任务调度。</p>
<h1 id="四，生产者-消费者模式"><a href="#四，生产者-消费者模式" class="headerlink" title="四，生产者-消费者模式"></a>四，生产者-消费者模式</h1><p>生产者-消费者模式是一个经典的多线程设计模式，它为多线程间的协作提供了良好的解决方案，是高并发编程过程中常用的一种设计模式。</p>
<p>在实际的软件开发过程中，经常会碰到如下场景:某些模块负责产生数据，另一些模块负责消费数据(此处的模块可以是类、承数、线程、进程等)。产生数据的模块可以形象地称为生产者，而消费数据的模块可以称为消费者。然而，仅仅抽象出来生产者和消费者还不够，该模式还需要有一个数据缓冲区作为生产者和消费者之间的中介:生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631688933417-2adb2133-1b2f-466b-aa63-87611bcf7591.png#align=left&display=inline&height=358&id=ue1e6ff89&margin=%5Bobject%20Object%5D&name=1.png&originHeight=358&originWidth=1590&size=88138&status=done&style=none&width=1590" alt="1.png"></p>
<p>数据缓冲区的作用主要在于能使生产者和消费者解耦。如果没有数据缓冲区，让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖(也就是耦合)。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。<br>生产者-消费者模式天生就是用来处理并发问题的。生产者和消费者是两个独立的并发主体，生产者把制造出来的数据往缓冲区一放，就可以再去生产下一个数据了。生产者基本上不用依赖消费者的处理速度。尤其是在生成者的速度时快时慢时，生产者-消费者模式的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。</p>
<p>在生产者-消费者模式中，缓冲区是性能的关键，缓冲区可以基于 ArrayList、LinkedList、BlockingQueue、环形队列等各种不同的数据存储组件去设计，所使用的组件不同，生产者-消费者模式实现的性能当然也就不同。</p>
<h1 id="五，Future模式"><a href="#五，Future模式" class="headerlink" title="五，Future模式"></a>五，Future模式</h1><p>Future模式是高并发设计与开发过程中常见的设计模式，它的核心思想是异步调用。对于Future模式来说，它不是立即返回我们所需要的数据，但是它会返回一个契约(或异步任务)，将来我们可以凭借这个契约(或异步任务)获取需要的结果。</p>
<p>在进行传统的RPC(远程调用)时，同步调用RPC是一段耗时的过程。当客户端发出RPC请求后，服务端完成请求处理需要很长的一段时间才会返回，这个过程中客户端一直在等待，直到数据返回后，再进行其他任务的处理。现有一个Client同步对三个Server分别进行一次RPC调用。</p>
<p>假设一次远程调用的时间为500毫秒，则一个Client同步对三个Server分别进行一次RPC调用的总时间需要耗费1500毫秒。如果要节省这个总时间，可以使用Future模式对其进行改造，将同步的RPC调用改为异步并发的RPC调用，一个Client异步并发对三个Server分别进行一次 RPC调用。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631689234632-aad4ed1d-5768-4ebc-a856-e6e865f5c9ce.png#align=left&display=inline&height=964&id=u5afb9737&margin=%5Bobject%20Object%5D&name=1.png&originHeight=964&originWidth=1510&size=183232&status=done&style=none&width=1510" alt="1.png"><br>一个Client同步对三个Server分别进行一次RPC调用<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1631689259140-e5bdcd3f-2ddc-4b5c-b4ca-9f87e5cb9aee.png#align=left&display=inline&height=778&id=u195bfeec&margin=%5Bobject%20Object%5D&name=1.png&originHeight=778&originWidth=1548&size=192250&status=done&style=none&width=1548" alt="1.png"></p>
<p>一个Client异步并发对三个Server分别进行一次RPC调用</p>
<p>假设一次远程调用的时间为500毫秒，则一个Client异步并发对三个 Server分别进行一次RPC调用的总时间只要耗费500毫秒。使用Future模式异步并发地进行RPC调用，客户端在得到一个RPC的返回结果前并不急于获取该结果，而是充分利用等待时间去执行其他的耗时操作(如其他RPC调用)，这就是Future模式的核心所在。</p>
<p>Future模式的核心思想是异步调用，有点类似于异步的Ajax请求。当调用某个耗时方法时，可以不急于立刻获取结果，而是让被调用者立刻返回一个契约(或异步任务)，并且将耗时的方法放到另外的线程中执行，后续凭契约再去获取异步执行的结果。</p>
<p>在具体的实现上，Future模式和异步回调模式既有区别，又有联系。Java的Future实现类并没有支持异步回调，仍然需要主动获取耗时任务的结果;而Java8中的CompletableFuture组件实现了异步回调模式。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/11/JUC/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">https://yinhuidong.github.io/2022/01/11/JUC/高并发设计模式/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">huidong.yin</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">huidong.yin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/juc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/JUC/%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/"><img class="prev-cover" src="/images/cover/juc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">线程间传递上下文信息</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/11/JUC/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"><img class="next-cover" src="/images/cover/juc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高并发核心模式之异步回调</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/11/JUC/CAS%E5%8E%9F%E7%90%86/" title="CAS原理"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CAS原理</div></div></a></div><div><a href="/2022/01/11/JUC/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/" title="Atomic原子类"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Atomic原子类</div></div></a></div><div><a href="/2022/01/11/JUC/AQS/" title="AQS"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">AQS</div></div></a></div><div><a href="/2022/01/11/JUC/CountDownLatch/" title="CountDownLatch"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CountDownLatch</div></div></a></div><div><a href="/2022/01/11/JUC/CyclicBarrier/" title="CyclicBarrier"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CyclicBarrier</div></div></a></div><div><a href="/2022/01/11/JUC/CompletableFuture/" title="CompletableFuture"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CompletableFuture</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到huidong.yin的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">132</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到huidong.yin的个人博客，联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">一，线程安全的单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81"><span class="toc-text">1.双重检查锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">2.静态内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CMaster-Worder%E6%A8%A1%E5%BC%8F"><span class="toc-text">二，Master-Worder模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Netty%E4%B8%ADMaster-Worker%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.Netty中Master-Worker模式的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Nginx%E4%B8%ADMaster-Worker%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.Nginx中Master-Worker模式的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CForkJoin%E6%A8%A1%E5%BC%8F"><span class="toc-text">三，ForkJoin模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ForkJoin%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.ForkJoin模式的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ForkJoin%E6%A1%86%E6%9E%B6"><span class="toc-text">2.ForkJoin框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ForkJoin%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8"><span class="toc-text">3.ForkJoin框架使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8F%AF%E9%80%92%E5%BD%92%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%B1%BBAccumulateTask"><span class="toc-text">3.1 可递归执行的异步任务类AccumulateTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8ForkJoinPool%E8%B0%83%E5%BA%A6AccmulateTask"><span class="toc-text">3.2 使用ForkJoinPool调度AccmulateTask()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ForkJoin%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E5%BF%83API"><span class="toc-text">4.ForkJoin框架的核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">4.1 构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-common%E9%80%9A%E7%94%A8%E6%B1%A0"><span class="toc-text">4.2 common通用池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">4.3 向线程池提交任务的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95"><span class="toc-text">5.工作窃取算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-ForkJoin%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">6.ForkJoin框架的原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">四，生产者-消费者模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%EF%BC%8CFuture%E6%A8%A1%E5%BC%8F"><span class="toc-text">五，Future模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/24/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E5%9B%9B%5D%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL[二十四]两阶段提交"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十四]两阶段提交"/></a><div class="content"><a class="title" href="/2022/01/24/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E5%9B%9B%5D%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL[二十四]两阶段提交">MySQL[二十四]两阶段提交</a><time datetime="2022-01-23T16:00:00.000Z" title="发表于 2022-01-24 00:00:00">2022-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/" title="MySQL[二十三]二进制日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十三]二进制日志"/></a><div class="content"><a class="title" href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/" title="MySQL[二十三]二进制日志">MySQL[二十三]二进制日志</a><time datetime="2022-01-22T16:00:00.000Z" title="发表于 2022-01-23 00:00:00">2022-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/22/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%BA%8C%5DCOUNT/" title="MySQL[二十二]COUNT"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十二]COUNT"/></a><div class="content"><a class="title" href="/2022/01/22/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%BA%8C%5DCOUNT/" title="MySQL[二十二]COUNT">MySQL[二十二]COUNT</a><time datetime="2022-01-21T16:00:00.000Z" title="发表于 2022-01-22 00:00:00">2022-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%80%5DLIMIT/" title="MySQL[二十一]LIMIT"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十一]LIMIT"/></a><div class="content"><a class="title" href="/2022/01/21/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%80%5DLIMIT/" title="MySQL[二十一]LIMIT">MySQL[二十一]LIMIT</a><time datetime="2022-01-20T16:00:00.000Z" title="发表于 2022-01-21 00:00:00">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十]海量数据处理"/></a><div class="content"><a class="title" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理">MySQL[二十]海量数据处理</a><time datetime="2022-01-19T16:00:00.000Z" title="发表于 2022-01-20 00:00:00">2022-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/juc.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>