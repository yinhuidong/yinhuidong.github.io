<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL[七]基于成本的优化 | 二十</title><meta name="keywords" content="MySQL"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于成本的优化">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL[七]基于成本的优化">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[%E4%B8%83]%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="基于成本的优化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2022-01-11T03:16:05.985Z">
<meta property="article:modified_time" content="2022-01-11T03:21:45.620Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[%E4%B8%83]%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL[七]基于成本的优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 11:21:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL[七]基于成本的优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-11T03:16:05.985Z" title="发表于 2022-01-11 11:16:05">2022-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T03:21:45.620Z" title="更新于 2022-01-11 11:21:45">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL[七]基于成本的优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-什么是成本？"><a href="#1-什么是成本？" class="headerlink" title="1.什么是成本？"></a>1.什么是成本？</h1><p>在<code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p>
<ul>
<li> <code>I/O</code>成本<br>我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。 </li>
<li> <code>CPU</code>成本<br>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。 </li>
</ul>
<p>对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，<code>MySQL</code>规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>。</p>
<blockquote>
<p>不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p>
</blockquote>
<h1 id="2-单表查询的成本"><a href="#2-单表查询的成本" class="headerlink" title="2.单表查询的成本"></a>2.单表查询的成本</h1><h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><p>把之前用到的<code>single_table</code>表搬来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>


<h2 id="2-2-基于成本的优化步骤"><a href="#2-2-基于成本的优化步骤" class="headerlink" title="2.2 基于成本的优化步骤"></a>2.2 基于成本的优化步骤</h2><p>在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE </span><br><span class="line">    key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    key2 &gt; 10 AND key2 &lt; 1000 AND </span><br><span class="line">    key3 &gt; key2 AND </span><br><span class="line">    key_part1 LIKE &#x27;%hello%&#x27; AND</span><br><span class="line">    common_field = &#x27;123&#x27;;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-1-根据搜索条件，找出所有可能使用的索引"><a href="#2-2-1-根据搜索条件，找出所有可能使用的索引" class="headerlink" title="2.2.1 根据搜索条件，找出所有可能使用的索引"></a>2.2.1 根据搜索条件，找出所有可能使用的索引</h3><p>对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，<code>MySQL</code>把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p>
<p>我们分析一下上边查询中涉及到的几个搜索条件：</p>
<ul>
<li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li>
<li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li>
<li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li>
<li><code>key_part1 LIKE &#39;%hello%&#39;</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li>
<li><code>common_field = &#39;123&#39;</code>，由于该列上压根儿没有索引，所以不会用到索引。</li>
</ul>
<p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p>
<h3 id="2-2-2-计算全表扫描的代价"><a href="#2-2-2-计算全表扫描的代价" class="headerlink" title="2.2.2 计算全表扫描的代价"></a>2.2.2 计算全表扫描的代价</h3><p>对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p>
<ul>
<li>聚簇索引占用的页面数</li>
<li>该表中的记录数</li>
</ul>
<p>这两个信息从哪来呢？<code>MySQL</code>为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的后面再谈，现在看看怎么查看这些统计信息。<code>MySQL</code>给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE &#x27;single_table&#x27;</span><br></pre></td></tr></table></figure>


<p>虽然出现了很多统计选项，但我们目前只关心两个：</p>
<ul>
<li> <code>Rows</code><br>本选项表示表中的记录条数。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。 </li>
<li> <code>Data_length</code><br>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：<br>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data_length = 聚簇索引的页面数量 x 每个页面的大小</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是<code>MySQL</code>在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，这些微调的值十分的小，并不影响我们分析。现在可以看一下全表扫描成本的计算过程：</p>
<ul>
<li><p> <code>I/O</code>成本<br><code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 x 1.0 + 1.1 = 98.1</span><br></pre></td></tr></table></figure></li>
<li><p> <code>CPU</code>成本：<br><code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 x 0.2 + 1.0 = 1939.6</span><br></pre></td></tr></table></figure></li>
<li><p> 总成本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">98.1 + 1939.6 = 2037.7</span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p>
<blockquote>
<p>表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是MySQL在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I/O成本的依据，是不区分内节点和叶子节点的。</p>
</blockquote>
<h3 id="2-2-3-计算使用不同索引执行查询的代价"><a href="#2-2-3-计算使用不同索引执行查询的代价" class="headerlink" title="2.2.3 计算使用不同索引执行查询的代价"></a>2.2.3 计算使用不同索引执行查询的代价</h3><p>从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p>
<h4 id="①使用idx-key2执行查询的成本分析"><a href="#①使用idx-key2执行查询的成本分析" class="headerlink" title="①使用idx_key2执行查询的成本分析"></a>①使用idx_key2执行查询的成本分析</h4><p><code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176350999-33e75909-f6cf-4f47-8a62-a2d8212eb876.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u71764c3f&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1170&originWidth=1622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=575463&status=done&style=none&taskId=u1e906447-5f38-4b93-8674-a23e7572a47&title=" alt="1.png"></p>
<p>对于使用<code>二级索引 + 回表</code>方式的查询，<code>MySQL</code>计算这种查询的成本依赖两个方面的数据：</p>
<ul>
<li><p> 范围区间数量<br>不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 x 1.0 = 1.0</span><br></pre></td></tr></table></figure></li>
<li><p>需要回表的记录数<br>优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算<code>idx_key2</code>在<code>(10, 1000)</code>这个范围区间中包含多少二级索引记录，计算过程是这样的： </p>
<ul>
<li> 步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。 </li>
<li> 步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。 </li>
<li> 步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176366166-30415d07-4c40-4385-bf7e-e6f27ecd0b98.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9da06e48&margin=%5Bobject%20Object%5D&name=2.png&originHeight=972&originWidth=1890&originalType=binary&ratio=1&rotation=0&showTitle=false&size=419948&status=done&style=none&taskId=ue5d8028d-6b8b-462c-8ee2-a9ab5e558aa&title=" alt="2.png"></li>
</ul>
</li>
</ul>
<p>如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就贼小了。<br>如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中，继续递归，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。<br>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 = 19.01</span><br></pre></td></tr></table></figure>
<p>其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。<br>在通过二级索引获取到记录之后，还需要干两件事儿： </p>
<ul>
<li><p> 根据这些记录里的主键值到聚簇索引中做回表操作<br><code>MySQL</code>认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上边统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：<br>其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 1.0 = 95.0</span><br></pre></td></tr></table></figure></li>
<li><p> 回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立<br>回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：<br><code>MySQL</code>只计算这个查找过程所需的<code>I/O</code>成本，也就是我们上一步骤中得到的<code>95.0</code>，在内存中的定位完整用户记录的过程的成本是忽略不计的。在定位到这些完整的用户记录后，需要检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立，这个比较过程花费的<code>CPU</code>成本就是：<br>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 = 19.0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p>
<ul>
<li><p> <code>I/O</code>成本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0 + 95 x 1.0 = 96.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li>
<li><p> <code>CPU</code>成本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 + 95 x 0.2 = 38.01 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96.0 + 38.01 = 134.01</span><br></pre></td></tr></table></figure>


<h4 id="②使用idx-key1执行查询的成本分析"><a href="#②使用idx-key1执行查询的成本分析" class="headerlink" title="②使用idx_key1执行查询的成本分析"></a>②使用idx_key1执行查询的成本分析</h4><p><code>idx_key1</code>对应的搜索条件是：<code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，也就是说相当于3个单点区间：</p>
<ul>
<li><code>[&#39;a&#39;, &#39;a&#39;]</code></li>
<li><code>[&#39;b&#39;, &#39;b&#39;]</code></li>
<li><code>[&#39;c&#39;, &#39;c&#39;]</code></li>
</ul>
<p>使用<code>idx_key1</code>搜索的示意图就是这样子：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176380041-9a9e19f0-8469-426c-a064-ec10b855b743.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u920d7136&margin=%5Bobject%20Object%5D&name=3.png&originHeight=1144&originWidth=1524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=621869&status=done&style=none&taskId=u47f178fc-4c5c-47b1-ae74-fcb0d934c72&title=" alt="3.png"></p>
<p>与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p>
<ul>
<li><p> 范围区间数量<br>使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 x 1.0 = 3.0</span><br></pre></td></tr></table></figure></li>
<li><p>需要回表的记录数<br>由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数： </p>
<ul>
<li> 查找单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数<br>计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，最后计算得到单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数是：<code>35</code>。 </li>
<li> 查找单点区间<code>[&#39;b&#39;, &#39;b&#39;]</code>对应的二级索引记录数<br>与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。 </li>
<li> 查找单点区间<code>[&#39;c&#39;, &#39;c&#39;]</code>对应的二级索引记录数<br>与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。 </li>
</ul>
</li>
</ul>
<p>所以，这三个单点区间总共需要回表的记录数就是： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 + 44 + 39 = 118</span><br></pre></td></tr></table></figure>
<p>读取这些二级索引记录的<code>CPU</code>成本就是： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 = 23.61</span><br></pre></td></tr></table></figure>
<p>得到总共需要回表的记录数之后，就要考虑： </p>
<ul>
<li><p> 根据这些记录里的主键值到聚簇索引中做回表操作<br>所需的<code>I/O</code>成本就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 1.0 = 118.0</span><br></pre></td></tr></table></figure></li>
<li><p> 回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立<br>此步骤对应的<code>CPU</code>成本就是：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 = 23.6</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p>
<ul>
<li><p> <code>I/O</code>成本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0 + 118 x 1.0 = 121.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li>
<li><p> <code>CPU</code>成本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 + 118 x 0.2 = 47.21 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.0 + 47.21 = 168.21</span><br></pre></td></tr></table></figure>


<h4 id="③是否有可能使用索引合并（Index-Merge）"><a href="#③是否有可能使用索引合并（Index-Merge）" class="headerlink" title="③是否有可能使用索引合并（Index Merge）"></a>③是否有可能使用索引合并（Index Merge）</h4><p>本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p>
<h3 id="2-2-4-对比各种执行方案的代价，找出成本最低的那一个"><a href="#2-2-4-对比各种执行方案的代价，找出成本最低的那一个" class="headerlink" title="2.2.4 对比各种执行方案的代价，找出成本最低的那一个"></a>2.2.4 对比各种执行方案的代价，找出成本最低的那一个</h3><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p>
<ul>
<li>全表扫描的成本：<code>2037.7</code></li>
<li>使用<code>idx_key2</code>的成本：<code>134.01</code></li>
<li>使用<code>idx_key1</code>的成本：<code>168.21</code></li>
</ul>
<p>很显然，使用<code>idx_key2</code>的成本最低，所以选择<code>idx_key2</code>来执行查询。</p>
<h2 id="2-3-基于索引统计数据的成本计算"><a href="#2-3-基于索引统计数据的成本计算" class="headerlink" title="2.3 基于索引统计数据的成本计算"></a>2.3 基于索引统计数据的成本计算</h2><p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下边这个查询（下边查询语句中的<code>...</code>表示还有很多参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure>


<p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。<code>MySQL</code>把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p>
<blockquote>
<p>index dive就是直接利用索引对应的B+树来计算某个范围区间对应的记录条数。</p>
</blockquote>
<p>有几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是如果很多的话，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。<code>MySQL</code>提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%dive%&#x27;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| eq_range_index_dive_limit | 200   |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure>


<p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。</p>
<p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM single_table;</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table        | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| single_table |          0 | PRIMARY      |            1 | id          | A         |       9693  |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| single_table |          0 | idx_key2     |            1 | key2        | A         |       9693  |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key1     |            1 | key1        | A         |        968 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key3     |            1 | key3        | A         |        799 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            1 | key_part1   | A         |        9673 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            2 | key_part2   | A         |        9999 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            3 | key_part3   | A         |       10000 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Table</code></td>
<td>索引所属表的名称。</td>
</tr>
<tr>
<td><code>Non_unique</code></td>
<td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code></td>
</tr>
<tr>
<td>，普通二级索引该列值为<code>1</code></td>
<td></td>
</tr>
<tr>
<td>。</td>
<td></td>
</tr>
<tr>
<td><code>Key_name</code></td>
<td>索引的名称。</td>
</tr>
<tr>
<td><code>Seq_in_index</code></td>
<td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code></td>
</tr>
<tr>
<td>，来说，<code>key_part1</code></td>
<td></td>
</tr>
<tr>
<td>、<code>key_part2</code></td>
<td></td>
</tr>
<tr>
<td>和<code>key_part3</code></td>
<td></td>
</tr>
<tr>
<td>对应的位置分别是1、2、3。</td>
<td></td>
</tr>
<tr>
<td><code>Column_name</code></td>
<td>索引列的名称。</td>
</tr>
<tr>
<td><code>Collation</code></td>
<td>索引列中的值是按照何种排序方式存放的，值为<code>A</code></td>
</tr>
<tr>
<td>时代表升序存放，为<code>NULL</code></td>
<td></td>
</tr>
<tr>
<td>时代表降序存放。</td>
<td></td>
</tr>
<tr>
<td><code>Cardinality</code></td>
<td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td>
</tr>
<tr>
<td><code>Sub_part</code></td>
<td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code></td>
</tr>
<tr>
<td>个字符或字节建立索引，这个属性表示的就是那个<code>n</code></td>
<td></td>
</tr>
<tr>
<td>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code></td>
<td></td>
</tr>
<tr>
<td>。</td>
<td></td>
</tr>
<tr>
<td><code>Packed</code></td>
<td>索引列如何被压缩，<code>NULL</code></td>
</tr>
<tr>
<td>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td>
<td></td>
</tr>
<tr>
<td><code>Null</code></td>
<td>该索引列是否允许存储<code>NULL</code></td>
</tr>
<tr>
<td>值。</td>
<td></td>
</tr>
<tr>
<td><code>Index_type</code></td>
<td>使用索引的类型，我们最常见的就是<code>BTREE</code></td>
</tr>
<tr>
<td>，其实也就是<code>B+</code></td>
<td></td>
</tr>
<tr>
<td>树索引。</td>
<td></td>
</tr>
<tr>
<td><code>Comment</code></td>
<td>索引列注释信息。</td>
</tr>
<tr>
<td><code>Index_comment</code></td>
<td>索引注释信息。</td>
</tr>
</tbody></table>
<p>上述属性其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。</p>
<p>前边说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p>
<ul>
<li> 使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。 </li>
<li> 使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。<br>结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个值的重复次数 ≈ Rows ÷ Cardinality</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 ÷ 968 ≈ 10（条）</span><br></pre></td></tr></table></figure>


<p>此时再看上边那条查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure>


<p>假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20000 x 10 = 200000</span><br></pre></td></tr></table></figure>


<p>使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是不精确！。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p>
<blockquote>
<p>在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</p>
</blockquote>
<h1 id="3-连接查询的成本"><a href="#3-连接查询的成本" class="headerlink" title="3. 连接查询的成本"></a>3. 连接查询的成本</h1><p>我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p>
<h2 id="3-1-条件过滤"><a href="#3-1-条件过滤" class="headerlink" title="3.1 条件过滤"></a>3.1 条件过滤</h2><p>我们前边说过，<code>MySQL</code>中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p>
<ul>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li>
</ul>
<p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：</p>
<ul>
<li><p> 查询一：<br>假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2;</span><br></pre></td></tr></table></figure></li>
<li><p> 查询二：<br>仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前边计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">WHERE s1.key2 &gt;10 AND s1.key2 &lt; 1000;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>有的时候扇出值的计算就变得很棘手，比方说下边几个查询：</p>
<ul>
<li><p> 查询三：<br>本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; &#39;xyz&#39;</code>条件。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p> 查询四：<br>本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; &#39;xyz&#39;</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; &#39;xyz&#39;</code>条件。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>查询五：<br>本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></li>
<li><code>common_field &gt; &#39;xyz&#39;</code></li>
</ul>
</li>
</ul>
<p>也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。 </p>
<p>说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p>
<ul>
<li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li>
<li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li>
</ul>
<p><code>MySQL</code>把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是<code>MySQL</code>单纯的瞎猜。</p>
<blockquote>
<p>在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。在MySQL 5.7中，MySQL引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。 MySQL称之为启发式规则（heuristic）。</p>
</blockquote>
<h2 id="3-2-两表连接成本分析"><a href="#3-2-两表连接成本分析" class="headerlink" title="3.2 两表连接成本分析"></a>3.2 两表连接成本分析</h2><p>连接查询的成本计算公式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure>


<p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p>
<ul>
<li>分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p>
<ul>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。</p>
<blockquote>
<p>左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询。</p>
</blockquote>
<p>比如对于下边这个查询来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND </span><br><span class="line">          s2.key2 &gt; 1000 AND s2.key2 &lt; 2000;</span><br></pre></td></tr></table></figure>


<p>可以选择的连接顺序有两种：</p>
<ul>
<li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li>
<li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li>
</ul>
<p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p>
<ul>
<li>使用<code>s1</code>作为驱动表的情况 <ul>
<li>分析对于驱动表的成本最低的执行方案<br>首先看一下涉及<code>s1</code>表单表的搜索条件有哪些： <ul>
<li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，很显然使用<code>idx_key2</code>执行查询的成本更低些。 </p>
<ul>
<li>然后分析对于被驱动表的成本最低的执行方案<br>此时涉及被驱动表<code>s2</code>的搜索条件就是： <ul>
<li><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</li>
<li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li>
</ul>
</li>
</ul>
<p>很显然，第一个条件由于<code>common_field</code>没有用到索引，此时访问<code>s2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，假设使用<code>idx_key2</code>的成本更小。<br>所以此时使用<code>s1</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>s2</code>作为驱动表的情况 <ul>
<li>分析对于驱动表的成本最低的执行方案<br>首先看一下涉及<code>s2</code>表单表的搜索条件有哪些： <ul>
<li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，假设使用<code>idx_key2</code>执行查询的成本更低些。 </p>
<ul>
<li>然后分析对于被驱动表的成本最低的执行方案<br>此时涉及被驱动表<code>s1</code>的搜索条件就是： <ul>
<li><code>s1.key1 = 常数</code></li>
<li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 2000</code></li>
</ul>
</li>
</ul>
<p>这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这时优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上边已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们并不知道，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本更低，这里假设使用<code>idx_key1</code>进行对<code>s1</code>的访问。<br>所以此时使用<code>s2</code>作为驱动表时的总成本就是： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</span><br></pre></td></tr></table></figure>


<p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下边这两个部分：</p>
<ul>
<li> 尽量减少驱动表的扇出 </li>
<li> 对被驱动表的访问成本尽量低<br>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。 </li>
</ul>
<h2 id="3-3-多表连接的成本分析"><a href="#3-3-多表连接的成本分析" class="headerlink" title="3.3 多表连接的成本分析"></a>3.3 多表连接的成本分析</h2><p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p>
<ul>
<li> 对于两表连接，比如表A和表B连接<br>只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。 </li>
<li> 对于三表连接，比如表A、表B、表C进行连接<br>有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。 </li>
<li> 对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。 </li>
<li> 对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。 </li>
</ul>
<p>有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍，不过<code>MySQL</code>想了很多办法减少计算非常多种连接顺序的成本的方法：</p>
<ul>
<li> 提前结束某种顺序的成本评估<br><code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。 </li>
<li> 系统变量<code>optimizer_search_depth</code><br>为了防止无穷无尽的分析各种连接顺序的成本，<code>MySQL</code>提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。 </li>
<li> 根据某些规则压根儿就不考虑某些连接顺序<br>即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以<code>MySQL</code>干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。 </li>
</ul>
<h1 id="4-调节成本常数"><a href="#4-调节成本常数" class="headerlink" title="4. 调节成本常数"></a>4. 调节成本常数</h1><p>我们前边已经介绍了两个<code>成本常数</code>：</p>
<ul>
<li>读取一个页面花费的成本默认是<code>1.0</code></li>
<li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li>
</ul>
<p>其实除了这两个成本常数，<code>MySQL</code>还支持好多，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库）的两个表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;</span><br><span class="line">+--------------------------+</span><br><span class="line">| Tables_in_mysql (%cost%) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| engine_cost              |</span><br><span class="line">| server_cost              |</span><br><span class="line">+--------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>


<p>一条语句的执行其实是分为两层的：</p>
<ul>
<li><code>server</code>层</li>
<li>存储引擎层</li>
</ul>
<p>在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p>
<h2 id="4-1mysql-server-cost表"><a href="#4-1mysql-server-cost表" class="headerlink" title="4.1mysql.server_cost表"></a>4.1mysql.server_cost表</h2><p><code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.server_cost;</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| cost_name                    | cost_value | last_update         | comment |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| disk_temptable_create_cost   |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| disk_temptable_row_cost      |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| key_compare_cost             |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_create_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_row_cost    |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| row_evaluate_cost            |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">6 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure>


<p>我们先看一下<code>server_cost</code>各个列都分别是什么意思：</p>
<ul>
<li> <code>cost_name</code><br>表示成本常数的名称。 </li>
<li> <code>cost_value</code><br>表示成本常数对应的值。如果该列的值为<code>NULL</code>的话，意味着对应的成本常数会采用默认值。 </li>
<li> <code>last_update</code><br>表示最后更新记录的时间。 </li>
<li> <code>comment</code><br>注释。 </li>
</ul>
<p>从<code>server_cost</code>中的内容可以看出来，目前在<code>server</code>层的一些操作对应的<code>成本常数</code>有以下几种：</p>
<table>
<thead>
<tr>
<th>成本常数名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>disk_temptable_create_cost</code></td>
<td><code>40.0</code></td>
<td>创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td>
</tr>
<tr>
<td><code>disk_temptable_row_cost</code></td>
<td><code>1.0</code></td>
<td>向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td>
</tr>
<tr>
<td><code>key_compare_cost</code></td>
<td><code>0.1</code></td>
<td>两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code></td>
</tr>
<tr>
<td>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>memory_temptable_create_cost</code></td>
<td><code>2.0</code></td>
<td>创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td>
</tr>
<tr>
<td><code>memory_temptable_row_cost</code></td>
<td><code>0.2</code></td>
<td>向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td>
</tr>
<tr>
<td><code>row_evaluate_cost</code></td>
<td><code>0.2</code></td>
<td>这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td>
</tr>
</tbody></table>
<blockquote>
<p>MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。<strong>创建临时表和对这个临时表进行写入和读取的操作代价还是很高的。</strong></p>
</blockquote>
<p>这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p>
<ul>
<li><p> 对我们感兴趣的成本常数做更新操作<br>比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.server_cost </span><br><span class="line">    SET cost_value = 0.4</span><br><span class="line">    WHERE cost_name = &#x27;row_evaluate_cost&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p> 让系统重新加载这个表的值。<br>使用下边语句即可：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p>
<h2 id="4-2mysql-engine-cost表"><a href="#4-2mysql-engine-cost表" class="headerlink" title="4.2mysql.engine_cost表"></a>4.2mysql.engine_cost表</h2><p><code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.engine_cost;</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| engine_name | device_type | cost_name              | cost_value | last_update         | comment |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| default     |           0 | io_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| default     |           0 | memory_block_read_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure>


<p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p>
<ul>
<li> <code>engine_name</code>列<br>指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。 </li>
<li> <code>device_type</code>列<br>指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。 </li>
</ul>
<p>我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p>
<table>
<thead>
<tr>
<th>成本常数名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>io_block_read_cost</code></td>
<td><code>1.0</code></td>
<td>从磁盘上读取一个块对应的成本。请注意我使用的是<code>块</code></td>
</tr>
<tr>
<td>，而不是<code>页</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>这个词儿。对于<code>InnoDB</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>存储引擎来说，一个<code>页</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>就是一个块，不过对于<code>MyISAM</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>存储引擎来说，默认是以<code>4096</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>字节作为一个块的。增大这个值会加重<code>I/O</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>memory_block_read_cost</code></td>
<td><code>1.0</code></td>
<td>与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td>
</tr>
</tbody></table>
<p>怎么从内存中和从磁盘上读取一个块的默认成本是一样的？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以<code>MySQL</code>认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改。</p>
<p>与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p>
<ul>
<li><p> 插入针对某个存储引擎的成本常数<br>比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mysql.engine_cost</span><br><span class="line">    VALUES (&#x27;InnoDB&#x27;, 0, &#x27;io_block_read_cost&#x27;, 2.0,</span><br><span class="line">    CURRENT_TIMESTAMP, &#x27;increase Innodb I/O cost&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p> 让系统重新加载这个表的值。<br>使用下边语句即可：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>在MySQL中，一个查询的执行成本是由IO成本和CPU成本组成的。对于InnoDB存储引擎来说，读取一个页面的默认IO成本是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。</p>
<p>在单表查询中，优化器生成执行计划的步骤如下：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那个方案</li>
</ol>
<p>在优化器生成执行计划过程中，需要依赖一些数据。这些数据可能是使用下面两种方式得到的：</p>
<ol>
<li>index dive：通过直接访问索引对应的B+树来获取数据</li>
<li>索引统计数据：直接依赖对表或者索引的统计数据</li>
</ol>
<p>为了更准确的计算连接查询的成本，MySQL提出了条件过滤的概念，也就是采用了某些规则来预测驱动表的扇出值。</p>
<p>对于内连接来说，为了生成成本最低的执行计划，需要考虑两方面的事情：</p>
<ol>
<li>选择最优的表连接顺序</li>
<li>为驱动表和被驱动表选择成本最低的访问方法</li>
</ol>
<p>我们可以通过手动修改MySQL数据库下engine_cost &amp; server_cost表中的某些成本常数，更精确的控制在生成执行计划时的成本计算过程。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[%E4%B8%83]%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/">https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[七]基于成本的优化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL[八]InnoDB统计数据收集原理</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/"><img class="next-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL[六]单表查询&amp;连接查询原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/" title="MySQL[一]入门"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[一]入门</div></div></a></div><div><a href="/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/" title="MySQL[二]概述"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">MySQL[二]概述</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/" title="MySQL[三]InnoDB索引结构"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[三]InnoDB索引结构</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/" title="MySQL[八]InnoDB统计数据收集原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[八]InnoDB统计数据收集原理</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%BA%94%5DInnoDb%E8%A1%A8%E7%A9%BA%E9%97%B4/" title="MySQL[五]InnoDb表空间"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[五]InnoDb表空间</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/" title="MySQL[六]单表查询&连接查询原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[六]单表查询&连接查询原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客卷....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E6%9C%AC%EF%BC%9F"><span class="toc-text">1.什么是成本？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">2.单表查询的成本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-text">2.1 准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-text">2.2 基于成本的优化步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-text">2.2.1 根据搜索条件，找出所有可能使用的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%AE%A1%E7%AE%97%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">2.2.2 计算全表扫描的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%AE%A1%E7%AE%97%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B4%A2%E5%BC%95%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-text">2.2.3 计算使用不同索引执行查询的代价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BD%BF%E7%94%A8idx-key2%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">①使用idx_key2执行查询的成本分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BD%BF%E7%94%A8idx-key1%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">②使用idx_key1执行查询的成本分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6%EF%BC%88Index-Merge%EF%BC%89"><span class="toc-text">③是否有可能使用索引合并（Index Merge）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%AF%B9%E6%AF%94%E5%90%84%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%8C%E6%89%BE%E5%87%BA%E6%88%90%E6%9C%AC%E6%9C%80%E4%BD%8E%E7%9A%84%E9%82%A3%E4%B8%80%E4%B8%AA"><span class="toc-text">2.2.4 对比各种执行方案的代价，找出成本最低的那一个</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E6%88%90%E6%9C%AC%E8%AE%A1%E7%AE%97"><span class="toc-text">2.3 基于索引统计数据的成本计算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-text">3. 连接查询的成本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4"><span class="toc-text">3.1 条件过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%B8%A4%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">3.2 两表连接成本分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">3.3 多表连接的成本分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%B0%83%E8%8A%82%E6%88%90%E6%9C%AC%E5%B8%B8%E6%95%B0"><span class="toc-text">4. 调节成本常数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1mysql-server-cost%E8%A1%A8"><span class="toc-text">4.1mysql.server_cost表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2mysql-engine-cost%E8%A1%A8"><span class="toc-text">4.2mysql.engine_cost表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-text">5. 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/" title="RabbitMQ"><img src="/images/cover/mq.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RabbitMQ"/></a><div class="content"><a class="title" href="/2022/01/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/" title="RabbitMQ">RabbitMQ</a><time datetime="2022-01-11T09:08:03.557Z" title="发表于 2022-01-11 17:08:03">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/MyBatis/Spring%20Data%20Jpa%E4%BD%BF%E7%94%A8%E7%AF%87/" title="Spring Data Jpa使用篇"><img src="/images/cover/MyBatis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Data Jpa使用篇"/></a><div class="content"><a class="title" href="/2022/01/11/MyBatis/Spring%20Data%20Jpa%E4%BD%BF%E7%94%A8%E7%AF%87/" title="Spring Data Jpa使用篇">Spring Data Jpa使用篇</a><time datetime="2022-01-11T06:37:31.534Z" title="发表于 2022-01-11 14:37:31">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/MyBatis/MyBatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="MyBatis应用分析与最佳实践"><img src="/images/cover/MyBatis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis应用分析与最佳实践"/></a><div class="content"><a class="title" href="/2022/01/11/MyBatis/MyBatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="MyBatis应用分析与最佳实践">MyBatis应用分析与最佳实践</a><time datetime="2022-01-11T06:37:23.826Z" title="发表于 2022-01-11 14:37:23">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/MyBatis/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="MyBatis源码分析"><img src="/images/cover/MyBatis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis源码分析"/></a><div class="content"><a class="title" href="/2022/01/11/MyBatis/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="MyBatis源码分析">MyBatis源码分析</a><time datetime="2022-01-11T06:37:14.818Z" title="发表于 2022-01-11 14:37:14">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%80%5D%E6%B3%A8%E8%A7%A3%E7%89%88Aop%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="Spring[十一]注解版Aop流程分析"><img src="/images/cover/spring.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring[十一]注解版Aop流程分析"/></a><div class="content"><a class="title" href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%80%5D%E6%B3%A8%E8%A7%A3%E7%89%88Aop%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/" title="Spring[十一]注解版Aop流程分析">Spring[十一]注解版Aop流程分析</a><time datetime="2022-01-11T06:13:44.508Z" title="发表于 2022-01-11 14:13:44">2022-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">骑摩托车去酒吧，该省省，该花花。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十,二十二十二十二十二十二十,二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>