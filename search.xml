<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring[十一]注解版Aop流程分析</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%80%5D%E6%B3%A8%E8%A7%A3%E7%89%88Aop%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%80%5D%E6%B3%A8%E8%A7%A3%E7%89%88Aop%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇介绍了实现AOP的两种方式，本篇我们通过分析源码流程，来看一下注解版AOP的实现。具体的源码细节，会在后面的篇章一行行翻译。</p></blockquote><h2 id="1-开启AOP的功能"><a href="#1-开启AOP的功能" class="headerlink" title="1.开启AOP的功能"></a>1.开启AOP的功能</h2><p>读源码需要找到入口或者抓手，AOP的源码我们如何入手呢？想要使用AOP的功能就需要在Spring的配置类上加上<code>**@EnableAspectJAutoProxy**</code>注解。<br>​</p><p>先分析一下这个注解：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否要创建基于子类 (CGLIB) 的代理，而不是基于标准 Java 接口的代理。 默认值为false 。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理应由 AOP 框架公开为ThreadLocal以通过AopContext类进行检索。</span></span><br><span class="line"><span class="comment"> * 默认关闭，即不保证AopContext访问将起作用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解的底层有一个<code>**@Import(AspectJAutoProxyRegistrar.class)**</code>，他往容器中导入了一个组件<code>**AspectJAutoProxyRegistrar**</code>。<br>​</p><p>看一下这个组件：<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*导入组件到容器中 AnnotationAwareAspectJAutoProxyCreator*/</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数一：固定类型</span></span><br><span class="line"><span class="comment">* 参数二：spring容器</span></span><br><span class="line"><span class="comment">* 参数三：标签</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><code>**AspectJAutoProxyRegistrar**</code> 实现了 <code>**ImportBeanDefinitionRegistrar**</code>接口，往容器中注册了一个bd信息。<code>**AnnotationAwareAspectJAutoProxyCreator**</code><br><strong>​</strong></p><h2 id="2-加载时机"><a href="#2-加载时机" class="headerlink" title="2.加载时机"></a>2.加载时机</h2><p><br>上一节我们分析到，在Spring的配置类上打一个注解，最后总会往容器中导入一个类：<code>**AnnotationAwareAspectJAutoProxyCreator**</code>。<br>​</p><p>我们来分析一下这个类的继承关系：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639247064786-3c67a6a0-91eb-4ed4-b8cb-f267bc197711.png#clientId=u3af27937-b92a-4&from=paste&height=602&id=u3a1bbc61&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1204&originWidth=3274&originalType=binary&ratio=1&size=237476&status=done&style=none&taskId=u6dd427ee-14ee-47e8-8b00-a15d364c7ba&width=1637" alt="image.png"><br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639140767570-e05eceaa-42a8-4f67-9300-0f2099ae852c.png#clientId=u1c4fa59c-afd3-4&from=paste&height=583&id=u8d009ebc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1166&originWidth=2248&originalType=binary&ratio=1&size=140509&status=done&style=none&taskId=u868a60a4-934f-4e1e-98d4-a54aea2c4ce&width=1124" alt="image.png"></p><p>按照顺序分析一下这个类的加载时机和加载的时候，里面的 <code>**initBeanFactory()**</code> &amp; <code>**setBeanFactory()**</code> 是什么时候执行的。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639142241742-009d0bb3-cbeb-4416-bfc9-6a2fbb70b996.png#clientId=u1c4fa59c-afd3-4&from=paste&height=759&id=u1ca56da3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1518&originWidth=2738&originalType=binary&ratio=1&size=224303&status=done&style=none&taskId=u4ce6e06a-1ea6-4326-84ef-fe0200a9420&width=1369" alt="image.png"><br>​</p><hr><p></p><ol><li>首先执行的是<code>**AbstractAdvisorAutoProxyCreator**</code>的<code>**setBeanFactory()**</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.setBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (!(beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: &quot;</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">initBeanFactory((ConfigurableListableBeanFactory) beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接下来执行的是<code>**AbstractAutoProxyCreator**</code>的<code>**setBeanFactory()**</code>。</li></ol><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><ol start="3"><li>然后执行的是<code>**AnnotationAwareAspectJAutoProxyCreator**</code>的<code>**initBeanFactory()**</code> 。</li></ol><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.initBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.aspectJAdvisorFactory = <span class="keyword">new</span> ReflectiveAspectJAdvisorFactory(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.aspectJAdvisorsBuilder =</span><br><span class="line"><span class="keyword">new</span> BeanFactoryAspectJAdvisorsBuilderAdapter(beanFactory, <span class="keyword">this</span>.aspectJAdvisorFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>最终执行的是<code>**AbstractAdvisorAutoProxyCreator**</code>的<code>**initBeanFactory()**</code>。</li></ol><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.advisorRetrievalHelper = <span class="keyword">new</span> BeanFactoryAdvisorRetrievalHelperAdapter(beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析<code>**AnnotationAwareAspectJAutoProxyCreator**</code>的执行时机。<br>​</p><h2 id="3-创建代理对象"><a href="#3-创建代理对象" class="headerlink" title="3.创建代理对象"></a>3.创建代理对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639143173344-da0586bb-69f1-4238-9142-1194856c2201.jpeg#clientId=u1c4fa59c-afd3-4&from=ui&id=u88428415&margin=%5Bobject%20Object%5D&name=AOP%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA.jpg&originHeight=1081&originWidth=3694&originalType=binary&ratio=1&size=361513&status=done&style=none&taskId=u5686694b-9755-440b-a854-d2d98b599ff" alt="AOP的加载时机.jpg"></p><h2 id="4-获取拦截器"><a href="#4-获取拦截器" class="headerlink" title="4.获取拦截器"></a>4.获取拦截器</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639144077347-e69c210a-3e88-4ecb-ae74-35147b27cb4e.png#clientId=u1c4fa59c-afd3-4&from=paste&height=744&id=uf38591f2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1488&originWidth=3168&originalType=binary&ratio=1&size=381332&status=done&style=none&taskId=u038dc2aa-14ef-4746-9d08-887bf1f0e83&width=1584" alt="image.png"></p><h2 id="5-链式调用通知方法"><a href="#5-链式调用通知方法" class="headerlink" title="5.链式调用通知方法"></a>5.链式调用通知方法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639145135270-7aac88b0-3c39-49d6-8fa7-abeba824d196.png#clientId=u1c4fa59c-afd3-4&from=paste&height=774&id=uf4afbe45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1548&originWidth=3330&originalType=binary&ratio=1&size=519662&status=done&style=none&taskId=ua64df5a7-3e0c-494b-9c00-2ec607cf5ca&width=1665" alt="image.png"></p><h2 id="6-流程总结"><a href="#6-流程总结" class="headerlink" title="6.流程总结"></a>6.流程总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639145817319-0081b004-ff69-47c5-8611-f7f041cfd23d.png#clientId=u1c4fa59c-afd3-4&from=paste&height=654&id=u9fa7f442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1308&originWidth=3320&originalType=binary&ratio=1&size=324462&status=done&style=none&taskId=ua8ce0ad5-7cc8-4e03-a301-6bc734dc11f&width=1660" alt="image.png"></p><blockquote><p>AOP其实就是往容器中导入了一个组件，这个组件是一个后置处理器，他会在对象创建之前尝试返回一个代理对象，如果不能成功返回，会在对象创建之后，init方法执行前后去判断当前对象是否需要被代理，如果需要被代理则根据各种条件去选择代理方式，创建代理对象，同时会去判断哪些切面和方法需要增强代理对象里面的方法，生成一条拦截器链。<br><br>在代理对象执行目标方法前后，通过拦截器对目标方法进行拦截，执行增强逻辑。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[扩展]模拟核心原理</title>
      <link href="/2022/01/11/Spring/Spring%5B%E6%89%A9%E5%B1%95%5D%E6%A8%A1%E6%8B%9F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/Spring/Spring%5B%E6%89%A9%E5%B1%95%5D%E6%A8%A1%E6%8B%9F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一，实现思路"><a href="#一，实现思路" class="headerlink" title="一，实现思路"></a>一，实现思路</h2><h3 id="1，配置阶段"><a href="#1，配置阶段" class="headerlink" title="1，配置阶段"></a>1，配置阶段</h3><table><thead><tr><th>配置web.xml</th><th>DispatcherServlet</th></tr></thead><tbody><tr><td>设定init-param</td><td>contextConfigLocation=classpath:application.xml</td></tr><tr><td>设定url-pattern</td><td>/*</td></tr><tr><td>配置Annotation</td><td><a href="/Controller">@Controller </a></td></tr><tr><td><a href="/Service">@Service </a></td><td></td></tr><tr><td><a href="/Autowrited">@Autowrited </a></td><td></td></tr><tr><td><a href="/RequestMapping">@RequestMapping </a></td><td></td></tr></tbody></table><h3 id="2-初始化阶段"><a href="#2-初始化阶段" class="headerlink" title="2,初始化阶段"></a>2,初始化阶段</h3><table><thead><tr><th>调用init方法</th><th>加载配置文件</th></tr></thead><tbody><tr><td>IOC容器初始化</td><td>MAP</td></tr><tr><td>扫描相关的类</td><td>scan-package=””</td></tr><tr><td>创建实例化并保存至容器</td><td>通过反射机制将类实例化放入IOC容器</td></tr><tr><td>进行DI操作</td><td>扫描IOC容器的实例，给没有赋值的属性自动填充</td></tr><tr><td>初始化HandlerMapping</td><td>讲一个URL和一个Method进行一对一的映射</td></tr></tbody></table><h3 id="3，运行阶段"><a href="#3，运行阶段" class="headerlink" title="3，运行阶段"></a>3，运行阶段</h3><table><thead><tr><th>调用doGet/doPost</th><th>web容器调用doget、dopost，获取req和resp对象</th></tr></thead><tbody><tr><td>匹配HandlerMapping</td><td>从req对象获取输入的URL，找到其对应的method</td></tr><tr><td>反射调用method.invoker()</td><td>利用反射调用方法并返回结果</td></tr><tr><td>response.getWrite().write()</td><td>将返回结果输出到浏览器</td></tr></tbody></table><h2 id="二，自定义配置"><a href="#二，自定义配置" class="headerlink" title="二，自定义配置"></a>二，自定义配置</h2><h3 id="1，配置-application-properties-文件"><a href="#1，配置-application-properties-文件" class="headerlink" title="1，配置 application.properties 文件"></a>1，配置 application.properties 文件</h3><p>为了解析方便，用 application.properties 来代替 application.xml 文件，具体配置内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scanPackage</span>=<span class="string">com.yhd.spring01</span></span><br></pre></td></tr></table></figure><h3 id="2，配置web-xml文件"><a href="#2，配置web-xml文件" class="headerlink" title="2，配置web.xml文件"></a>2，配置web.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span> <span class="attr">xmlns:javaee</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:web</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="string"><span class="tag">http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;2.4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>YHD Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>yhdmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.yhd.spring01.servlet.HdDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>application.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>yhdmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3，自定义注解"><a href="#3，自定义注解" class="headerlink" title="3，自定义注解"></a>3，自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HdAutowired &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HdController &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HdRequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HdRequestParam &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HdService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4，编写模拟业务"><a href="#4，编写模拟业务" class="headerlink" title="4，编写模拟业务"></a>4，编写模拟业务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HdService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> <span class="keyword">implements</span> <span class="title">IDemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My name is &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HdController</span></span><br><span class="line"><span class="meta">@HdRequestMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HdAutowired</span></span><br><span class="line">    <span class="keyword">private</span> IDemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HdRequestMapping(&quot;/query&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(HttpServletRequest req, HttpServletResponse resp,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="meta">@HdRequestParam(&quot;name&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">        String result = demoService.get(name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp.getWriter().write(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@HdRequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest req, HttpServletResponse resp,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="meta">@HdRequestParam(&quot;a&quot;)</span> Integer a, <span class="meta">@HdRequestParam(&quot;b&quot;)</span> Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp.getWriter().write(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@HdRequestMapping(&quot;/remove&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(HttpServletRequest req,HttpServletResponse resp,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="meta">@HdRequestParam(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，容器初始化"><a href="#三，容器初始化" class="headerlink" title="三，容器初始化"></a>三，容器初始化</h2><h3 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h3><h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>1.首先在doGet方法里面调用doDispatcher方法，根据请求路径判断路径是否存在，如果不存在就返回404存在就从容器中拿到路径对应的方法，通过动态代理执行对应的方法</p><p>2.在类加载阶段，用流来加载配置文件，从配置文件读取配置的包扫描路径根据包扫描路径进行迭代遍历，利用反射创建所有类上标有controller注解的类加入到容器，并下钻到类中，将类中每一个方法的绝对访问路径和方法加入到容器，迭代遍历创建所有标有service注解的类，如果该类实现了接口，将该接口的全限定类型名和类实例对象也放入容器，达到根据接口注入的效果。</p><p>3.属性赋值，遍历容器中所有类，如果类中标有@autowried注解，将属性对应的值设置进去。</p><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><p>1.clazz.isAnnotationPresent(HdController.class)<br>判断clazz上有没有HdController注解</p><p>2.field.set(mappings.get(clazz.getName()), mappings.get(beanName));<br>属性赋值：args1：给哪个属性设值，args2：设置的什么值</p><p>3.method.invoke(mappings.get(method.getDeclaringClass().getName()), new Object[]{req, resp, params.get(“name”)[0]});<br>通过动态代理执行方法，方法所在类名，方法参数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createtime</span> 2021/1/31 15:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 模拟IOC容器的创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HdDispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//映射关系  访问路径-方法名   全限定类名-实例对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; mappings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doDispatch(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//组装路径</span></span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line">        url = url.replace(contextPath, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//判断路径是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.mappings.containsKey(url)) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;404 NotFound!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取路径对应的方法参数，通过动态代理进行增强</span></span><br><span class="line">        Method method = (Method) <span class="keyword">this</span>.mappings.get(url);</span><br><span class="line">        Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">        method.invoke(mappings.get(method.getDeclaringClass().getName()), <span class="keyword">new</span> Object[]&#123;req, resp, params.get(<span class="string">&quot;name&quot;</span>)[<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载配置文件</span></span><br><span class="line">            Properties configContext = <span class="keyword">new</span> Properties();</span><br><span class="line">            is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(config.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>));</span><br><span class="line">            configContext.load(is);</span><br><span class="line">            <span class="comment">//获取扫描路径</span></span><br><span class="line">            String scanPackage = configContext.getProperty(<span class="string">&quot;scanPackage&quot;</span>);</span><br><span class="line">            doScanner(scanPackage);</span><br><span class="line">            <span class="keyword">for</span> (String className : mappings.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!className.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">                <span class="comment">//当前这个类上有没有controller注解</span></span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(HdController.class)) &#123;</span><br><span class="line">                    mappings.put(className, clazz.newInstance());</span><br><span class="line">                    String baseUrl = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    <span class="comment">//判断有没有一级访问路径</span></span><br><span class="line">                    <span class="keyword">if</span> (clazz.isAnnotationPresent(HdRequestMapping.class)) &#123;</span><br><span class="line">                        HdRequestMapping requestMapping = clazz.getAnnotation(HdRequestMapping.class);</span><br><span class="line">                        baseUrl = requestMapping.value();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Method[] methods = clazz.getMethods();</span><br><span class="line">                    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAnnotationPresent(HdRequestMapping.class)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        HdRequestMapping requestMapping = method.getAnnotation(HdRequestMapping.class);</span><br><span class="line">                        <span class="comment">//拼装路径</span></span><br><span class="line">                        String url = (baseUrl + <span class="string">&quot;/&quot;</span> + requestMapping.value()).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                        <span class="comment">//map放的是：controller里面一个方法的访问绝对路径，这个对应的方法</span></span><br><span class="line">                        mappings.put(url, method);</span><br><span class="line">                        System.out.println(<span class="string">&quot;Mapped &quot;</span> + url + <span class="string">&quot;,&quot;</span> + method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(HdService.class)) &#123;</span><br><span class="line">                    HdService service = clazz.getAnnotation(HdService.class);</span><br><span class="line">                    String beanName = service.value();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">                        beanName = clazz.getName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Object instance = clazz.newInstance();</span><br><span class="line">                    <span class="comment">//map里面放的是类名和实例对象</span></span><br><span class="line">                    mappings.put(beanName, instance);</span><br><span class="line">                    <span class="comment">//将这个类实现的接口和实例对象放进去</span></span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; i : clazz.getInterfaces()) &#123;</span><br><span class="line">                        mappings.put(i.getName(), instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//属性注入</span></span><br><span class="line">            <span class="keyword">for</span> (Object object : mappings.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class clazz = object.getClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(HdController.class)) &#123;</span><br><span class="line">                    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">                    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!field.isAnnotationPresent(HdAutowired.class)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        HdAutowired autowired = field.getAnnotation(HdAutowired.class);</span><br><span class="line">                        String beanName = autowired.value();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">                            beanName = field.getType().getName();</span><br><span class="line">                        &#125;</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            field.set(mappings.get(clazz.getName()), mappings.get(beanName));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;Diy MVC Framework is init&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;/&quot;</span> + scanPackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        File classDir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        Arrays.stream(classDir.listFiles()).forEach(file -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanner(scanPackage + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String clazzName = (scanPackage + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">                mappings.put(clazzName, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-0版本"><a href="#2-0版本" class="headerlink" title="2.0版本"></a>2.0版本</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>1.0版本的所有代码都写在了一个方法里面，代码耦合度 十分高，不符合开发规范</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>采用设计模式（工厂模式、单例模式、委派模式、策略模式），改造业务逻辑。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createtime</span> 2021/2/1 11:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HdDispatcherServlet2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties configContext = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_LOCATION = <span class="string">&quot;contextConfigLocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        loadConfig(config.getInitParameter(CONFIG_LOCATION));</span><br><span class="line">        <span class="comment">//2.扫描所有的组件</span></span><br><span class="line">        doScanPackages(configContext.getProperty(<span class="string">&quot;scanPackage&quot;</span>));</span><br><span class="line">        <span class="comment">//3.将组件加入到容器</span></span><br><span class="line">        refersh();</span><br><span class="line">        <span class="comment">//4.属性设值</span></span><br><span class="line">        population();</span><br><span class="line">        <span class="comment">//5.建立方法与路径的映射</span></span><br><span class="line">        routingAndMapping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立方法与路径的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">routingAndMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        classNames.forEach(className -&gt; &#123;</span><br><span class="line">            Object instance = ioc.get(className);</span><br><span class="line">            <span class="keyword">if</span> (instance.getClass().isAnnotationPresent(HdController.class)) &#123;</span><br><span class="line">                String baseUrl = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (instance.getClass().isAnnotationPresent(HdRequestMapping.class)) &#123;</span><br><span class="line">                    baseUrl += instance.getClass().getAnnotation(HdRequestMapping.class).value().trim();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String finalBaseUrl = baseUrl;</span><br><span class="line">                Arrays.asList(instance.getClass().getDeclaredMethods()).forEach(method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.isAnnotationPresent(HdRequestMapping.class)) &#123;</span><br><span class="line">                        String methodUrl = finalBaseUrl;</span><br><span class="line">                        methodUrl += method.getAnnotation(HdRequestMapping.class).value().trim();</span><br><span class="line">                        handlerMappings.put(methodUrl, method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性设值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">population</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = ioc.keySet();</span><br><span class="line"></span><br><span class="line">        keySet.forEach(key -&gt; &#123;</span><br><span class="line">            Field[] fields = ioc.get(key).getClass().getFields();</span><br><span class="line">            Arrays.asList(fields).forEach(field -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(HdAutowired.class)) &#123;</span><br><span class="line">                    HdAutowired autowired = field.getAnnotation(HdAutowired.class);</span><br><span class="line">                    String name = autowired.value().trim();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(autowired.value().trim())) &#123;</span><br><span class="line">                        name = field.getType().getName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        field.set(name, ioc.get(name));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容器刷新</span></span><br><span class="line"><span class="comment">     * 组件加入到容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refersh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNames == <span class="keyword">null</span> || classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;组件扫描出现异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(HdController.class)) &#123;</span><br><span class="line">                <span class="comment">//TODO 类名处理</span></span><br><span class="line">                ioc.put(clazz.getSimpleName(), clazz.newInstance());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(HdService.class)) &#123;</span><br><span class="line">                Object instance = clazz.newInstance();</span><br><span class="line">                ioc.put(clazz.getSimpleName(), instance);</span><br><span class="line">                Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; inter : interfaces) &#123;</span><br><span class="line">                    ioc.put(inter.getSimpleName(), clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组件扫描</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scanPackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanPackages</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        URL url = getClass().getClassLoader().getResource(<span class="string">&quot;/&quot;</span> + scanPackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        File files = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : files.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanPackages(scanPackage + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String className = scanPackage + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initParameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadConfig</span><span class="params">(String initParameter)</span> </span>&#123;</span><br><span class="line">        InputStream is = getClass().getClassLoader().getResourceAsStream(initParameter);</span><br><span class="line">        configContext.load(is);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatcher(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot; 500 server error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatcher</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String realPath = req.getRequestURI().replace(req.getContextPath(), <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = req.getParameterMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handlerMappings.containsKey(realPath)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;404 Not Found!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method method = handlerMappings.get(realPath);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            Class param = parameterTypes[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (param == HttpServletRequest.class) &#123;</span><br><span class="line">                paramValues[i] = req;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (param == HttpServletResponse.class) &#123;</span><br><span class="line">                paramValues[i] = resp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (param == String.class) &#123;</span><br><span class="line">                HdRequestParam requestParam = parameterTypes[i].getAnnotation(HdRequestParam.class);</span><br><span class="line">                String value = requestParam.value();</span><br><span class="line">                String[] realParam = parameterMap.get(value);</span><br><span class="line">                paramValues[i] = Arrays.toString(realParam)</span><br><span class="line">                        .replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                        .replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        method.invoke(method.getDeclaringClass().getSimpleName(), paramValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convertParamType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-0版本"><a href="#3-0版本" class="headerlink" title="3.0版本"></a>3.0版本</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>HandlerMapping还不能像SpringMVC一样支持正则，url参数还不支持强制类型转换，反射调用之前还需要重新获取bean的name。</p><p>改造 HandlerMapping，在真实的 Spring 源码中，HandlerMapping 其实是一个 List 而非 Map。List 中的元素是一个自定义的类型。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>使用内部类维护requestMapping和url之间的关系。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HdDispatcherServlet3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties configContext = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_LOCATION = <span class="string">&quot;contextConfigLocation&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlerMapping = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存方法对应的实例</span></span><br><span class="line">        <span class="keyword">private</span> Object controller;</span><br><span class="line">        <span class="comment">//保存映射的方法</span></span><br><span class="line">        <span class="keyword">private</span> Method method;</span><br><span class="line">        <span class="comment">//正则匹配</span></span><br><span class="line">        <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">        <span class="comment">//参数顺序</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, Integer&gt; paramIndexMapping = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Pattern pattern, Object controller, Method method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.controller = controller;</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">            paramIndexMapping = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            putParamIndexMapping(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putParamIndexMapping</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//提取方法中加了注解的参数</span></span><br><span class="line">            Annotation[][] pa = method.getParameterAnnotations();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pa.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Annotation a : pa[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> HdRequestParam) &#123;</span><br><span class="line">                        String paramName = ((HdRequestParam) a).value();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(paramName.trim())) &#123;</span><br><span class="line">                            paramIndexMapping.put(paramName, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提取方法中的req和resp</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                Class&lt;?&gt; type = parameterTypes[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (type == HttpServletRequest.class ||</span><br><span class="line">                        type == HttpServletResponse.class) &#123;</span><br><span class="line">                    paramIndexMapping.put(type.getName(), i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件</span></span><br><span class="line">        loadConfig(config.getInitParameter(CONFIG_LOCATION));</span><br><span class="line">        <span class="comment">//2.扫描所有的组件</span></span><br><span class="line">        doScanPackages(configContext.getProperty(<span class="string">&quot;scanPackage&quot;</span>));</span><br><span class="line">        <span class="comment">//3.将组件加入到容器</span></span><br><span class="line">        refersh();</span><br><span class="line">        <span class="comment">//4.属性设值</span></span><br><span class="line">        population();</span><br><span class="line">        <span class="comment">//5.建立方法与路径的映射</span></span><br><span class="line">        routingAndMapping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立方法与路径的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">routingAndMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ioc.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : ioc.entrySet()) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = entry.getValue().getClass();</span><br><span class="line">            <span class="keyword">if</span> (!clazz.isAnnotationPresent(HdController.class)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String url = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(HdRequestMapping.class)) &#123;</span><br><span class="line">                HdRequestMapping requestMapping = clazz.getAnnotation(HdRequestMapping.class);</span><br><span class="line">                url = requestMapping.value();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!method.isAnnotationPresent(HdRequestMapping.class)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                HdRequestMapping requestMapping = method.getAnnotation(HdRequestMapping.class);</span><br><span class="line">                String regex = (<span class="string">&quot;/&quot;</span> + url + requestMapping.value()).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                Pattern pattern = Pattern.compile(regex);</span><br><span class="line">                handlerMapping.add(<span class="keyword">new</span> Handler(pattern, entry.getValue(), method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性设值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">population</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = ioc.keySet();</span><br><span class="line"></span><br><span class="line">        keySet.forEach(key -&gt; &#123;</span><br><span class="line">            Field[] fields = ioc.get(key).getClass().getFields();</span><br><span class="line">            Arrays.asList(fields).forEach(field -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(HdAutowired.class)) &#123;</span><br><span class="line">                    HdAutowired autowired = field.getAnnotation(HdAutowired.class);</span><br><span class="line">                    String name = autowired.value().trim();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(autowired.value().trim())) &#123;</span><br><span class="line">                        name = field.getType().getName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        field.set(name, ioc.get(name));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容器刷新</span></span><br><span class="line"><span class="comment">     * 组件加入到容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refersh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNames == <span class="keyword">null</span> || classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;组件扫描出现异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(HdController.class)) &#123;</span><br><span class="line">                <span class="comment">//TODO 类名处理</span></span><br><span class="line">                ioc.put(clazz.getSimpleName(), clazz.newInstance());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clazz.isAnnotationPresent(HdService.class)) &#123;</span><br><span class="line">                Object instance = clazz.newInstance();</span><br><span class="line">                ioc.put(clazz.getSimpleName(), instance);</span><br><span class="line">                Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                <span class="keyword">for</span> (Class&lt;?&gt; inter : interfaces) &#123;</span><br><span class="line">                    ioc.put(inter.getSimpleName(), clazz);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组件扫描</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scanPackage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanPackages</span><span class="params">(String scanPackage)</span> </span>&#123;</span><br><span class="line">        URL url = getClass().getClassLoader().getResource(<span class="string">&quot;/&quot;</span> + scanPackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line"></span><br><span class="line">        File files = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : files.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                doScanPackages(scanPackage + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getName().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String className = scanPackage + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initParameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadConfig</span><span class="params">(String initParameter)</span> </span>&#123;</span><br><span class="line">        InputStream is = getClass().getClassLoader().getResourceAsStream(initParameter);</span><br><span class="line">        configContext.load(is);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doDispatcher(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot; 500 server error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatcher</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        Handler handler = getHandler(req);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;404 Not Found!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = handler.getMethod().getParameterTypes();</span><br><span class="line"></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : params.entrySet()) &#123;</span><br><span class="line">            String value = Arrays.toString(param.getValue()).replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .replaceAll(<span class="string">&quot;\\s&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!handler.getParamIndexMapping().containsKey(param.getKey())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Integer index = handler.getParamIndexMapping().get(param.getKey());</span><br><span class="line">            paramValues[index] = <span class="keyword">this</span>.convert(parameterTypes[index], value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletRequest.class.getName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> reqIndex = handler.paramIndexMapping.get(HttpServletRequest.class.getName());</span><br><span class="line">            paramValues[reqIndex] = req;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler.paramIndexMapping.containsKey(HttpServletResponse.class.getName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> respIndex = handler.paramIndexMapping.get(HttpServletResponse.class.getName());</span><br><span class="line">            paramValues[respIndex] = resp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = handler.getMethod().invoke(handler.getController(), paramValues);</span><br><span class="line">        <span class="keyword">if</span> (returnValue == <span class="keyword">null</span> || returnValue <span class="keyword">instanceof</span> Void) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(returnValue.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convert</span><span class="params">(Class&lt;?&gt; parameterType, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.class == parameterType) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Handler <span class="title">getHandler</span><span class="params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String url = req.getRequestURI();</span><br><span class="line">        String contextPath = req.getContextPath();</span><br><span class="line">        url = url.replace(contextPath, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                .replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Handler handler : handlerMapping) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Matcher matcher = handler.pattern.matcher(url);</span><br><span class="line">                <span class="comment">//如果没有匹配上继续下一个匹配</span></span><br><span class="line">                <span class="keyword">if</span> (!matcher.matches()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[扩展]MVC使用篇</title>
      <link href="/2022/01/11/Spring/Spring%5B%E6%89%A9%E5%B1%95%5DMVC%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
      <url>/2022/01/11/Spring/Spring%5B%E6%89%A9%E5%B1%95%5DMVC%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一，springmvc基本概念"><a href="#一，springmvc基本概念" class="headerlink" title="一，springmvc基本概念"></a>一，springmvc基本概念</h1><h2 id="1-三层架构"><a href="#1-三层架构" class="headerlink" title="1.三层架构"></a>1.三层架构</h2><p>开发架构一般基于两种形式，一种是c/s架构，也就是客户端服务器，另一种是b/s架构，也就是浏览器服务器。javaee的开发基本都是b/s架构。在b/s架构中，系统表转的三层架构包括：表现层，业务层，持久层。</p><ul><li>表现层：web层。负责接收客户端请求，向客户端响应结果。依赖于业务层，接受请求调用业务层进行业务处理，并将处理结果响应回客户端。</li></ul><ol><li>展示层：展示结果。</li><li>控制层：接受请求</li></ol><p>表现层的设计一般都是使用MVC设计模式。</p><ul><li>业务层：service层。负责业务逻辑处理。</li></ul><p>业务层可能会依赖于持久层，如果需要对数据持久化，需要保证事物的一致性。</p><ul><li>持久层：dao层。负责数据持久化。</li></ul><ol><li>数据库：对数据进行持久化的载体。</li><li>数据访问层：业务层和持久层交互的接口</li></ol><p>持久层就是和数据库交互，对数据库表进行增删改查。</p><h2 id="2-MVC模型"><a href="#2-MVC模型" class="headerlink" title="2.MVC模型"></a>2.MVC模型</h2><p>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：</p><ul><li>Model（模型）：通常指的就是我们的数据模型。作用一般情况下用于封装数据。</li><li>View（视图）：通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。</li><li>Controller（控制器）：是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。</li></ul><h2 id="3-springmvc是什么"><a href="#3-springmvc是什么" class="headerlink" title="3.springmvc是什么"></a>3.springmvc是什么</h2><p>SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring<br>FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功<br>能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring<br>的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。<br>​</p><p>SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成<br>为最优秀的 MVC 框架。<br>​</p><p>它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持<br>RESTful 编程风格的请求。</p><h2 id="4-springmvc和struts2的优劣对比"><a href="#4-springmvc和struts2的优劣对比" class="headerlink" title="4.springmvc和struts2的优劣对比"></a>4.springmvc和struts2的优劣对比</h2><p>共同点：</p><ol><li>它们都是表现层框架，都是基于 MVC 模型编写的。</li><li>它们的底层都离不开原始 ServletAPI。</li><li>它们处理请求的机制都是一个核心控制器。</li></ol><p>区别：</p><ol><li>Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter </li><li>Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所</li></ol><p>以 Spring MVC 会稍微比 Struts2 快些。</p><ol start="3"><li>Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便</li></ol><p>(JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注<br>解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。)</p><ol start="4"><li>Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提</li></ol><p>升，尤其是 struts2 的表单标签，远没有 html 执行效率高。</p><h1 id="二，Springmvc入门"><a href="#二，Springmvc入门" class="headerlink" title="二，Springmvc入门"></a>二，Springmvc入门</h1><h2 id="1-入门案例"><a href="#1-入门案例" class="headerlink" title="1.入门案例"></a>1.入门案例</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>点击页面超链接，跳转到成功页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;success/success&quot;</span>&gt;testSuccess&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/success&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">success</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入门案例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/success&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testSuccess</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testSuccess()...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>配置核心控制器：一个Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 DispatcherServlet --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 映射地址 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="springmvc-xml"><a href="#springmvc-xml" class="headerlink" title="springmvc.xml"></a>springmvc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--前缀解析器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/views/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--后缀解析器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-入门案例流程分析"><a href="#2-入门案例流程分析" class="headerlink" title="2.入门案例流程分析"></a>2.入门案例流程分析</h2><ol><li>服务器启动，加载应用。读取web.xml中的配置创建spring容器并且初始化容器中的对象。从案例中可以发现创建的是successController和InternalResourceViewResolver，实际上远不止这些。</li><li>浏览器发送请求，经过前端控制器，被其捕获，他并不处理请求，只是根据路径的URL匹配有没有对应的，如果匹配到@RequestMapping中的内容，就转发。</li><li>转发到控制层执行对应的方法，该方法有一个返回值。</li><li>根据方法的返回值，借助视图解析器对象找到对应的视图结果。</li><li>渲染结果视图，响应浏览器</li></ol><h2 id="3-请求响应流程"><a href="#3-请求响应流程" class="headerlink" title="3.请求响应流程"></a>3.请求响应流程</h2><p><img src="https://img-blog.csdnimg.cn/20200909220034986.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70#pic_center#crop=0&crop=0&crop=1&crop=1&id=AWyDh&originHeight=610&originWidth=1306&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求相应流程：</span><br><span class="line">    请求先来到springDispatcherServlet看Springmvc是否存在对应的映射？</span><br><span class="line">        如果不存在，看springmvc的配置文件是否配置了&lt;mvc:default-servlet-handler/&gt;</span><br><span class="line">            如果不存在，页面响应404，控制台打印no mapping found</span><br><span class="line">            如果存在，转发到目标资源。</span><br><span class="line">        如果存在，请求交给handlerMapping（处理器映射器），由它获取HandlerExecutionChain对象，</span><br><span class="line">        再交给HandlerAdapter（处理器适配器）对象，调用拦截器的PreHandle方法，</span><br><span class="line">        然后调用目标Handler方法得到ModelAndview对象，调用拦截器的PostHnadle方法，</span><br><span class="line">        查看是否存在异常</span><br><span class="line">            如果存在，由异常处理器处理异常，得到新的ModelAndView对象，</span><br><span class="line">            如果不存在异常，由视图解析器解析视图，得到实际的View，渲染视图，调用拦截器的afterCompletion方法</span><br></pre></td></tr></table></figure><h2 id="4-案例中涉及的组件"><a href="#4-案例中涉及的组件" class="headerlink" title="4.案例中涉及的组件"></a>4.案例中涉及的组件</h2><ol><li>DispatcherServlet：前端控制器:用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性</li><li>HandlerMapping：处理器映射器:HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li><li>Handler：处理器:开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</li><li>HandlAdapter：处理器适配器:通过适配器对处理器进行执行，通过拓展适配器可以处理更多类型。</li><li>View Resolver：视图解析器:View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名.即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户</li><li>View：视图:SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</li><li>mvc:annotation-driven说明:在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。使 用 mvc:annotation-driven 自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用mvc:annotation-driven/替代注解处理器和适配器的配置。</li></ol><h2 id="5-RequestMapping注解"><a href="#5-RequestMapping注解" class="headerlink" title="5.RequestMapping注解"></a>5.RequestMapping注解</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">源码：</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,</span> <span class="string">ElementType.TYPE&#125;)//可以加到类上和方法上</span></span><br><span class="line"><span class="attr">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="attr">@Documented</span></span><br><span class="line"><span class="attr">@Mapping</span></span><br><span class="line"><span class="attr">public</span> <span class="string">@interface RequestMapping &#123; &#125;</span></span><br><span class="line"><span class="attr">作用：</span></span><br><span class="line"><span class="meta">用于建立请求</span> <span class="string">URL 和处理请求方法之间的对应关系。</span></span><br><span class="line"><span class="attr">出现位置：</span></span><br><span class="line"><span class="attr">1.类上</span></span><br><span class="line"><span class="meta">请求</span> <span class="string">URL 的第一级访问目录，便于模块化管理。</span></span><br><span class="line"><span class="attr">2.方法上</span></span><br><span class="line"><span class="meta">请求</span> <span class="string">URL 的第二级访问目录。</span></span><br><span class="line"><span class="attr">属性：</span></span><br><span class="line"><span class="meta">value：用于指定请求的</span> <span class="string">URL。它和 path 属性的作用是一样的。</span></span><br><span class="line"><span class="attr">method：用于指定请求的方式。</span></span><br><span class="line"><span class="meta">params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的</span> <span class="string">key 和 value 必须和</span></span><br><span class="line"><span class="attr">配置的一模一样。</span></span><br><span class="line"><span class="attr">例如：</span></span><br><span class="line"><span class="attr">params</span> = <span class="string">&#123;&quot;accountName&quot;&#125;，表示请求参数必须有 accountName</span></span><br><span class="line"><span class="attr">params</span> = <span class="string">&#123;&quot;moeny!100&quot;&#125;，表示请求参数中 money 不能是 100。</span></span><br><span class="line"><span class="attr">headers：用于指定限制请求消息头的条件。</span></span><br><span class="line"><span class="attr">注意：</span></span><br><span class="line"><span class="meta">以上四个属性只要出现</span> <span class="string">2 个或以上时，他们的关系是与的关系。</span></span><br></pre></td></tr></table></figure><h1 id="三，请求参数的绑定"><a href="#三，请求参数的绑定" class="headerlink" title="三，请求参数的绑定"></a>三，请求参数的绑定</h1><h2 id="1-绑定的机制"><a href="#1-绑定的机制" class="headerlink" title="1.绑定的机制"></a>1.绑定的机制</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">表单中请求参数都是基于</span> <span class="string">key=value 的。</span></span><br><span class="line"><span class="attr">SpringMVC</span> <span class="string">绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。</span></span><br><span class="line"><span class="attr">例如：</span></span><br><span class="line"><span class="meta">&lt;a</span> <span class="string">href=&quot;account/findAccount?accountId=10&quot;&gt;查询账户&lt;/a&gt;</span></span><br><span class="line"><span class="attr">中请求参数是：</span></span><br><span class="line"><span class="attr">accountId</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">/**</span></span><br><span class="line"><span class="meta">*</span> <span class="string">查询账户</span></span><br><span class="line"><span class="meta">*</span> <span class="string">@return</span></span><br><span class="line"><span class="attr">*/</span></span><br><span class="line"><span class="attr">@RequestMapping(&quot;/findAccount&quot;)</span></span><br><span class="line"><span class="attr">public</span> <span class="string">String findAccount(Integer accountId) &#123;</span></span><br><span class="line"><span class="attr">System.out.println(&quot;查询了账户。。。。&quot;+accountId);</span></span><br><span class="line"><span class="attr">return</span> <span class="string">&quot;success&quot;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-支持的数据类型"><a href="#2-支持的数据类型" class="headerlink" title="2.支持的数据类型"></a>2.支持的数据类型</h2><ul><li><p>基本类型参数：</p><p>  包括基本类型和 String 类型</p></li><li><p>POJO 类型参数：</p><p>  包括实体类，以及关联的实体类</p></li><li><p>数组和集合类型参数：</p><p>  包括 List 结构和 Map 结构的集合（包括数组）</p></li></ul><p><strong>SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。</strong></p><h2 id="3-使用要求"><a href="#3-使用要求" class="headerlink" title="3.使用要求"></a>3.使用要求</h2><ol><li><p>如果是基本类型或者 String 类型：</p><p> 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)</p></li><li><p>如果是 POJO 类型，或者它的关联对象：</p><p> 要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</p></li><li><p>如果是集合类型,有两种方式：</p><p> 第一种：</p><pre><code> 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。</code></pre><p> 第二种：</p><pre><code> 接收的请求参数是 json 格式数据。需要借助一个注解实现</code></pre><p>注意:</p><blockquote><p>它还可以实现一些数据类型自动转换。<br>如遇特殊类型转换要求，需要我们自己编写自定义类型转换器。</p></blockquote></li></ol><h2 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4.代码示例"></a>4.代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 参数绑定1:</span></span><br><span class="line"><span class="comment">  * bean中包含bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/getBean&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getBean</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;getBean()...&quot;</span>);</span><br><span class="line">     System.out.println(person);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 参数绑定2</span></span><br><span class="line"><span class="comment">  * 集合类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/getCollection&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getList</span><span class="params">(MyCollection collection)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;getList()....&quot;</span>);</span><br><span class="line">     System.out.println(collection);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;success/getBean&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">  id:  &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;id&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">   name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user.name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    age:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;user.age&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;success/getCollection&quot;</span>&gt;</span><br><span class="line">    name:  &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;list[0].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    age: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;list[0].age&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;map[1].name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    age: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;map[1].age&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="5-请求参数乱码问题"><a href="#5-请求参数乱码问题" class="headerlink" title="5.请求参数乱码问题"></a>5.请求参数乱码问题</h2><p>idea控制台输出中文乱码：-Dfile.encoding=UTF-8</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编码过滤器,必须放在web.xml最上面，防止缓存 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 此处/*代表过滤所有请求 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-关于静态资源处理"><a href="#6-关于静态资源处理" class="headerlink" title="6.关于静态资源处理"></a>6.关于静态资源处理</h2><p>在 springmvc 的配置文件中可以配置，静态资源不过滤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/scripts/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/javascript/**&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-关于get请求"><a href="#7-关于get请求" class="headerlink" title="7.关于get请求"></a>7.关于get请求</h2><p>tomacat 对 GET 和 POST 请求处理方式是不同的，GET 请求的编码问题，要改 tomcat 的 server.xml</p><p>配置文件，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span>/&gt;</span></span><br><span class="line">改为：</span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">useBodyEncodingForURI</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">如果遇到 ajax 请求仍然乱码，请把：</span><br><span class="line">useBodyEncodingForURI=&quot;true&quot;改为 URIEncoding=&quot;UTF-8&quot;</span><br><span class="line">即可</span><br></pre></td></tr></table></figure><h2 id="8-自定义类型转换器"><a href="#8-自定义类型转换器" class="headerlink" title="8.自定义类型转换器"></a>8.自定义类型转换器</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>jsp页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;success/date&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;date&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDate</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||<span class="string">&quot;&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> format.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(<span class="string">&quot;类型转换异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类型转换器</p><p>spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义类型转换--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置类型转换器工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionServiceFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span><span class="comment">&lt;!-- 配置自定义类型转换器 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.utils.StringToDate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionServiceFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自定义数据类型转换</span></span><br><span class="line"><span class="comment">    * 1.编写类型转换类，实现 Converter 接口，该接口有两个泛型。</span></span><br><span class="line"><span class="comment">    * 2.配置文件中配置转换器,并在注解支持里面注册。</span></span><br><span class="line"><span class="comment">    * 3.控制层参数列表传入转换类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="9-使用servletAPI对象作为方法参数"><a href="#9-使用servletAPI对象作为方法参数" class="headerlink" title="9.使用servletAPI对象作为方法参数"></a>9.使用servletAPI对象作为方法参数</h2><p>springMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 ServletAPI 对象有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取原生ServletAPI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getServlet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServlet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;getServlet()...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;success/getServlet&quot;&gt;getServlet&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><h1 id="四，常用注解"><a href="#四，常用注解" class="headerlink" title="四，常用注解"></a>四，常用注解</h1><h2 id="1-RequestParam"><a href="#1-RequestParam" class="headerlink" title="1.RequestParam"></a>1.RequestParam</h2><p>作用：<br>    把请求中指定名称的参数给控制器中的形参赋值。<br>属性：<br>    value：请求参数中的名称。<br>    required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestParam</span> 当表单name和形参列表名字不一致时，使用此注解。</span></span><br><span class="line"><span class="comment">     * 属性：</span></span><br><span class="line"><span class="comment">     * name：指定表单的name</span></span><br><span class="line"><span class="comment">     * required：指定是否为必须</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;, required = false)</span> String username, Integer age)</span> </span>&#123;</span><br><span class="line">        System.out.println(username + <span class="string">&quot; &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;anno/test1&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="2-RequestBody"><a href="#2-RequestBody" class="headerlink" title="2.RequestBody"></a>2.RequestBody</h2><p>作用：<br>    用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。<br>    get 请求方式不适用。<br>属性：<br>    required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值<br>    为 false，get 请求得到是 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestBody</span> 用于获取请求体内容</span></span><br><span class="line"><span class="comment">     * 属性：</span></span><br><span class="line"><span class="comment">     * 属性：</span></span><br><span class="line"><span class="comment">     * required：指定是否为必须</span></span><br><span class="line"><span class="comment">     * 当请求方式为get时，指定为true会报错，</span></span><br><span class="line"><span class="comment">     * 指定为false时，拿到的是null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(<span class="meta">@RequestBody(required = false)</span> String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;anno/test2&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="3-PathVariable"><a href="#3-PathVariable" class="headerlink" title="3.PathVariable"></a>3.PathVariable</h2><p>作用：<br>    用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。<br>    url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。<br>属性：<br>    value：用于指定 url 中占位符名称。<br>    required：是否必须提供占位符。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;anno/test3/张三&quot;</span>&gt;test3&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@PathVariable</span> restful风格，spring3.0新特性</span></span><br><span class="line"><span class="comment"> * 以/参数方式传递参数</span></span><br><span class="line"><span class="comment"> * 次注解的value属性指定传递的参数名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test3/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于rest风格url"><a href="#关于rest风格url" class="headerlink" title="关于rest风格url"></a>关于rest风格url</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">*什么是</span> <span class="string">rest：</span></span><br><span class="line"><span class="meta">REST（英文：Representational</span> <span class="string">State Transfer，简称 REST）描述了一个架构样式的网络系统，</span></span><br><span class="line"><span class="meta">比如</span> <span class="string">web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之</span></span><br><span class="line"><span class="meta">一。在目前主流的三种</span> <span class="string">Web 服务交互方案中，REST 相比于 SOAP（Simple Object Access protocol，简单</span></span><br><span class="line"><span class="meta">对象访问协议）以及</span> <span class="string">XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码，REST 都倾向于用更</span></span><br><span class="line"><span class="meta">加简单轻量的方法设计和实现。值得注意的是</span> <span class="string">REST 并没有一个明确的标准，而更像是一种设计的风格。</span></span><br><span class="line"><span class="meta">它本身并没有什么实用性，其核心价值在于如何设计出符合</span> <span class="string">REST 风格的网络接口。</span></span><br><span class="line"><span class="meta">*restful</span> <span class="string">的优点</span></span><br><span class="line"><span class="attr">它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</span></span><br><span class="line"><span class="meta">*restful</span> <span class="string">的特性：</span></span><br><span class="line"><span class="attr">*资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。</span></span><br><span class="line"><span class="meta">它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个</span> <span class="string">URI（统一</span></span><br><span class="line"><span class="meta">资源定位符）指向它，每种资源对应一个特定的</span> <span class="string">URI 。要</span></span><br><span class="line"><span class="meta">获取这个资源，访问它的</span> <span class="string">URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。 表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层 （Representation）。</span></span><br><span class="line"><span class="meta">比如，文本可以用</span> <span class="string">txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二</span></span><br><span class="line"><span class="attr">进制格式。</span></span><br><span class="line"><span class="meta">*状态转化（State</span> <span class="string">Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。</span></span><br><span class="line"><span class="meta">*HTTP</span> <span class="string">协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，</span></span><br><span class="line"><span class="meta">必须通过某种手段，让服务器端发生“状态转化”（State</span> <span class="string">Transfer）。而这种转化是建立在表现层之上的，所以</span></span><br><span class="line"><span class="meta">就是</span> <span class="string">“表现层状态转化”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET 、POST 、PUT、</span></span><br><span class="line"><span class="meta">DELETE。它们分别对应四种基本操作：GET</span> <span class="string">用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来</span></span><br><span class="line"><span class="attr">删除资源。</span></span><br><span class="line"><span class="meta">*restful</span> <span class="string">的示例：</span></span><br><span class="line"><span class="meta">/account/1</span> <span class="string">HTTP GET ： 得到 id = 1 的 account </span></span><br><span class="line"><span class="meta">/account/1</span> <span class="string">HTTP DELETE： 删除 id = 1 的 account </span></span><br><span class="line"><span class="meta">/account/1</span> <span class="string">HTTP PUT： 更新 id = 1 的 account</span></span><br><span class="line"><span class="meta">/account</span> <span class="string">HTTP POST： 新增 account</span></span><br></pre></td></tr></table></figure><h2 id="4-requestHeader"><a href="#4-requestHeader" class="headerlink" title="4.requestHeader"></a>4.requestHeader</h2><p>作用：<br>    用于获取请求消息头。<br>属性：<br>    value：提供消息头名称<br>    required：是否必须有此消息头<br>注：<br>    在实际开发中一般不怎么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestHeader</span> 获取请求头信息，不常用</span></span><br><span class="line"><span class="comment"> * 属性：</span></span><br><span class="line"><span class="comment"> * value:</span></span><br><span class="line"><span class="comment"> * required:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test4</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;Accept-Language&quot;, required = false)</span> String value)</span> </span>&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;anno/test4&quot;</span>&gt;test4&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><h2 id="5-CookieValue"><a href="#5-CookieValue" class="headerlink" title="5.CookieValue"></a>5.CookieValue</h2><p>作用：<br>    用于把指定 cookie 名称的值传入控制器方法参数。<br>属性：<br>    value：指定 cookie 的名称。<br>    required：是否必须有此 cookie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CookieValue</span> 获取cookie里面的信息</span></span><br><span class="line"><span class="comment"> * 属性：</span></span><br><span class="line"><span class="comment"> * value：</span></span><br><span class="line"><span class="comment"> * required：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test5&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test5</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;, required = false)</span> String value)</span> </span>&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;anno/test5&quot;</span>&gt;test5&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><h2 id="6-ModelAttribute"><a href="#6-ModelAttribute" class="headerlink" title="6.ModelAttribute"></a>6.ModelAttribute</h2><p>作用：<br>    该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。<br>    出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可<br>    以修饰有具体返回值的方法。<br>    出现在参数上，获取指定的数据给参数赋值。<br>属性：<br>    value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。<br>应用场景：<br>    当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。<br>    例如：<br>    我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数<br>    据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@ModelAttribute</span></span></span><br><span class="line"><span class="comment">    * 1.夹在方法上：</span></span><br><span class="line"><span class="comment">    *      1.没有返回值</span></span><br><span class="line"><span class="comment">    *      可以应用在从表单获取的值不全，在返回方法前先给其将值补全</span></span><br><span class="line"><span class="comment">    *      2.有返回值</span></span><br><span class="line"><span class="comment">    *      可以根据表单提交的一个值在到达控制层之前先去从数据库查询，</span></span><br><span class="line"><span class="comment">    *      *严重怀疑这个方法利用动态代理对方法进行增强。</span></span><br><span class="line"><span class="comment">    * 2.加在方法参数上：</span></span><br><span class="line"><span class="comment">    *      可以为指定的属性赋值</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/test6&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test6</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">       System.out.println(user.getName() + <span class="string">&quot;...&quot;</span> + user.getAge());</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@ModelAttribute</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">       System.out.println(user.getName()+<span class="string">&quot; &quot;</span>+user.getAge()+<span class="string">&quot;......&quot;</span>);</span><br><span class="line">       user.setAge(<span class="number">20</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;anno/test6&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="场景二："><a href="#场景二：" class="headerlink" title="场景二："></a>场景二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/test6&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test6</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(user.getName() + <span class="string">&quot;...&quot;</span> + user.getAge());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">test22</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟从数据库查询数据</span></span><br><span class="line">        User user=findUserByname(name);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//模拟服务层dao层方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">findUserByname</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;anno/test6&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟服务层dao层方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">findUserByname</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(name);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test7&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test7</span><span class="params">(<span class="meta">@ModelAttribute(value=&quot;1&quot;)</span> User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">(String name, Map&lt;String,User&gt;map)</span></span>&#123;</span><br><span class="line">    <span class="comment">//模拟从数据库查询</span></span><br><span class="line">    User user=findUserByname(name);</span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;anno/test7&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h2 id="7-SessionAttribute"><a href="#7-SessionAttribute" class="headerlink" title="7.SessionAttribute"></a>7.SessionAttribute</h2><p>作用：<br>    用于多次执行控制器方法间的参数共享。<br>属性：<br>    value：用于指定存入的属性名称<br>    type：用于指定存入的数据类型</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;session/put&quot;</span>&gt;put&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;session/get&quot;</span>&gt;get&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;session/delete&quot;</span>&gt;delete&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/session&quot;)</span></span><br><span class="line"><span class="meta">@SessionAttributes(value = &#123;&quot;name&quot;,&quot;age&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存入Session</span></span><br><span class="line"><span class="comment">     *  Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap</span></span><br><span class="line"><span class="comment">     *  该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/put&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">put</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;尹会东&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;age&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出Session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(ModelMap map)</span></span>&#123;</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除Session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(SessionStatus status)</span></span>&#123;</span><br><span class="line">        status.setComplete();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五，响应数据和结果视图"><a href="#五，响应数据和结果视图" class="headerlink" title="五，响应数据和结果视图"></a>五，响应数据和结果视图</h1><h2 id="1-返回值分类"><a href="#1-返回值分类" class="headerlink" title="1.返回值分类"></a>1.返回值分类</h2><h3 id="①void"><a href="#①void" class="headerlink" title="①void"></a>①void</h3><p><strong>在 controller 方法形参上可以定义 request 和 response，使用 request 或 response 指定响应结果：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1、使用</span> <span class="string">request 转向页面，如下：</span></span><br><span class="line"><span class="meta">request.getRequestDispatcher(&quot;/WEB-INF/pages/success.jsp&quot;).forward(request,</span> <span class="string"></span></span><br><span class="line"><span class="attr">response);</span></span><br><span class="line"><span class="meta">2、也可以通过</span> <span class="string">response 页面重定向：</span></span><br><span class="line"><span class="meta">response.sendRedirect(&quot;testRetrunString&quot;)</span> <span class="string">3、也可以通过 response 指定响应结果，例如响应 json 数据：</span></span><br><span class="line"><span class="attr">response.setCharacterEncoding(&quot;utf-8&quot;);</span></span><br><span class="line"><span class="meta">response.setContentType(&quot;application/json;charset</span>=<span class="string">utf-8&quot;);</span></span><br><span class="line"><span class="meta">response.getWriter().write(&quot;json</span> <span class="string">串&quot;);</span></span><br></pre></td></tr></table></figure><h3 id="②ModelAndView"><a href="#②ModelAndView" class="headerlink" title="②ModelAndView"></a>②ModelAndView</h3><p>ModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。</p><p>该对象中有两个方法：</p><h3 id="③转发和重定向"><a href="#③转发和重定向" class="headerlink" title="③转发和重定向"></a>③转发和重定向</h3><h4 id="forward-转发"><a href="#forward-转发" class="headerlink" title="forward 转发"></a><strong>forward</strong> <strong>转发</strong></h4><p>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。<br>​</p><p>需要注意的是，如果用了 formward：则路径必须写成实际视图 url，不能写逻辑视图。<br>​</p><p>它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。</p><h4 id="Redirect-重定向"><a href="#Redirect-重定向" class="headerlink" title="Redirect 重定向"></a><strong>Redirect</strong> <strong>重定向</strong></h4><p>contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用:redirect:它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/return&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">returnController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值类型为String，在request作用于存放值，并显示到页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/string&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;尹会东&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值类型为void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/void&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletResponse response, HttpServletRequest request)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//      //request.getRequestDispatcher(&quot;/WEB-INF/views/success.jsp&quot;).forward(request,response);</span></span><br><span class="line">        <span class="comment">//response.sendRedirect(&quot;/index.jsp&quot;);</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值类型为ModelAndView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/model&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        mv.addObject(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        mv.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关键字：forward和redirect</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/fr&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;..................&quot;</span>);</span><br><span class="line">        <span class="comment">//return &quot;forward:/WEB-INF/views/success.jsp&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;<span class="keyword">return</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;<span class="keyword">return</span>返回值类型&lt;/h3&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;return/string&quot;</span> &gt;string&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;return/void&quot;</span> &gt;<span class="keyword">void</span>&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;return/model&quot;</span> &gt;model&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;return/fr&quot;</span> &gt;fr&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="④-ResponseBody-注解响应json数据"><a href="#④-ResponseBody-注解响应json数据" class="headerlink" title="④@ResponseBody  注解响应json数据"></a>④<a href="/ResponseBody">@ResponseBody </a> 注解响应json数据</h3><p>作用：<br>​</p><p>该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ajax&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ajax</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送Ajax异步请求</span></span><br><span class="line"><span class="comment">     * 1.静态资源处理：在配置文件中加入&lt;mvc:resource /&gt;标签，指定放行的资源。</span></span><br><span class="line"><span class="comment">     * 2.导入jackson的依赖</span></span><br><span class="line"><span class="comment">     * 3.</span></span><br><span class="line"><span class="comment">     *      <span class="doctag">@RequestBody</span></span></span><br><span class="line"><span class="comment">     *      接受请求体消息</span></span><br><span class="line"><span class="comment">     *      <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment">     *      发送响应体消息</span></span><br><span class="line"><span class="comment">     * 4.springmvc框架已经为我们封装好了处理json数据的方法，底层会自动执行。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/ajax&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">User <span class="title">testAjax</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        user.setName(<span class="string">&quot;yinhuidong&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Ajax&lt;/title&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(<span class="string">&quot;#btn&quot;</span>).click(function () &#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">&quot;ajax/ajax&quot;</span>,</span><br><span class="line">                    contentType:<span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">                    data: <span class="string">&#x27;&#123;&quot;name&quot;:&quot;aa&quot;,&quot;age&quot;:20&#125;&#x27;</span>,</span><br><span class="line">                    dataType: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">                    type: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">                    success: function (data) &#123;</span><br><span class="line">                        alert(data.name);</span><br><span class="line">                        alert(data.age);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> value=<span class="string">&quot;别点我&quot;</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//data:JSON.stringify(&#123;&quot;name&quot;:&quot;张三&quot;,&quot;msg&quot;:message&#125;),</span><br><span class="line">data:&#x27;&#123;&quot;name&quot;:&quot;张三&quot;,&quot;msg&quot;:&quot;123&quot;&#125;&#x27;,</span><br></pre></td></tr></table></figure><h1 id="六，文件上传和下载"><a href="#六，文件上传和下载" class="headerlink" title="六，文件上传和下载"></a>六，文件上传和下载</h1><h2 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1.文件上传"></a>1.文件上传</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li><p>form 表单的 enctype 取值必须是：multipart/form-data</p><pre><code>     (默认值是:application/x-www-form-urlencoded)</code></pre><p> enctype:是表单请求正文的类型</p></li><li><p>method 属性取值必须是 Post</p></li><li><p>提供一个文件选择域<input type=”file” /></p></li></ol><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">当</span> <span class="string">form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。 </span></span><br><span class="line"><span class="attr">enctype</span>=<span class="string">”application/x-www-form-urlencoded”时，form 表单的正文内容是：</span></span><br><span class="line">         <span class="attr">key</span>=<span class="string">value&amp;key=value&amp;key=value</span></span><br><span class="line"><span class="meta">当</span> <span class="string">form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成：</span></span><br><span class="line">     <span class="meta">每一部分都是</span> <span class="string">MIME 类型描述的正文</span></span><br><span class="line"><span class="meta">-----------------------------7de1a433602ac</span> <span class="string">分界符</span></span><br><span class="line"><span class="meta">Content-Disposition</span>: <span class="string">form-data; name=&quot;userName&quot; 协议头</span></span><br><span class="line"><span class="attr">aaa</span> <span class="string">协议的正文</span></span><br><span class="line"><span class="attr">-----------------------------7de1a433602ac</span></span><br><span class="line"><span class="meta">Content-Disposition</span>: <span class="string">form-data; name=&quot;file&quot;; </span></span><br><span class="line"><span class="attr">filename</span>=<span class="string">&quot;C:\Users\zhy\Desktop\fileupload_demofile\b.txt&quot;</span></span><br><span class="line"><span class="meta">Content-Type</span>: <span class="string">text/plain 协议的类型（MIME 类型）</span></span><br><span class="line"><span class="attr">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span></span><br><span class="line"><span class="attr">-----------------------------7de1a433602ac--</span></span><br></pre></td></tr></table></figure><h3 id="①传统模式的文件上传"><a href="#①传统模式的文件上传" class="headerlink" title="①传统模式的文件上传"></a>①传统模式的文件上传</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;文件上传&lt;/h3&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;file/fileupload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    择文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传文件&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;hr/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">upload</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传1:</span></span><br><span class="line"><span class="comment">     * 传统的文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/fileupload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileupload</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 先获取到要上传的文件目录</span></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建File对象，一会向该路径下上传文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="comment">// 判断路径是否存在，如果不存在，创建该路径</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建磁盘文件项工厂</span></span><br><span class="line">        DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">        ServletFileUpload fileUpload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line">        <span class="comment">// 解析request对象</span></span><br><span class="line">        List&lt;FileItem&gt; list = fileUpload.parseRequest(request);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">            <span class="comment">// 判断文件项是普通字段，还是上传的文件</span></span><br><span class="line">            <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 上传文件项</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取到上传文件的名称</span></span><br><span class="line">            String filename = fileItem.getName();</span><br><span class="line">            <span class="comment">// 上传文件</span></span><br><span class="line">            fileItem.write(<span class="keyword">new</span> File(file, filename));</span><br><span class="line">            <span class="comment">// 删除临时文件</span></span><br><span class="line">            fileItem.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="②springmvc文件上传"><a href="#②springmvc文件上传" class="headerlink" title="②springmvc文件上传"></a>②springmvc文件上传</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;file/upload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    择文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传文件&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;hr/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * springmvc文件上传</span></span><br><span class="line"><span class="comment">  * 1.导入依赖</span></span><br><span class="line"><span class="comment">  * commons-upload</span></span><br><span class="line"><span class="comment">  * commons-io</span></span><br><span class="line"><span class="comment">  * 2.配置文件解析器</span></span><br><span class="line"><span class="comment">  * 3.编写jsp页面</span></span><br><span class="line"><span class="comment">  * 4.代码实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">fileupload2</span><span class="params">(HttpSession session, MultipartFile upload)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">     <span class="comment">//获取文件上传路径</span></span><br><span class="line">     String path = session.getServletContext().getRealPath(<span class="string">&quot;/img&quot;</span>);</span><br><span class="line">     File file = <span class="keyword">new</span> File(path);</span><br><span class="line">     <span class="comment">//判断不存在该目录就创建</span></span><br><span class="line">     <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">         file.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//获取文件名</span></span><br><span class="line">     String filename = upload.getOriginalFilename();</span><br><span class="line">     System.out.println(filename);</span><br><span class="line">     <span class="comment">//起别名</span></span><br><span class="line">     String s = UUID.randomUUID().toString().replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).toUpperCase();</span><br><span class="line">     filename=s+filename;</span><br><span class="line">     <span class="comment">//开始上传</span></span><br><span class="line">     upload.transferTo(<span class="keyword">new</span> File(file,filename));</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-文件下载"><a href="#2-文件下载" class="headerlink" title="2.文件下载"></a>2.文件下载</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h3&gt;文件下载&lt;/h3&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;down/down?name=6.jpg&quot;</span>&gt;点击下载&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/down&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">down</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     * 1.获取文件名</span></span><br><span class="line"><span class="comment">     * 2.获得文件下载路径</span></span><br><span class="line"><span class="comment">     * 3.拼接</span></span><br><span class="line"><span class="comment">     * 4.用流来加载文件到字节数组</span></span><br><span class="line"><span class="comment">     * 5.设置头信息以附件形式打开</span></span><br><span class="line"><span class="comment">     * 6.设置响应状态吗</span></span><br><span class="line"><span class="comment">     * 7.下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/down&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; down(HttpSession session,String name)<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取文件下载路径</span></span><br><span class="line">        String path = session.getServletContext().getRealPath(<span class="string">&quot;/img&quot;</span>);</span><br><span class="line">        <span class="comment">//加上文件名</span></span><br><span class="line">        String finalpath = path + File.separator + name;</span><br><span class="line">        FileInputStream is = <span class="keyword">new</span> FileInputStream(finalpath);</span><br><span class="line">        <span class="comment">//is.available()获取流的字节数</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">        is.read(bytes);</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        <span class="comment">//设置有附件形式打开</span></span><br><span class="line">        headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span>+name);</span><br><span class="line">        <span class="comment">//设置响应吗</span></span><br><span class="line">        HttpStatus status=HttpStatus.OK;</span><br><span class="line">        ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; entity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, status);</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="keyword">return</span> entity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七，springmvc中的异常处理"><a href="#七，springmvc中的异常处理" class="headerlink" title="七，springmvc中的异常处理"></a>七，springmvc中的异常处理</h1><h2 id="1-异常处理的思路"><a href="#1-异常处理的思路" class="headerlink" title="1.异常处理的思路"></a>1.异常处理的思路</h2><p>系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，<br>后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。<br>​</p><p>系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端<br>控制器交由异常处理器进行异常处理。</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h2><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-09-17:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-09-17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerException</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        MyException mye=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MyException)&#123;</span><br><span class="line">            mye= (MyException) e;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mye=<span class="keyword">new</span> MyException();</span><br><span class="line">        &#125;</span><br><span class="line">        mye.setMessage(<span class="string">&quot;系统繁忙，请稍后再试！&quot;</span>);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;message&quot;</span>,mye.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;/error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--异常处理类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;handlerException&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.exception.HandlerException&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-09-17:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试异常</span></span><br><span class="line"><span class="comment">     * 1.编写自定义异常类，继承Exception类</span></span><br><span class="line"><span class="comment">     * 2.编写异常处理类，</span></span><br><span class="line"><span class="comment">     * 3.在配置文件中配置异常处理类</span></span><br><span class="line"><span class="comment">     * 4.模拟发生异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span><span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;exception/test&quot;</span>&gt;测试异常&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>全局异常处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span></span></span><br><span class="line"><span class="function">            <span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">             HttpServletResponse response, Object o, Exception e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isAjax = JudgeRequestType.judgeIsAjax(request);</span><br><span class="line">        <span class="keyword">if</span> (isAjax)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String message=e.getMessage();</span><br><span class="line"></span><br><span class="line">                Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">                String json = gson.toJson(message);</span><br><span class="line">                response.getWriter().write(json);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JudgeRequestType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judgeIsAjax</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        String accept = request.getHeader(<span class="string">&quot;Accept&quot;</span>);</span><br><span class="line">        String header = request.getHeader(<span class="string">&quot;X-Requested-With&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">                (accept!=<span class="keyword">null</span> &amp;&amp;accept.length()&gt;<span class="number">0</span>&amp;&amp;accept.contains(<span class="string">&quot;application/json&quot;</span>))</span><br><span class="line">                        ||</span><br><span class="line">                        (header!=<span class="keyword">null</span>&amp;&amp;header.length()&gt;<span class="number">0</span>&amp;&amp;header.equals(<span class="string">&quot;XMLHttpRequest&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八，springmvc中的拦截器"><a href="#八，springmvc中的拦截器" class="headerlink" title="八，springmvc中的拦截器"></a>八，springmvc中的拦截器</h1><h2 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h2><p>Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。<br>​</p><p>谈到拦截器，还要向大家提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺<br>序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。<br>​</p><p>说到这里，可能大家脑海中有了一个疑问，这不是我们之前学的过滤器吗？是的它和过滤器是有几分相似，但<br>是也有区别，接下来我们就来说说他们的区别：</p><ol><li>过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。</li><li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。</li><li>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。</li><li>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦</li></ol><p>截的。<br>​</p><p>它也是 AOP 思想的具体应用。我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。</p><h2 id="自定义拦截器步骤"><a href="#自定义拦截器步骤" class="headerlink" title="自定义拦截器步骤"></a>自定义拦截器步骤</h2><h3 id="1-写一个类继承HandlerInterceptor接口"><a href="#1-写一个类继承HandlerInterceptor接口" class="headerlink" title="1.写一个类继承HandlerInterceptor接口"></a>1.写一个类继承HandlerInterceptor接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-09-17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intercepter1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. preHandle方法是controller方法执行前拦截的方法</span></span><br><span class="line"><span class="comment">     * 1. 可以使用request或者response跳转到指定的页面</span></span><br><span class="line"><span class="comment">     * 2. return true放行，执行下一个拦截器，如果没有拦截器，</span></span><br><span class="line"><span class="comment">     *    执行controller中的方法。</span></span><br><span class="line"><span class="comment">     * 3. return false不放行，不会执行controller中的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle()....&quot;</span>);</span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;/WEB-INF/views/error.jsp&quot;).forward(request, response);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. postHandle是controller方法执行后执行的方法，在JSP视图执行前。</span></span><br><span class="line"><span class="comment">     * 1. 可以使用request或者response跳转到指定的页面</span></span><br><span class="line"><span class="comment">     * 2. 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. postHandle方法是在JSP执行后执行</span></span><br><span class="line"><span class="comment">     *   request或者response不能再跳转页面了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在springmvc的配置文件中配置拦截器"><a href="#2-在springmvc的配置文件中配置拦截器" class="headerlink" title="2.在springmvc的配置文件中配置拦截器"></a>2.在springmvc的配置文件中配置拦截器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置一个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置拦截路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置哪些不拦截--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;mvc:exclude-mapping path=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置bean--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.intercept.Intercepter1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置拦截路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置哪些不拦截--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;mvc:exclude-mapping path=&quot;&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置bean--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.intercept.Intercepter2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写测试类和jsp页面"><a href="#3-编写测试类和jsp页面" class="headerlink" title="3.编写测试类和jsp页面"></a>3.编写测试类和jsp页面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-09-17:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/intercepter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntercepter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.编写拦截器</span></span><br><span class="line"><span class="comment">     * 2.在配置文件中配置拦截器</span></span><br><span class="line"><span class="comment">     * 3.测试</span></span><br><span class="line"><span class="comment">     * 4.多个拦截器执行顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;controller().....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;intercepter/test&quot;</span>&gt;测试拦截器&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="4-定义多个拦截器"><a href="#4-定义多个拦截器" class="headerlink" title="4.定义多个拦截器"></a>4.定义多个拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-09-17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Intercepter2</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. preHandle方法是controller方法执行前拦截的方法</span></span><br><span class="line"><span class="comment">     * 1. 可以使用request或者response跳转到指定的页面</span></span><br><span class="line"><span class="comment">     * 2. return true放行，执行下一个拦截器，如果没有拦截器，</span></span><br><span class="line"><span class="comment">     *    执行controller中的方法。</span></span><br><span class="line"><span class="comment">     * 3. return false不放行，不会执行controller中的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle2()....&quot;</span>);</span><br><span class="line">        <span class="comment">//request.getRequestDispatcher(&quot;/WEB-INF/views/error.jsp&quot;).forward(request, response);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. postHandle是controller方法执行后执行的方法，在JSP视图执行前。</span></span><br><span class="line"><span class="comment">     * 1. 可以使用request或者response跳转到指定的页面</span></span><br><span class="line"><span class="comment">     * 2. 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle()2....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. postHandle方法是在JSP执行后执行</span></span><br><span class="line"><span class="comment">     *   request或者response不能再跳转页面了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion()2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器的简单应用"><a href="#拦截器的简单应用" class="headerlink" title="拦截器的简单应用"></a>拦截器的简单应用</h2><h3 id="需求：-1"><a href="#需求：-1" class="headerlink" title="需求："></a>需求：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、有一个登录页面，需要写一个 controller 访问页面 </span><br><span class="line">2、登录页面有一提交表单的动作。需要在 controller 中处理。</span><br><span class="line">2.1、判断用户名密码是否正确</span><br><span class="line">2.2、如果正确 向 session 中写入用户信息</span><br><span class="line">2.3、返回登录成功。</span><br><span class="line">3、拦截用户请求，判断用户是否登录</span><br><span class="line">3.1、如果用户已经登录。放行</span><br><span class="line">3.2、如果用户未登录，跳转到登录页面</span><br></pre></td></tr></table></figure><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><h4 id="1-控制器代码"><a href="#1-控制器代码" class="headerlink" title="1.控制器代码"></a>1.控制器代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登陆页面</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(Model model)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//登陆提交</span></span><br><span class="line"><span class="comment">//userid：用户账号，pwd：密码</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/loginsubmit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginsubmit</span><span class="params">(HttpSession session,String userid,String pwd)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//向 session 记录用户身份信息</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;activeUser&quot;</span>, userid);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/main.jsp&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//session 过期</span></span><br><span class="line">session.invalidate();</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-拦截器代码"><a href="#2-拦截器代码" class="headerlink" title="2.拦截器代码"></a>2.拦截器代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Public <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//如果是登录页面则放行</span></span><br><span class="line"><span class="keyword">if</span>(request.getRequestURI().indexOf(<span class="string">&quot;login.action&quot;</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line"><span class="comment">//如果用户已登录也放行</span></span><br><span class="line"><span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;user&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户没有登录挑战到登录页面</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/login.jsp&quot;</span>).forward(request,response);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[扩展]基本使用篇</title>
      <link href="/2022/01/11/Spring/Spring%5B%E6%89%A9%E5%B1%95%5D%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/"/>
      <url>/2022/01/11/Spring/Spring%5B%E6%89%A9%E5%B1%95%5D%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一，Spring的概述"><a href="#一，Spring的概述" class="headerlink" title="一，Spring的概述"></a>一，Spring的概述</h1><h2 id="1-Spring是什么？"><a href="#1-Spring是什么？" class="headerlink" title="1.Spring是什么？"></a>1.Spring是什么？</h2><p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。<br>​</p><h2 id="2-Spring的优势？"><a href="#2-Spring的优势？" class="headerlink" title="2.Spring的优势？"></a>2.Spring的优势？</h2><ol><li>方便解耦，简化开发</li><li>AOP编程的支持</li><li>声明式事务的支持</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>降低JavaEE API 的使用难度</li><li>源码是经典的学习范例</li></ol><p>​</p><h2 id="3-Spring的体系结构图"><a href="#3-Spring的体系结构图" class="headerlink" title="3.Spring的体系结构图"></a>3.Spring的体系结构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1632208697381-b838ad79-5c83-4e06-bd9d-c3379365a04e.png#clientId=uc63229ee-eaaa-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6f381ecb&margin=%5Bobject%20Object%5D&name=spring%E6%9E%B6%E6%9E%84.png&originHeight=508&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=85612&status=done&style=none&taskId=ua9594cc0-dec9-4b40-9d92-c85c960303b&title=" alt="spring架构.png"></p><h1 id="二，IOC"><a href="#二，IOC" class="headerlink" title="二，IOC"></a>二，IOC</h1><h2 id="1-程序的耦合和解耦"><a href="#1-程序的耦合和解耦" class="headerlink" title="1.程序的耦合和解耦"></a>1.程序的耦合和解耦</h2><p>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须 存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。<br>​</p><h2 id="2-解决耦合的思路"><a href="#2-解决耦合的思路" class="headerlink" title="2.解决耦合的思路"></a>2.解决耦合的思路</h2><p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//此处只是一个字符串</code>，此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的）。<br>​</p><p>同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。解决这个问题也很简单，使用配置文件配置。<br>​</p><h2 id="3-工厂模式解耦"><a href="#3-工厂模式解耦" class="headerlink" title="3.工厂模式解耦"></a>3.工厂模式解耦</h2><p>在实际开发中可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。<br>​</p><h2 id="4-代码案例"><a href="#4-代码案例" class="headerlink" title="4.代码案例"></a>4.代码案例</h2><h3 id="4-1-AccountMapper"><a href="#4-1-AccountMapper" class="headerlink" title="4.1 AccountMapper"></a>4.1 AccountMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 二十</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/9/21 3:23 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了update()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了add()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了delete()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-AccountService"><a href="#4-2-AccountService" class="headerlink" title="4.2 AccountService"></a>4.2 AccountService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 二十</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/9/21 3:25 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account = (Account) BeanFactory.getBean(<span class="string">&quot;account&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountDao = (AccountMapper) BeanFactory.getBean(<span class="string">&quot;accountMapper&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.add(account);</span><br><span class="line">        System.out.println(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(accountDao);</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">        System.out.println(account.toString());</span><br><span class="line">        System.out.println(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-BeanFactory"><a href="#4-3-BeanFactory" class="headerlink" title="4.3 BeanFactory"></a>4.3 BeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 二十</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/9/21 3:27 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties prop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String configFile = <span class="string">&quot;beans.properties&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = BeanFactory.class.getClassLoader().getResourceAsStream(configFile);</span><br><span class="line">            prop = <span class="keyword">new</span> Properties();</span><br><span class="line">            prop.load(in);</span><br><span class="line">            beans = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            Enumeration&lt;Object&gt; keys = prop.keys();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements()) &#123;</span><br><span class="line">                String key = keys.nextElement().toString();</span><br><span class="line">                String path = prop.getProperty(key);</span><br><span class="line">                Object value = Class.forName(path).newInstance();</span><br><span class="line">                beans.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> in != <span class="keyword">null</span>;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> name != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> beans.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-beans-properties"><a href="#4-4-beans-properties" class="headerlink" title="4.4 beans.properties"></a>4.4 beans.properties</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">accountService=com.es.service.AccountService</span><br><span class="line">accountMapper=com.es.mapper.AccountMapper</span><br><span class="line">account=com.es.domain.Account</span><br></pre></td></tr></table></figure><h3 id="4-5-单元测试"><a href="#4-5-单元测试" class="headerlink" title="4.5 单元测试"></a>4.5 单元测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//AccountService service=new AccountServiceImpl();</span></span><br><span class="line">AccountService service = (AccountService) BeanFactory.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">service.delete(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-控制反转"><a href="#5-控制反转" class="headerlink" title="5.控制反转"></a>5.控制反转</h2><ol><li><p>存哪去？     </p><blockquote><p>分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。<br>到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。<br>所以我们的答案就是在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 map 称之为容器。 </p></blockquote></li><li><p>还是没解释什么是工厂？     </p><blockquote><p>工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。<br>原来：我们在获取对象时，都是采用 new 的方式。是主动的。<br>现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。 </p></blockquote></li><li><p>明确 ioc 的作用：</p><blockquote><p><strong>削减计算机程序的耦合(解除我们代码中的依赖关系)。</strong></p></blockquote></li></ol><h1 id="三，使用IOC解决程序的耦合"><a href="#三，使用IOC解决程序的耦合" class="headerlink" title="三，使用IOC解决程序的耦合"></a>三，使用IOC解决程序的耦合</h1><h2 id="1-基于xml形式的装配"><a href="#1-基于xml形式的装配" class="headerlink" title="1.基于xml形式的装配"></a>1.基于xml形式的装配</h2><h3 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><p>​</p><ol><li>创建maven工程，导入相关依赖</li><li>创建spring的配置文件，applicationContext.xml配置文件</li><li>让spring管理资源，在spring的配置文件中配置service和mapper</li></ol><p>​</p><h3 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试基于xml形式的spring ioc获取对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    User user= (User) ioc.getBean(<span class="string">&quot;user&quot;</span>);<span class="comment">//在此处打断点验证对象是什么时候被创建的。</span></span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于xml形式装配bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.domain.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-细节"><a href="#2-细节" class="headerlink" title="2.细节"></a>2.细节</h2><h3 id="2-1-BeanFactory和ApplicationContext的区别"><a href="#2-1-BeanFactory和ApplicationContext的区别" class="headerlink" title="2.1 BeanFactory和ApplicationContext的区别"></a>2.1 BeanFactory和ApplicationContext的区别</h3><p>BeanFactory 才是 Spring 容器中的顶层接口。<br>​</p><p>ApplicationContext 是它的子接口。<br>​</p><p>BeanFactory 和 ApplicationContext 的区别：创建对象的时间点不一样。     </p><ul><li>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。     </li><li>BeanFactory：什么使用什么时候创建对象</li></ul><p>​</p><h3 id="2-2-ApplicationContext接口的实现类"><a href="#2-2-ApplicationContext接口的实现类" class="headerlink" title="2.2 ApplicationContext接口的实现类"></a>2.2 ApplicationContext接口的实现类</h3><p><code>ClasspathXmlApplicationContext</code>：从类的根路径下加载配置文件，推荐使用这种方式。<br>​</p><p><code>FileSystemXmlApplicationContext</code>：从磁盘路径上加载配置文件，可以指定在任意位置。<br>​</p><p><code>AnnotationConfigApplicationContext</code>：当使用注解配置容器或者对象的时候，需要使用此类来创建 spring 容器，用来读取注解。<br>​</p><h3 id="2-3-bean标签"><a href="#2-3-bean标签" class="headerlink" title="2.3 bean标签"></a>2.3 bean标签</h3><p>作用：用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</p><p>属性：</p><ul><li>id：给对象在容器中提供一个唯一标识。用于获取对象。</li><li>class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</li><li>scope：指定对象的作用范围。<ul><li>singleton :默认值，单例的.</li><li>prototype :多例的.</li><li>request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</li><li>session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</li><li>global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.</li></ul></li><li>init-method：指定类中的初始化方法名称。</li><li>destroy-method：指定类中销毁方法名称。</li></ul><h3 id="2-4-bean的生命周期和作用范围"><a href="#2-4-bean的生命周期和作用范围" class="headerlink" title="2.4 bean的生命周期和作用范围"></a>2.4 bean的生命周期和作用范围</h3><p><strong>单例对象</strong>：<code>scope=&quot;singleton&quot;</code>    一个应用只有一个对象的实例。它的作用范围就是整个引用。<br>​</p><p>生命周期：     </p><ul><li>对象出生：当应用加载，创建容器时，对象就被创建了。     </li><li>对象活着：只要容器在，对象一直活着。     </li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。 </li></ul><p>​</p><p><strong>多例对象</strong>：<code>scope=&quot;prototype&quot;</code>     每次访问对象时，都会重新创建对象实例。<br>​</p><p>生命周期：     </p><ul><li>对象出生：当使用对象时，创建新的对象实例。     </li><li>对象活着：只要对象在使用中，就一直活着。     </li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ul><h3 id="2-5-实例化bean的三种方式"><a href="#2-5-实例化bean的三种方式" class="headerlink" title="2.5 实例化bean的三种方式"></a>2.5 实例化bean的三种方式</h3><h4 id="2-5-1-使用无参构造器"><a href="#2-5-1-使用无参构造器" class="headerlink" title="2.5.1.使用无参构造器"></a>2.5.1.使用无参构造器</h4><p>默认情况下：它会根据默认无参构造器来创建类对象。如果bean中没有默认无参构造器，将会创建失败。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;accountService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-静态工厂"><a href="#2-5-2-静态工厂" class="headerlink" title="2.5.2.静态工厂"></a>2.5.2.静态工厂</h4><p>此种方式是使用StaticFactory类中的静态方法创建对象，并存入Spring容器。<br>​</p><p>id属性：指定bean的id，用于从容器中获取。<br>​</p><p>class属性：指定静态工厂的全限定类名。<br>​</p><p>factory-method属性：指定生产对象的静态方法。<br>​</p><p>案例：<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟一个静态工厂，创建业务层实现类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">createAccountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;accountService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.factory.StaticFactory&quot;</span> factory-method=<span class="string">&quot;createAccountService&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-实例工厂"><a href="#2-5-3-实例工厂" class="headerlink" title="2.5.3 实例工厂"></a>2.5.3 实例工厂</h4><p>此种方式先把工厂的创建交给spring容器来管理。然后再使用工厂的bean来调用里面的方法。<br>​</p><p>factory-bean属性：用于指定实例工厂bean的id。<br>​</p><p>factory-method属性：用于指定实例工厂中创建对象的方法。<br>​</p><p>案例：<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟一个实例工厂，创建业务层实现类</span></span><br><span class="line"><span class="comment">* 此工厂创建对象，必须现有工厂实例对象，再调用方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IAccountService <span class="title">createAccountService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;instancFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.factory.InstanceFactory&quot;</span>&gt;&lt;/bean&gt; </span><br><span class="line">&lt;bean id=<span class="string">&quot;accountService&quot;</span>factory-bean=<span class="string">&quot;instancFactory&quot;</span>factory- method=<span class="string">&quot;createAccountService&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="3-依赖注入"><a href="#3-依赖注入" class="headerlink" title="3.依赖注入"></a>3.依赖注入</h2><p>依赖注入（Dependency Injection）他是spring框架的核心，ioc的具体实现。<br>​</p><p>编写程序的时候，通过控制反转，把对象的创建交给spring容器，但是代码中不可能出现没有依赖的情况。<br>​</p><p>ioc解耦只是降低他们的依赖关系，但是不会消除。比如我们的业务层仍然会调用持久层的方法。<br>​</p><p>那么这种业务层和持久层的依赖关系，在使用spring框架之后，就让spring来维护了。<br>​</p><p>简单地说，就是坐等框架把持久层的对象传入业务层，不需要开发人员手动去获取。<br>​</p><h3 id="3-1-构造函数注入"><a href="#3-1-构造函数注入" class="headerlink" title="3.1 构造函数注入"></a>3.1 构造函数注入</h3><p>就是使用类中的构造函数给成员变量赋值。</p><blockquote><p>注意：赋值的操作不是我们自己做的，而是通过配置的方式，让spring框架来为我们注入。</p></blockquote><p>​</p><h3 id="3-2-set-注入"><a href="#3-2-set-注入" class="headerlink" title="3.2 set()注入"></a>3.2 set()注入</h3><p>在类中提供需要注入的成员的set方法。<br>​</p><h3 id="3-3-注入集合属性"><a href="#3-3-注入集合属性" class="headerlink" title="3.3 注入集合属性"></a>3.3 注入集合属性</h3><p>给类中的集合成员传递值，他用的也是set方法的注入方式，只不过变量的数据类型都是集合。<br>​</p><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4 案例"></a>3.4 案例</h3><h4 id="3-4-1-User"><a href="#3-4-1-User" class="headerlink" title="3.4.1 User"></a>3.4.1 User</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirth</span><span class="params">(Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被创建了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user中的show方法背调用了。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, birth=&quot;</span> + birth +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-Person"><a href="#3-4-2-Person" class="headerlink" title="3.4.2 Person"></a>3.4.2 Person</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-3-CollectionDemo"><a href="#3-4-3-CollectionDemo" class="headerlink" title="3.4.3 CollectionDemo"></a>3.4.3 CollectionDemo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String [] arr;</span><br><span class="line">    <span class="keyword">private</span>  List&lt;String&gt; myList;</span><br><span class="line">    <span class="keyword">private</span>  Set&lt;String&gt; mySet;</span><br><span class="line">    <span class="keyword">private</span>  Map&lt;String,String&gt; myMap;</span><br><span class="line">    <span class="keyword">private</span> Properties myProp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArr</span><span class="params">(String[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProp</span><span class="params">(Properties myProp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myProp = myProp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getArr() &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getMyList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getMySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMyMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getMyProp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myProp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-4配置文件"><a href="#3-4-4配置文件" class="headerlink" title="3.4.4配置文件"></a>3.4.4配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 基于xml形式装配bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.es.java1.User&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--使用get方法创建bean--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user2&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.es.java1.User&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;张&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line">        &lt;value&gt;<span class="number">20</span>&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;birth&quot;</span> ref=<span class="string">&quot;now&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;now&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--集合和数组类型的依赖注入--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;demo&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.es.java1.CollectionDemo&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;arr&quot;</span>&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">111</span>&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">222</span>&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">333</span>&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;myList&quot;</span>&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">111</span>&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">222</span>&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">333</span>&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;mySet&quot;</span>&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">111</span>&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">222</span>&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;<span class="number">333</span>&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;myMap&quot;</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">&quot;aaa&quot;</span> value=<span class="string">&quot;aaa&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=<span class="string">&quot;bbb&quot;</span> value=<span class="string">&quot;bbb&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=<span class="string">&quot;ccc&quot;</span> value=<span class="string">&quot;ccc&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;myProp&quot;</span>&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=<span class="string">&quot;aaa&quot;</span>&gt;aaa&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=<span class="string">&quot;bbb&quot;</span>&gt;bbb&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=<span class="string">&quot;ccc&quot;</span>&gt;ccc&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--使用默认构造器创建bean--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.es.java1.Person&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;张&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;20&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="3-4-5-测试类"><a href="#3-4-5-测试类" class="headerlink" title="3.4.5 测试类"></a>3.4.5 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试基于xml形式的spring ioc获取对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    User user= (User) ioc.getBean(<span class="string">&quot;user&quot;</span>);<span class="comment">//在此处打断点验证对象是什么时候被创建的。</span></span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用默认构造器的形式创建bean对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    Person p= (Person) ioc.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    Person p2= (Person) ioc.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    System.out.println(p.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用get方法进行依赖注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    User user= (User) ioc.getBean(<span class="string">&quot;user2&quot;</span>);<span class="comment">//在此处打断点验证对象是什么时候被创建的。</span></span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合和数组的依赖注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    CollectionDemo demo= (CollectionDemo) ioc.getBean(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(demo.getArr()));</span><br><span class="line">    System.out.println(demo.getMyList());</span><br><span class="line">    System.out.println(demo.getMySet());</span><br><span class="line">    System.out.println(demo.getMyMap());</span><br><span class="line">    System.out.println(demo.getMyProp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四，使用ioc实现账户CRUD"><a href="#四，使用ioc实现账户CRUD" class="headerlink" title="四，使用ioc实现账户CRUD"></a>四，使用ioc实现账户CRUD</h1><h2 id="1-基于xml形式"><a href="#1-基于xml形式" class="headerlink" title="1.基于xml形式"></a>1.基于xml形式</h2><h3 id="1-1-引用外部属性文件"><a href="#1-1-引用外部属性文件" class="headerlink" title="1.1 引用外部属性文件"></a>1.1 引用外部属性文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:druid.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;initialSize&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;maxActive&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-SPEL表达式"><a href="#1-2-SPEL表达式" class="headerlink" title="1.2 SPEL表达式"></a>1.2 SPEL表达式</h3><h4 id="1-2-1-简介"><a href="#1-2-1-简介" class="headerlink" title="1.2.1 简介"></a>1.2.1 简介</h4><p>​</p><p>Spring Expression Language，Spring表达式语言，简称SpEL。支持运行时查询并可以操作对象图。<br>​</p><p>和JSP页面上的EL表达式、Struts2中用到的OGNL表达式一样，SpEL根据JavaBean风格的getXxx()、setXxx()方法定义的属性访问对象图，完全符合我们熟悉的操作习惯。<br>​</p><h4 id="1-2-2-基本语法"><a href="#1-2-2-基本语法" class="headerlink" title="1.2.2 基本语法"></a>1.2.2 基本语法</h4><p>​</p><p>SpEL使用#{…}作为定界符，所有在大框号中的字符都将被认为是SpEL表达式。<br>​</p><h4 id="1-2-3-使用字面量"><a href="#1-2-3-使用字面量" class="headerlink" title="1.2.3 使用字面量"></a>1.2.3 使用字面量</h4><pre><code>●整数：&lt;property name=&quot;count&quot; value=&quot;#&#123;5&#125;&quot;/&gt;●小数：&lt;property name=&quot;frequency&quot; value=&quot;#&#123;89.7&#125;&quot;/&gt;●科学计数法：&lt;property name=&quot;capacity&quot; value=&quot;#&#123;1e4&#125;&quot;/&gt;●String类型的字面量可以使用单引号或者双引号作为字符串的定界符号    &lt;property name=”name” value=&quot;#&#123;&#39;Chuck&#39;&#125;&quot;/&gt;    &lt;property name=&#39;name&#39; value=&#39;#&#123;&quot;Chuck&quot;&#125;&#39;/&gt;●Boolean：&lt;property name=&quot;enabled&quot; value=&quot;#&#123;false&#125;&quot;/&gt;</code></pre><h4 id="1-2-4-引用其他bean"><a href="#1-2-4-引用其他bean" class="headerlink" title="1.2.4 引用其他bean"></a>1.2.4 引用其他bean</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp04&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.parent.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;empId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1003&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Kate&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;detp&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;dept&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-5-引用其他bean的属性值作为自己某个属性的值"><a href="#1-2-5-引用其他bean的属性值作为自己某个属性的值" class="headerlink" title="1.2.5 引用其他bean的属性值作为自己某个属性的值"></a>1.2.5 引用其他bean的属性值作为自己某个属性的值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp05&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.parent.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;empId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1003&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Kate&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;dept.deptName&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-6调用非静态方法"><a href="#1-2-6调用非静态方法" class="headerlink" title="1.2.6调用非静态方法"></a>1.2.6调用非静态方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建一个对象，在SpEL表达式中调用这个对象的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;salaryGenerator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.spel.bean.SalaryGenerator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.spel.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 通过对象方法的返回值为属性赋值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;salayOfYear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;salaryGenerator.getSalaryOfYear(5000)&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-7调用静态方法"><a href="#1-2-7调用静态方法" class="headerlink" title="1.2.7调用静态方法"></a>1.2.7调用静态方法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.spel.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在SpEL表达式中调用类的静态方法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;T(java.lang.Math).PI*20&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-8-运算符"><a href="#1-2-8-运算符" class="headerlink" title="1.2.8 运算符"></a>1.2.8 运算符</h4><p>①算术运算符：+、-、*、/、%、^<br>②字符串连接：+<br>③比较运算符：&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge<br>④逻辑运算符：and, or, not, |<br>⑤三目运算符：判断条件?判断结果为true时的取值:判断结果为false时的取值<br>⑥正则表达式：matches<br>​</p><h3 id="1-3-Spring的-和-的区别"><a href="#1-3-Spring的-和-的区别" class="headerlink" title="1.3 Spring的#和$的区别"></a>1.3 Spring的#和$的区别</h3><p><code>$&#123;key名称&#125;</code>：<br>​</p><ol><li>用户获取外部文件中指定key的值；</li></ol><p>​</p><ol start="2"><li>可以出现在xml配置文件中，也可以出现在注解@Value中；</li></ol><p>​</p><ol start="3"><li>一般用户获取数据库配置文件的内容信息等。</li></ol><p><code>#&#123;表达式&#125;</code>：<br>​</p><ol><li>SpEL表达式的格式，详情(<a href="https://blog.csdn.net/xingfei_work/article/details/76058178">https://blog.csdn.net/xingfei_work/article/details/76058178)</a>)；</li></ol><p>​</p><ol start="2"><li>可以出现在xml配置文件中，也可以出现在注解@Value中</li></ol><p>​</p><ol start="3"><li>可以任意表达式，支持运算符等。</li></ol><p>​</p><h3 id="1-4-案例"><a href="#1-4-案例" class="headerlink" title="1.4 案例"></a>1.4 案例</h3><h4 id="1-4-1-配置文件"><a href="#1-4-1-配置文件" class="headerlink" title="1.4.1 配置文件"></a>1.4.1 配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置自动扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.es&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;runner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.domain.Account&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/eesy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yhd666&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-2-持久层"><a href="#1-4-2-持久层" class="headerlink" title="1.4.2 持久层"></a>1.4.2 持久层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.dao.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(<span class="string">&quot;select * from account&quot;</span>,<span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(<span class="string">&quot;select * from account where id = ? &quot;</span>,<span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(<span class="string">&quot;insert into account(name,money)values(?,?)&quot;</span>,account.getName(),account.getMoney());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(<span class="string">&quot;delete from account where id=?&quot;</span>,accountId);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-业务层"><a href="#1-4-3-业务层" class="headerlink" title="1.4.3 业务层"></a>1.4.3 业务层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.es.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer acccountId)</span> </span>&#123;</span><br><span class="line">        accountDao.deleteAccount(acccountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-4-测试类"><a href="#1-4-4-测试类" class="headerlink" title="1.4.4 测试类"></a>1.4.4 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IAccountService service= (IAccountService) ioc.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        service.deleteAccount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-xml和注解混搭"><a href="#2-xml和注解混搭" class="headerlink" title="2.xml和注解混搭"></a>2.xml和注解混搭</h2><h3 id="2-1-用于创建对象"><a href="#2-1-用于创建对象" class="headerlink" title="2.1 用于创建对象"></a>2.1 用于创建对象</h3><p>他们的作用就和在XML配置文件中编写一个<bean>标签实现的功能是一样的。</p><ul><li>​<code>Component</code>:</li></ul><p> 作用：用于把当前类对象存入spring容器中<br> 属性：<br>     value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</p><ul><li>​<code>Controller</code>：一般用在表现层</li><li>​<code>Service</code>：一般用在业务层</li><li>​<code>Repository</code>：一般用在持久层</li></ul><p>​</p><p>以上个注解他们的作用和属性与Component是一模一样。<br>​</p><p>他们是spring框架为我们提供明确的层使用的注解，使我们的层对象更加清晰。<br>​</p><h3 id="2-2-用于注入数据"><a href="#2-2-用于注入数据" class="headerlink" title="2.2 用于注入数据"></a>2.2 用于注入数据</h3><p>他们的作用就和在xml配置文件中的bean标签中写一个<property>标签的作用是一样的。</p><ul><li><code>Autowired</code>:</li></ul><p> 作用：自动照类型注入。只要容器中唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功<br>       如果ioc容器中没任何bean的类型和要注入的变量类型匹配，则报错。<br>       如果Ioc容器中多个类型匹配时：<br> 出现位置：<br>     可以是变量上，也可以是方法上<br> 细节：<br>     在使用注解注入时，set方法就不是必须的了。</p><ul><li>​<code>Qualifier</code>:</li></ul><p> 作用：在照类型注入的基础之上再照名称注入。它在给类成员注入时不能单独使用。但是在给方法参数注入时可以<br> 属性：<br>     value：用于指定注入bean的id。</p><ul><li>​<code>Resource</code></li></ul><p> 作用：直接照bean的id注入。它可以独立使用<br> 属性：<br>     name：用于指定bean的id。<br>以上个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。<br>另外，集合类型的注入只能通过XML来实现。<br>​</p><ul><li>​<code>Value</code></li></ul><p> 作用：用于注入基本类型和String类型的数据<br> 属性：<br>     value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式，SpEL的写法：${表达式}<br>​</p><h3 id="2-3-用于改变作用范围"><a href="#2-3-用于改变作用范围" class="headerlink" title="2.3.用于改变作用范围"></a>2.3.用于改变作用范围</h3><p>他们的作用就和在bean标签中使用scope属性实现的功能是一样的。</p><ul><li>​<code>Scope</code></li></ul><p> 作用：用于指定bean的作用范围<br> 属性：<br>     value：指定范围的取值。常用取值：singleton prototype<br>​</p><h3 id="2-4-和生命周期相关"><a href="#2-4-和生命周期相关" class="headerlink" title="2.4 和生命周期相关"></a>2.4 和生命周期相关</h3><p>他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的。<br>​</p><ul><li>​<code>PreDestroy</code></li></ul><p> 作用：用于指定销毁方法</p><ul><li>​<code>PostConstruct</code></li></ul><p> 作用：用于指定初始化方法<br>​</p><h3 id="2-5-案例"><a href="#2-5-案例" class="headerlink" title="2.5 案例"></a>2.5 案例</h3><h4 id="2-5-1-配置文件"><a href="#2-5-1-配置文件" class="headerlink" title="2.5.1 配置文件"></a>2.5.1 配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置自动扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.es&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/eesy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yhd666&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-2-持久层"><a href="#2-5-2-持久层" class="headerlink" title="2.5.2 持久层"></a>2.5.2 持久层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.dao.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository(value = &quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(<span class="string">&quot;select * from account&quot;</span>,<span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(<span class="string">&quot;select * from account where id = ? &quot;</span>,<span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(<span class="string">&quot;insert into account(name,money)values(?,?)&quot;</span>,account.getName(),account.getMoney());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(<span class="string">&quot;delete from account where id=?&quot;</span>,accountId);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-业务层"><a href="#2-5-3-业务层" class="headerlink" title="2.5.3 业务层"></a>2.5.3 业务层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.es.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer acccountId)</span> </span>&#123;</span><br><span class="line">        accountDao.deleteAccount(acccountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-测试类"><a href="#2-5-4-测试类" class="headerlink" title="2.5.4 测试类"></a>2.5.4 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.es.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-01-11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    ApplicationContext ioc=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IAccountService service= (IAccountService) ioc.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">        service.deleteAccount(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-纯注解配置"><a href="#3-纯注解配置" class="headerlink" title="3.纯注解配置"></a>3.纯注解配置</h2><h3 id="3-1-注解"><a href="#3-1-注解" class="headerlink" title="3.1 注解"></a>3.1 注解</h3><ul><li>​<code>Configuration</code></li></ul><p>作用：指定当前类是一个配置类<br>细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。</p><ul><li>​<code>ComponentScan</code></li></ul><p>作用：用于通过注解指定spring在创建容器时要扫描的包<br>属性：<br>          value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。<br>                 我们使用此注解就等同于在xml中配置了:<br> <code>&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;</code></p><ul><li>​<code>Bean</code></li></ul><p>作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中<br>属性:<br>          name:用于指定bean的id。当不写时，默认值是当前方法的名称<br>细节：<br>          当我们使用注解配置方法时，如果有方法参数，spring框架会去容器中查找没可用的bean对象。<br>          查找的方式和Autowired注解的作用是一样的</p><ul><li><p>​<code>Import</code></p><pre><code>作用：用于导入其他的配置类属性：    value：用于指定其他配置类的字节码。            当我们使用Import的注解之后，Import注解的类就父配置类，而导入的都是子配置类</code></pre></li><li><p>​<code>PropertySource</code></p><pre><code>作用：用于指定properties文件的位置 属性：   value：指定文件的名称和路径。            关键字：classpath，表示类路径下</code></pre><p>​</p></li></ul><h3 id="3-2-spring整合junit4"><a href="#3-2-spring整合junit4" class="headerlink" title="3.2 spring整合junit4"></a>3.2 spring整合junit4</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">1、应用程序的入口</span><br><span class="line">main方法</span><br><span class="line">2、junit单元测试中，没有main方法也能执行</span><br><span class="line">junit集成了一个main方法</span><br><span class="line">该方法就会判断当前测试类中哪些方法有 @Test注解</span><br><span class="line">junit就让有Test注解的方法执行</span><br><span class="line">3、junit不会管我们是否采用spring框架</span><br><span class="line">在执行测试方法时，junit根本不知道我们是不是使用了spring框架</span><br><span class="line">所以也就不会为我们读取配置文件/配置类创建spring核心容器</span><br><span class="line">4、由以上三点可知</span><br><span class="line">当测试方法执行时，没有Ioc容器，就算写了Autowired注解，也无法实现注入</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"> * 使用Junit单元测试：测试我们的配置</span><br><span class="line"> * Spring整合junit的配置</span><br><span class="line"> *      1、导入spring整合junit的jar(坐标)</span><br><span class="line"> *      2、使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的</span><br><span class="line"> *             @Runwith(SpringJUnit4ClassRunner.class)</span><br><span class="line"> *      3、告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置</span><br><span class="line"> *          @ContextConfiguration</span><br><span class="line"> *                  locations：指定xml文件的位置，加上classpath关键字，表示在类路径下</span><br><span class="line"> *                  classes：指定注解类所在地位置</span><br><span class="line"> *</span><br><span class="line"> *   当我们使用spring 5.x版本的时候，要求junit的jar必须是4.12及以上</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="3-3-1-配置类"><a href="#3-3-1-配置类" class="headerlink" title="3.3.1 配置类"></a>3.3.1 配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-01-16:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.es&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:c3p0.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-配置子类"><a href="#3-3-2-配置子类" class="headerlink" title="3.3.2 配置子类"></a>3.3.2 配置子类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-01-16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;runner&quot;)</span></span><br><span class="line">    <span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">getRunner</span><span class="params">(<span class="meta">@Qualifier(&quot;ds1&quot;)</span> DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        QueryRunner runner = <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">        <span class="keyword">return</span> runner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name=&quot;ds1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream is = JdbcConfig.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            prop.load(is);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;ds2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComboPooledDataSource dataSource=<span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">            dataSource.setDriverClass(driver);</span><br><span class="line">            dataSource.setJdbcUrl(url);</span><br><span class="line">            dataSource.setUser(username);</span><br><span class="line">            dataSource.setPassword(password);</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PropertyVetoException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-测试类"><a href="#3-3-3-测试类" class="headerlink" title="3.3.3 测试类"></a>3.3.3 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = com.es.java1.SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService service = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.deleteAccount(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五，AOP面向切面编程"><a href="#五，AOP面向切面编程" class="headerlink" title="五，AOP面向切面编程"></a>五，AOP面向切面编程</h1><h2 id="1-动态代理"><a href="#1-动态代理" class="headerlink" title="1.动态代理"></a>1.动态代理</h2><h3 id="1-1-基于接口的动态代理"><a href="#1-1-基于接口的动态代理" class="headerlink" title="1.1 基于接口的动态代理"></a>1.1 基于接口的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//被代理类对象要声明为最终的</span></span><br><span class="line">        <span class="keyword">final</span> Producer producer=<span class="keyword">new</span> Producer();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态代理：</span></span><br><span class="line"><span class="comment">         *  特点：字节码随用随创建，随用随加载</span></span><br><span class="line"><span class="comment">         *  作用：不修改源码的基础上对方法增强</span></span><br><span class="line"><span class="comment">         *  分类：</span></span><br><span class="line"><span class="comment">         *      基于接口的动态代理</span></span><br><span class="line"><span class="comment">         *      基于子类的动态代理</span></span><br><span class="line"><span class="comment">         *  基于接口的动态代理：</span></span><br><span class="line"><span class="comment">         *      涉及的类：Proxy</span></span><br><span class="line"><span class="comment">         *      提供者：JDK官方</span></span><br><span class="line"><span class="comment">         *  如何创建代理对象：</span></span><br><span class="line"><span class="comment">         *      使用Proxy类中的newProxyInstance方法</span></span><br><span class="line"><span class="comment">         *  创建代理对象的要求：</span></span><br><span class="line"><span class="comment">         *      被代理类最少实现一个接口，如果没有则不能使用</span></span><br><span class="line"><span class="comment">         *  newProxyInstance方法的参数：</span></span><br><span class="line"><span class="comment">         *      ClassLoader：类加载器</span></span><br><span class="line"><span class="comment">         *          它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</span></span><br><span class="line"><span class="comment">         *      Class[]：字节码数组</span></span><br><span class="line"><span class="comment">         *          它是用于让代理对象和被代理对象相同方法。固定写法。</span></span><br><span class="line"><span class="comment">         *      InvocationHandler：用于提供增强的代码</span></span><br><span class="line"><span class="comment">         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</span></span><br><span class="line"><span class="comment">         *          此接口的实现类都是谁用谁写。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//代理对象和被代理类对象要实现同一个接口</span></span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 作用：执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * 方法参数的含义</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy   代理对象的引用</span></span><br><span class="line"><span class="comment">                     * 1. 可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()。</span></span><br><span class="line"><span class="comment">                     * 2. 可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象。</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method  当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args    当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>        和被代理对象方法相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object value=<span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//获取方法执行的参数</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            Float money= (Float) args[<span class="number">0</span>];</span><br><span class="line">                            <span class="comment">//两个参数：被代理类对象，方法增强的参数</span></span><br><span class="line">                            value=method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">IProducer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售产品，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对生产厂家要求的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-基于子类的动态代理"><a href="#1-2-基于子类的动态代理" class="headerlink" title="1.2 基于子类的动态代理"></a>1.2 基于子类的动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-02-1:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态代理：</span></span><br><span class="line"><span class="comment">         *  特点：字节码随用随创建，随用随加载</span></span><br><span class="line"><span class="comment">         *  作用：不修改源码的基础上对方法增强</span></span><br><span class="line"><span class="comment">         *  分类：</span></span><br><span class="line"><span class="comment">         *      基于接口的动态代理</span></span><br><span class="line"><span class="comment">         *      基于子类的动态代理</span></span><br><span class="line"><span class="comment">         *  基于子类的动态代理：</span></span><br><span class="line"><span class="comment">         *      涉及的类：Enhancer</span></span><br><span class="line"><span class="comment">         *      提供者：第方cglib库</span></span><br><span class="line"><span class="comment">         *  如何创建代理对象：</span></span><br><span class="line"><span class="comment">         *      使用Enhancer类中的create方法</span></span><br><span class="line"><span class="comment">         *  创建代理对象的要求：</span></span><br><span class="line"><span class="comment">         *      被代理类是最终类</span></span><br><span class="line"><span class="comment">         *  create方法的参数：</span></span><br><span class="line"><span class="comment">         *      Class：字节码</span></span><br><span class="line"><span class="comment">         *          它是用于指定被代理对象的字节码。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      Callback：用于提供增强的代码</span></span><br><span class="line"><span class="comment">         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</span></span><br><span class="line"><span class="comment">         *          此接口的实现类都是谁用谁写。</span></span><br><span class="line"><span class="comment">         *          我们一般写的都是该接口的子接口实现类：MethodInterceptor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">             *    以上个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强的代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.java2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售产品，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用动态代理对spring进行方法增强"><a href="#1-3-使用动态代理对spring进行方法增强" class="headerlink" title="1.3 使用动态代理对spring进行方法增强"></a>1.3 使用动态代理对spring进行方法增强</h3><p>接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">che</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java1</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">che</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  java1 java;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJava</span><span class="params">(java1 java)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.java = java;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterface <span class="title">getBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyInterface proxyJava = (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">                java.getClass().getClassLoader(),</span><br><span class="line">                java.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object value = <span class="keyword">null</span>;</span><br><span class="line">                        System.out.println(<span class="string">&quot;方法执行前....&quot;</span>);</span><br><span class="line">                        value = method.invoke(java, args);</span><br><span class="line">                        System.out.println(<span class="string">&quot;方法执行之后....&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxyJava;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;proxyJava&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyInterface myInterface;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(myInterface.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(myInterface.del(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(myInterface.che(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(myInterface.div(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;factory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.es.factory.BeanFactory&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;java&quot;</span> ref=<span class="string">&quot;java&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;java&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.es.java1.java1&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;proxyJava&quot;</span> factory-bean=<span class="string">&quot;factory&quot;</span> factory-method=<span class="string">&quot;getBean&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="2-AOP"><a href="#2-AOP" class="headerlink" title="2.AOP"></a>2.AOP</h2><h3 id="2-1-AOP相关概念"><a href="#2-1-AOP相关概念" class="headerlink" title="2.1 AOP相关概念"></a>2.1 AOP相关概念</h3><p>AOP：全称是 <code>Aspect Oriented Programming </code>即：面向切面编程。就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p><ul><li><p>作用：</p><pre><code>  在程序运行期间，不修改源码对已有方法进行增强。</code></pre></li><li><p>优势：</p><pre><code>  减少重复代码  提高开发效率  维护方便</code></pre></li></ul><p><strong>AOP 相关术语</strong></p><ul><li><p>Joinpoint(连接点):</p><pre><code>  所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。</code></pre></li><li><p>Pointcut(切入点):</p><pre><code>  所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</code></pre></li><li><p>Advice(通知/增强):</p><pre><code>  所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。</code></pre><p>  通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</p></li><li><p>Introduction(引介):</p><pre><code>  引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</code></pre></li><li><p>Target(目标对象):被代理对象</p><pre><code>  代理的目标对象。</code></pre></li><li><p>Weaving(织入):</p><pre><code>  是指把增强应用到目标对象来创建新的代理对象的过程。  spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</code></pre></li><li><p>Proxy（代理:</p><pre><code>  一个类被 AOP 织入增强后，就产生一个结果代理类。</code></pre></li><li><p>Aspect(切面):</p><pre><code>  是切入点和通知（引介的结合</code></pre><p>​</p></li></ul><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。<br>​</p><h3 id="2-2-基于xml形式的配置"><a href="#2-2-基于xml形式的配置" class="headerlink" title="2.2 基于xml形式的配置"></a>2.2 基于xml形式的配置</h3><h4 id="2-2-1-配置步骤"><a href="#2-2-1-配置步骤" class="headerlink" title="2.2.1 配置步骤"></a>2.2.1 配置步骤</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;!--spring中基于XML的AOP配置步骤</span></span><br><span class="line">    <span class="attr">1、把通知Bean也交给spring来管理</span></span><br><span class="line">    <span class="meta">2、使用aop</span>:<span class="string">config标签表明开始AOP的配置</span></span><br><span class="line">    <span class="meta">3、使用aop</span>:<span class="string">aspect标签表明配置切面</span></span><br><span class="line">            <span class="attr">id属性：是给切面提供一个唯一标识</span></span><br><span class="line">            <span class="attr">ref属性：是指定通知类bean的Id。</span></span><br><span class="line">    <span class="meta">4、在aop</span>:<span class="string">aspect标签的内部使用对应标签来配置通知的类型</span></span><br><span class="line">           <span class="attr">我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知</span></span><br><span class="line">           <span class="attr">aop</span>:<span class="string">before：表示配置前置通知</span></span><br><span class="line">                <span class="attr">method属性：用于指定Logger类中哪个方法是前置通知</span></span><br><span class="line">                <span class="attr">pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强</span></span><br><span class="line">        <span class="attr">切入点表达式的写法：</span></span><br><span class="line">            <span class="attr">关键字：execution(表达式)</span></span><br><span class="line">            <span class="attr">表达式：</span></span><br><span class="line">                <span class="meta">访问修饰符</span>  <span class="string">返回值  包名.包名.包名...类名.方法名(参数列表)</span></span><br><span class="line">            <span class="attr">标准的表达式写法：</span></span><br><span class="line">                <span class="attr">public</span> <span class="string">void com.itheima.service.impl.AccountServiceImpl.saveAccount()</span></span><br><span class="line">            <span class="attr">访问修饰符可以省略</span></span><br><span class="line">                <span class="attr">void</span> <span class="string">com.itheima.service.impl.AccountServiceImpl.saveAccount()</span></span><br><span class="line">            <span class="attr">返回值可以使用通配符，表示任意返回值</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">com.itheima.service.impl.AccountServiceImpl.saveAccount()</span></span><br><span class="line">            <span class="attr">包名可以使用通配符，表示任意包。但是几级包，就需要写几个*.</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">*.*.*.*.AccountServiceImpl.saveAccount())</span></span><br><span class="line">            <span class="attr">包名可以使用..表示当前包及其子包</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">*..AccountServiceImpl.saveAccount()</span></span><br><span class="line">            <span class="attr">类名和方法名都可以使用*来实现通配</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">*..*.*()</span></span><br><span class="line">            <span class="attr">参数列表：</span></span><br><span class="line">                <span class="attr">可以直接写数据类型：</span></span><br><span class="line">                    <span class="meta">基本类型直接写名称</span>           <span class="string">int</span></span><br><span class="line">                    <span class="meta">引用类型写包名.类名的方式</span>   <span class="string">java.lang.String</span></span><br><span class="line">                <span class="attr">可以使用通配符表示任意类型，但是必须参数</span></span><br><span class="line">                <span class="attr">可以使用..表示无参数均可，参数可以是任意类型</span></span><br><span class="line">            <span class="attr">全通配写法：</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">*..*.*(..)</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">实际开发中切入点表达式的通常写法：</span></span><br><span class="line">                <span class="attr">切到业务层实现类下的所方法</span></span><br><span class="line">                    <span class="meta">*</span> <span class="string">com.itheima.service.impl.*.*(..)</span></span><br><span class="line"><span class="attr">--&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.java1.java1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;logging&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.java2.Logging&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span></span><br><span class="line"><span class="comment">          此标签写在aop:aspect标签内部只能当前切面使用。</span></span><br><span class="line"><span class="comment">          它还可以写在aop:aspect外面，此时就变成了所切面可用</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public int com.es.java1.java1.*(int,int))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;logging&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置前置通知：在切入点方法执行之前执行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">pointcut</span>=<span class="string">&quot;execution(public int com.es.java1.java1.*(int,int))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置后置通知：在切入点方法正常执行之后值。它和异常通知永远只能执行一个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterReturn&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置异常通知：在切入点方法执行产生异常之后执行。它和后置通知永远只能执行一个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置最终通知：无论切入点方法是否正常执行它都会在其后面执行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置环绕通知 详细的注释 :Logger类中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:around</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java1</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">che</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;java&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyInterface java;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        java.div(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;★★★前置★★★&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;★★★后置★★★&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;★★★异常★★★&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;★★★最终★★★&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     *      当我们配置了环绕通知之后，切入点方法没执行，而通知方法执行了。</span></span><br><span class="line"><span class="comment">     * 分析：</span></span><br><span class="line"><span class="comment">     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知明确的切入点方法调用，而我们的代码中没。</span></span><br><span class="line"><span class="comment">     * 解决：</span></span><br><span class="line"><span class="comment">     *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口一个方法proceed()，此方法就相当于明确调用切入点方法。</span></span><br><span class="line"><span class="comment">     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * spring中的环绕通知：</span></span><br><span class="line"><span class="comment">     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object value=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取方法执行的参数</span></span><br><span class="line">        Object []args=pjp.getArgs();</span><br><span class="line">        <span class="comment">//获取方法名</span></span><br><span class="line">        String methodName = pjp.getSignature().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;★★★前置★★★&quot;</span>+methodName+<span class="string">&quot;...&quot;</span>+Arrays.toString(args));</span><br><span class="line">            value=pjp.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">&quot;★★★后置★★★&quot;</span>+methodName+<span class="string">&quot;...&quot;</span>+Arrays.toString(args)+<span class="string">&quot;...&quot;</span>+value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;★★★异常★★★&quot;</span>+methodName+<span class="string">&quot;...&quot;</span>+Arrays.toString(args));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;★★★最终★★★&quot;</span>+methodName+<span class="string">&quot;...&quot;</span>+Arrays.toString(args)+<span class="string">&quot;...&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-基于注解的配置"><a href="#2-3-基于注解的配置" class="headerlink" title="2.3 基于注解的配置"></a>2.3 基于注解的配置</h3><h4 id="2-3-1-步骤"><a href="#2-3-1-步骤" class="headerlink" title="2.3.1 步骤"></a>2.3.1 步骤</h4><ol><li><p>首先在配置文件里开启声明式aop注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启声明式事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在logging类上声明其为一个切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span><span class="comment">//声明一个切面</span></span><br></pre></td></tr></table></figure></li><li><p>在类中声明一个方法作为切入点表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * com.es.java1.java1.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在各个方法上添加注解</p></li><li><p>设置切面优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(2)</span><span class="comment">//通过@Order(2)注解指定切面优先级，value值越小，优先级越高，默认是int最大值。</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-案例"><a href="#2-3-2-案例" class="headerlink" title="2.3.2 案例"></a>2.3.2 案例</h4></li></ol><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--开启声明式事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置自动扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.es&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>日志类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-04-16:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;logging&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(value=&quot;execution(* com.es.java1.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint jp)</span></span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        String name = jp.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>+name+<span class="string">&quot;...&quot;</span>+Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;execution(* com.es.java1.*.*(..))&quot;,returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint jp,Object result)</span></span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        String name = jp.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning...&quot;</span>+name+<span class="string">&quot;...&quot;</span>+Arrays.toString(args)+<span class="string">&quot;...&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;execution(* com.es.java1.*.*(..))&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint jp,Exception e)</span></span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        String name = jp.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing...&quot;</span>+name+<span class="string">&quot;...&quot;</span>+Arrays.toString(args)+<span class="string">&quot;...&quot;</span>+e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.es.java1.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint jp)</span></span>&#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        String name = jp.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>+name+<span class="string">&quot;...&quot;</span>+Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Add add;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        add.add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(add.del(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//配置通用的切入点表达式</span><br><span class="line">@Pointcut(value = &quot;execution(* com.es.dao.impl.ComputerDaoImpl.*(..))&quot;)</span><br><span class="line">public void pointCut()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//引用通用的切入点表达式</span><br><span class="line">@Before(&quot;pointCut()&quot;)</span><br><span class="line">public void before(JoinPoint point)&#123;</span><br><span class="line">    System.out.println(&quot;前置通知--&gt;&quot;+&quot;方法名：&quot;+point.getSignature().getName()+&quot;参数列表：&quot;+ Arrays.asList(point.getArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六，spring的事务"><a href="#六，spring的事务" class="headerlink" title="六，spring的事务"></a>六，spring的事务</h1><h2 id="1-基于AOP的事务处理模拟"><a href="#1-基于AOP的事务处理模拟" class="headerlink" title="1.基于AOP的事务处理模拟"></a>1.基于AOP的事务处理模拟</h2><h3 id="1-1-步骤-1"><a href="#1-1-步骤-1" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><ol><li>创建一个链接工具类，负责从线程获取连接，并实现与线程的绑定。</li><li>创建和事务管理相关的工具类，负责处理事务操作</li><li>利用aop实现事务处理</li></ol><p>​</p><h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h3><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置dao--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;runner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connection&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置queryRunner--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;runner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbutils.QueryRunner&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/eesy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yhd666&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置transactionManager--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.utils.TransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connection&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置ConnectionUtils--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connection&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.utils.ConnectionUtils&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.es.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;txA&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beginTransaction&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;commit&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-returning</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;rollback&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after-throwing</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;release&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:after</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>持久层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.es.utils.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span>  <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(),<span class="string">&quot;select * from account&quot;</span>,<span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account.class));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runner.query(connectionUtils.getThreadConnection(),<span class="string">&quot;select * from account where id = ? &quot;</span>,<span class="keyword">new</span> BeanHandler&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(connectionUtils.getThreadConnection(),<span class="string">&quot;insert into account(name,money)values(?,?)&quot;</span>,account.getName(),account.getMoney());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(connectionUtils.getThreadConnection(),<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            runner.update(connectionUtils.getThreadConnection(),<span class="string">&quot;delete from account where id=?&quot;</span>,accountId);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(),<span class="string">&quot;select * from account where name = ? &quot;</span>,<span class="keyword">new</span> BeanListHandler&lt;Account&gt;(Account.class),accountName);</span><br><span class="line">            <span class="keyword">if</span>(accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(accounts.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;结果集不唯一，数据有问题&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.es.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都是在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);</span><br><span class="line">            <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            <span class="comment">//2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接的工具类，它用于从数据源中获取一个连接，并且实现和线程的绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程上的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.先从ThreadLocal上获取</span></span><br><span class="line">            Connection conn = tl.get();</span><br><span class="line">            <span class="comment">//2.判断当前线程上是否连接</span></span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3.从数据源中获取一个连接，并且存入ThreadLocal中</span></span><br><span class="line">                conn = dataSource.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4.返回当前线程上的连接</span></span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把连接和线程解绑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和事务管理相关的工具类，它包含了，开启事务，提交事务，回滚事务和释放连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().rollback();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadConnection().close();<span class="comment">//还回连接池中</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-spring的事务配置"><a href="#2-spring的事务配置" class="headerlink" title="2.spring的事务配置"></a>2.spring的事务配置</h2><h3 id="2-1-spring中基于xml的事务配置"><a href="#2-1-spring中基于xml的事务配置" class="headerlink" title="2.1 spring中基于xml的事务配置"></a>2.1 spring中基于xml的事务配置</h3><h4 id="2-2-1-配置步骤-1"><a href="#2-2-1-配置步骤-1" class="headerlink" title="2.2.1 配置步骤"></a>2.2.1 配置步骤</h4><p><strong>spring中基于XML的声明式事务控制配置步骤</strong><br>​</p><ol><li><p>配置事务管理器</p></li><li><p>配置事务的通知</p><pre><code> 此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的 使用tx:advice标签配置事务通知     属性：         id：给事务通知起一个唯一标识         transaction-manager：给事务通知提供一个事务管理器引用</code></pre></li><li><p>配置AOP中的通用切入点表达式</p></li><li><p>建立事务通知和切入点表达式的对应关系</p></li><li><p>配置事务的属性</p><pre><code>是在事务的通知tx:advice标签的内部</code></pre><p>​</p></li></ol><p><strong>配置事务的属性</strong><br>​</p><ol><li>isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</li><li>propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</li><li>read-only：用于指定事务是否只读。只查询方法才能设置为true。默认值是false，表示读写。</li><li>timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。</li><li>rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li><li>no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li></ol><p>​</p><h4 id="2-2-2-案例"><a href="#2-2-2-案例" class="headerlink" title="2.2.2 案例"></a>2.2.2 案例</h4><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.es&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.domain.Account&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.es.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yhd666&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///eesy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring中基于XML的声明式事务控制配置步骤</span></span><br><span class="line"><span class="comment">        1、配置事务管理器</span></span><br><span class="line"><span class="comment">        2、配置事务的通知</span></span><br><span class="line"><span class="comment">                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的</span></span><br><span class="line"><span class="comment">                使用tx:advice标签配置事务通知</span></span><br><span class="line"><span class="comment">                    属性：</span></span><br><span class="line"><span class="comment">                        id：给事务通知起一个唯一标识</span></span><br><span class="line"><span class="comment">                        transaction-manager：给事务通知提供一个事务管理器引用</span></span><br><span class="line"><span class="comment">        3、配置AOP中的通用切入点表达式</span></span><br><span class="line"><span class="comment">        4、建立事务通知和切入点表达式的对应关系</span></span><br><span class="line"><span class="comment">        5、配置事务的属性</span></span><br><span class="line"><span class="comment">               是在事务的通知tx:advice标签的内部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置事务的属性</span></span><br><span class="line"><span class="comment">                       isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</span></span><br><span class="line"><span class="comment">                       propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</span></span><br><span class="line"><span class="comment">                       read-only：用于指定事务是否只读。只查询方法才能设置为true。默认值是false，表示读写。</span></span><br><span class="line"><span class="comment">                       timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。</span></span><br><span class="line"><span class="comment">                       rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class="line"><span class="comment">                       no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class="line"><span class="comment">               --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.es.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>持久层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="keyword">super</span>.getJdbcTemplate().query(<span class="string">&quot;select * from account where id = ?&quot;</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty()?<span class="keyword">null</span>:accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = <span class="keyword">super</span>.getJdbcTemplate().query(<span class="string">&quot;select * from account where name = ?&quot;</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);</span><br><span class="line">        <span class="keyword">if</span>(accounts.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(accounts.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;结果集不唯一&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getJdbcTemplate().update(<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.es.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.es.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.es.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都是在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);</span><br><span class="line">            <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            <span class="comment">//2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// int i=1/0;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.es.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-03-12:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService service;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        service.transfer(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="number">1000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-spring中基于注解的事务配置"><a href="#2-2-spring中基于注解的事务配置" class="headerlink" title="2.2 spring中基于注解的事务配置"></a>2.2 spring中基于注解的事务配置</h3><h4 id="2-2-1-配置步骤-2"><a href="#2-2-1-配置步骤-2" class="headerlink" title="2.2.1 配置步骤"></a>2.2.1 配置步骤</h4><ol><li>在配置文件配置事务管理器</li><li>开始声明式事务的支持</li><li>在对应的方法上加@Transcational注解，事务声明注解:该注解可以添加到类或者方法上</li></ol><p>属性：<br>      <code>propagation</code>:用来设置事务的传播行为：一个方法运行在一个开启了事务的方法中，当前方法是使用原有的事务还是开启新事物<br>      <code>required</code>:如果有事务就使用，没有就开启一个新的（默认）<br>      <code>required_new</code>:必须开启新事物<br>      <code>supports</code>：如果有事务就运行，否则也不开启新的事务<br>      <code>no_supports</code>:即使有事务也不用<br>​</p><h4 id="2-2-2-案例-1"><a href="#2-2-2-案例-1" class="headerlink" title="2.2.2 案例"></a>2.2.2 案例</h4><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:druid.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring中基于注解 的声明式事务控制配置步骤</span></span><br><span class="line"><span class="comment">        1、配置事务管理器</span></span><br><span class="line"><span class="comment">        2、开启spring对注解事务的支持</span></span><br><span class="line"><span class="comment">        3、在需要事务支持的地方使用@Transactional注解</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启spring对注解事务的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.es&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>持久层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span>  <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">&quot;select * from account where id = ?&quot;</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountId);</span><br><span class="line">        <span class="keyword">return</span> accounts.isEmpty()?<span class="keyword">null</span>:accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = jdbcTemplate.query(<span class="string">&quot;select * from account where name = ?&quot;</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),accountName);</span><br><span class="line">        <span class="keyword">if</span>(accounts.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(accounts.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;结果集不唯一&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accounts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;update account set name=?,money=? where id=?&quot;</span>,account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 账户的业务层实现类</span><br><span class="line"> *</span><br><span class="line"> * 事务控制应该都是在业务层</span><br><span class="line"> */</span><br><span class="line">@Service(&quot;accountService&quot;)</span><br><span class="line">@Transactional(readOnly = false,propagation = Propagation.SUPPORTS)</span><br><span class="line">public class AccountServiceImpl implements IAccountService&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void setAccountDao(IAccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Account findAccountById(Integer accountId) &#123;</span><br><span class="line">        return accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional(readOnly = false,propagation = Propagation.REQUIRED)</span><br><span class="line">    public void transfer(String sourceName, String targetName, Float money) &#123;</span><br><span class="line">        System.out.println(&quot;transfer....&quot;);</span><br><span class="line">            //2.1根据名称查询转出账户</span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            //2.2根据名称查询转入账户</span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            //2.3转出账户减钱</span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            //2.4转入账户加钱</span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            //2.5更新转出账户</span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line">            int i=1/0;</span><br><span class="line"></span><br><span class="line">            //2.6更新转入账户</span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService service;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        service.transfer(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="number">1000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[十五]事务增强器源码分析</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%BA%94%5D%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BA%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%BA%94%5D%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BA%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上一篇回顾了一下传统的JDBC事务，并分析了Spring解析事务标签，创建事务代理对象的源码，本篇我们来分析在目标方法执行的前后，事务增强器是如何工作的。</p></blockquote><h2 id="1-相关接口"><a href="#1-相关接口" class="headerlink" title="1.相关接口"></a>1.相关接口</h2><blockquote><p>在分析事务增强器的源码之前，先来过一些接口，明确接口的作用和接口之间的关系。</p></blockquote><ol><li><strong>java jdbc规范接口：DataSource、 Connection</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360142615-f53fc7d2-f134-498a-9f77-947bc6c57642.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=u3069b40c&margin=%5Bobject%20Object%5D&name=1%E3%80%81DataSource%E6%8E%A5%E5%8F%A3.jpg&originHeight=710&originWidth=1494&originalType=binary&ratio=1&size=65255&status=done&style=none&taskId=u669f5a8e-a000-4109-8b4a-630fef09f74" alt="1、DataSource接口.jpg"></p><ol start="2"><li><strong>事务属性承载对象：TransactionAttribute</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360207909-4b8e565e-ee03-4dad-b8e2-3e0a21a80508.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=ud4b019d2&margin=%5Bobject%20Object%5D&name=3%E3%80%81TransactionAttribute%20%E7%B1%BB%E5%9B%BE.jpg&originHeight=1942&originWidth=2207&originalType=binary&ratio=1&size=262431&status=done&style=none&taskId=u61fb0bd0-908f-4f1d-9f35-1c799bb720c" alt="3、TransactionAttribute 类图.jpg"></p><ol start="3"><li><strong>事务管理器：TransactionManager、PlatformTransactionManager</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360237800-f3cb0532-0e4b-4bef-a442-0d6c6496c75c.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=uef862b94&margin=%5Bobject%20Object%5D&name=4%E3%80%81TransactionManager.jpg&originHeight=745&originWidth=1004&originalType=binary&ratio=1&size=51062&status=done&style=none&taskId=u420e50cc-21da-458b-b7bc-5ae958065bd" alt="4、TransactionManager.jpg"></p><ol start="4"><li><strong>数据库链接holder：ConnectionHolder</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360258786-1781fcc2-3ead-4a1b-adb0-3adc30cdd88f.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=u76a1124d&margin=%5Bobject%20Object%5D&name=2%E3%80%81ConnectionHolder%E7%B1%BB%E5%9B%BE.jpg&originHeight=1901&originWidth=2994&originalType=binary&ratio=1&size=353075&status=done&style=none&taskId=ua6da747e-be53-44d6-b1c7-8e6d4418e6e" alt="2、ConnectionHolder类图.jpg"></p><ol start="5"><li><strong>Spring抽象出来的事务对象：JdbcTransactionObjectSupport、DataSourceTransactionObject</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360283948-9134b6d0-04e0-4b64-8097-967030ad5c47.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=u78a9d307&margin=%5Bobject%20Object%5D&name=5%E3%80%81Spring%20%E4%BA%8B%E5%8A%A1%E5%AF%B9%E8%B1%A1.jpg&originHeight=1660&originWidth=2606&originalType=binary&ratio=1&size=273625&status=done&style=none&taskId=u291b42e9-8ffe-4db8-aaef-4544541873d" alt="5、Spring 事务对象.jpg"></p><ol start="6"><li><strong>Spring抽象出来的事务状态（包装“事务对象”，做了一些增强）：AbstractTransactionStatus、DefaultTransactionStatus</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360310245-bb29b64c-a37e-45d5-8ca9-561f16a5f73c.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=ucb7e42d8&margin=%5Bobject%20Object%5D&name=6%E3%80%81Spring%20%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E7%B1%BB%E5%9B%BE.jpg&originHeight=2770&originWidth=3365&originalType=binary&ratio=1&size=609316&status=done&style=none&taskId=ue337b7cb-8f15-42b4-8f08-0facfc344d2" alt="6、Spring 事务状态类图.jpg"></p><ol start="7"><li><strong>Spring抽象出来的事务信息（集大成者“txMgr”、“txStatus”、“txAttr”…）：TransactionInfo</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639360331108-2c9255a7-7319-4495-a883-fbe2ea8eecc9.jpeg#clientId=u02bf6af8-51b4-4&from=ui&id=u1e3f258d&margin=%5Bobject%20Object%5D&name=7%E3%80%81TransactionInfo.jpg&originHeight=777&originWidth=2139&originalType=binary&ratio=1&size=125450&status=done&style=none&taskId=u8ca0aa62-2637-4a66-9264-e37dbcd5f7b" alt="7、TransactionInfo.jpg"></p><hr><h2 id="2-事务增强器"><a href="#2-事务增强器" class="headerlink" title="2.事务增强器"></a>2.事务增强器</h2><blockquote><p>接下来我们来分析事务增强器源码。</p></blockquote><p>​</p><p>事务增强器的入口自然是<code>**invoke()**</code>。<br>​</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务增强器的入口</span></span><br><span class="line"><span class="comment"> * invocation：后续事务增强器向后驱动事务拦截器的时候还需要使用它</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line"><span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line"><span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line"><span class="comment">/*需要被事务增强器增强的目标类型</span></span><br><span class="line"><span class="comment">* invocation.getThis()  拿到目标对象</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数一：目标方法</span></span><br><span class="line"><span class="comment">//参数二：目标对象类型</span></span><br><span class="line"><span class="comment">//参数三：</span></span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> CoroutinesInvocationCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> invocation.getThis();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line"><span class="keyword">return</span> invocation.getArguments();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们直接往下看<code>**invokeWithinTransaction()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">Object result;</span><br><span class="line"><span class="keyword">final</span> ThrowableHolder throwableHolder = <span class="keyword">new</span> ThrowableHolder();</span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object retVal = invocation.proceedWithInvocation();</span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line"><span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">throwableHolder.throwable = ex;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getCause();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line"><span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line"><span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line"><span class="keyword">if</span> (throwableHolder.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法的内容很多：<br>​</p><ol><li><p>获取事务注解解析器，解析事务注解</p></li><li><p>获取事务名称</p></li><li><p>判断如果是声明式事务</p><blockquote><ol><li><code>**createTransactionIfNecessary()**</code> 创建一个最上层的事务上下文，包含所有的事务资源</li><li>驱动方法增强逻辑继续往下执行</li><li><code>**completeTransactionAfterThrowing(txInfo, ex)**</code>执行业务代码出现异常时的逻辑</li><li><code>**cleanupTransactionInfo(txInfo)**</code>还原现场逻辑</li><li><code>**commitTransactionAfterReturning(txInfo)**</code>提交事务逻辑</li></ol></blockquote></li><li><p>判断如果是编程式事务，走编程式事务的逻辑….</p></li></ol><p>​</p><p>接下来我们来分析这几个核心逻辑。<br>​</p><h2 id="3-创建最上层的事务上下文"><a href="#3-创建最上层的事务上下文" class="headerlink" title="3.创建最上层的事务上下文"></a>3.创建最上层的事务上下文</h2><p>​</p><p>这里是事务的核心逻辑，涉及到事务嵌套和传播行为，隔离级别。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//进行一个包装，提供事务名</span></span><br><span class="line">txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务状态对象</span></span><br><span class="line">TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//根据事物属性创建事务状态对象，事务状态：一般情况下包装着事务对象；特殊情况 status.Transaction 有可能为空</span></span><br><span class="line"><span class="comment">//方法上的注解为 @Transactional上的注解 传播行为设置为了 NOT_SUPPORTED || NEVER</span></span><br><span class="line"><span class="comment">//具体看一下这个方法</span></span><br><span class="line">status = tm.getTransaction(txAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line"><span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//包装成一个上层的事务上下文对象</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取事务状态对象</li><li>包装成事务上下文对象</li></ol><p>主要的逻辑在这里<code>**getTransaction()**</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务属性信息</span></span><br><span class="line">TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"><span class="comment">//获取事务对象，非常关键</span></span><br><span class="line">Object transaction = doGetTransaction();</span><br><span class="line"><span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"><span class="comment">//条件成立说明当前是重入的事务的情况</span></span><br><span class="line"><span class="comment">//a开启事务 a调用b ，b也加了事务注解  ，开启了事务的情况</span></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line"><span class="comment">//事务重入的分支逻辑 ，这里就涉及到了传播行为</span></span><br><span class="line"><span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line"><span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行到这里说明当前线程没有绑定连接资源，没开启事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用当前事务，没有事务就会抛出异常</span></span><br><span class="line"><span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PROPAGATION_REQUIRED   PROPAGATION_REQUIRES_NEWPROPAGATION_NESTED 则进入</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line"><span class="comment">//挂起了个寂寞，因为线程并没有绑定事务</span></span><br><span class="line">SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//线程未开启事务时，这三种情况都会去开启一个新的事物</span></span><br><span class="line"><span class="comment">//开启事务的逻辑</span></span><br><span class="line"><span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//走到这里是什么情况？ support ||  not support || never</span></span><br><span class="line"><span class="comment">//没有使用新的事务</span></span><br><span class="line"><span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line"><span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line"><span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取事务属性信息&amp;事务对象</li><li>如果是事务重入的逻辑，就做事务重入逻辑的处理</li><li>判断当前事务如果超时了，抛出异常</li><li>PROPAGATION_MANDATORY，有就使用当前事务，没有就抛异常</li><li>PROPAGATION_REQUIRED   PROPAGATION_REQUIRES_NEW    PROPAGATION_NESTED 开启一个新的事物</li><li>support ||  not support || never 没有使用新的事务，不会主动开启</li><li>最终构建事务状态对象</li></ol><p><code>**doGetTransaction() 获取事务对象。**</code><br>​</p><p><code>**handleExistingTransaction()处理事务重入的逻辑。**</code><br>​</p><p><code>**startTransaction()开启新事物的逻辑。**</code><br><strong>​</strong></p><h3 id="3-1-获取事务对象"><a href="#3-1-获取事务对象" class="headerlink" title="3.1 获取事务对象"></a>3.1 获取事务对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//先创建事务对象</span></span><br><span class="line">DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line"><span class="comment">//事务的保存点，这个由事务管理器控制</span></span><br><span class="line">txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line"><span class="comment">//TransactionSynchronizationManager 事务同步管理器</span></span><br><span class="line"><span class="comment">//从tl中获取连接资源，有可能拿到null，也有可能不是null</span></span><br><span class="line"><span class="comment">//什么时候是null，什么时候不是null？</span></span><br><span class="line"><span class="comment">//==null:事务方法a调用了非事务方法b</span></span><br><span class="line"><span class="comment">//!=null:事务方法a调用了事务方法b</span></span><br><span class="line">ConnectionHolder conHolder =</span><br><span class="line">(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line"><span class="comment">//为事务对象赋能，参数二传递的false， 表示当前事务是否新分配了连接资源，而不是和上层事务共享，默认是false，表示共享。</span></span><br><span class="line">txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2处理事务重入"><a href="#3-2处理事务重入" class="headerlink" title="3.2处理事务重入"></a>3.2处理事务重入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">TransactionDefinition definition, <span class="comment">/*事务属性*/</span>Object transaction<span class="comment">/*事务对象*/</span>, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进入这个方法的时候说明当前线程已经持有一个事务了，需要根据新方法的事务注解传播行为，走不同的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PROPAGATION_NEVER：需要抛异常</span></span><br><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PROPAGATION_NOT_SUPPORTED：有事务就挂起当前事务</span></span><br><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Suspending current transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看一下挂起的逻辑</span></span><br><span class="line">Object suspendedResources = suspend(transaction);</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="comment">//将挂起事务返回的 挂起持有者对象(这里面持有上一个事务对象的连接资源和线程上下文参数) 给事务状态对象赋能</span></span><br><span class="line"><span class="comment">//step into 创建一个新的 事务状态对象  ，这里的第二个参数 事务 为null ；表示线程执行到当前方法执行到事务增强的后置处理逻辑的时候</span></span><br><span class="line"><span class="comment">//提交事务的时候会检查事务状态的事务是否有值，如果没有值，Spring就不会做提交的操作。</span></span><br><span class="line"><span class="comment">//参数6：suspendedResources 线程执行到后置处理的逻辑的时候，执行到恢复现场的时候会检查这个参数是否有值，如果有值会进行恢复现场的操作。</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">definition, <span class="keyword">null</span><span class="comment">/*说明当前线程未手动开启事务，连接是直接从数据源拿的，不需要手动提交事务了*/</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PROPAGATION_REQUIRES_NEW：挂起当前事务，开启一个新的事务</span></span><br><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Suspending current transaction, creating new transaction with name [&quot;</span> +</span><br><span class="line">definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//挂起上层事务，新建事务</span></span><br><span class="line">SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//开启一个专属于当前方法的新事务，因为当前方法被挂起的事务执行完当前方法后还要回到上层继续执行，所以</span></span><br><span class="line"><span class="comment">//suspendedResources用来恢复现场</span></span><br><span class="line"><span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line"><span class="keyword">throw</span> beginEx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//嵌套事务的逻辑，如果当前存在事务，则在嵌套事务内执行 ，</span></span><br><span class="line"><span class="comment">//如果当前没有事务，则与required的操作类似</span></span><br><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line"><span class="comment">//默认情况下，spring是不开启这种传播行为的，除非手动开启，所以默认是false。</span></span><br><span class="line"><span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(</span><br><span class="line"><span class="string">&quot;Transaction manager does not allow nested transactions by default - &quot;</span> +</span><br><span class="line"><span class="string">&quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating nested transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般成立，默认是true</span></span><br><span class="line"><span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line"><span class="comment">// 为当前方法创建一个 事务状态对象，共享的上层事务，执行的扩展点是外层的，也不需要挂起事务。</span></span><br><span class="line">DefaultTransactionStatus status =</span><br><span class="line">prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//创建一个保存点 ，重要！！！</span></span><br><span class="line">status.createAndHoldSavepoint();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 开启新事物</span></span><br><span class="line"><span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating in existing transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否需要验证，默认是false</span></span><br><span class="line"><span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line"><span class="keyword">if</span> (currentIsolationLevel == <span class="keyword">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">definition + <span class="string">&quot;] specifies isolation level which is incompatible with existing transaction: &quot;</span> +</span><br><span class="line">(currentIsolationLevel != <span class="keyword">null</span> ?</span><br><span class="line">isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line"><span class="string">&quot;(unknown)&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">definition + <span class="string">&quot;] is not marked as read-only but existing transaction is&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行到这里就剩下 required &amp; supports</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line"><span class="comment">//prepareTransactionStatus（）上面已经分析过了，属于构造器重载逻辑</span></span><br><span class="line"><span class="comment">//参数二：事务对象 -&gt; connHodler 是 doGetTransaction()的时候从西安城上下文内获取的上层事务的连接资源</span></span><br><span class="line"><span class="comment">//参数六：是空，因为我们没有挂起任何事务</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(definition, transaction<span class="comment">/*事务也是使用上层的*/</span>, <span class="keyword">false</span><span class="comment">/*表示并不是一个为自己创建的事务，与上层方法共享*/</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>PROPAGATION_NEVER：需要抛异常</li><li>PROPAGATION_NOT_SUPPORTED：有事务就挂起当前事务</li><li>PROPAGATION_REQUIRES_NEW：挂起当前事务，开启一个新的事务</li><li>嵌套事务的逻辑，如果当前存在事务，则在嵌套事务内执行 ，如果当前没有事务，则与required的操作类似</li><li>required &amp; supports，不会创建事务对象</li><li>最终创建事务状态对象并返回</li></ol><p>​</p><p>看一下创建事务保存点的逻辑，<code>**createAndHoldSavepoint()**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAndHoldSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getSavepointManager()：这里实际上就执行到了jdbc的方法，创建保存点，然后保存。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setSavepoint(getSavepointManager().createSavepoint());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-开启新事物"><a href="#3-3-开启新事物" class="headerlink" title="3.3 开启新事物"></a>3.3 开启新事物</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line"><span class="comment">//一般情况下是true  ，这个值控制是否执行事务的扩展逻辑，这东西有点类似ioc的后置处理器</span></span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line"><span class="comment">//创建默认的事务状态对象，第三个参数为true，会为当前事务分配 连接资源，就是事务是专门为了当前方法开启的</span></span><br><span class="line"><span class="comment">//suspendedResources:表示挂起的事务  ，从上面过来这里实际上是null。</span></span><br><span class="line">DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line"><span class="comment">//开启事务 核心逻辑 ，参数一：事务对象；参数二：事务属性</span></span><br><span class="line">doBegin(transaction, definition);</span><br><span class="line"><span class="comment">//处理TransactionSynchronization</span></span><br><span class="line">prepareSynchronization(status, definition);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑在这里<code>**doBegin()**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line"><span class="comment">//事务对象</span></span><br><span class="line">DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">/*判断当前事务对象是不是有线程资源，没有就会走if的逻辑，有就说明需要为当前方法分为连接资源*/</span></span><br><span class="line"><span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line"><span class="comment">//通过数据源拿到真实的数据库连接</span></span><br><span class="line">Connection newCon = obtainDataSource().getConnection();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="string">&quot;] for JDBC transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重点：将上一步创建的数据库连接包装为ConnectionHolder，并且为事务对象赋能</span></span><br><span class="line"><span class="comment">//参数二很关键，给事务新申请的而连接资源，那么就将事务对象的 newConnectionHolder 设置为true。表示当前目标方法开启了一个自己的事务。</span></span><br><span class="line">txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//获取事务对象商的数据库连接</span></span><br><span class="line">con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"><span class="comment">//修改数据库连接上的一些属性 step into</span></span><br><span class="line">Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line"><span class="comment">//将连接原来的隔离级别保存到事务对象，方便释放连接的时候，设置回原来的状态</span></span><br><span class="line">txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果连接的自动提交是true，一般会成立</span></span><br><span class="line"><span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line"><span class="comment">//因为接下来就是设置自动提交为false，这里设置 must ，表示回头释放的时候要设置回去</span></span><br><span class="line">txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源头，相当于在数据库开启了事务</span></span><br><span class="line">con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没啥实际的东西</span></span><br><span class="line">prepareTransactionalConnection(con, definition);</span><br><span class="line"><span class="comment">//激活holder的事务状态</span></span><br><span class="line">txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//获取超时时间</span></span><br><span class="line"><span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line"><span class="comment">//如果时间不相等，就设置</span></span><br><span class="line"><span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是新开启的事务，分配了新的连接就会成立，这个时候需要将线程和连接进行一个绑定  tl</span></span><br><span class="line"><span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">&quot;Could not open JDBC Connection for transaction&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>判断当前事务对象是不是有线程资源，没有就会走if的逻辑，有就说明需要为当前方法分为连接资源</p></li><li><p>通过数据源拿到真实的数据库连接</p></li><li><p>将上一步创建的数据库连接包装为ConnectionHolder，并且为事务对象赋能</p></li><li><p>获取事务对象商的数据库连接</p></li><li><p>修改数据库连接上的一些属性</p></li><li><p>将连接原来的隔离级别保存到事务对象，方便释放连接的时候，设置回原来的状态</p></li><li><p>如果连接的自动提交是true，改成false</p></li><li><p>激活holder的事务状态</p></li><li><p>设置超时时间</p></li><li><p>如果是新开启的事务，分配了新的连接就会成立，这个时候需要将线程和连接进行一个绑定  tl</p><h2 id="4-异常回滚逻辑"><a href="#4-异常回滚逻辑" class="headerlink" title="4.异常回滚逻辑"></a>4.异常回滚逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo<span class="comment">/*当前事务上下文*/</span>, Throwable ex<span class="comment">/*目标方法抛出的异常信息*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line"><span class="string">&quot;] after exception: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//条件一：一般都是成立的</span></span><br><span class="line"><span class="comment">//条件二：transactionAttribute.rollbackOn(ex) 判断目标方法抛出的异常是否需要回滚，条件成立，说明需要回滚。</span></span><br><span class="line"><span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//如果需要回滚，就会走到事务管理器的回滚逻辑</span></span><br><span class="line">txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus()<span class="comment">/*当前事务状态对象*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);</span><br><span class="line">ex2.initApplicationException(ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//执行到这里，说明当前事务虽然抛出了异常，但是该异常并不会导致整个事务回滚</span></span><br><span class="line"><span class="comment">// We don&#x27;t roll back on this exception.</span></span><br><span class="line"><span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">ex2.initApplicationException(ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断目标方法的异常是否需要回滚？</p></li><li><p>需要，<code>**rollback()**</code>。</p></li><li><p>不需要，<code>**commit()**</code>。</p></li></ol><p>​</p><p>来看一下<code>**rollback()**</code>的逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line"><span class="comment">//看这个逻辑</span></span><br><span class="line">processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看<code>**processRollback()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//事务扩展逻辑的调用点</span></span><br><span class="line">triggerBeforeCompletion(status);</span><br><span class="line"><span class="comment">//说明当前事务是一个内嵌事务 ，当前方法使用的事务是上层的事务，如果有保存点，就回滚到保存点</span></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回滚到保存点的操作</span></span><br><span class="line">status.rollbackToHeldSavepoint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//条件成立：说明当前方法是一个开启了一个新的事物的方法</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委派模式，核心逻辑</span></span><br><span class="line">doRollback(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//执行到这里说明，这个事务不是当前方法开启的 （共享上层事务）|| 当前方法压根没开启事务（not_supports，never, supports）</span></span><br><span class="line"><span class="comment">// Participating in larger transaction</span></span><br><span class="line"><span class="comment">//说的是第一种情况：当前方法共享上层事务</span></span><br><span class="line"><span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line"><span class="comment">//条件一：什么时候成立？当前方法共享上层事务，业务代码强制设置当前整个事务 需要回滚的话，可以通过 设置 status.isLocalRollbackOnly() = true</span></span><br><span class="line"><span class="comment">//条件二：默认是true</span></span><br><span class="line"><span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个共享上层事务的方法可以直接回滚嘛？不行的，需要将回滚的操作交给上层方法来做。</span></span><br><span class="line"><span class="comment">如何交给？设置status.isLocalRollbackOnly()=true，这样的话，线程回到上层事务提交逻辑的时候，会检查该字段，发现是true，就会执行回滚逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这里其实就是设置回滚字段为true  先拿到事务状态对象-&gt; 事务对象 -&gt; 连接持有者 -&gt; 设置rollbackOnly =true。</span></span><br><span class="line">doSetRollbackOnly(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//没有事务</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line"><span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line"><span class="comment">//事务扩展调用点</span></span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务扩展调用点</span></span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line"><span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line"><span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//看这里</span></span><br><span class="line">cleanupAfterCompletion(status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注两个核心的方法<code>**doRollback() &amp; rollbackToHeldSavepoint()**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollbackToHeldSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="comment">//获取事务的保存点</span></span><br><span class="line">Object savepoint = getSavepoint();</span><br><span class="line"><span class="keyword">if</span> (savepoint == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TransactionUsageException(</span><br><span class="line"><span class="string">&quot;Cannot roll back to savepoint - no savepoint associated with current transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回滚到保存点</span></span><br><span class="line">getSavepointManager().rollbackToSavepoint(savepoint);</span><br><span class="line"><span class="comment">//删除保存点</span></span><br><span class="line">getSavepointManager().releaseSavepoint(savepoint);</span><br><span class="line"><span class="comment">//清空保存点</span></span><br><span class="line">setSavepoint(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Rolling back JDBC transaction on Connection [&quot;</span> + con + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">con.rollback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> translateException(<span class="string">&quot;JDBC rollback&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-还原现场逻辑"><a href="#5-还原现场逻辑" class="headerlink" title="5.还原现场逻辑"></a>5.还原现场逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">cleanupTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (txInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//往下看</span></span><br><span class="line">txInfo.restoreThreadLocalStatus();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line"><span class="comment">// Will be null if none was set.</span></span><br><span class="line"><span class="comment">//相当于事务出栈的逻辑</span></span><br><span class="line">transactionInfoHolder.set(<span class="keyword">this</span>.oldTransactionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很简单，就是让当前事务出栈。将栈内的事务设置成上一层事务。</p><h2 id="6-提交事务逻辑"><a href="#6-提交事务逻辑" class="headerlink" title="6.提交事务逻辑"></a>6.提交事务逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用事务管理器的提交事务方法</span></span><br><span class="line">txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()<span class="comment">/*事务状态*/</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了事务管理器的提交事务方法。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line"><span class="comment">//说明是业务强制回滚</span></span><br><span class="line"><span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理回滚</span></span><br><span class="line">processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shouldCommitOnGlobalRollbackOnly() 默认是true</span></span><br><span class="line"><span class="comment">//defStatus.isGlobalRollbackOnly() 其实就是defStatus -&gt;txObject-&gt;connHolder-&gt;rollbackOnly 字段</span></span><br><span class="line"><span class="comment">//下层事务使用上层事务的时候，想回滚，就会设置这个标记</span></span><br><span class="line"><span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">processRollback(defStatus, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理提交</span></span><br><span class="line">processCommit(defStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心的逻辑在<code>**processCommit()**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">prepareForCommit(status);</span><br><span class="line">triggerBeforeCommit(status);</span><br><span class="line">triggerBeforeCompletion(status);</span><br><span class="line">beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line"><span class="comment">//有保存点就清理</span></span><br><span class="line">status.releaseHeldSavepoint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line"><span class="comment">//底层提交事务</span></span><br><span class="line">doCommit(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span></span><br><span class="line"><span class="comment">// marker but still didn&#x27;t get a corresponding exception from commit.</span></span><br><span class="line"><span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line"><span class="string">&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnexpectedRollbackException ex) &#123;</span><br><span class="line"><span class="comment">// can only be caused by doCommit</span></span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionException ex) &#123;</span><br><span class="line"><span class="comment">// can only be caused by doCommit</span></span><br><span class="line"><span class="keyword">if</span> (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">doRollbackOnCommitException(status, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (!beforeCompletionInvoked) &#123;</span><br><span class="line">triggerBeforeCompletion(status);</span><br><span class="line">&#125;</span><br><span class="line">doRollbackOnCommitException(status, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger afterCommit callbacks, with an exception thrown there</span></span><br><span class="line"><span class="comment">// propagated to callers but the transaction still considered as committed.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">triggerAfterCommit(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//清理资源，比如保存点</span></span><br><span class="line">cleanupAfterCompletion(status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，清理保存点，提交事务，执行扩展点逻辑，清理资源。<br>​</p><p>我们来看一下资源的清理<code>**cleanupAfterCompletion(status)**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanupAfterCompletion</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置当前方法的事务状态为完成状态</span></span><br><span class="line">status.setCompleted();</span><br><span class="line"><span class="comment">//清理逻辑 线程上下文变量 &amp; 扩展点注册的东西</span></span><br><span class="line"><span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">TransactionSynchronizationManager.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是开启的新事物，还原现场操作 最重要的就是解绑线程持有的连接</span></span><br><span class="line"><span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">doCleanupAfterCompletion(status.getTransaction());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明当前事务执行的时候，挂起了一个上层的事务</span></span><br><span class="line"><span class="keyword">if</span> (status.getSuspendedResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Resuming suspended transaction after completion of inner transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Object transaction = (status.hasTransaction() ? status.getTransaction() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//唤醒上层的事务</span></span><br><span class="line">resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看几个核心方法<code>**doCleanupAfterCompletion()**</code> &amp; <code>**resume()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the connection holder from the thread, if exposed.</span></span><br><span class="line"><span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset connection.</span></span><br><span class="line">Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (txObject.isMustRestoreAutoCommit()) &#123;</span><br><span class="line">con.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">DataSourceUtils.resetConnectionAfterTransaction(</span><br><span class="line">con, txObject.getPreviousIsolationLevel(), txObject.isReadOnly());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Could not reset JDBC Connection after transaction&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Releasing JDBC Connection [&quot;</span> + con + <span class="string">&quot;] after transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">DataSourceUtils.releaseConnection(con, <span class="keyword">this</span>.dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txObject.getConnectionHolder().clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, <span class="meta">@Nullable</span> SuspendedResourcesHolder resourcesHolder)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourcesHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object suspendedResources = resourcesHolder.suspendedResources;</span><br><span class="line"><span class="keyword">if</span> (suspendedResources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//重新绑定上一个事务的资源</span></span><br><span class="line">doResume(transaction, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;TransactionSynchronization&gt; suspendedSynchronizations = resourcesHolder.suspendedSynchronizations;</span><br><span class="line"><span class="keyword">if</span> (suspendedSynchronizations != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//将线程上下文变量恢复为上一个事务的现场</span></span><br><span class="line">TransactionSynchronizationManager.setActualTransactionActive(resourcesHolder.wasActive);</span><br><span class="line">TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(resourcesHolder.isolationLevel);</span><br><span class="line">TransactionSynchronizationManager.setCurrentTransactionReadOnly(resourcesHolder.readOnly);</span><br><span class="line">TransactionSynchronizationManager.setCurrentTransactionName(resourcesHolder.name);</span><br><span class="line">doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**doResume()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doResume</span><span class="params">(<span class="meta">@Nullable</span> Object transaction, Object suspendedResources)</span> </span>&#123;</span><br><span class="line">TransactionSynchronizationManager.bindResource(obtainDataSource(), suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一个逻辑<code>**doSuspend()**</code>。挂起逻辑<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doSuspend</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line"><span class="comment">//将事务对象的 连接持有者设置为null，不想和上层事务共享连接资源...</span></span><br><span class="line"><span class="comment">//当前方法有可能是不开启事务 || 要开启一个独立的事务</span></span><br><span class="line">txObject.setConnectionHolder(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//解绑线程上的事务，将连接持有者从tl移除掉，这样业务就不会再拿上层事务的连接资源了</span></span><br><span class="line"><span class="keyword">return</span> TransactionSynchronizationManager.unbindResource(obtainDataSource());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-思考与沉淀"><a href="#7-思考与沉淀" class="headerlink" title="7.思考与沉淀"></a>7.思考与沉淀</h2><p>事务的源码有一些琐碎，至此整个事务的源码其实已经分析完了，为了形成一个清晰，完整的链路，我画了一张事务源码的流程图。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639530544687-790faab3-e6f6-49d8-a669-f0788c26d7af.jpeg#clientId=u217fb12b-17ef-4&from=ui&id=uca405042&margin=%5Bobject%20Object%5D&name=%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg&originHeight=4158&originWidth=3633&originalType=binary&ratio=1&size=1387702&status=done&style=none&taskId=u4a346fa1-9066-40f9-a64d-d10377efb13" alt="事务增强流程图.jpg"></p><blockquote><p>我们再来回顾一下事务的流程。<br>@EnableTransactionManagement<br>    利用TransactionManagementConfigurationSelector给容器中会导入组件<br>     给容器中导入了两个类：<br>     1.AutoProxyRegistrar<br>        往容器中导入了一个组件：InfrastructureAdvisorAutoProxyCreator<br>        这个类是什么？利用后置处理器，包装对象，返回一个代理对象（增强器），代理对象执行方法的时候利用拦截器进行调用<br>     2.ProxyTransactionManagementConfiguration<br>        给容器中注册了三个bean：<br>            1.事务增强器 ：advisor切面<br>            2.事务注解解析器：解析事务注解，获取注解信息<br>            3.事务增强器的拦截器：拦截事务相关的advisor切面<br>                ctrl + H 查看类的继承关系：这个类是MethodInterceptor的子类<br>                    在目标方法执行的时候：<br>                        执行拦截器链条<br>                            事务拦截器：<br>                                1.先获取事务相关的属性<br>                                2.在获取事务管理器，如果事先没有添加和执行任何事务管理器，最终会从容器中拿出来一个默认的<br>                                3.执行目标方法<br>                                    1.如果是异常，获取到事务管理器，利用事务管理器进行回滚<br>                                    2.如果是正常执行，利用事务管理器，提交事务。<br>        事务注解解析器和事务增强器的拦截器都包含在事务增强器中，为事务增强器赋能。<br></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639530888585-e2a5d858-bc08-4466-8d4d-39884bcdd635.jpeg#clientId=u217fb12b-17ef-4&from=ui&id=u4122a893&margin=%5Bobject%20Object%5D&name=spring%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81.jpg&originHeight=1441&originWidth=1576&originalType=binary&ratio=1&size=244687&status=done&style=none&taskId=ub378c947-e51b-4ecc-8fba-ebad34b98d5" alt="spring事务源码.jpg"></p><blockquote><p>至此，事务源码分析完成，后续的篇章，我们会去分析web请求的相关流程，我是二十，熟读Java生态圈源码，精通Java高并发编程，欢迎点赞关注。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[十四]事务标签解析&amp;创建代理对象</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E5%9B%9B%5D%E4%BA%8B%E5%8A%A1%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90&amp;%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%8D%81%E5%9B%9B%5D%E4%BA%8B%E5%8A%A1%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90&amp;%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇我们开始分析Spring的事务，在看源码之前，我们先来做一些铺垫。</p></blockquote><h2 id="1-JDBC-amp-Spring事务"><a href="#1-JDBC-amp-Spring事务" class="headerlink" title="1.JDBC&amp;Spring事务"></a>1.JDBC&amp;Spring事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection co = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        co = JDBCUtils.getConnection();</span><br><span class="line">        co.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        String sql1 = <span class="string">&quot;update user_table set balance=balance-? where user=?&quot;</span>;</span><br><span class="line">        String sql2 = <span class="string">&quot;update user_table set balance=balance+? where user=?&quot;</span>;</span><br><span class="line">        update(co,sql1,<span class="number">100</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(10/0);</span></span><br><span class="line">        update(co,sql2,<span class="number">100</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        co.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;转账成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            co.rollback();</span><br><span class="line">            System.out.println(<span class="string">&quot;转账失败！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(co,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection co, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ps = co.prepareStatement(sql);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.closeResource(<span class="keyword">null</span>, ps, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来看一下Spring事务。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639311479914-3b3f60da-3852-4154-9959-209a89b9d75b.png#clientId=u0935c84d-6a8b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=444&id=u89f9a8ea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=888&originWidth=1404&originalType=binary&ratio=1&rotation=0&showTitle=false&size=481526&status=done&style=none&taskId=u31b294bd-9692-421c-96f0-5a55d29b8e8&title=&width=702" alt="image.png"></p><h2 id="2-事务传播行为"><a href="#2-事务传播行为" class="headerlink" title="2.事务传播行为"></a>2.事务传播行为</h2><p>​</p><p>所谓 spring 事务的传播属性，就是定义在存在多个事务同时存在的时候，spring 应该如何处理这些事务的行为。这些属性在 TransactionDefinition 中定义。<br>​</p><table><thead><tr><th>常量名称</th><th>常量解释</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring默认的事务的传播。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>支持当前事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED 属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager 事务管理器起效。</td></tr></tbody></table><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_REQUIRED</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">ServiceB serviceB；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">serviceB.b();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>线程执行到serviceA.a() 方法时，其实是执行的  代理serviceA对象的a方法。</li><li>执行代理serviceA对象的a方法<ol><li>执行a方法的增强逻辑-&gt; 事务增强器 (环绕增强)</li><li>事务增强器会做什么事? 提取事务标签属性</li><li>检查当前线程有没有绑定 conn 数据库连接 资源？ 发现当前线程未绑定（TransactionSync…Manager#resources 是 ThreadLocal&lt;Map&lt;obj,obj&gt;&gt;，检查key:datasource 有没有数据）</li><li>因为未绑定conn资源，所以线程下一步就是 到 datasource.getConnection() 获取一个conn资源</li><li>因为新获取的conn资源的autocommit是true，所以这一步 修改 autocommit 为false，表示手动提交事务，这一步也表示 开启事务（修改conn其它 属性..）</li><li>绑定conn资源到 TransactionSync…Manager#resources，key：datasource</li></ol></li><li>执行事务增强器后面的增强器..</li><li>最后一个advice调用 target的目标方法 a() 方法<ol><li>假设target a方法 需要访问数据库 执行SQL 的话，程序需要获取一个 conn 资源，到哪拿？ DataSourceUtils.getConnection(datasource) 这一步最终会拿到 事务增强器 前置增强逻辑 存放在 TransactionSync..Manager#resources 内的conn 资源</li><li>执行方法a逻辑…可能会执行一些 SQL 语句…</li></ol></li><li>线程执行到这样一行代码：serviceB.b()</li><li>serviceB 它是一个代理对象，因为它也使用了 <a href="/Transactional">@Transactional </a> 注解了，Spring 会为它创建代理的。 </li><li>执行代理serviceB对象的b方法<ol><li>执行b方法的增强逻辑-&gt; 事务增强器（环绕增强）</li><li>事务增强器会做什么事? 提取事务标签属性</li><li>检查当前线程有没有绑定 conn 数据库连接 资源？发现当前线程已经绑定了 conn 数据库连接资源了</li><li>检查事务注解属性，发现自己打的propagation == REQUIRED，所以继续共享 conn 数据库链接资源</li></ol></li><li>执行事务增强器后面的增强器..</li><li>最后一个device调用 target (serviceB)的目标方法 b() 方法<ol><li>假设target b方法 需要访问数据库 执行SQL 的话，程序需要获取一个 conn 资源，到哪拿？ DataSourceUtils.getConnection(datasource) 这一步最终会拿到 代理serviceA对象存放在 TransactionSync..Manager#resources 内的conn 资源</li><li>执行方法b逻辑…可能会执行一些 SQL 语句…</li></ol></li><li>线程继续执行 事务增强器 环绕增强的后置逻辑 （代理serviceB.b() 方法的 后置增强）</li><li>检查发现，serviceB.b() 事务并不是 当前 b方法开启的，所以 基本不做什么事情..</li><li>线程继续回到 目标 serviceA.a() 方法内，继续执行</li><li>执行方法a逻辑…可能会执行一些 SQL 语句…</li><li>线程继续回到 代理 serviceA.a() 方法内，继续执行</li><li>执行a方法的增强逻辑-&gt; 事务增强器 (环绕增强-后置增强逻辑)</li><li>提交事务/回滚事务</li><li>恢复连接状态 （将conn的autocommit 设置回 true…等等）</li><li>清理工作（将绑定的conn资源从TransactionSync…Manager#resources移除）</li><li>conn 连接关闭 （归还连接到datasource）</li></ol><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_SUPPORTS</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">ServiceB serviceB；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">serviceB.b();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line"><span class="meta">@Transactional(propagation = SUPPORTS)</span>   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑和上面完全一致。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Transactional(Propagation = SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在未绑定事务的情况下，去调用serviceA.a() 方法会发生什么呢？</p><ol><li>线程执行到serviceA.a() 方法时，其实是执行的  代理serviceA对象的a方法。</li><li>执行代理serviceA对象的a方法<ol><li>执行a方法的增强逻辑-&gt; 事务增强器 (环绕增强)</li><li>事务增强器会做什么事? 提取事务标签属性</li><li>检查当前线程有没有绑定 conn 数据库连接 资源？ 发现当前线程未绑定（TransactionSync…Manager#resources 是 ThreadLocal&lt;Map&lt;obj,obj&gt;&gt;，检查key:datasource 有没有数据）</li><li>啥也不用做..</li></ol></li><li>执行事务增强器后面的增强器..</li><li>最后一个advice调用 target的目标方法 a() 方法<ol><li>假设target a方法 需要访问数据库 执行SQL 的话，程序需要获取一个 conn 资源，到哪拿？ DataSourceUtils.getConnection(datasource) ，因为事务增强器前置增强逻辑 并没有 向TransactionSync..Manager#resources 内绑定conn资源</li><li>因为 上一步未拿到 conn资源，所以 DataSourceUtils 通过 datasource.getConnection() 获取了一个全新的 conn 资源（注意：conn.autocommit == true,执行的每一条sql 都是一个 独立事务！！）</li><li>执行方法a逻辑…可能会执行一些 SQL 语句…</li></ol></li><li>线程继续执行到代理serviceA对象的a方法 （事务增强器-后置增强逻辑）<ol><li>检查发现 TrasactionSync..Manager#resources 并未绑定任何 conn 资源，所以 这一步啥也不做了…</li></ol></li></ol><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_MANDATORY   很少使用..</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">ServiceB serviceB；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">serviceB.b();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line"><span class="meta">@Transactional(propagation = MANDATORY)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是这样的话，情况和 PROPAGATION_REQUIRED 案例分析 完全一致。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Transactional(Propagation = MANDATORY)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在未绑定事务的情况下，去调用serviceA.a() 方法会发生什么呢？</p><ol><li>线程执行到serviceA.a() 方法时，其实是执行的  代理serviceA对象的a方法。</li><li>执行代理serviceA对象的a方法<ol><li>执行a方法的增强逻辑-&gt; 事务增强器 (环绕增强)</li><li>事务增强器会做什么事? 提取事务标签属性</li><li>检查当前线程有没有绑定 conn 数据库连接 资源？ 发现当前线程未绑定（TransactionSync…Manager#resources 是 ThreadLocal&lt;Map&lt;obj,obj&gt;&gt;，检查key:datasource 有没有数据）</li><li>直接抛出异常…</li></ol></li><li>…</li></ol><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PROPAGATION_REQUIRES_NEW</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">ServiceB serviceB；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">serviceB.b();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line"><span class="meta">@Transactional(propagation = REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li> 线程执行到serviceA.a() 方法时，其实是执行的  代理serviceA对象的a方法。 </li><li> 执行代理serviceA对象的a方法</li><li>执行a方法的增强逻辑-&gt; 事务增强器 (环绕增强)</li><li>事务增强器会做什么事? 提取事务标签属性</li><li>检查当前线程有没有绑定 conn 数据库连接 资源？ 发现当前线程未绑定（TransactionSync…Manager#resources 是 ThreadLocal&lt;Map&lt;obj,obj&gt;&gt;，检查key:datasource 有没有数据）</li><li>因为未绑定conn资源，所以线程下一步就是 到 datasource.getConnection() 获取一个conn资源</li><li>因为新获取的conn资源的autocommit是true，所以这一步 修改 autocommit 为false，表示手动提交事务，这一步也表示 开启事务（修改conn其它 属性..）</li><li>绑定conn资源到 TransactionSync…Manager#resources，key：datasource </li><li> 执行事务增强器后面的增强器.. </li><li> 最后一个advice调用 target的目标方法 a() 方法</li><li>假设target a方法 需要访问数据库 执行SQL 的话，程序需要获取一个 conn 资源，到哪拿？ DataSourceUtils.getConnection(datasource) 这一步最终会拿到 事务增强器 前置增强逻辑 存放在 TransactionSync..Manager#resources 内的conn 资源</li><li>执行方法a逻辑…可能会执行一些 SQL 语句… </li><li> 线程执行到这样一行代码：serviceB.b() </li><li> serviceB 它是一个代理对象，因为它也使用了 <a href="/Transactional">@Transactional </a> 注解了，Spring 会为它创建代理的。  </li><li> 执行代理serviceB对象的b方法</li><li>执行b方法的增强逻辑-&gt; 事务增强器（环绕增强）</li><li>事务增强器会做什么事? 提取事务标签属性</li><li>检查发现当前线程已经绑定了conn资源（并且手动开启了事务..），又发现 当前方法的 传播行为：REQUIRES_NEW ，需要开启一个新的事务..</li><li>将已经绑定的conn资源 保存到 suspand 变量内</li><li>因为 REQUIRES_NEW 不会和上层共享同一个事务，所以这一步 又到 datasource.getConnection() 获取了一个全新的 conn 数据库连接资源</li><li>因为新获取的conn资源的autocommit是true，所以这一步 修改 autocommit 为false，表示手动提交事务，这一步也表示 开启事务（修改conn其它 属性..）</li><li>绑定conn资源到 TransactionSync…Manager#resources，key：datasource </li><li> 执行事务增强器后面的增强器.. </li><li> 最后一个advice调用 target （serviceB）的目标方法 b() 方法</li><li>假设target b方法 需要访问数据库 执行SQL 的话，程序需要获取一个 conn 资源，到哪拿？ DataSourceUtils.getConnection(datasource) 这一步最终会拿到 事务增强器 前置增强逻辑 存放在 TransactionSync..Manager#resources 内的<br>conn 资源</li><li>执行方法a逻辑…可能会执行一些 SQL 语句… </li><li> 线程继续执行 事务增强器 环绕增强的后置逻辑 （代理serviceB.b() 方法的 后置增强）</li><li>检查发现，serviceB.b() 事务是 b方法开启的，所以 需要做一些事情了</li><li>执行b方法的增强逻辑-&gt; 事务增强器 (环绕增强-后置增强逻辑)</li><li>提交事务/回滚事务</li><li>恢复连接状态 （将conn的autocommit 设置回 true…等等）</li><li>清理工作（将绑定的conn资源从TransactionSync…Manager#resources移除）</li><li>conn 连接关闭 （归还连接到datasource）</li><li>检查suspand 发现 该变量有值，需要执行 恢复现场的工作 resume() </li><li> 恢复现场</li><li>将suspand 挂起的 conn 资源再次  绑定到 TransactionSync…Manager#resources 内，方便 serviceA 继续使用它的conn资源 （它自己的事务） </li><li> 线程继续回到 serviceA.a() 方法内</li><li>继续执行一些sql …注意 这里它使用的 conn 是 serviceA 申请的 conn </li><li> 线程继续执行 事务增强器 环绕增强的后置逻辑 （代理serviceA.a() 方法的 后置增强）</li><li>检查发现，serviceA.a() 事务是 a方法开启的，所以 需要做一些事情了</li><li>执行a方法的增强逻辑-&gt; 事务增强器 (环绕增强-后置增强逻辑)</li><li>提交事务/回滚事务</li><li>恢复连接状态 （将conn的autocommit 设置回 true…等等）</li><li>清理工作（将绑定的conn资源从TransactionSync…Manager#resources移除）</li><li>conn 连接关闭 （归还连接到datasource） </li></ol><hr><h2 id="3-隔离级别"><a href="#3-隔离级别" class="headerlink" title="3.隔离级别"></a>3.隔离级别</h2><h3 id="3-1-Mysql"><a href="#3-1-Mysql" class="headerlink" title="3.1 Mysql"></a>3.1 Mysql</h3><table><thead><tr><th>隔离级别</th><th>隔离级别的值</th><th>导致的问题</th></tr></thead><tbody><tr><td>Read-Uncommitted</td><td>0</td><td>导致脏读</td></tr><tr><td>Read-Committed</td><td>1</td><td>避免脏读，允许不可重复读和幻读</td></tr><tr><td>Repeatable-Read</td><td>2</td><td>避免脏读，不可重复读，允许幻读</td></tr><tr><td>Serializable</td><td>3</td><td>串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重</td></tr></tbody></table><ol><li>脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。</li></ol><ol start="2"><li>不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。</li></ol><ol start="3"><li>幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。</li></ol><p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB。</strong><br><strong>​</strong></p><h3 id="3-2-Spring"><a href="#3-2-Spring" class="headerlink" title="3.2 Spring"></a>3.2 Spring</h3><table><thead><tr><th>常量</th><th>解释</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</td></tr></tbody></table><h2 id="4-事务嵌套"><a href="#4-事务嵌套" class="headerlink" title="4.事务嵌套"></a>4.事务嵌套</h2><p>这里内容在实际开发中比较重要，因此我们再来做一下简单的回顾。</p><p>假设外层事务 Service A 的 Method A() 调用 内层 Service B 的 Method B()</p><p><strong>PROPAGATION_REQUIRED(Spring 默认)</strong></p><p>如果 ServiceB.MethodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行ServiceA.MethodA() 的时候 Spring 已经起了事务，这时调用 ServiceB.MethodB()，ServiceB.MethodB() 看到自己已经运行在 ServiceA.MethodA() 的事务内部，就不再起新的事务。</p><p>假如 ServiceB.MethodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。</p><p>这样，在 ServiceA.MethodA() 或者在 ServiceB.MethodB() 内的任何地方出现异常，事务都会被回滚。</p><p><strong>PROPAGATION_REQUIRES_NEW</strong></p><p>比如我们设计 ServiceA.MethodA() 的事务级别为 PROPAGATION_REQUIRED，ServiceB.MethodB() 的事务级别为 PROPAGATION_REQUIRES_NEW。那么当执行到 ServiceB.MethodB() 的时候，ServiceA.MethodA() 所在的事务就会挂起，ServiceB.MethodB() 会起一个新的事务，等待 ServiceB.MethodB() 的事务完成以后，它才继续执行。</p><p>他 与 PROPAGATION_REQUIRED 的 事 务 区 别 在 于 事 务 的 回 滚 程 度 了 。 因 为ServiceB.MethodB() 是新起一个事务，那么就是存在两个不同的事务。如果ServiceB.MethodB() 已 经 提 交 ， 那 么 ServiceA.MethodA() 失 败 回 滚 ，ServiceB.MethodB() 是不会回滚的。如果 ServiceB.MethodB() 失败回滚，如果他抛出的异常被 ServiceA.MethodA() 捕获，ServiceA.MethodA() 事务仍然可能提交(主要看 B 抛出的异常是不是 A 会回滚的异常)。</p><p><strong>PROPAGATION_SUPPORTS</strong><br>假设 ServiceB.MethodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到ServiceB.MethodB()时，如果发现 ServiceA.MethodA()已经开启了一个事务，则加入当前的事务，如果发现 ServiceA.MethodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。</p><p><strong>PROPAGATION_NESTED</strong><br>现 在 的 情 况 就 变 得 比 较 复 杂 了 , ServiceB.MethodB() 的 事 务 属 性 被 配 置 为PROPAGATION_NESTED, 此时两者之间又将如何协作呢?</p><p>ServiceB.MethodB() 如果 rollback, 那么内部事务(即 ServiceB.MethodB()) 将回滚到它执行前的 SavePoint而外部事务(即 ServiceA.MethodA()) 可以有以下两种处理方式:</p><ol><li>捕获异常，执行异常分支逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MethodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceB.MethodB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SomeException) &#123;</span><br><span class="line">    <span class="comment">// 执行其他业务, 如 ServiceC.MethodC();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这 种 方 式 也 是 嵌 套 事 务 最 有 价 值 的 地 方 , 它 起 到 了 分 支 执 行 的 效 果 , 如 果ServiceB.MethodB()失败, 那么执行 ServiceC.MethodC(), 而 ServiceB.MethodB()已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过),这 种 特 性 可 以 用 在 某 些 特 殊 的 业 务 中 , 而 PROPAGATION_REQUIRED 和PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。</p><ol start="2"><li>外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB.MethodB())rollback, 那么首先 ServiceB.MethodB() 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA.MethodA()) 将根据具体的配置决定自己是commit 还是 rollback。</li></ol><p>​</p><blockquote><p>接下来我们来看事务的源码。</p></blockquote><h2 id="5-Spring事务标签解析"><a href="#5-Spring事务标签解析" class="headerlink" title="5.Spring事务标签解析"></a>5.Spring事务标签解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;url&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- spring中基于注解 的声明式事务控制配置步骤</span><br><span class="line">    <span class="number">1</span>、配置事务管理器</span><br><span class="line">    <span class="number">2</span>、开启spring对注解事务的支持</span><br><span class="line">    <span class="number">3</span>、在需要事务支持的地方使用<span class="meta">@Transactional</span>注解</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;transactionManager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 开启spring对注解事务的支持--&gt;</span><br><span class="line">&lt;tx:annotation-driven&gt;&lt;/tx:annotation-driven&gt;</span><br></pre></td></tr></table></figure><p>这是开启Spring事务需要在配置文件写的一些配置标签，主要就是最后一行，开启事务功能。<br>​</p><p>这个标签不是Spring的原生标签，所以需要额外的解析器来解析。在spring-tx包下的META-INF目录下，有一个spring.handlers配置文件，里面注册了事务标签的解析器。<br>​</p><p>我们来看下这个解析器。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类就是事务标签解析器，注意这里有一个init方法，加载一些当前解析器能够解析的bean标签，给解析器赋能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION_MANAGER_ATTRIBUTE = <span class="string">&quot;transaction-manager&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = <span class="string">&quot;transactionManager&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getTransactionManagerName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?</span><br><span class="line">element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;advice&quot;</span>, <span class="keyword">new</span> TxAdviceBeanDefinitionParser());</span><br><span class="line"><span class="comment">//拉看这个标签的解析逻辑</span></span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;annotation-driven&quot;</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(<span class="string">&quot;jta-transaction-manager&quot;</span>, <span class="keyword">new</span> JtaTransactionManagerBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要来看下<code>**AnnotationDrivenBeanDefinitionParser**</code>解析器的解析标签逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//向Spring容器注册一个BD：TransactionalEventListenerFactory</span></span><br><span class="line">registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line"><span class="comment">//从标签里面获取mode属性，一般我们不配置这个属性，所以走else的逻辑</span></span><br><span class="line">String mode = element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line"><span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">registerTransactionAspect(element, parserContext);</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;jakarta.transaction.Transactional&quot;</span>, getClass().getClassLoader())) &#123;</span><br><span class="line">registerJtaTransactionAspect(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// mode=&quot;proxy&quot;  往下走</span></span><br><span class="line">AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下走。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//向Spring容器中注册BD -&gt; InfrastructureAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="comment">//BD的名称：internalAutoProxyCreator ，相当于往容器中加入了AOP的组件</span></span><br><span class="line">AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line"><span class="comment">//事务切面的名称 ：org.springframework.transaction.config.internalTransactionAdvisor</span></span><br><span class="line">String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;</span><br><span class="line"><span class="comment">//如果容器中没有事务切面,就往容器中注册一个事务切面</span></span><br><span class="line"><span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) &#123;</span><br><span class="line"><span class="comment">//把标签包装成一个对象</span></span><br><span class="line">Object eleSource = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the TransactionAttributeSource definition.</span></span><br><span class="line">RootBeanDefinition sourceDef = <span class="keyword">new</span> RootBeanDefinition(</span><br><span class="line"><span class="string">&quot;org.springframework.transaction.annotation.AnnotationTransactionAttributeSource&quot;</span>);</span><br><span class="line">sourceDef.setSource(eleSource);</span><br><span class="line">sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the TransactionInterceptor definition. 事务增强器</span></span><br><span class="line">RootBeanDefinition interceptorDef = <span class="keyword">new</span> RootBeanDefinition(TransactionInterceptor.class);</span><br><span class="line">interceptorDef.setSource(eleSource);</span><br><span class="line">interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"><span class="comment">//往bd中注册信息 事务管理器</span></span><br><span class="line">registerTransactionManager(element, interceptorDef);</span><br><span class="line"><span class="comment">//往bd里面注册事务属性信息</span></span><br><span class="line">interceptorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(sourceName));</span><br><span class="line">String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the TransactionAttributeSourceAdvisor definition.</span></span><br><span class="line">RootBeanDefinition advisorDef = <span class="keyword">new</span> RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);</span><br><span class="line">advisorDef.setSource(eleSource);</span><br><span class="line">advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">advisorDef.getPropertyValues().add(<span class="string">&quot;transactionAttributeSource&quot;</span>, <span class="keyword">new</span> RuntimeBeanReference(sourceName));</span><br><span class="line">advisorDef.getPropertyValues().add(<span class="string">&quot;adviceBeanName&quot;</span>, interceptorName);</span><br><span class="line"><span class="keyword">if</span> (element.hasAttribute(<span class="string">&quot;order&quot;</span>)) &#123;</span><br><span class="line">advisorDef.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, element.getAttribute(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);</span><br><span class="line"></span><br><span class="line">CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), eleSource);</span><br><span class="line">compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(sourceDef, sourceName));</span><br><span class="line">compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(interceptorDef, interceptorName));</span><br><span class="line">compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(advisorDef, txAdvisorBeanName));</span><br><span class="line">parserContext.registerComponent(compositeDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是往容器中注册了几个bean。我们通过一张图来看一下。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639320096877-430edcf8-e4d5-4a58-893c-995045b57993.png#clientId=u0935c84d-6a8b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=503&id=u4cb9d029&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1006&originWidth=2454&originalType=binary&ratio=1&rotation=0&showTitle=false&size=846386&status=done&style=none&taskId=ufff47c36-5a84-454f-be19-b52d587d5c6&title=&width=1227" alt="image.png"><br>​</p><h2 id="6-创建代理对象"><a href="#6-创建代理对象" class="headerlink" title="6.创建代理对象"></a>6.创建代理对象</h2><p>上面说到，解析事务标签的时候会往Spring容器中注入一个类<code>**InfrastructureAdvisorAutoProxyCreator**</code>。我们来看一下这个类的继承关系。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639323805778-1e8cbdc6-75f6-49b2-88ad-a1a09a3b524b.png#clientId=u0a6287cf-05aa-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=532&id=ua8527b84&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1064&originWidth=3274&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219119&status=done&style=none&taskId=u8153d4d1-81db-4f43-994e-883b951866f&title=&width=1637" alt="image.png"><br>这个是是一个抽象自动代理创建器，也是一个后置处理器。这里就和AOP的逻辑关联起来了。我们直接看AOP创建代理对象的后置处理器的方法。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean<span class="comment">/*spring容器完全初始化完毕的对象*/</span>, String beanName<span class="comment">/*bean名称*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*获取缓存建：大部分情况下都是beanName，如果是工厂bean对象，也有可能是 &amp; */</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">/*防止重复代理某个bean实例*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">/*判断是否需要包装 AOP操作的入口*/</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑前面已经解释过，直接往下走。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*条件一般不成立，因为正常情况下很少使用TargetSourceCreator 去创建对象。BeforeInstantiation阶段*/</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果当前bean对象不需要增强处理</span></span><br><span class="line"><span class="comment"> * 判断是在BeforeInstantiation阶段阶段做的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 条件一：判断当前bean类型是否是基础框架类型的实例，不能被增强</span></span><br><span class="line"><span class="comment"> * 条件二：判断当前beanname是否是是忽略的bean，不需要被增强</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="comment">//进入这里表示不需要增强</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="comment">//直接返回上层</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找适合当前类的通知 非常重要 ！！！</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//判断当前查询出来的通知是不是空，如果不是空，说明走增强逻辑</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="comment">//记得放在缓存true</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">/*真正去创建代理对象*/</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass()<span class="comment">/*目标对象*/</span>, beanName<span class="comment">/*beanName*/</span>, specificInterceptors<span class="comment">/*匹配当前目标对象class的拦截器*/</span>,</span><br><span class="line"><span class="keyword">new</span> SingletonTargetSource(bean)<span class="comment">/*把当前bean进行了一个封装*/</span>);</span><br><span class="line"><span class="comment">//保存代理对象类型</span></span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="comment">//返回代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行到这里说明没查到这个类相关的通知，没法增强，直接返回</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下<code>**getAdvicesAndAdvisorsForBean()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">//查询合适当前类型的通知</span></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="comment">//通知为空返回空</span></span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则转成一个数组返回</span></span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*获取到当前项目里面所有可以使用的增强器*/</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">/*将上一步获取到的全部增强器进行过滤，留下适合当前类的*/</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line"><span class="comment">/*在这一步，会在index为0 的位置添加一个增强器*/</span></span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看过滤增强器的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*如果这个类全部可用的增强器为空，直接返回*/</span></span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配当前class 的 advisor 信息</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//不考虑音阶增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设 值为false</span></span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前增强器是否匹配class</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的都是匹配当前class的advisor</span></span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这个重载的方法<code>**canApply()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大多数情况下是走这里，因为创建的增强器是  InstantiationModelAwarePointcutAdvisorImpl</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring事务导入到容器中的增强器是哪一个呢？回顾一下上面的图，<code>**BeanFactoryTransactionAttributeSourceAdvisor**</code>。<br>​</p><p>我们直接来到这个bean。<br>​</p><p>这个时候我们在来看<code>**canApply()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断当前切点是否匹配当前class*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//条件成立：说明当前class就不满足切点的定义  ，直接返回，因为后面是判断方法匹配的逻辑，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务逻辑：BeanFactoryTransactionAttributeSourceAdvisor 里面有一个连接点。这个时候获取到的实际上就是事务增强器里面的连接点的方法匹配器。</span></span><br><span class="line"><span class="comment">//其他逻辑不用管，我们直接跳到方法匹配的逻辑。</span></span><br><span class="line"><span class="comment">//获取方法匹配器</span></span><br><span class="line">MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line"><span class="comment">//如果是true，直接返回true，因为true不做判断，直接匹配所有方法</span></span><br><span class="line"><span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line"><span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//skip</span></span><br><span class="line">IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存当前目标对象clazz + 目标对象 父类 爷爷类 ... 的接口 + 自身实现的接口</span></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//判断目标对象是不是代理对象，确保classes内存储的数据包括目标对象的class，而不是代理类class</span></span><br><span class="line"><span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"><span class="comment">//遍历classes，获取当前class定义的method，整个for循环会检查当前目标clazz 上级接口的所有方法</span></span><br><span class="line"><span class="comment">//看看是否会被方法匹配器匹配，如果有一个方法匹配成功，就说明目标class需要被AOP代理增强</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="comment">//事务注释：方法匹配：TransactionAttributeSourcePointcut 的 方法实现。</span></span><br><span class="line"><span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行到这里，说明当前类的所有方法都没有匹配成功，当前类不需要AOP的增强。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用到<code>**TransactionAttributeSourcePointcut**</code>类的<code>**matches()**</code>。我们来看一下。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line"><span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看 <code>**getTransactionAttribute()**</code>，  来到了  <code>**AbstractFallbackTransactionAttributeSource**</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缓存的逻辑</span></span><br><span class="line"><span class="comment">// First, see if we have a cached value.</span></span><br><span class="line">Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Value will either be canonical value indicating there is no transaction attribute,</span></span><br><span class="line"><span class="comment">// or an actual transaction attribute.</span></span><br><span class="line"><span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//真正去执行的逻辑。</span></span><br><span class="line"><span class="comment">// We need to work it out. 解析事务属性注解，获取事务属性信息。</span></span><br><span class="line">TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line"><span class="comment">// Put it in the cache.  加缓存。</span></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line"><span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">DefaultTransactionAttribute dta = (DefaultTransactionAttribute) txAttr;</span><br><span class="line">dta.setDescriptor(methodIdentification);</span><br><span class="line">dta.resolveAttributeStrings(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Adding transactional method &#x27;&quot;</span> + methodIdentification + <span class="string">&quot;&#x27; with attribute: &quot;</span> + txAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找事物注解信息并加缓存。<br>​</p><p><code>**computeTransactionAttribute()**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line"><span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取目标类上的method，因为@Transactional注解可能是标记在接口上的</span></span><br><span class="line"><span class="comment">// The method may be on an interface, but we need attributes from the target class.</span></span><br><span class="line"><span class="comment">// If the target class is null, the method will be unchanged.</span></span><br><span class="line">Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取目标类上的方法的注解信息。</span></span><br><span class="line"><span class="comment">// First try is the method in the target class.</span></span><br><span class="line">TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//获取到了就返回</span></span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Second try is the transaction attribute on the target class.</span></span><br><span class="line"><span class="comment">//到实现类的方法上去找</span></span><br><span class="line">txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line"><span class="comment">//找到则返回</span></span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时说明注解是打在了接口上，到目标接口上提取method信息</span></span><br><span class="line"><span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fallback is to look at the original method.</span></span><br><span class="line">txAttr = findTransactionAttribute(method);</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//找到则返回</span></span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时说明注解可能打在了目标接口的方法上，到接口的方法上提取注解信息</span></span><br><span class="line"><span class="comment">// Last fallback is the class of the original method.</span></span><br><span class="line">txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line"><span class="keyword">return</span> txAttr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//说明method并没有定义事务注解信息，不需要事务支持。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要逻辑就是获取到类，接口或者方法上的事务注解信息。我们来看一下具体的解析事务注解的逻辑。<code>**findTransactionAttribute()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">findTransactionAttribute</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看这个类的属性，有一个事务注解解析器集合，这个集合是何时赋值的呢？<br>是在创建这个类的时候，看构造器，我们只需要关注 <code>**SpringTransactionAnnotationParser**</code> 整一个解析器即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TransactionAnnotationParser&gt; annotationParsers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">(<span class="keyword">boolean</span> publicMethodsOnly)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line"><span class="keyword">if</span> (jta12Present || ejb3Present) &#123;</span><br><span class="line"><span class="keyword">this</span>.annotationParsers = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line"><span class="keyword">if</span> (jta12Present) &#123;</span><br><span class="line"><span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> JtaTransactionAnnotationParser());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ejb3Present) &#123;</span><br><span class="line"><span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> Ejb3TransactionAnnotationParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再回到提取事务注解信息的逻辑。<code>**determineTransactionAttribute()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line"><span class="comment">//我们来看 SpringTransactionAnnotationParser 里面的逻辑</span></span><br><span class="line">TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line"><span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> attr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是循环所有的解析器，提取解析事务注解信息，我们来看 <code>**SpringTransactionAnnotationParser**</code> 里面的逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line"><span class="comment">//从类或者方法上查找@Transactional这个注解</span></span><br><span class="line">AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">element, Transactional.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//解析注解阶段为事务属性TransactionAttribute</span></span><br><span class="line"><span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是从类或者方法上查找到注解，然后通过<code>**parseTransactionAnnotation()**</code>解析注解为<code>**TransactionAttribute**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析事务注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line"></span><br><span class="line">Propagation propagation = attributes.getEnum(<span class="string">&quot;propagation&quot;</span>);</span><br><span class="line">rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">Isolation isolation = attributes.getEnum(<span class="string">&quot;isolation&quot;</span>);</span><br><span class="line">rbta.setIsolationLevel(isolation.value());</span><br><span class="line"></span><br><span class="line">rbta.setTimeout(attributes.getNumber(<span class="string">&quot;timeout&quot;</span>).intValue());</span><br><span class="line">String timeoutString = attributes.getString(<span class="string">&quot;timeoutString&quot;</span>);</span><br><span class="line">Assert.isTrue(!StringUtils.hasText(timeoutString) || rbta.getTimeout() &lt; <span class="number">0</span>,</span><br><span class="line"><span class="string">&quot;Specify &#x27;timeout&#x27; or &#x27;timeoutString&#x27;, not both&quot;</span>);</span><br><span class="line">rbta.setTimeoutString(timeoutString);</span><br><span class="line"></span><br><span class="line">rbta.setReadOnly(attributes.getBoolean(<span class="string">&quot;readOnly&quot;</span>));</span><br><span class="line">rbta.setQualifier(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">rbta.setLabels(Arrays.asList(attributes.getStringArray(<span class="string">&quot;label&quot;</span>)));</span><br><span class="line"></span><br><span class="line">List&lt;RollbackRuleAttribute&gt; rollbackRules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;rollbackFor&quot;</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;rollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> RollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; rbRule : attributes.getClassArray(<span class="string">&quot;noRollbackFor&quot;</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String rbRule : attributes.getStringArray(<span class="string">&quot;noRollbackForClassName&quot;</span>)) &#123;</span><br><span class="line">rollbackRules.add(<span class="keyword">new</span> NoRollbackRuleAttribute(rbRule));</span><br><span class="line">&#125;</span><br><span class="line">rbta.setRollbackRules(rollbackRules);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是具体解析事务注解信息的逻辑。<br>​</p><blockquote><p>阶段性梳理一下，这里我们匹配到了事务相关的增强器，接下来我们要去为当前加了Transaction注解的bean创建代理对象。</p></blockquote><blockquote><p>至此，我们分析完了解析事务标签，创建打了Transaction注解的bean创建代理对象的源码流程分析，接下来就是分析，需要被事务增强的目标方法执行过程中，事务增强器是如何对目标方法加上事务的。</p></blockquote><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[十三]Ioc整合Aop创建代理对象</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%89%5DIoc%E6%95%B4%E5%90%88Aop%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%89%5DIoc%E6%95%B4%E5%90%88Aop%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>临时补充一篇内容，昨晚忽然看源码发现忽略了这Ioc整合Aop创建代理对象的过程，本篇我们来补充一下核心的逻辑。</p></blockquote><h2 id="1-解析xml标签"><a href="#1-解析xml标签" class="headerlink" title="1.解析xml标签"></a>1.解析xml标签</h2><p>之前我们说过了注解版开发AOP功能，如果是xml版的需要在配置文件配置<code>_**&lt;aop:aspectj-autoproxy /&gt;**_</code>。<br>​</p><p>我们先找到这个标签的解析器<code>**AspectJAutoProxyBeanDefinitionParser**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 包装 &lt;aop:aspectj-autoproxy /&gt;标签数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parserContext 它持有一个 readerContext  ，    readerContext里面 有持有一个 registry ，也就是 bf。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*解析标签，创建一个自动代理创建器*/</span></span><br><span class="line">AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">extendBeanDefinition(element, parserContext);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>这个方法就是解析标签，创建抽象自动代理创建器，注册到容器中，是不是和前面的流程很像？<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*拿到 bf ， 包装标签*/</span></span><br><span class="line">BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"><span class="comment">/*执行到这里，spring容器中已经有了aop相关的bd信息，接下来的逻辑属于扩展 。</span></span><br><span class="line"><span class="comment">* 这里的主要逻辑就是对aop标签上可配置的属性进行解析。*/</span></span><br><span class="line">useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下解析标签属性的逻辑<code>**useClassProxyingIfNecessary()**</code> &amp; <code>**registerComponentIfNecessary()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Element sourceElement)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*属于扩展逻辑，判断aop的标签上有没有配置proxy-target-class属性，这个属性默认是关闭的，如果开启的话，目标对象不管有没有实现接口，都会使用cglib的代理方式*/</span></span><br><span class="line"><span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">boolean</span> proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line"><span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line"><span class="comment">/*这里的逻辑就是假如你配置了这个属性是true，就会拿到bd信息，往bd信息里面在添加一个属性，设置成true。*/</span></span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*exposeProxy：也是可以在aop标签配置的属性，就是判断当前代理对象是否要暴露在aop上下文，方便代理对象内部的真实对象拿到代理对象。*/</span></span><br><span class="line"><span class="keyword">boolean</span> exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line"><span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要就是决定用哪种方式创建代理对象。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerComponentIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> BeanDefinition beanDefinition, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">parserContext.registerComponent(</span><br><span class="line"><span class="keyword">new</span> BeanComponentDefinition(beanDefinition, AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是判断是不是需要将抽象自动代理创建器注册到解析器的上下文。<br>​</p><h2 id="2-抽象自动代理创建器"><a href="#2-抽象自动代理创建器" class="headerlink" title="2.抽象自动代理创建器"></a>2.抽象自动代理创建器</h2><p>我们接下来回归主线，来看<code>**AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary()**</code>的逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数一：固定类型</span></span><br><span class="line"><span class="comment">* 参数二：spring容器</span></span><br><span class="line"><span class="comment">* 参数三：标签</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下跟<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*判断容器里面有没有这个名字的bean，如果有的话就拿出来*/</span></span><br><span class="line"><span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line"><span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line"><span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line"><span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line"><span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*通常情况下，其实走不到上面的逻辑，除非自己手写了aop*/</span></span><br><span class="line"><span class="comment">/*创建一个bd，并且注册到容器中*/</span></span><br><span class="line">RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">beanDefinition.setSource(source);</span><br><span class="line">beanDefinition.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line"><span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是给容器中注册了一个<code>**beanDefinition**</code>，这个<code>**beanDefinition**</code>就是<code>**AbstractAutoProxyCreator**</code>。<br>​</p><p>前面在注解流程里面我们分析了，Ioc在通过<code>**getBean()**</code>创建单实例bean对象的时候，执行到<code>**initializeBean()**</code>的时候，会执行bean的后置处理器，我们再来回顾一下这里的逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 初始化给定的 bean 实例，应用工厂回调以及 init 方法和 bean 后处理器。</span></span><br><span class="line"><span class="comment">* 从createBean调用传统定义的 bean，从initializeBean调用现有 bean 实例。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*检查当前bean是否实现了aware接口，再具体判断实现的哪个aware接口，做一些赋能操作。*/</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">/*初始化之前，后置处理器的调用点*/</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*执行初始化方法*/</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">/*初始化后的后置处理器执行点*/</span></span><br><span class="line"><span class="comment">/*典型应用：AOP的具体实现*/</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常都是在执行<code>**invokeInitMethods()**</code>,之后的后置处理器的after方法返回一个代理对象，我们继续往下走。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">* 一旦某个后置处理器返回的结果为空</span></span><br><span class="line"><span class="comment">* 就返回上一个后置处理器的结果，后面的后置处理器方法不在执行*/</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是后处理器的逻辑。在这里就会调用到我们前面注册到容器中的<code>**AbstractAutoProxyCreator**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean<span class="comment">/*spring容器完全初始化完毕的对象*/</span>, String beanName<span class="comment">/*bean名称*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*获取缓存建：大部分情况下都是beanName，如果是工厂bean对象，也有可能是 &amp; */</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">/*防止重复代理某个bean实例*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">/*判断是否需要包装 AOP操作的入口*/</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构建缓存key</li><li>判断如果<code>**earlyProxyReferences**</code>里面移除的对象和当前完全初始化好的对象不是同一个，说明什么？说明有其他地方通过<code>**FactoryBean**</code>的<code>**getObject()**</code>创建了当前bean的代理对象，所以需要移除。</li><li>判断是否需要包装<code>**wrapIfNecessary(bean, beanName, cacheKey)**</code></li></ol><p><strong>​</strong></p><h2 id="3-earlyProxyReferences"><a href="#3-earlyProxyReferences" class="headerlink" title="3.earlyProxyReferences"></a>3.earlyProxyReferences</h2><p>我们先来分析下这个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>假设A，B两个类现在发生了循环依赖，创建A的时候发现需要B对象，然后<strong>A会把自己的代理对象放到三级缓存</strong>，然后递归去创建B对象。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</span><br></pre></td></tr></table></figure><p>就是这行代码，前面我们是有讲过的，然后我们继续往下跟。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取早期bean实例对象的引用，用来解决循环依赖。</span></span><br><span class="line"><span class="comment"> * 这里说明了一个问题：为什么是三级缓存不是二级缓存。</span></span><br><span class="line"><span class="comment"> * Obtain a reference for early access to the specified bean,</span></span><br><span class="line"><span class="comment"> * typically for the purpose of resolving a circular reference.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean (for error handling purposes)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object to expose as bean reference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line"><span class="comment">/*判断要返回的早期单实例对象是否需要增强，如果需要增强，就进行包装，返回包装好的对象*/</span></span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面会遍历所有的<code>**SmartInstantiationAwareBeanPostProcessor**</code>，判断是否需要返回增强的对象。<br>​</p><p>而我们的<code>**AbstractAutoProxyCreator**</code>恰恰实现了<code>**SmartInstantiationAwareBeanPostProcessor**</code>。<br><br>所以<code>**getEarlyBeanReference()**</code>会执行<code>**AbstractAutoProxyCreator**</code>里面的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会把<strong>目标对象本身A放入到缓存中，返回A的早期代理对象</strong>。<br>​</p><p>在我们递归创建B的的时候，为B进行属性赋值的时候，回去从缓存拿A。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从一级缓存拿*/</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*从二级缓存拿*/</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*从三级缓存拿*/</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="comment">/*条件成立：说明第三级缓存有数据。这里就涉及到了缓存的升级 ，很简单 ，从三级挪到二级 ，再反手干掉三级的。*/</span></span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>这里第二次调用到了<code>**singletonFactory.getObject()**</code>，（此时是B创建过程中获取A），然后又会走到<code>**getEarlyBeanReference()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，会<strong>将A的代理对象放到缓存，返回A的代理对象</strong>。<br>​</p><p>所以当我们递归创建B后，回头用B为A属性赋值之后，执行A的初始化方法，就会走到抽象自动代理创建器的后置处理器逻辑，然后再来看这个方法<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean<span class="comment">/*A的代理对象*/</span>, String beanName<span class="comment">/*bean名称*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*获取缓存建：大部分情况下都是beanName，如果是工厂bean对象，也有可能是 &amp; */</span></span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">/*防止重复代理某个bean实例*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey)<span class="comment">/*A本身*/</span> != bean) &#123;</span><br><span class="line"><span class="comment">/*判断是否需要包装 AOP操作的入口*/</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**earlyProxyReferences.remove(cacheKey) != bean**</code>，因为此时缓存里面的是A的代理对象，传进来的也是A的代理对象，所以判断相等，直接返回，不需要再次创建A的代理对象。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639287187655-e2678d7f-136b-4a82-9466-9917a763eeb0.png#clientId=u506170ae-4cd9-4&from=paste&height=645&id=u13bd4ef0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1290&originWidth=3030&originalType=binary&ratio=1&size=578584&status=done&style=none&taskId=u0f36d3cc-6717-43da-a302-e1135e44a4b&width=1515" alt="image.png"></p><p>至此，这里就解释清楚了。<br>​</p><p>接下来，我们来看代理对象的创建过程。<code>**wrapIfNecessary()**</code><br><strong>​</strong></p><h2 id="4-是否需要创建代理对象"><a href="#4-是否需要创建代理对象" class="headerlink" title="4.是否需要创建代理对象"></a>4.是否需要创建代理对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*条件一般不成立，因为正常情况下很少使用TargetSourceCreator 去创建对象。BeforeInstantiation阶段*/</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果当前bean对象不需要增强处理</span></span><br><span class="line"><span class="comment"> * 判断是在BeforeInstantiation阶段阶段做的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 条件一：判断当前bean类型是否是基础框架类型的实例，不能被增强</span></span><br><span class="line"><span class="comment"> * 条件二：判断当前beanname是否是是忽略的bean，不需要被增强</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="comment">//进入这里表示不需要增强</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="comment">//直接返回上层</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找适合当前类的通知 非常重要 ！！！</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//判断当前查询出来的通知是不是空，如果不是空，说明走增强逻辑</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="comment">//记得放在缓存true</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">/*真正去创建代理对象*/</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass()<span class="comment">/*目标对象*/</span>, beanName<span class="comment">/*beanName*/</span>, specificInterceptors<span class="comment">/*匹配当前目标对象class的拦截器*/</span>,</span><br><span class="line"><span class="keyword">new</span> SingletonTargetSource(bean)<span class="comment">/*把当前bean进行了一个封装*/</span>);</span><br><span class="line"><span class="comment">//保存代理对象类型</span></span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="comment">//返回代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行到这里说明没查到这个类相关的通知，没法增强，直接返回</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>通过<code>**getAdvicesAndAdvisorsForBean()**</code>查找适合当前类的通知。<br>​</p><p>然后通过<code>**createProxy()**</code>去创建代理对象，最终返回代理对象。<br>​</p><h2 id="5-查找通知"><a href="#5-查找通知" class="headerlink" title="5.查找通知"></a>5.查找通知</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">//查询合适当前类型的通知</span></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="comment">//通知为空返回空</span></span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则转成一个数组返回</span></span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看<code>**findEligibleAdvisors()**</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*获取到当前项目里面所有可以使用的增强器*/</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">/*将上一步获取到的全部增强器进行过滤，留下适合当前类的*/</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line"><span class="comment">/*在这一步，会在index为0 的位置添加一个增强器*/</span></span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取全部增强器，过滤排序，返回。<br>​</p><p>先看一下如何获取的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Assert.state(<span class="keyword">this</span>.advisorRetrievalHelper != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactoryAdvisorRetrievalHelper available&quot;</span>);</span><br><span class="line"><span class="comment">//查询出来通过 bean 的方式配置的 增强器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * advisorRetrievalHelper 是怎么初始化的？</span></span><br><span class="line"><span class="comment"> * 这个类实现了 beanFactoryAware接口  ，在初始化beanFactory的时候， 创建了一个 helper 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line">String[] advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line"><span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//通过 bf 查询出来 bd 配置的 class 是 增强器的 子类 的beanName</span></span><br><span class="line">advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要是没拿到，就直接返回，没必要往下走了</span></span><br><span class="line"><span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line"><span class="comment">//注意：当前的helper是适配器包装的，真正的逻辑在适配器里面，但是实际上，适配器里面的这个方法也是返回 true</span></span><br><span class="line"><span class="comment">//这个方法的作用是判断当前给定名字的bean是否合格</span></span><br><span class="line"><span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line"><span class="comment">//当前bean如果是在创建中的话，那就打印个日志，记录下</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Skipping currently created advisor &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//从 bf 查询出来 当前这个名字和类型的增强器实例加入到增强器列表中</span></span><br><span class="line">advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line"><span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">String bceBeanName = bce.getBeanName();</span><br><span class="line"><span class="keyword">if</span> (bceBeanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(bceBeanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Skipping advisor &#x27;&quot;</span> + name +</span><br><span class="line"><span class="string">&quot;&#x27; with dependency on currently created bean: &quot;</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ignore: indicates a reference back to the bean we&#x27;re trying to advise.</span></span><br><span class="line"><span class="comment">// We want to find advisors other than the currently created bean itself.</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下如何过滤出当前类需要的增强器的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*核心逻辑*/</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*如果这个类全部可用的增强器为空，直接返回*/</span></span><br><span class="line"><span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配当前class 的 advisor 信息</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//不考虑音阶增强</span></span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设 值为false</span></span><br><span class="line"><span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="comment">// already processed</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断当前增强器是否匹配class</span></span><br><span class="line"><span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回的都是匹配当前class的advisor</span></span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下<code>_**canApply()**_</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大多数情况下是走这里，因为创建的增强器是  InstantiationModelAwarePointcutAdvisorImpl</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*判断当前切点是否匹配当前class*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//条件成立：说明当前class就不满足切点的定义  ，直接返回，因为后面是判断方法匹配的逻辑，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取方法匹配器</span></span><br><span class="line">MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line"><span class="comment">//如果是true，直接返回true，因为true不做判断，直接匹配所有方法</span></span><br><span class="line"><span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line"><span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//skip</span></span><br><span class="line">IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存当前目标对象clazz + 目标对象 父类 爷爷类 ... 的接口 + 自身实现的接口</span></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//判断目标对象是不是代理对象，确保classes内存储的数据包括目标对象的class，而不是代理类class</span></span><br><span class="line"><span class="keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"><span class="comment">//遍历classes，获取当前class定义的method，整个for循环会检查当前目标clazz 上级接口的所有方法</span></span><br><span class="line"><span class="comment">//看看是否会被方法匹配器匹配，如果有一个方法匹配成功，就说明目标class需要被AOP代理增强</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="keyword">if</span> (introductionAwareMethodMatcher != <span class="keyword">null</span> ?</span><br><span class="line">introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行到这里，说明当前类的所有方法都没有匹配成功，当前类不需要AOP的增强。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**matches()**</code>上一篇已经分析过了，这里不再赘述。<br>​</p><p>查找到匹配当前类的切面以后，我们再看一看如何创建的代理对象。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*类型断言，成立*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line"><span class="comment">/*给当前的bd添加了一个属性*/</span></span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个代理对象的工厂，他必须持有创建AOP代理class的生产资料</span></span><br><span class="line"><span class="comment">// 1. 目标对象</span></span><br><span class="line"><span class="comment">//2. 增强信息</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line"><span class="comment">//从当前类赋值一些信息到工厂</span></span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//说明咱们有使用 xml 配置修改过 aop ProxyTargetClass</span></span><br><span class="line"><span class="keyword">if</span> (proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="comment">// Explicit handling of JDK proxy targets (for introduction advice scenarios)</span></span><br><span class="line"><span class="keyword">if</span> (Proxy.isProxyClass(beanClass)) &#123;</span><br><span class="line"><span class="comment">// Must allow for introductions; can&#x27;t just set interfaces to the proxy&#x27;s interfaces only.</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; ifc : beanClass.getInterfaces()) &#123;</span><br><span class="line">proxyFactory.addInterface(ifc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No proxyTargetClass flag enforced, let&#x27;s apply our default checks...</span></span><br><span class="line"><span class="comment">//如果bd定义内有 preserverTargetClass = true ，那么bd对应的class创建代理对象的时候</span></span><br><span class="line"><span class="comment">//使用cglib，否则还得继续判断，判断需要代理的接口</span></span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//评估需要代理的接口，判断使用什么代理</span></span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建切面集合</span></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line"><span class="comment">//扩展点</span></span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line"><span class="comment">//传递给代理工厂的这些增强器信息做过基础匹配，也就是classFilter匹配</span></span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ClassLoader classLoader = getProxyClassLoader();</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">classLoader = ((SmartClassLoader) classLoader).getOriginalClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终还是调用了<code>**proxyFactory.getProxy(classLoader)**</code>。<br>​</p><p>至此，整个AOP的逻辑算是正式完成，下一篇我将带领大家一起分析下事务的源码。<br>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[十二]Aop源码分析</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%BA%8C%5DAop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%BA%8C%5DAop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇通过简单的分析，我们大概清楚了整个AOP代码实现的大体流程。本篇我们将从代码入手，一点点分解AOP的实现代码。</p></blockquote><h2 id="1-使用AOP的代码"><a href="#1-使用AOP的代码" class="headerlink" title="1.使用AOP的代码"></a>1.使用AOP的代码</h2><p>先看一段代码，看看如何使用AOP的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认代理所有方法</span></span><br><span class="line">proxyAllMethods();</span><br><span class="line"><span class="comment">//定制代理</span></span><br><span class="line"><span class="comment">//proxyMethod();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认情况。代理所有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyAllMethods</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.创建被代理对象</span></span><br><span class="line">Tiger tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="comment">//2.创建spring代理工厂对象 ProxyFactory</span></span><br><span class="line"><span class="comment">//proxyFactory 是 config + factory 的存在  持有 aop 操作 的 所有的生产资料</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(tiger);</span><br><span class="line"><span class="comment">//3. 添加拦截器</span></span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor01());</span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor02());</span><br><span class="line"><span class="comment">//4.获取代理对象，分析如何获取的代理对象？</span></span><br><span class="line">Animals proxy = (Animals) proxyFactory.getProxy();</span><br><span class="line">proxy.eat(<span class="string">&quot;人&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">proxy.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理指定的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建被代理对象</span></span><br><span class="line">Tiger tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="comment">//2.创建spring代理工厂对象 ProxyFactory</span></span><br><span class="line"><span class="comment">//proxyFactory 是 config + factory 的存在  持有 aop 操作 的 所有的生产资料</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(tiger);</span><br><span class="line"><span class="comment">//3.添加方法拦截</span></span><br><span class="line">MyPointCut pointCut = <span class="keyword">new</span> MyPointCut();</span><br><span class="line">proxyFactory.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(pointCut,<span class="keyword">new</span> MethodInterceptor01()));</span><br><span class="line">proxyFactory.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(pointCut,<span class="keyword">new</span> MethodInterceptor02()));</span><br><span class="line"><span class="comment">//4.获取代理对象 分析如何获得代理对象</span></span><br><span class="line">Animals proxy = (Animals) proxyFactory.getProxy();</span><br><span class="line"></span><br><span class="line">proxy.eat(<span class="string">&quot;人肉&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">proxy.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptor01</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="meta">@NonNull</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;method interceptor begin!----1&quot;</span>);</span><br><span class="line">Object result = invocation.proceed();</span><br><span class="line">System.out.println(<span class="string">&quot;method interceptor end!---4&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptor02</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="meta">@NonNull</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;method interceptor begin!----2&quot;</span>);</span><br><span class="line">Object result = invocation.proceed();</span><br><span class="line">System.out.println(<span class="string">&quot;method interceptor end!----3&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老虎吃&quot;</span>+food);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;跑的贼快！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPointCut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> clazz -&gt; <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MethodMatcher() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> method.getName().equals(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是使用AOP的两种方式，默认是代理全部方法，另一个则是代理指定的方法。接下来，我们来对源码进行分析。<br>​</p><h2 id="2-抓手"><a href="#2-抓手" class="headerlink" title="2.抓手"></a>2.抓手</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyAllMethods</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.创建被代理对象</span></span><br><span class="line">Tiger tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line"><span class="comment">//2.创建spring代理工厂对象 ProxyFactory</span></span><br><span class="line"><span class="comment">//proxyFactory 是 config + factory 的存在  持有 aop 操作 的 所有的生产资料</span></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(tiger);</span><br><span class="line"><span class="comment">//3. 添加拦截器</span></span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor01());</span><br><span class="line">proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor02());</span><br><span class="line"><span class="comment">//4.获取代理对象，分析如何获取的代理对象？</span></span><br><span class="line">Animals proxy = (Animals) proxyFactory.getProxy();</span><br><span class="line">proxy.eat(<span class="string">&quot;人&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">proxy.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面首先首先是创建了一个代理工厂，然后给代理工厂添加拦截器，最后通过代理工厂来获取代理对象，最后通过代理对象执行目标方法。<br>​</p><p>接下来我们来看代理工厂。<br>​</p><h2 id="3-代理工厂"><a href="#3-代理工厂" class="headerlink" title="3.代理工厂"></a>3.代理工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将目标对象封装成为 SingletonTargetSource 保存到父类字段内</span></span><br><span class="line">setTarget(target);</span><br><span class="line"><span class="comment">//获取目标对象class 的所有接口 ，保存到父类字段内</span></span><br><span class="line">setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639234501126-02594c19-dc91-4adf-b4d0-a13860a4a61b.png#clientId=u24ddacc8-01b2-4&from=paste&height=540&id=ud8b3ce3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1680&originalType=binary&ratio=1&size=217930&status=done&style=none&taskId=uc216fa2c-022e-4bf2-8b25-ffc65a15b16&width=840" alt="image.png"><br>在<code>**ProxyFactory**</code>的构造器内将目标对象和目标对象实现的接口封装到了父类的字段里面。<br>​</p><p>上图是<code>**ProxyFactory**</code>的继承关系，可以先简单过一下，有一个印象。<br>​</p><h2 id="4-添加切面"><a href="#4-添加切面" class="headerlink" title="4.添加切面"></a>4.添加切面</h2><p><code>**proxyFactory.addAdvice(new MethodInterceptor01())**</code><br><br>这一行代码是往代理工厂添加拦截器/切面。<br>​</p><p>看一下添加的流程<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="keyword">this</span>.advisors.size();</span><br><span class="line">addAdvice(pos, advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是调用了<code>**AdvisedSupport**</code>类的添加切面方法。<br>​</p><p>在添加切面的方法里获取了当前类的增强器个数。然后和切面一起传递到重载的方法里。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">Assert.notNull(advice, <span class="string">&quot;Advice must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//不考虑，引介增强，很少用</span></span><br><span class="line"><span class="keyword">if</span> (advice <span class="keyword">instanceof</span> IntroductionInfo) &#123;</span><br><span class="line"><span class="comment">// We don&#x27;t need an IntroductionAdvisor for this kind of introduction:</span></span><br><span class="line"><span class="comment">// It&#x27;s fully self-describing.</span></span><br><span class="line">addAdvisor(pos, <span class="keyword">new</span> DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不考虑，引介增强，很少用</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> DynamicIntroductionAdvice) &#123;</span><br><span class="line"><span class="comment">// We need an IntroductionAdvisor for this kind of introduction.</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//spring中Advice对应的接口就是Advisor，Spring使用Advisor包装着AOP的Advice实例</span></span><br><span class="line">addAdvisor(pos, <span class="keyword">new</span> DefaultPointcutAdvisor(advice));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>然后调用了<code>**addAdvisor()**</code>，添加增强器。<br>​</p><p>因为我们没有指定切点，所以创建了一个默认的切点的增强器<code>**DefaultPointcutAdvisor**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="comment">//引介相关的逻辑，不考虑</span></span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">validateIntroductionAdvisor((IntroductionAdvisor) advisor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委派模式</span></span><br><span class="line">addAdvisorInternal(pos, advisor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>这里面调用了<code>**addAdvisorInternal(pos, advisor)**</code>，继续往下看。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAdvisorInternal</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">Assert.notNull(advisor, <span class="string">&quot;Advisor must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//如果当前AOP配置已经冻结了，不能在添加切面了，添加的话会抛出异常。</span></span><br><span class="line"><span class="keyword">if</span> (isFrozen()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Cannot add advisor: Configuration is frozen.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果传入的切面的位置大于当前切面的个数，抛异常，因为位置下标默认从-1开始。</span></span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>.advisors.size()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="string">&quot;Illegal position &quot;</span> + pos + <span class="string">&quot; in advisor list with size &quot;</span> + <span class="keyword">this</span>.advisors.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加增强器</span></span><br><span class="line"><span class="keyword">this</span>.advisors.add(pos, advisor);</span><br><span class="line"><span class="comment">//清理缓存</span></span><br><span class="line">adviceChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进行一些校验逻辑，然后添加增强器，清理缓存。<br>​</p><h2 id="5-获取代理对象"><a href="#5-获取代理对象" class="headerlink" title="5.获取代理对象"></a>5.获取代理对象</h2><p><code>**proxyFactory.getProxy()**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据工厂的设置创建代理对象</span></span><br><span class="line"><span class="comment"> * 可以反复的调用。</span></span><br><span class="line"><span class="comment"> * 如果我们添加或者删除接口，效果会有所不同，可以添加和删除拦截器。</span></span><br><span class="line"><span class="comment"> * 使用默认的类加载器：默认是线程上下文类加载器（如果需要创建代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建AOP 的 代理  ，那么  AOP 的代理是什么 ？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AopProxy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * createAopProxy() ：去创建代理对象的逻辑</span></span><br><span class="line"><span class="comment"> * getProxy()：获取创建好的代理对象，这里有两个实现分别是jdk的动态代理和cglib的动态代理。</span></span><br><span class="line"><span class="comment"> * CglibAopProxy</span></span><br><span class="line"><span class="comment"> * JdkDynamicAopProxy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面先是利用<code>**createAopProxy()**</code>创建了一个代理对象，然后通过<code>**getProxy()**</code>来获取一个代理对象。<br>​</p><p>我们先来分析<code>**createAopProxy()**</code>，看一看代理对象是如何创建的？<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类应该调用它来获得一个新的 AOP 代理。 他们不应该创建一个AOP代理this作为参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * active属性实际上就是一个标记，在创建第一个代理对象的时候，会将他设置为true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析一下下面这行代码的流程：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 获取aop的代理工厂  看一下AopProxyFactory</span></span><br><span class="line"><span class="comment"> * 2. 使用工厂创建一个aop的代理  ,如何创建代理的？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是通过<code>**getAopProxyFactory()**</code>获取AOP的代理工厂，然后通过<code>**createAopProxy(this)**</code>传入当前类来获取一个代理对象。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类里面已经持有了一个默认的aop的代理工厂</span></span><br><span class="line"><span class="comment"> * ctrl + h 查看当前类的继承关系</span></span><br><span class="line"><span class="comment"> * 当前类是 ProxyFactory的父类，所以里面的代理工厂会被默认的初始化加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下上图类的继承关系，其实在创建<code>**ProxyFactory**</code>的时候，隐式调用父类的构造器的时候，就已经在<code>**ProxyCreatorSupport**</code>里面创建了一个默认的AOP代理工厂<code>**DefaultAopProxyFactory**</code>。<br>​</p><p>接下来再来看如何创建一个AOP代理对象的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config 就是我们的ProxyFactory对象，ProxyFactory他是一个配置管理对象</span></span><br><span class="line"><span class="comment"> *               保存着创建代理对象所有的生产资料。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个AOP的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AopConfigException 如果某些不期望我们修改的配置被修改，就会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 条件一：暂且不管</span></span><br><span class="line"><span class="comment"> * 条件二：true 表示强制使用cglib代理，</span></span><br><span class="line"><span class="comment"> * 条件三：true 表示被代理对象没有实现任何接口没有办法使用jdk的动态代理，只能使用cglib的动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; <span class="comment">//该条件不需要考虑</span></span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">config.isOptimize() ||  <span class="comment">//设置了这个属性，那么就是强制使用cglib的动态代理</span></span><br><span class="line">config.isProxyTargetClass() ||  <span class="comment">//设置了这个属性，那么就是强制使用cglib的动态代理</span></span><br><span class="line">hasNoUserSuppliedProxyInterfaces(config) <span class="comment">//判断被代理对象有没有实现接口，没有实现接口，那还用锤子jdk的动态代理</span></span><br><span class="line">)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">//走到这里的话，很大程度上就已经会使用cglib的动态代理</span></span><br><span class="line"><span class="comment">//获取目标对象的类型，为空的话肯定没法继续往下走了，直接异常中断</span></span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标对象是一个接口 或者 已经是一个被代理过得类型（此时是多重代理） ，只能使用jdk的动态代理</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//走cglib的动态代理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//执行到这里的情况 ： 实现了接口,大多数情况我们都是面向接口编程，走这里</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据条件判断我们到底是创建JDK的代理对象还是创建Cglib的代理对象，因为我们的案例代码的目标类是实现了接口的，所以默认会走jdk的动态代理。<br>​</p><h2 id="6-JdkDynamicAopProxy"><a href="#6-JdkDynamicAopProxy" class="headerlink" title="6.JdkDynamicAopProxy"></a>6.JdkDynamicAopProxy</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的配置，通过构造器创建aop 的动jdk态代理对象</span></span><br><span class="line"><span class="comment"> * 这里的config是啥？就是我们的代理工厂对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="comment">//非空断言</span></span><br><span class="line">Assert.notNull(config, <span class="string">&quot;AdvisedSupport must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//如果配置里面的切面数==0 &amp;&amp; 配置里面的目标对象是空对象，那么代理无法继续往下走了，直接抛异常中断</span></span><br><span class="line"><span class="keyword">if</span> (config.getAdvisorCount() == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;No advisors and no TargetSource specified&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.advised = config;</span><br><span class="line"><span class="comment">//获取当前被代理对象实现的接口数组 ,具体的实现逻辑？</span></span><br><span class="line"><span class="keyword">this</span>.proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//查找所有被代理的接口，如果有equals 和 hashcode就打个标</span></span><br><span class="line">findDefinedEqualsAndHashCodeMethods(<span class="keyword">this</span>.proxiedInterfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>判断如果配置里面没有该被代理对象的切面，或者被代理对象是空，那就不能往下走了，抛出异常。<br>​</p><p>获取当前被代理对象实现的接口数组<code>**AopProxyUtils.completeProxiedInterfaces(this.advised, true)**</code>。<br>​</p><p>查找所有被代理的接口，如果有equals 和 hashcode就打个标。<br>​</p><p>看一下如何获取到当前被代理对象实现的接口数组的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿到被代理对象的所有接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, <span class="keyword">boolean</span> decoratingProxy) &#123;</span><br><span class="line"><span class="comment">/*从proxyFactory中获取所有的target提取出来的接口*/</span></span><br><span class="line">Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line"><span class="comment">/*如果接口长度是0*/</span></span><br><span class="line"><span class="keyword">if</span> (specifiedInterfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//拿到目标对象的类型</span></span><br><span class="line">Class&lt;?&gt; targetClass = advised.getTargetClass();</span><br><span class="line"><span class="comment">//如果目标对象的类型不为空</span></span><br><span class="line"><span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果目标对象是一个接口，那么就将目标对象设置到接口列表里面</span></span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">advised.setInterfaces(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果目标对象是一个代理类，那么也将目标对象设置到接口列表</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">advised.setInterfaces(targetClass.getInterfaces());</span><br><span class="line">&#125;</span><br><span class="line">specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*创建一个新的接口数组，长度是原接口数量+spring追加的三个接口数量*/</span></span><br><span class="line">List&lt;Class&lt;?&gt;&gt; proxiedInterfaces = <span class="keyword">new</span> ArrayList&lt;&gt;(specifiedInterfaces.length + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; ifc : specifiedInterfaces) &#123;</span><br><span class="line"><span class="comment">// 只有非密封接口实际上有资格进行JDK代理(在JDK 17上)</span></span><br><span class="line"><span class="keyword">if</span> (!ifc.isSealed()) &#123;</span><br><span class="line">proxiedInterfaces.add(ifc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果这个接口里面没有SpringProxy这个接口，那么就需要添加一个，打标，标识这个代理对象是Spring创建的*/</span></span><br><span class="line"><span class="keyword">if</span> (!advised.isInterfaceProxied(SpringProxy.class)) &#123;</span><br><span class="line">proxiedInterfaces.add(SpringProxy.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断目标对象的所有接口是否有advice接口，没有就手动添加*/</span></span><br><span class="line"><span class="keyword">if</span> (!advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)) &#123;</span><br><span class="line">proxiedInterfaces.add(Advised.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果目标对象的所有接口里面，没有DecoratingProxy的接口，那就添加一个</span></span><br><span class="line"><span class="keyword">if</span> (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class)) &#123;</span><br><span class="line">proxiedInterfaces.add(DecoratingProxy.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回接口类型数组</span></span><br><span class="line"><span class="keyword">return</span> ClassUtils.toClassArray(proxiedInterfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看<code>**getProxy(**</code>)的逻辑。<br>​</p><h2 id="7-getProxy"><a href="#7-getProxy" class="headerlink" title="7.getProxy()"></a>7.getProxy()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里如果没有传类加载器，就使用默认的类加载器，默认是线程上下文类加载器</span></span><br><span class="line"><span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载，继续往下走。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="comment">//打印日志的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过jdk的动态代理来创建代理对象 this == this::invoke  该方法最终会返回一个代理类对象</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, <span class="keyword">this</span>.proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过JDK的动态代理来创建代理对象，为啥会传入当前类<code>**JdkDynamicAopProxy**</code>，因为当前类实现了<code>**InvocationHandler**</code>接口。<br>​</p><p>因此，当代理对象调用目标方法的时候，就会执行该类的<code>**invoke()**</code>。<br>​</p><h2 id="8-代理对象执行目标方法"><a href="#8-代理对象执行目标方法" class="headerlink" title="8.代理对象执行目标方法"></a>8.代理对象执行目标方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy<span class="comment">/*代理对象*/</span>, Method method<span class="comment">/*目标方法*/</span>, Object[] args<span class="comment">/*目标方法对应的参数*/</span>)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//advised 这里实际上就是proxyFactory的引用，targetSource 实际上就是上层传递封装的targetsource</span></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*如果代理类实现的接口里面有equals方法，就使用里面的，否则使用jdk提供的equals方法*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果代理类实现的接口里面提供了hashcode方法，就是用里面的，否则用jdk的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="keyword">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*暂时尚未用到，TODO*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要将当前的代理对象设置在aop上下文中</span></span><br><span class="line"><span class="comment"> * aop上下文对象实际上就是一个threadLocal</span></span><br><span class="line"><span class="comment"> * 为什么要引入一个aop上下文？</span></span><br><span class="line"><span class="comment"> * 目标对象A B</span></span><br><span class="line"><span class="comment"> * 通过代理的方式调用A.eat()</span></span><br><span class="line"><span class="comment"> * 这个eat方法里面有恰恰调用到了B的方法，这个时候B对象实际上并不是代理对象，所以</span></span><br><span class="line"><span class="comment"> * b的方法执行前后并不会被增强，为了解决这个问题，就引入了aop的上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// 将当前代理对象设置到aop上下文中，并返回老的代理对象</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据targetSource拿到目标对象*/</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line"><span class="comment">/*根据目标对象拿到目标对象的类型*/</span></span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是最关键的地方，查找适合该方法的增强  具体是如何查找的？</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询出匹配当前方法拦截器的数量是0 说明当前方法不需要被增强，直接通过反射调用目标对象的目标方法。*/</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line"><span class="comment">/*调用目标对象的目标方法*/</span></span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*说明有匹配当前method的方法拦截器，说明要做增强处理 */</span></span><br><span class="line">MethodInvocation invocation =</span><br><span class="line"><span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">/*核心驱动逻辑在ReflectiveMethodInvocation*/</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取方法的返回值类型*/</span></span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line"><span class="comment">/*如果目标方法返回目标对象 ，做一个替换  ，返回代理对象*/</span></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">retVal = proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法是void类型，但是返回值类型还不为空，说明有问题，抛异常</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line"><span class="string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line"><span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// 将上次设置的proxy在此设置回去到aop上下文内</span></span><br><span class="line"><span class="comment">//因为当前代理对象的目标方法已经完成了，需要回到上一层逻辑</span></span><br><span class="line"><span class="comment">//属于恢复现场的逻辑</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>抛开一切不是很重要的逻辑<br>​</p><p>判断当前代理对象是否应该暴露出去，aop上下文<code>**AopContext**</code>实际上就是一个ThreadLocal。<br>​</p><p><strong>为什么要引入AOP的上下文？</strong><br>​</p><p>假设有目标对象A,B。<br>​</p><p>通过代理的方式调用A.eat()。<br>​</p><p>这个eat()方法里面恰恰调用了B的方法，这个时候对象实际上并不是代理对象，所以B的方法执行前后并不会被增强，为了解决这个问题，就引入了AOP上下文。<br>​</p><p>通过<code>**getInterceptorsAndDynamicInterceptionAdvice()**</code>查找到当前方法执行前后需要执行的增强器。<br><br>如果当前方法匹配的增强器数量是0，那么直接通过反射调用目标方法。<br>​</p><p>否则说明有匹配的增强器，需要做增强处理。<code>**retVal=ReflectiveMethodInvocation.proceed(）**</code><br>​</p><p>retVal就是方法的返回值。<br>​</p><p>判断如果方法最终返回的目标对象，那就替换成代理对象。<br>​</p><p>判断如果方法是void类型，但是返回值类型还不为空，说明有问题，抛异常。<br>​</p><p>最终返回结果，并将AOP上下文的代理对象还原成里面原有的对象，因为当前代理对象的目标方法已经完成了，需要回到上一层逻辑。<br><br>至此，AOP整个流程就分析完了，剩下的一些核心的细节：<br>​</p><ol><li><code>**getInterceptorsAndDynamicInterceptionAdvice()**</code>查找到当前方法执行前后需要执行的增强器</li><li><code>**retVal=ReflectiveMethodInvocation.proceed(）**</code>执行增强器逻辑</li></ol><p>​</p><blockquote><p>通过前面的分析，我们大体上了解了Spring的Aop的执行流程。接下来我们在看一些核心的细节，如何查找目标方法的增强器。</p></blockquote><h2 id="9-查找增强器"><a href="#9-查找增强器" class="headerlink" title="9.查找增强器"></a>9.查找增强器</h2><p><code>**List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先尝试从缓存拿</span></span><br><span class="line">MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line"><span class="comment">/*如果缓存为空*/</span></span><br><span class="line"><span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*那就走查找逻辑，并刷新缓存</span></span><br><span class="line"><span class="comment">* advisorChainFactory什么时候创建的？</span></span><br><span class="line"><span class="comment">* 这个是在proxyFactory里面的一个变量，代理工厂创建出来，他就创建出来了</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line"><span class="keyword">this</span>, method, targetClass);</span><br><span class="line"><span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最终返回查找到的值*/</span></span><br><span class="line"><span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找缓存，如果没命中则去查找并放入缓存放回。我们继续往下看查找逻辑<code>**this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice()**</code>。<br>​</p><p>这个<code>**advisorChainFactory**</code>是什么？看当前类的属性<code>**AdvisorChainFactory advisorChainFactory = new DefaultAdvisorChainFactory();**</code></p><p>从这里我们就定位到了看哪个方法的逻辑<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">Advised config<span class="comment">/*代理工厂*/</span>, Method method<span class="comment">/*目标方法*/</span>, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass<span class="comment">/*目标对象类型*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个接口是切面适配器的注册中心</span></span><br><span class="line"><span class="comment"> * 1.可以注册AdvisorAdapter 适配器目的：将非advisor类型的增强包装成advisor  ，将advisor类型的增强提取出来对应的 方法拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取代理工厂内部持有的增强信息</span></span><br><span class="line"><span class="comment"> * 1. addAdvice</span></span><br><span class="line"><span class="comment"> * 2. addAdvisor</span></span><br><span class="line"><span class="comment"> * 最终在代理工厂中都会包装成 advisor</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">Advisor[] advisors = config.getAdvisors();</span><br><span class="line"><span class="comment">/*创建一个拦截器列表，长度就是advisor的长度*/</span></span><br><span class="line">List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</span><br><span class="line"><span class="comment">/*真实的目标对象类型*/</span></span><br><span class="line">Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line"><span class="comment">/*引介增强相关*/</span></span><br><span class="line">Boolean hasIntroductions = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line"><span class="comment">/*包含切点信息的增强，内部逻辑就是做匹配算法*/</span></span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line"><span class="comment">// 转换成 PointcutAdvisor 类型，可以获取到切点信息</span></span><br><span class="line">PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line"><span class="comment">/*条件二成立，说明当前被代理对象的class匹配当前advisor成功，可能被advisor增强，具体还要看方法匹配。 这里可以看一下 Pointcut 源码*/</span></span><br><span class="line"><span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line"><span class="comment">/*获取切点信息的方法匹配器，做方法级别的匹配*/</span></span><br><span class="line">MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line"><span class="keyword">boolean</span> match;</span><br><span class="line"><span class="comment">/*引介相关的，不需要考虑*/</span></span><br><span class="line"><span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line"><span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</span><br><span class="line">hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">&#125;</span><br><span class="line">match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*进行方法匹配 目标方法匹配成功 ， match = true，当前的增强器可以应用到method*/</span></span><br><span class="line">match = mm.matches(method, actualClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断是否还需要运行时的匹配*/</span></span><br><span class="line"><span class="keyword">if</span> (match) &#123;</span><br><span class="line"><span class="comment">/*提取出advisor类持有的拦截器信息  registry里面包含三个默认的增强器*/</span></span><br><span class="line">MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line"><span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line"><span class="comment">/*如果是运行时匹配，那就走运行时匹配的逻辑*/</span></span><br><span class="line"><span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*将方法拦截器追加到拦截器列表里面去*/</span></span><br><span class="line">interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*不考虑引介，所以直接跳过*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line"><span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*适配所有方法的*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*返回所有匹配当前方法的拦截器*/</span></span><br><span class="line"><span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法有点长，我们挑重点慢慢分析。<br>​</p><p>首先获取到切面适配器的注册中心，切面适配器<code>**AdvisorAdapter**</code>是做什么的？<br>​</p><p>将非advisor类型的增强包装成advisor  ，将advisor类型的增强提取出来对应的 方法拦截器。<br>​</p><p>获取代理工厂内部持有的增强信息<br>​</p><ol><li>Advice</li><li>Advisor</li></ol><p>最终在代理工厂中都会被包装成Advisor。<br>​</p><p>遍历所有的拦截器：<br>​</p><ol><li><p>先是处理切点类型的增强器</p><blockquote><ol><li>先将增强器转化成<code>**PointcutAdvisor**</code>类型</li><li>判断如果当前被代理对象的class匹配增强器成功，说明可能增强成功，还要看具体的方法匹配，这里可以看一下<code>**PointCut**</code> 源码</li><li>获取切点信息的方法匹配器，准备做方法级别的匹配</li><li><code>**match = mm.matches(method, actualClass)**</code>进行具体的方法匹配</li><li>判断是否需要运行时匹配</li><li>如果需要，提取出增强器持有的拦截器信息(registry里面默认持有三个增强器)，走运行时匹配的逻辑 -&gt; 将<code>**InterceptorAndDynamicMethodMatcher**</code>加入到拦截器列表</li><li>如果不需要，将方法拦截器添加到拦截器列表</li></ol></blockquote></li><li><p>处理引介类型的增强器</p><blockquote><p>这里的逻辑我们不需要关注</p></blockquote></li><li><p>处理适配所有方法的增强器</p><blockquote><p>从增强器的适配中心获取所有的拦截器</p></blockquote></li></ol><p>最终返回匹配当前方法的所有拦截器<br>​</p><h2 id="10-方法匹配"><a href="#10-方法匹配" class="headerlink" title="10.方法匹配"></a>10.方法匹配</h2><p>这里我们再看一下具体的方法匹配逻辑。<br>​</p><p>看一下<code>**AbstractRegexpMethodPointcut**</code>，说实话，营养价值不大，有兴趣可以自行琢磨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (matchesPattern(ClassUtils.getQualifiedMethodName(method, targetClass)) ||</span><br><span class="line">(targetClass != method.getDeclaringClass() &amp;&amp;</span><br><span class="line">matchesPattern(ClassUtils.getQualifiedMethodName(method, method.getDeclaringClass()))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Match the specified candidate against the configured patterns.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> signatureString &quot;java.lang.Object.hashCode&quot; style signature</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the candidate matches at least one of the specified patterns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesPattern</span><span class="params">(String signatureString)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.patterns.length; i++) &#123;</span><br><span class="line"><span class="keyword">boolean</span> matched = matches(signatureString, i);</span><br><span class="line"><span class="keyword">if</span> (matched) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.excludedPatterns.length; j++) &#123;</span><br><span class="line"><span class="keyword">boolean</span> excluded = matchesExclusion(signatureString, j);</span><br><span class="line"><span class="keyword">if</span> (excluded) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-拦截器的核心驱动"><a href="#11-拦截器的核心驱动" class="headerlink" title="11.拦截器的核心驱动"></a>11.拦截器的核心驱动</h2><p>获取到所有的匹配当前方法的拦截器后，最终我们是要驱动所有的拦截器去执行，接下来分析下拦截器的核心驱动逻辑。<code>**invocation.proceed()**</code>，核心逻辑在<code>**ReflectiveMethodInvocation**</code>中。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 因为从-1开始，如果当前拦截器下标 == 拦截器数量-1 ，说明所有方法拦截器都执行过了，接下来需要执行目标对象的目标方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/*调用连接点*/</span></span><br><span class="line"><span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取下一个方法拦截器*/</span></span><br><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line"><span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="comment">/*判断是否需要运行时匹配*/</span></span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"></span><br><span class="line">InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line"><span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*大部分情况下会走到else这里静态匹配*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 让当前方法拦截器执行invoke即可 ，并且将当前对象传递进去</span></span><br><span class="line"><span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否所有拦截器都执行完了，如果是的话，执行目标方法<code>**invokeJoinpoint()**</code>。<br>​</p><p>获取下一个拦截器，判断是否需要做运行时匹配，大部分情况下，我们都是走静态匹配的逻辑。<br>​</p><p>让当前方法拦截器执行<code>**invoke()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>通过这样类似递归的链式调用，每一个拦截器等待下一个拦截器执行完成返回以后在执行，拦截器的机制保证了通知方法与目标方法的执行顺序。<br>​</p><p>再来看下如何调用目标方法。<code>**invokeJoinpoint()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下追。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(<span class="meta">@Nullable</span> Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use reflection to invoke the method.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line"><span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="comment">// Invoked method threw a checked exception.</span></span><br><span class="line"><span class="comment">// We must rethrow it. The client won&#x27;t see the interceptor.</span></span><br><span class="line"><span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;AOP configuration seems to be invalid: tried calling method [&quot;</span> +</span><br><span class="line">method + <span class="string">&quot;] on target [&quot;</span> + target + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;Could not access method [&quot;</span> + method + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过暴力反射来调用目标方法执行。<br>​</p><h2 id="12-切点表达式"><a href="#12-切点表达式" class="headerlink" title="12.切点表达式"></a>12.切点表达式</h2><p><code>**PointCut**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the ClassFilter for this pointcut.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the ClassFilter (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类过滤器：判断某个类是否符合切点位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the MethodMatcher for this pointcut.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the MethodMatcher (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * 方法匹配器：判断类中某个方法是否匹配条件，匹配条件的方法才会被增强</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前面案例代码中，有一个我们自己实现的切点，可以回顾一下。</p></blockquote><p>最终回顾下开头的一张图，明确下<code>**Advised --持有--&gt; Advisor --持有--&gt; Advice --子类--&gt;Interceptor --子类--&gt;MethodInterceptor**</code>关系：<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639244740087-0aff2acc-6151-410c-8f49-5d93f59216ff.png#clientId=uedc3a3ab-2b31-4&from=paste&height=550&id=u3f8e64de&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1100&originWidth=1882&originalType=binary&ratio=1&size=788714&status=done&style=none&taskId=u59e1ae3f-dd3f-40ed-a493-8f672e8a65b&width=941" alt="image.png"></p><p>至此，整个AOP的全部流程已经梳理清晰。下一篇，我们将开始分析Spring的事务。<br>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[十]Aop的两种实现方式</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%8D%81%5DAop%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%8D%81%5DAop%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇开始Aop的相关的内容，aop的底层使用到了动态代理的，我们针对一个方法可以配置多个切面，也就实现了多重代理。本篇先不看源码，从开发者的角度观望如何实现多重代理。</p></blockquote><p>​</p><h1 id="一，代理模式"><a href="#一，代理模式" class="headerlink" title="一，代理模式"></a>一，代理模式</h1><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<br>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问。<br>代理模式的主要角色如下。 </p><ol><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。 </li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 </li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 </li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639137533831-6d73c59b-b3fb-4ca9-968f-1b46508ecd39.png#clientId=ua2e65725-91dd-4&from=paste&height=184&id=u1b02b553&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=704&originalType=binary&ratio=1&size=41967&status=done&style=none&taskId=u30c834db-1d96-420b-86b0-3a1a0ddecee&width=352" alt="image.png"><br>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。<br>根据代理的创建时期，代理模式分为静态代理和动态代理。 </p><ul><li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。 </li><li>动态：在程序运行时，运用反射机制动态创建而成。 <h2 id="1-JDK的动态代理"><a href="#1-JDK的动态代理" class="headerlink" title="1.JDK的动态代理"></a>1.JDK的动态代理</h2></li></ul><p>动态代理</p><ol><li>特点：字节码随用随修改，随用随加载</li><li>作用：在不修改源码的基础上在运行时动态的对方法进行增强</li><li>分类：<ol><li>基于接口的动态代理</li><li>基于子类的动态代理</li></ol></li><li>基于接口的动态代理<ol><li>涉及的类：Proxy</li><li>提供者：JDK官方</li></ol></li><li>如何创建代理对象<ol><li>使用Proxy类的<code>**newProxyInstance()**</code></li></ol></li><li>创建代理对象的要求<ol><li>被代理类最少实现一个接口，如果没有则不能使用</li></ol></li><li><code>**newProxyInstance()**</code>的参数<ol><li>ClassLoader：类加载器，用于加载代理对象字节码文件；和被代理对象使用相同的类加载器。</li><li>Class[]：字节码数组，用于让代理对象和被代理对象实现相同方法的。</li><li>InvocationHandler：用于提供增强的代码，他是让我们自定义如何代理，我们一般都是写一个该接口的实现类。</li></ol></li><li>简单的实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//被代理类对象要声明为最终的</span></span><br><span class="line">        <span class="keyword">final</span> Producer producer=<span class="keyword">new</span> Producer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理对象和被代理类对象要实现同一个接口</span></span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 作用：执行被代理对象的任何接口方法都会经过该方法</span></span><br><span class="line"><span class="comment">                     * 方法参数的含义</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy   代理对象的引用</span></span><br><span class="line"><span class="comment">                     * 1. 可以使用反射获取代理对象的信息（也就是proxy.getClass().getName()。</span></span><br><span class="line"><span class="comment">                     * 2. 可以将代理对象返回以进行连续调用，这就是proxy存在的目的，因为this并不是代理对象。</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method  当前执行的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args    当前执行方法所需的参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>        和被代理对象方法相同的返回值</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object value=<span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//获取方法执行的参数</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//判断当前方法是不是销售</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            Float money= (Float) args[<span class="number">0</span>];</span><br><span class="line">                            <span class="comment">//两个参数：被代理类对象，方法增强的参数</span></span><br><span class="line">                            value=method.invoke(producer,money*<span class="number">0.8f</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyProducer.saleProduct(<span class="number">10000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.es.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">IProducer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销售产品，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供售后服务，并拿到钱：&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对生产厂家要求的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销售</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterService</span><span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2.cglib动态代理"></a>2.cglib动态代理</h2></li></ol><p> 基于子类的动态代理</p><ol><li> 涉及的类：Enhancer ，提供者：第方cglib库 </li><li>如何创建代理对象： 使用Enhancer类中的create方法 </li><li>创建代理对象的要求： 被代理类是最终类 </li><li>create方法的参数： <ol><li>Class：字节码 ：它是用于指定被代理对象的字节码。 </li><li>Callback：用于提供增强的代码 ：它是让我们写如何代理。我们一般都是些一个该接口的实现类。 我们一般写的都是该接口的子接口实现类：<code>**MethodInterceptor**</code></li></ol></li><li>简单的实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinhuidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020-03-02-1:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行被代理对象的任何方法都会经过该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">             *    以上个参数和基于接口的动态代理中invoke方法的参数是一样的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> methodProxy ：当前执行方法的代理对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//提供增强的代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//1.获取方法执行的参数</span></span><br><span class="line">                Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//2.判断当前方法是不是销售</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;saleProduct&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(<span class="number">12000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二，多重代理"><a href="#二，多重代理" class="headerlink" title="二，多重代理"></a>二，多重代理</h1><h2 id="1-基于责任链模式的多重代理"><a href="#1-基于责任链模式的多重代理" class="headerlink" title="1.基于责任链模式的多重代理"></a>1.基于责任链模式的多重代理</h2><h3 id="1-1-被代理的方法"><a href="#1-1-被代理的方法" class="headerlink" title="1.1 被代理的方法"></a>1.1 被代理的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;猫吃&quot;</span>+food+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2封装目标对象的目标方法"><a href="#1-2封装目标对象的目标方法" class="headerlink" title="1.2封装目标对象的目标方法"></a>1.2封装目标对象的目标方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetMethod</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 目标对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Object target;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 目标方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Method method;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TargetMethod</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">      <span class="keyword">this</span>.method = method;</span><br><span class="line">      <span class="keyword">this</span>.args = args;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> method;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.method = method;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Object[] getArgs() &#123;</span><br><span class="line">      <span class="keyword">return</span> args;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArgs</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.args = args;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-抽象的责任链节点和驱动责任链往下执行的头节点"><a href="#1-3-抽象的责任链节点和驱动责任链往下执行的头节点" class="headerlink" title="1.3 抽象的责任链节点和驱动责任链往下执行的头节点"></a>1.3 抽象的责任链节点和驱动责任链往下执行的头节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSlot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   TargetMethod targetMethod;</span><br><span class="line"></span><br><span class="line">   AbstractSlot next;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> Object <span class="title">invoke</span><span class="params">(TargetMethod targetMethod)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextSlot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(TargetMethod targetMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> hasNextSlot() ?</span><br><span class="line">            next.invoke(targetMethod) :</span><br><span class="line">            targetMethod.getMethod()</span><br><span class="line">                  .invoke(</span><br><span class="line">                        targetMethod.getTarget(),</span><br><span class="line">                        targetMethod.getArgs()</span><br><span class="line">                  );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AbstractSlot</span><span class="params">(TargetMethod targetMethod, AbstractSlot next)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.targetMethod = targetMethod;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TargetMethod <span class="title">getTargetMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> targetMethod;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetMethod</span><span class="params">(TargetMethod targetMethod)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.targetMethod = targetMethod;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AbstractSlot <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(AbstractSlot next)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.next = next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AbstractSlot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">extends</span> <span class="title">AbstractSlot</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function">Object <span class="title">invoke</span><span class="params">(TargetMethod targetMethod)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-对方法增强的类"><a href="#1-4-对方法增强的类" class="headerlink" title="1.4 对方法增强的类"></a>1.4 对方法增强的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamic</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object target ;</span><br><span class="line"></span><br><span class="line">   AbstractSlot head;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> head.proceed(<span class="keyword">new</span> TargetMethod(</span><br><span class="line">            target,method,args</span><br><span class="line">      ));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamic</span><span class="params">(Object target, AbstractSlot head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">      <span class="keyword">this</span>.head = head;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5测试类"><a href="#1-5测试类" class="headerlink" title="1.5测试类"></a>1.5测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      AbstractSlot.Head head = <span class="keyword">new</span> AbstractSlot.Head();</span><br><span class="line">      AbstractSlot first = <span class="keyword">new</span> First();</span><br><span class="line">      AbstractSlot second=<span class="keyword">new</span> Second();</span><br><span class="line">      first.setNext(second);</span><br><span class="line">      head.setNext(first);</span><br><span class="line"></span><br><span class="line">      JdkDynamic jdkDynamic = <span class="keyword">new</span> JdkDynamic(<span class="keyword">new</span> Cat(),head);</span><br><span class="line">      Animal proxy = (Animal) jdkDynamic.getProxy();</span><br><span class="line">      proxy.eat(<span class="string">&quot;事物&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">First</span> <span class="keyword">extends</span> <span class="title">AbstractSlot</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function">Object <span class="title">invoke</span><span class="params">(TargetMethod targetMethod)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         Object result = <span class="keyword">null</span>;</span><br><span class="line">         System.out.println(<span class="string">&quot;增强逻辑&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            result= proceed(targetMethod);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;增强逻辑&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Second</span> <span class="keyword">extends</span> <span class="title">AbstractSlot</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function">Object <span class="title">invoke</span><span class="params">(TargetMethod targetMethod)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         Object result = <span class="keyword">null</span>;</span><br><span class="line">         System.out.println(<span class="string">&quot;增强逻辑&quot;</span>);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            result= proceed(targetMethod);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">&quot;增强逻辑&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基于拦截器的多重代理"><a href="#2-基于拦截器的多重代理" class="headerlink" title="2.基于拦截器的多重代理"></a>2.基于拦截器的多重代理</h2><h3 id="2-1-拦截器"><a href="#2-1-拦截器" class="headerlink" title="2.1 拦截器"></a>2.1 拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">invoke</span><span class="params">(MyInvocation myInvocation)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> <span class="keyword">implements</span> <span class="title">MyInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MyInvocation myInvocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Object result = <span class="keyword">null</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      result=myInvocation.proceed();</span><br><span class="line">      System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">implements</span> <span class="title">MyInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MyInvocation myInvocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Object result = <span class="keyword">null</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      result=myInvocation.proceed();</span><br><span class="line">      System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-增强器"><a href="#2-2-增强器" class="headerlink" title="2.2 增强器"></a>2.2 增强器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">proceed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationImpl</span> <span class="keyword">implements</span> <span class="title">MyInvocation</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   List&lt;MyInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> size =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   TargetMethod targetMethod;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> size == interceptors.size()?</span><br><span class="line">               targetMethod.getMethod()</span><br><span class="line">                     .invoke(</span><br><span class="line">                           targetMethod.getTarget(),</span><br><span class="line">                           targetMethod.getArgs()</span><br><span class="line">                     ):</span><br><span class="line">               interceptors.get(size++)</span><br><span class="line">                     .invoke(<span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationImpl</span><span class="params">(List&lt;MyInterceptor&gt; interceptors, TargetMethod targetMethod)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">      <span class="keyword">this</span>.targetMethod = targetMethod;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-对方法的增强类"><a href="#2-3-对方法的增强类" class="headerlink" title="2.3 对方法的增强类"></a>2.3 对方法的增强类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object target;</span><br><span class="line"></span><br><span class="line">   List&lt;MyInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MyInterceptor a)</span> </span>&#123;</span><br><span class="line">      interceptors.add(a);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyInvocationImpl(</span><br><span class="line">            interceptors,</span><br><span class="line">            <span class="keyword">new</span> TargetMethod(</span><br><span class="line">                  target,</span><br><span class="line">                  method,</span><br><span class="line">                  args</span><br><span class="line">            )</span><br><span class="line">      ).proceed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-测试类"><a href="#2-4-测试类" class="headerlink" title="2.4 测试类"></a>2.4 测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      JdkProxy jdkProxy = <span class="keyword">new</span> JdkProxy(<span class="keyword">new</span> Cat());</span><br><span class="line">      jdkProxy.add(<span class="keyword">new</span> One());</span><br><span class="line">      jdkProxy.add(<span class="keyword">new</span> Two());</span><br><span class="line">      ((Animal) jdkProxy.getProxy()).eat(<span class="string">&quot;事务&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三，AOP相关概念"><a href="#三，AOP相关概念" class="headerlink" title="三，AOP相关概念"></a>三，AOP相关概念</h1></li></ol><p>AOP：全称是 Aspect Oriented Programming 即：面向切面编程。就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。<br>​</p><ul><li>作用：<br>在程序运行期间，不修改源码对已有方法进行增强。</li><li>优势：<br>减少重复代码<br>提高开发效率<br>维护方便</li></ul><p>AOP 相关术语</p><ul><li>Joinpoint(连接点):<br>所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。</li><li>Pointcut(切入点):<br>所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</li><li>Advice(通知/增强):<br>所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。<br>通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</li><li>Introduction(引介):<br>引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</li><li>Target(目标对象):被代理对象<br>代理的目标对象。</li><li>Weaving(织入):<br>是指把增强应用到目标对象来创建新的代理对象的过程。<br>spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</li><li>Proxy（代理:<br>一个类被 AOP 织入增强后，就产生一个结果代理类。</li><li>Aspect(切面):<br>是切入点和通知（引介的结合）</li></ul><p>​</p><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。<br>​</p><blockquote><p>至此，我们通过两种方式完成了多重代理实现AOP，也简单介绍了两种实现动态代理的方式，和AOP相关的一些概念。下一篇将开始分析注解版Aop源码。</p></blockquote><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[九]三级缓存&amp;循环依赖</title>
      <link href="/2022/01/11/Spring/Spring%5B%E4%B9%9D%5D%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98&amp;%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/01/11/Spring/Spring%5B%E4%B9%9D%5D%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98&amp;%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇补充了一下Spring的组件，注解和扩展点，在开发中如果清楚的了解这些东西，会对你的案例设计，产生意想不到的效果。我呢，只是对这些组件注解扩展点进行一个介绍分析，具体的如何为业务赋能还需要结合实际的开发场景。</p></blockquote><ol><li>什么是循环依赖？</li><li>有几种循环依赖？</li><li>Spring是如何解决循环依赖的？</li><li>Spring为什么用三级缓存解决循环依赖，用二级可不可以？</li><li>当目标对象产生代理对象时，Spring容器中(第一级缓存)到底存储的是谁？<h2 id="一，问题-amp-答案"><a href="#一，问题-amp-答案" class="headerlink" title="一，问题&amp;答案"></a>一，问题&amp;答案</h2><h2 id="1-什么是循环依赖"><a href="#1-什么是循环依赖" class="headerlink" title="1.什么是循环依赖"></a>1.什么是循环依赖</h2></li></ol><p>类和类之间的依赖关系形成了闭环，就叫做循环依赖。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639057921722-1d73190e-b4e3-4813-a669-7e2f6deceb02.png#clientId=ue695aaea-210e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=574&id=uf8df2a48&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1148&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140784&status=done&style=none&taskId=udedabf40-8834-44f2-a5d7-3625742af07&title=&width=744" alt="image.png"></p><h2 id="2-有几种循环依赖"><a href="#2-有几种循环依赖" class="headerlink" title="2.有几种循环依赖"></a>2.有几种循环依赖</h2><ul><li>通过构造方法进行依赖注入时产生的循环依赖问题。</li><li>通过setter方法进行依赖注入且是在多例(原型)模式下产生的循环依赖问题。</li><li>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li></ul><p>​</p><p><strong>注意：在Spring中，只有【第三种方式】的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。</strong></p><blockquote><ul><li>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</li><li>第二种setter方法&amp;&amp;多例的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。</li></ul></blockquote><p>回顾一下单实例bean创建的过程<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639060379658-21a3857d-017b-4455-8c3a-e2c56921a831.png#clientId=ue695aaea-210e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u86884e18&margin=%5Bobject%20Object%5D&name=image.png&originHeight=566&originWidth=3022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126898&status=done&style=none&taskId=udead99ff-8461-4594-9242-6babc3df859&title=&width=1511" alt="image.png"></p><h2 id="3-Spring是如何解决循环依赖的？"><a href="#3-Spring是如何解决循环依赖的？" class="headerlink" title="3.Spring是如何解决循环依赖的？"></a>3.Spring是如何解决循环依赖的？</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639064715854-5a8b248b-7e80-40dc-bfbf-14009d38faa0.jpeg#clientId=ue695aaea-210e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7fc45cd7&margin=%5Bobject%20Object%5D&name=%E4%B8%A4%E4%B8%AAbean%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg&originHeight=436&originWidth=3418&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121277&status=done&style=none&taskId=u904da0f4-8ef0-4879-92f2-9f0d06a2e08&title=" alt="两个bean循环依赖的创建流程.jpg"></p><p><a href="https://www.processon.com/view/link/61b224c1e0b34d28b2784777">下载原图可点击这里</a><br>​</p><p>1.A创建过程中需要B，于是A将自己放到三级缓存去实例化B</p><p>2.B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，没有，再查三级缓存，找到了A，然后把三级缓存里面的A放到二级缓存里面，并删除三级缓存里面的A。</p><p>3.B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A还未创建完），然后接着回来创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面。</p><p>spring解决循环依赖依靠的是Bean的中间态这个概念，而这个中间态指的是已经实例化但还没初始化的状态—–&gt;半成品。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DefaultSingletonBeanRegistry</span></span><br><span class="line"><span class="comment">//一级缓存：实例化完的bean</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三级缓存：单例bean工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级缓存：早期暴露的bean</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h2 id="4-Spring为什么用三级缓存解决循环依赖，用二级可不可以？"><a href="#4-Spring为什么用三级缓存解决循环依赖，用二级可不可以？" class="headerlink" title="4.Spring为什么用三级缓存解决循环依赖，用二级可不可以？"></a>4.Spring为什么用三级缓存解决循环依赖，用二级可不可以？</h2><p><strong>为什么第三级缓存要使用ObjectFactory？需要提前产生代理对象。</strong><br><strong>​</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639067436550-cd7f2d6d-2f4d-46d4-927e-1513bbb9ddd1.jpeg#clientId=ue695aaea-210e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u28d585e6&margin=%5Bobject%20Object%5D&name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg&originHeight=512&originWidth=1781&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105610&status=done&style=none&taskId=ub455ba8b-235c-4a8b-b731-50e07cfbef2&title=" alt="未命名文件.jpg"><br><strong>​</strong></p><p><strong>什么时候将Bean的引用提前暴露给第三级缓存的ObjectFactory持有？时机就是在第一步实例化之后，第二步依赖注入之前，完成此操作。</strong><br><strong>​</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639067733807-6abdbf62-cabd-4557-9313-02851a8872cd.png#clientId=ue695aaea-210e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=716&id=u59b22b56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1432&originWidth=2948&originalType=binary&ratio=1&rotation=0&showTitle=false&size=256835&status=done&style=none&taskId=u220405cd-bdba-452f-b153-058dbea7e87&title=&width=1474" alt="image.png"></p><p>至此，我就解释清楚了整个三级缓存和循环依赖。不得不感慨，在我大三的时候，这道题还号称是阿里P7的面试题，大四的时候，我就连续四场面试被问到，行业内卷啊。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[八]注解&amp;组件篇</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%85%AB%5D%E6%B3%A8%E8%A7%A3&amp;%E7%BB%84%E4%BB%B6%E7%AF%87/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%85%AB%5D%E6%B3%A8%E8%A7%A3&amp;%E7%BB%84%E4%BB%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>写在前面：最近在编译最新版spring源码的时候，踩了写小坑。先来看一下最新的官方文档：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a><br>在build from source里面声明了最新的编译过程：<a href="https://github.com/spring-projects/spring-framework/wiki/Build-from-Source">https://github.com/spring-projects/spring-framework/wiki/Build-from-Source</a><br>由于最近spring做了一些升级，想要在本地构建spring源码，需要使用jdk17。<br>此外，最近gradle的语法也因为版本的原因，改动很大。想要在spring源码里面对gradle进行一些定制化配置的时候，可以参照gradle官网。<br><a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p></blockquote><h2 id="1-注解"><a href="#1-注解" class="headerlink" title="1.注解"></a>1.注解</h2><h3 id="1-1总览"><a href="#1-1总览" class="headerlink" title="1.1总览"></a>1.1总览</h3><ul><li>@Bean   容器中注册组件</li><li>@Primary    同类组件如果有多个，标注主组件</li><li>@DependsOn  组件之间声明依赖关系</li><li>@Lazy   组件懒加载（最后使用的时候才会去创建）</li><li>@Scope  声明组件的作用范围</li><li>@Configuration  声明这是一个配置类，替换xml</li><li>@Component  @Controller @Service @Repository</li><li>@Indexed    加速注解，所有标注了@Indexed的组件，直接会启动快速加载</li><li>@Order  数字越小，优先级越高，越先工作</li><li>@ComponentScan  包扫描</li><li>@Conditional    条件注入</li><li>@Import 导入第三方jar包中的组件，或者定制批量导入组件逻辑</li><li>@ImportResource 导入以前的xml配置文件，让其生效</li><li>@Profile 基于多环境激活</li><li>@PropertySource 外部properties配置文件和javaBean进行绑定，结合ConfigurationProperties</li><li>@PropertySources    @PropertySource的组合注解</li><li>@Autowired 自动装配</li><li>@Qualifier  精准指定</li><li>@Resource jsr250规范的jdk自带注解</li><li>@Value  取值，计算机环境变量，jvm系统 xxx</li><li>@Lookup 单例组件依赖非单例组件，非单例组件获取需要使用方法<h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2.案例"></a>1.2.案例</h3><code>com.yhd.annotation.AnnoMainTest</code><br>​</li></ul><h2 id="2-组件与SPI扩展点机制"><a href="#2-组件与SPI扩展点机制" class="headerlink" title="2.组件与SPI扩展点机制"></a>2.组件与SPI扩展点机制</h2><h3 id="2-1总览"><a href="#2-1总览" class="headerlink" title="2.1总览"></a>2.1总览</h3><ol><li>基础接口<br> Resource+ResourceLoader 将来自各种不同渠道的配置文件等进行一层抽象封装，让开发人员不必关注于底层的细节实现，通过资源加载器加载资源。<br> BeanFactory ioc容器顶层接口 ✅<br> BeanDefinition  从resource解析出bean的定义信息 ✅<br> BeanDefinitionReader    bean定义信息读取器 ，从resource 读取解析 BeanDefinition<br> BeanDefinitionRegistry  bean定义信息的注册中心 解析出来的BeanDefinition信息会被注册到这里<br> ApplicationContext      ioc核心接口 ✅<br> Aware   实现xxxAware接口是为了能够获取到xxx相关的一些属性 ✅<pre><code> BeanNameAware BeanFactoryAware ApplicationEventPublisherAware ApplicationContextAware ApplicationStartupAware BeanClassLoaderAware ImportAware EnvironmentAware</code></pre></li><li>生命周期-后置处理器<br> BeanFactoryPostProcessor ✅<pre><code> BeanDefinitionRegistryPostProcessor ✅</code></pre> InitializingBean ✅<br> DisposableBean ✅<br> BeanPostProcessor ✅<br> SmartInitializingSingleton ✅</li><li>监听器<br> ApplicationListener ✅<h3 id="2-2案例"><a href="#2-2案例" class="headerlink" title="2.2案例"></a>2.2案例</h3></li></ol><p><code>com.yhd.annotation.AnnoMainTest</code><br>​</p><p>补充：spring源码地址：<a href="https://gitee.com/yin_huidong/spring.git">https://gitee.com/yin_huidong/spring.git</a><br>​</p><p>此源码main分支为手动翻译好的中文注释版spring源码。</p><h1 id="一，组件注册"><a href="#一，组件注册" class="headerlink" title="一，组件注册"></a>一，组件注册</h1><h2 id="1-Configuration-amp-Bean"><a href="#1-Configuration-amp-Bean" class="headerlink" title="1.Configuration&amp;Bean"></a>1.Configuration&amp;Bean</h2><p><code>@Configuration</code>注解标识的类标识这是一个Spring的配置类。<br>​</p><p><code>@Bean</code>注解：给容器中注册一个bean，id默认是方法名作为id。<br>​</p><ul><li>value：指定id名</li><li>initMethod：指定初始化方法</li><li>destoryMethod：指定销毁方法</li></ul><p>​</p><h3 id="1-1-SpringConfig"><a href="#1-1-SpringConfig" class="headerlink" title="1.1 SpringConfig"></a>1.1 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;,initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Person"><a href="#1-2-Person" class="headerlink" title="1.2 Person"></a>1.2 Person</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-Test"><a href="#1-3-Test" class="headerlink" title="1.3 Test"></a>1.3 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext ioc =</span><br><span class="line">            <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person person = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-RunWith-amp-ContextConfiguration"><a href="#2-RunWith-amp-ContextConfiguration" class="headerlink" title="2.RunWith&amp;ContextConfiguration"></a>2.RunWith&amp;ContextConfiguration</h2><p><code>@RunWith</code>：Spring整合Junit4。<br>​</p><p><code>@ContextConfiguration</code>：指定配置类。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3.ComponentScan"></a>3.ComponentScan</h2><p>@ComponentScan(“com.yhd”) 组件扫描</p><ul><li>value:指定扫描的包</li><li><code>includeFilters = &#123;@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class)&#125;</code></li></ul><p>只包含哪些包（需要指明：useDefaultFilters = false）</p><ul><li><p>type </p><blockquote><p>type:FilterType.ANNOTATION:按照注解过滤<br>type=FilterType.ASSIGNABLE_TYPE：按照类型过滤<br>type=ASPECTJ,切面<br>type=REGEX,正则<br>type=CUSTOM，定制（需要实现TypeFilter接口）</p></blockquote></li><li><p>excludeFilters:指明排除哪些包不被扫描</p></li></ul><p>​</p><h3 id="3-1-SpringConfig"><a href="#3-1-SpringConfig" class="headerlink" title="3.1 SpringConfig"></a>3.1 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.yhd&quot;,</span></span><br><span class="line"><span class="meta">        includeFilters = &#123;</span></span><br><span class="line"><span class="meta">                @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class),</span></span><br><span class="line"><span class="meta">                @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE)</span></span><br><span class="line"><span class="meta">        &#125;, excludeFilters = &#123;&#125;, useDefaultFilters = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;, initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Test"><a href="#3-2-Test" class="headerlink" title="3.2 Test"></a>3.2 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//查看容器中bean的名字</span></span><br><span class="line">        String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Scope"><a href="#4-Scope" class="headerlink" title="4.Scope"></a>4.Scope</h2><p>作用：设置组件作用域。<br>​</p><p>@Scope 默认是单例的<br>点击进入该注解，在此点击进入文档注释中的ConfigurableBeanFactory<br>可以看到该注解的几个取值：</p><ul><li>singleton 单例</li><li>prototype 多例</li><li>request 同一次请求</li><li>session 同一个session作用域</li></ul><p>在scope=singleton时，对象在容器已创建立即加入容器。<br>在scope=prototype时，对象每次调用的时候都会添加到容器。<br>​</p><h3 id="4-1-SpringConfig"><a href="#4-1-SpringConfig" class="headerlink" title="4.1 SpringConfig"></a>4.1 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;, initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Test"><a href="#4-2-Test" class="headerlink" title="4.2 Test"></a>4.2 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p1 = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">    Person p2 = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">    System.out.println(p1==p2?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Lazy"><a href="#5-Lazy" class="headerlink" title="5.Lazy"></a>5.Lazy</h2><p><code>@Lazy</code> 懒加载<br>单实例bean，默认在容器创建时候添加对象。<br>懒加载：容器启动不创建对象，第一次获取/使用时在创建对象并初始化。<br>​</p><h3 id="5-1-SpringConfig"><a href="#5-1-SpringConfig" class="headerlink" title="5.1 SpringConfig"></a>5.1 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;, initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person已经加载到容器中！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-Test"><a href="#5-2-Test" class="headerlink" title="5.2 Test"></a>5.2 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比加上这个注解前后，容器中单实例bean的变化：<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1632277956022-cec1b5d9-8ba7-421c-83aa-dfffe53f58f9.png#clientId=ucdb58a32-1b99-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=udc264d0f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=644&originWidth=2130&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1927983&status=done&style=none&taskId=ufbe77aa0-15f8-4584-8909-c8cc9d359ad&title=&width=1065" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1632278031980-acef9aef-aee4-494e-8b90-c65d62499094.png#clientId=ucdb58a32-1b99-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=305&id=ud471a365&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=2100&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1763263&status=done&style=none&taskId=ucbadda80-415b-480f-8e55-8872463a562&title=&width=1050" alt="image.png"></p><h2 id="6-Conditional"><a href="#6-Conditional" class="headerlink" title="6.Conditional"></a>6.Conditional</h2><p>@Conditional<br>点击进入<br><code>Class&lt;? extends Condition&gt;[] value();</code><br>发现这个注解里面的value属性需要传入一个Condition数组，<br>点击进入Condition<br><code>boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);</code><br>因此，可以实现Condition接口，来使用该注解<br>​</p><p>当该注解加在方法上，标识满足条件时，该方法会执行<br>当该注解加在类上时，表示满足条件时，该类里面的所有方法才会执行，否则一个都不执行。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All &#123;<span class="doctag">@link</span> Condition&#125;s that must &#123;<span class="doctag">@linkplain</span> Condition#matches match&#125;</span></span><br><span class="line"><span class="comment"> * in order for the component to be registered.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if the condition matches.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-案例：根据当前系统环境将对应的bean加入到容器"><a href="#6-1-案例：根据当前系统环境将对应的bean加入到容器" class="headerlink" title="6.1 案例：根据当前系统环境将对应的bean加入到容器"></a>6.1 案例：根据当前系统环境将对应的bean加入到容器</h3><h4 id="6-1-1-SpringConfig"><a href="#6-1-1-SpringConfig" class="headerlink" title="6.1.1 SpringConfig"></a>6.1.1 SpringConfig</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(&#123;Mac.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person已经加载到容器中！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;person2&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(&#123;Linux.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person已经加载到容器中！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-条件类"><a href="#6-1-2-条件类" class="headerlink" title="6.1.2 条件类"></a>6.1.2 条件类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mac</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>).contains(<span class="string">&quot;Mac&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>).contains(<span class="string">&quot;linux&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-3-Test"><a href="#6-1-3-Test" class="headerlink" title="6.1.3 Test"></a>6.1.3 Test</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Person person = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        Person person2 = ioc.getBean(<span class="string">&quot;person2&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Import"><a href="#7-Import" class="headerlink" title="7.Import"></a>7.Import</h2><p>用来快速导入一个bean，默认类名是该类的全限定类名，单例。<br>​</p><h3 id="7-1-SpringConfig"><a href="#7-1-SpringConfig" class="headerlink" title="7.1 SpringConfig"></a>7.1 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Dog.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(&#123;Mac.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person已经加载到容器中！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;person2&quot;)</span></span><br><span class="line">    <span class="meta">@Conditional(&#123;Linux.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person已经加载到容器中！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">&quot;二十&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Test"><a href="#7-2-Test" class="headerlink" title="7.2 Test"></a>7.2 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Dog dog = ioc.getBean(Dog.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> dog!=<span class="keyword">null</span>;</span><br><span class="line">    dog.setId(<span class="number">1</span>);</span><br><span class="line">    dog.setName(<span class="string">&quot;asdfg&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;dog = &quot;</span> + dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-ImportSelector"><a href="#8-ImportSelector" class="headerlink" title="8.ImportSelector"></a>8.ImportSelector</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span></span><br><span class="line"><span class="comment"> * or regular component classes to import.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击查看<code>@Import</code>注解可以发现：<br>​</p><p>里面还可以传入{<code>@link Configuration</code>}, {<code>@link ImportSelector</code>}, {<code>@link ImportBeanDefinitionRegistrar</code>}<br>​</p><p><strong>importSelector其实就是一个接口，我们需要通过实现它来传入impot注解。</strong><br><strong>​</strong></p><h3 id="8-1-MyImportSelector"><a href="#8-1-MyImportSelector" class="headerlink" title="8.1 MyImportSelector"></a>8.1 MyImportSelector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.yhd.pojo.Person&quot;</span>,<span class="string">&quot;com.yhd.pojo.Dog&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-SpringConfig"><a href="#8-2-SpringConfig" class="headerlink" title="8.2 SpringConfig"></a>8.2 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-Test"><a href="#8-3-Test" class="headerlink" title="8.3 Test"></a>8.3 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-ImportBeanDefinitionRegistrar"><a href="#9-ImportBeanDefinitionRegistrar" class="headerlink" title="9.ImportBeanDefinitionRegistrar"></a>9.ImportBeanDefinitionRegistrar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-MyImportBeanDefinitionRegistrar"><a href="#9-1-MyImportBeanDefinitionRegistrar" class="headerlink" title="9.1 MyImportBeanDefinitionRegistrar"></a>9.1 MyImportBeanDefinitionRegistrar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;dog&quot;</span>, <span class="keyword">new</span> RootBeanDefinition(<span class="string">&quot;com.yhd.pojo.Dog&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-MyImportBeanDefinitionRegistrar"><a href="#9-2-MyImportBeanDefinitionRegistrar" class="headerlink" title="9.2 MyImportBeanDefinitionRegistrar"></a>9.2 MyImportBeanDefinitionRegistrar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-Test"><a href="#9-3-Test" class="headerlink" title="9.3 Test"></a>9.3 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-FactoryBean"><a href="#10-FactoryBean" class="headerlink" title="10.FactoryBean"></a>10.FactoryBean</h2><p>​</p><p>spring的工厂模式造Bean</p><ol><li>如果传入id获取到的是工厂造的bean</li><li>如果传入的是&amp;id获取到的是工厂本身</li></ol><p>​</p><h3 id="10-1-PersonFactory"><a href="#10-1-PersonFactory" class="headerlink" title="10.1 PersonFactory"></a>10.1 PersonFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">&quot;FactoryBean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-SpringConfig"><a href="#10-2-SpringConfig" class="headerlink" title="10.2 SpringConfig"></a>10.2 SpringConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonFactory <span class="title">personFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-Test"><a href="#10-3-Test" class="headerlink" title="10.3 Test"></a>10.3 Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PersonFactory personFactory = (PersonFactory) ioc.getBean(<span class="string">&quot;&amp;personFactory&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;personFactory = &quot;</span> + personFactory);</span><br><span class="line"></span><br><span class="line">        Person person = (Person) ioc.getBean(<span class="string">&quot;personFactory&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*personFactory = com.yhd.factory.PersonFactory@6e20b53a</span></span><br><span class="line"><span class="comment">        person = Person(id=1, name=FactoryBean)*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-原理"><a href="#10-4-原理" class="headerlink" title="10.4 原理"></a>10.4 原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//more能获取到工厂bean的方法就是在id前加上前缀&amp;</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="11-LookUp"><a href="#11-LookUp" class="headerlink" title="11.LookUp"></a>11.LookUp</h2><p>​</p><p>如果有一个类C,需要用到类B,如果使用@Autowired注解注入B,那么B每次调用都是同一个对象，即使B不是单例的，现在我希望每次调用B都是不一样的，那么实现方案有2个：<br>​</p><h3 id="11-1-每次从容器中获取B"><a href="#11-1-每次从容器中获取B" class="headerlink" title="11.1 每次从容器中获取B"></a>11.1 每次从容器中获取B</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(scopeName= ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">//原型 也就是非单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B b = (B)applicationContext.getBean(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        b.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-使用-lookup注解"><a href="#11-2-使用-lookup注解" class="headerlink" title="11.2 使用@lookup注解"></a>11.2 使用@lookup注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(scopeName= ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">//原型 也就是非单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B b = getB();</span><br><span class="line">        b.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> B <span class="title">getB</span><span class="params">()</span></span>; <span class="comment">//一般都是抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二，生命周期"><a href="#二，生命周期" class="headerlink" title="二，生命周期"></a>二，生命周期</h1><h2 id="1-Bean指定初始化和销毁方法"><a href="#1-Bean指定初始化和销毁方法" class="headerlink" title="1.@Bean指定初始化和销毁方法"></a>1.@Bean指定初始化和销毁方法</h2><p>bean的生命周期：创建，初始化，使用，销毁。<br>​</p><p>容器管理bean的生命周期：我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候，来调用我们自定义的初始化和销毁方法。<br>​</p><p>单例模式：先是执行对象的无参构造，赋值后，执行初始化方法，在创建容器的时候加入对象，在容器关闭时，执行销毁方法。<br>​</p><p>多例模式：先创建容器，每次调用对象时，调用无参构造方法，赋值后，执行初始化方法。对象的销毁由java垃圾回收机制回收。<br>​</p><h3 id="1-1-单例"><a href="#1-1-单例" class="headerlink" title="1.1 单例"></a>1.1 单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;,initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person person = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1632297278217-55f6c676-b8f4-42ce-acdb-aa054c0f7826.png#clientId=ucdb58a32-1b99-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=119&id=uabd5b8c5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246134&status=done&style=none&taskId=u0d0ac7fa-2428-488b-9585-0d9a885e14b&title=&width=383" alt="image.png"></p><h3 id="1-2-多例"><a href="#1-2-多例" class="headerlink" title="1.2 多例"></a>1.2 多例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scope(value = &quot;prototype&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;,initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1632297312477-2e671031-6e89-4414-8971-d32a0fbe2817.png#clientId=ucdb58a32-1b99-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=136&id=ua55b3236&margin=%5Bobject%20Object%5D&name=image.png&originHeight=272&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&size=271870&status=done&style=none&taskId=u0f9b91a9-dcd1-48f0-ba85-df6e50a3127&title=&width=371" alt="image.png"></p><h2 id="2-实现接口完成对象的初始化和销毁"><a href="#2-实现接口完成对象的初始化和销毁" class="headerlink" title="2.实现接口完成对象的初始化和销毁"></a>2.实现接口完成对象的初始化和销毁</h2><p><strong>InitializingBean, DisposableBean</strong><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterPropertiesSet()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;容器创建成功！&quot;</span>);</span><br><span class="line">        Person person = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1632297595603-fe4edd53-395c-4aeb-8571-fb7fa94a78bc.png#clientId=ucdb58a32-1b99-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=139&id=uc648cc12&margin=%5Bobject%20Object%5D&name=image.png&originHeight=278&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&size=287741&status=done&style=none&taskId=ucace1dc0-dd44-4a89-943a-926fe855e33&title=&width=381" alt="image.png"></p><h2 id="3-BeanPostProcessor"><a href="#3-BeanPostProcessor" class="headerlink" title="3.BeanPostProcessor"></a>3.BeanPostProcessor</h2><p>bean的后置处理器，在bean的初始化前后做一些处理工作，需要加入到容器中。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyBeanPostProcessor.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-BeanFactoryPostProcessor"><a href="#4-BeanFactoryPostProcessor" class="headerlink" title="4.BeanFactoryPostProcessor"></a>4.BeanFactoryPostProcessor</h2><p>bean工厂的后置处理器，可以在spring解析完配置文件，创建对象之前，对bean的定义信息进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;=======BeanFactoryPostProcessor=========&quot;</span>);</span><br><span class="line">      BeanDefinition person = beanFactory.getBeanDefinition(<span class="string">&quot;computer&quot;</span>);</span><br><span class="line">      person.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">      System.out.println(<span class="string">&quot;=======BeanFactoryPostProcessor=========&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认Computer对象是单实例的，</span></span><br><span class="line"><span class="comment"> * 通过beanFactory的后置处理器处理之后，变成原型的</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 执行时机：打断点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*ioc容器创建的12个核心方法里面*/</span></span><br><span class="line">   Computer computer = ioc.getBean(Computer.class);</span><br><span class="line">   Computer computer2 = ioc.getBean(Computer.class);</span><br><span class="line">   System.out.println(computer == computer2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-BeanDefinitionRegistryPostProcessor"><a href="#5-BeanDefinitionRegistryPostProcessor" class="headerlink" title="5.BeanDefinitionRegistryPostProcessor"></a>5.BeanDefinitionRegistryPostProcessor</h2><p>他是bean工厂后置处理器的子类<br><em>插播一条广告：BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor之间的关系？</em><br><em>BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor的子类和扩展</em><br><em>它里面 搞了一个新的方法 postProcessBeanDefinitionRegistry ，可以往容器中注册更多的bd信息。</em><br><em>扩展点：</em><br><em>①BeanFactoryPostProcessor 对bd信息进行修改</em><br><em>②postProcessBeanDefinitionRegistry 添加更多的bd信息</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">/*这个是她的父类里面的方法 对 bd信息进行修改*/</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">/*这个是给他本身的方法，可以添加额外的 bd 信息*/</span></span><br><span class="line">      GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">      beanDefinition.setBeanClass(RegistryBean.class);</span><br><span class="line">      <span class="comment">//beanDefinition.setScope();</span></span><br><span class="line">      registry.registerBeanDefinition(<span class="string">&quot;registryBean&quot;</span>,beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBeanDefinitionRegistryPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RegistryBean registryBean = ioc.getBean(<span class="string">&quot;registryBean&quot;</span>, RegistryBean.class);</span><br><span class="line">   System.out.println(<span class="string">&quot;registryBean = &quot;</span> + registryBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-SmartInitializingSingleton"><a href="#6-SmartInitializingSingleton" class="headerlink" title="6.SmartInitializingSingleton"></a>6.SmartInitializingSingleton</h2><p><em>在所有的单实例bean 通过getBean方法完成初始化之后,就会去查找这个类型的SmartInitializingSingleton 的 组件 ，执行里面的 方法.</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySmartInitializingSingleton</span> <span class="keyword">implements</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;断点调试。。。。&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Lifecycle-amp-amp-SmartLifecycle"><a href="#7-Lifecycle-amp-amp-SmartLifecycle" class="headerlink" title="7.Lifecycle &amp;&amp; SmartLifecycle"></a>7.Lifecycle &amp;&amp; SmartLifecycle</h2><p>容器创建完成之后的回调，相当于<br><em>传递的参数autoStartUpOnly是干嘛的？</em><br><em>表示只启动SmartLifeCycle生命周期对象，并且启动的对象autoStartUpOnly必须是true，</em><br><em>不会启动普通的生命周期对象，</em><br><em>false的时候，会启动全部的生命周期对象。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLifeCycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> running =<span class="keyword">false</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">true</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo one start!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">false</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo one stop!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> running;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSmartLifeCycle</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">false</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">true</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo two start!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">false</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo two stop!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> running;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三，属性赋值"><a href="#三，属性赋值" class="headerlink" title="三，属性赋值"></a>三，属性赋值</h1><h2 id="1-Value"><a href="#1-Value" class="headerlink" title="1.Value"></a>1.Value</h2><p><code>@Value</code>注解可以给属性赋值，支持SPEL表达式，${},,基本数值。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Value(&quot;二十&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-PropertySource"><a href="#2-PropertySource" class="headerlink" title="2.PropertySource"></a>2.PropertySource</h2><p><code>@PropertySource</code>加载外部属性文件<br>​</p><p>支持一次写多个，标注在配置类上。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name=二十</span><br><span class="line">person.age=<span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:person.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四，自动装配"><a href="#四，自动装配" class="headerlink" title="四，自动装配"></a>四，自动装配</h1><p>Spring利用依赖注入DI，完成对IOC容器中各个组件的依赖关系赋值。<br>​</p><h2 id="1-Autowired-amp-amp-Qualifier-amp-amp-Primary"><a href="#1-Autowired-amp-amp-Qualifier-amp-amp-Primary" class="headerlink" title="1.@Autowired  &amp;&amp; @Qualifier  &amp;&amp; @Primary"></a>1.@Autowired  &amp;&amp; @Qualifier  &amp;&amp; @Primary</h2><ol><li>默认优先按照类型去容器中找对应的组件，<code>ioc.getBean(BookDao.class);</code></li><li>如果找到多个相同类型的组件，再讲属性的名称作为组件的id去容器中查找<code>ioc.getBean(&quot;bookDao&quot;);</code></li><li><code>@Qualifier(&quot;bookDao&quot;)</code>,使用<code>@Qualifier</code>指定要装配的组件的id，而不是使用属性名</li><li>自动装配默认一定要将属性赋值好，没有就会报错.可以使用<code>@Autowired（required=false）</code></li><li><code>@Primary</code> 让Spring进行自动装配的时候，默认使用首选bean，也可以继续使用<code>@Qualifier</code>指定需要装配的bean的id</li></ol><p>​</p><h2 id="2-Resource-amp-amp-Inject"><a href="#2-Resource-amp-amp-Inject" class="headerlink" title="2.@Resource  &amp;&amp; @Inject"></a>2.@Resource  &amp;&amp; @Inject</h2><p>spring还支持使用<code>@Resource</code>（jsr250）和<code>@inject</code>（jsr330）【java规范的注解】<br>​</p><p><code>@Resource</code>：可以和<code>@Autowired</code>一样实现自动装配，默认按照组件名称进行装配.不支持<code>@Primary</code>和required=false<br>​</p><p><code>@Inject</code>：需要导入javax.inject包，没有required=false<br>​</p><h2 id="3-方法，构造器位置的自动注入"><a href="#3-方法，构造器位置的自动注入" class="headerlink" title="3.方法，构造器位置的自动注入"></a>3.方法，构造器位置的自动注入</h2><p><code>@Autowired</code>：构造器，参数，方法，属性，都是从容器中获取参数组件的值。</p><ol><li>标注在方法上：<code>@Bean</code>+方法参数，参数从容器中获取，默认不写<code>@Autowired</code>效果是一样的，都能自动装配</li><li>标在构造器上：如果组件只有一个构造器，这个有参构造器的<code>@Autowired</code>可以省略</li><li>放在参数位置</li></ol><p>​</p><h3 id="3-1-构造器注入"><a href="#3-1-构造器注入" class="headerlink" title="3.1 构造器注入"></a>3.1 构造器注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//此处注解可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dog</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person=person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Dog dog = ioc.getBean(<span class="string">&quot;dog&quot;</span>, Dog.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;dog = &quot;</span> + dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-set-注入"><a href="#3-2-set-注入" class="headerlink" title="3.2 set()注入"></a>3.2 set()注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//此处的注解不能省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person=person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Bean的方式"><a href="#3-3-Bean的方式" class="headerlink" title="3.3 @Bean的方式"></a>3.3 @Bean的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;person&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;dog&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//此处的注解可以省略不写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Aware接口，自定义组件使用Spring底层的组件"><a href="#4-Aware接口，自定义组件使用Spring底层的组件" class="headerlink" title="4.Aware接口，自定义组件使用Spring底层的组件"></a>4.Aware接口，自定义组件使用Spring底层的组件</h2><p>自定义接口想要使用<code>Spring</code>底层的一些组件<code>（ApplicationContext，BeanFactory，xxx）</code><br>​</p><p>自定义接口实现<code>xxxAware</code>，在创建对象的时候，会调用接口规定的方法注入相关组件，Aware吧Spring底层的一些接口注入到自定义的<code>Bean</code>中<br>​</p><p><code>xxxAware</code>：功能：使用<code>xxxProcessor</code><br>​</p><p><code>ApplicationContextAware--&gt;ApplicationContextAwareProcessor</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ioc;</span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//自此处打断点</span></span><br><span class="line">        <span class="keyword">this</span>.ioc=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//此处打断点</span></span><br><span class="line">        <span class="keyword">this</span>.beanFactory=beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Profile根据环境装配"><a href="#5-Profile根据环境装配" class="headerlink" title="5.@Profile根据环境装配"></a>5.@Profile根据环境装配</h2><p><code>@Profile</code>:指定组件在那个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p><ol><li>加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中，默认是default环境</li><li>写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li><li>没有标识环境标识的bean在任何环境下都是加载的。</li></ol><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringValueResolver resolver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dev&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String pwd)</span></span>&#123;</span><br><span class="line">        DruidDataSource source = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        source.setName(name);</span><br><span class="line">        source.setPassword(pwd);</span><br><span class="line">        source.setDriverClassName(driver);</span><br><span class="line">        source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;pro&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;pro&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource2</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String pwd)</span></span>&#123;</span><br><span class="line">        DruidDataSource source = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        source.setName(name);</span><br><span class="line">        source.setPassword(pwd);</span><br><span class="line">        source.setDriverClassName(driver);</span><br><span class="line">        source.setUrl(<span class="string">&quot;jdbc:mysql:///ssm&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource3</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span> String pwd)</span></span>&#123;</span><br><span class="line">        DruidDataSource source = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        source.setName(name);</span><br><span class="line">        source.setPassword(pwd);</span><br><span class="line">        source.setDriverClassName(driver);</span><br><span class="line">        source.setUrl(<span class="string">&quot;jdbc:mysql:///zuoye&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resolver=resolver;</span><br><span class="line">        driver = resolver.resolveStringValue(<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>激活环境：</p><ol><li>使用命令行动态参数：在虚拟机参数位置加载：</li></ol><p><code>-Dspring.profiles.active=test</code></p><ol start="2"><li>代码方式激活</li></ol><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnotationConfigApplicationContext ioc = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ioc.getEnvironment().setActiveProfiles(<span class="string">&quot;dev&quot;</span>);</span><br><span class="line">    ioc.register(SpringConfig4.class);</span><br><span class="line">    ioc.refresh();</span><br><span class="line">    String[] names = ioc.getBeanNamesForType(DataSource.class);</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五，事件驱动"><a href="#五，事件驱动" class="headerlink" title="五，事件驱动"></a>五，事件驱动</h1><h2 id="1-ApplicationListener-amp-amp-ApplicationEvent"><a href="#1-ApplicationListener-amp-amp-ApplicationEvent" class="headerlink" title="1.ApplicationListener &amp;&amp; ApplicationEvent"></a>1.ApplicationListener &amp;&amp; ApplicationEvent</h2><p>通过自定义不同类型的事件，使用不同的监听器监听不同类型的事件，做到jvm进程内的消息队列，事件驱动，解耦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   String message;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(source);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source,String message)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(source);</span><br><span class="line">      <span class="keyword">this</span>.message=message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;发布了一个事件：&quot;</span>+message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">      event.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试spring 的 ioc 容器的事件发布</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPublishEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(CONFIG_LOCATION);</span><br><span class="line">   ioc.publishEvent(<span class="keyword">new</span> MyEvent(<span class="string">&quot;&quot;</span>, <span class="string">&quot;这是我自定义的一个事件&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-EventListener"><a href="#2-EventListener" class="headerlink" title="2.@EventListener"></a>2.@EventListener</h2><p>对上面写法的一个优化，更加简洁，开发量更少，懒人必备神器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ioc.publishEvent(<span class="keyword">new</span> ApplicationEvent(<span class="string">&quot;hello，spring&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.getSource();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@EventListener(classes = ApplicationEvent.class)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;event = &quot;</span> + event);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[七]initializeBean()</title>
      <link href="/2022/01/11/Spring/Spring%5B%E4%B8%83%5DinitializeBean()/"/>
      <url>/2022/01/11/Spring/Spring%5B%E4%B8%83%5DinitializeBean()/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇分析了单实例bean创建过程中的属性赋值，接下来我们分析，单实例bean属性赋值之后的初始化<code>**initializeBean()**</code>。</p></blockquote><h2 id="1-initializeBean"><a href="#1-initializeBean" class="headerlink" title="1. initializeBean()"></a>1. initializeBean()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*检查当前bean是否实现了aware接口，再具体判断实现的哪个aware接口，做一些赋能操作。*/</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">/*初始化之前，后置处理器的调用点*/</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*执行初始化方法*/</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">/*初始化后的后置处理器执行点*/</span></span><br><span class="line"><span class="comment">/*典型应用：AOP的具体实现*/</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化之前，把当前bean实现的所有Aware接口都执行一遍。<code>**invokeAwareMethods()**</code><br>在初始化之前，调用后置处理器。<code>**applyBeanPostProcessorsBeforeInitialization()**</code><br>执行初始化逻辑。<code>**invokeInitMethods()**</code><br>执行后置处理器的调用点，典型的实现其实就是AOP。<code>**applyBeanPostProcessorsAfterInitialization()**</code><br>返回包装对象。<br>​</p><h2 id="2-invokeAwareMethods"><a href="#2-invokeAwareMethods" class="headerlink" title="2.invokeAwareMethods()"></a>2.invokeAwareMethods()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">ClassLoader bcl = getBeanClassLoader();</span><br><span class="line"><span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行相关的Aware接口方法。</p><h2 id="3-applyBeanPostProcessorsBeforeInitialization"><a href="#3-applyBeanPostProcessorsBeforeInitialization" class="headerlink" title="3.applyBeanPostProcessorsBeforeInitialization()"></a>3.applyBeanPostProcessorsBeforeInitialization()</h2><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="comment">/*beanPostProcessor的执行逻辑*/</span></span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环所有的后置处理器，执行前置方法，如果有一个返回结果为空，直接短路，后面的都不执行了。<br>​</p><h2 id="4-invokeInitMethods"><a href="#4-invokeInitMethods" class="headerlink" title="4.invokeInitMethods()"></a>4.invokeInitMethods()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">/*如果是实现了InitializingBean接口*/</span></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行afterPropertiesSet方法*/</span></span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line"><span class="comment">/*判断重写init方法没？*/</span></span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line"><span class="comment">/*执行重写的init方法*/</span></span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断实现了<code>**InitializingBean**</code>接口的，执行里面的方法。<br>判断重写了初始化方法的，执行重写的方法。</p><h3 id="4-1-invokeCustomInitMethod"><a href="#4-1-invokeCustomInitMethod" class="headerlink" title="4.1 invokeCustomInitMethod()"></a>4.1 invokeCustomInitMethod()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeCustomInitMethod</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">/*从bd获取init方法*/</span></span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line">Assert.state(initMethodName != <span class="keyword">null</span>, <span class="string">&quot;No init method set&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* isNonPublicAccessAllowed 非公开访问</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里完成之后就会获取到通过init方法定义的方法对象。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">Method initMethod = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">BeanUtils.findMethod(bean.getClass(), initMethodName) :</span><br><span class="line">ClassUtils.getMethodIfAvailable(bean.getClass(), initMethodName));</span><br><span class="line"><span class="comment">/*如果init方法为空*/</span></span><br><span class="line"><span class="keyword">if</span> (initMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.isEnforceInitMethod()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">&quot;Could not find an init method named &#x27;&quot;</span> +</span><br><span class="line">initMethodName + <span class="string">&quot;&#x27; on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No default init method named &#x27;&quot;</span> + initMethodName +</span><br><span class="line"><span class="string">&quot;&#x27; found on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ignore non-existent default lifecycle methods.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Invoking init method  &#x27;&quot;</span> + initMethodName + <span class="string">&quot;&#x27; on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将init方法转换成接口层面获取的initMethod*/</span></span><br><span class="line">Method methodToInvoke = ClassUtils.getInterfaceMethodIfPossible(initMethod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*反射执行方法*/</span></span><br><span class="line">ReflectionUtils.makeAccessible(methodToInvoke);</span><br><span class="line">methodToInvoke.invoke(bean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一些列处理，反射调用初始化方法。</p><h2 id="5-applyBeanPostProcessorsAfterInitialization"><a href="#5-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="5.applyBeanPostProcessorsAfterInitialization()"></a>5.applyBeanPostProcessorsAfterInitialization()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">* 一旦某个后置处理器返回的结果为空</span></span><br><span class="line"><span class="comment">* 就返回上一个后置处理器的结果，后面的后置处理器方法不在执行*/</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化之后，遍历所有的后置处理器，执行后置处理器的后置方法，如果有一个返回结果是空，直接返回，后面的后置处理器都不执行了。<br>​</p><p>至此，整个ioc容器的刷新流程就都分析完了，重点就在于单实例bean的创建流程，首先会去<code>**getBean() doGetBean() getSinglton() createBean() doCreateBean() populateBean() initializeBean()**</code>。下一篇我们将会去分析Spring的三级缓存和循环依赖。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[六]populateBean()</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%85%AD%5DpopulateBean()/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%85%AD%5DpopulateBean()/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上一篇中我们分析完了<code>**createBean()**</code>，并详解讲解了三中创建单实例bean对象的方法，在bean实例创建出来之后，就是对bean的属性赋值和初始化操作，本篇我们继续往下分析。</p></blockquote><h2 id="1-populateBean"><a href="#1-populateBean" class="headerlink" title="1.populateBean()"></a>1.populateBean()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*这里是判断假如beanWrapper是空，但是mbd中的属性还有值，那就说明需要抛出异常，因为没法给一个null赋值。*/</span></span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Cannot apply property values to null instance&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在设置属性之前，给任何实例化的bean后处理器修改bean状态的机会。例如，这可以用来支持各种类型的属性注入。*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mbd.isSynthetic()默认是false，取反成立。</span></span><br><span class="line"><span class="comment"> * 判断有没有instantiationAwareBeanPostProcessors，条件成立说明有。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="comment">/*这里又是后置处理器的一个调用点：实例化之后的调用，调用的是后置处理器的afterInstantiation方法。*/</span></span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="comment">/*返回值将决定当前实例需要在进行依赖注入处理，默认返回true*/</span></span><br><span class="line"><span class="keyword">if</span> (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是处理依赖注入的逻辑*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*三元运算符获取属性，有就把属性赋值给pvs ，没有就给一个null*/</span></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> resolvedAutowireMode = mbd.getResolvedAutowireMode();</span><br><span class="line"><span class="comment">/*这里判断依赖注入是按照名字注入还是按照类型注入，根据不同的选择走不同的处理逻辑。*/</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line"><span class="comment">/*吧属性进行一个包装*/</span></span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="comment">/*按照名字注入，根据字段名称查找依赖bean完成注入*/</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="comment">/*按照类型注入*/</span></span><br><span class="line"><span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*相当于处理了依赖数据后的pvs*/</span></span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*表示当前是否拥有instantiationAwareBeanPostProcessors需要执行*/</span></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="comment">/*是否需要进行依赖检察，不重要*/</span></span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*后置处理器的调用点*/</span></span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line"><span class="comment">/*典型应用：@Autowired 注解的注入*/</span></span><br><span class="line">PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pvs = pvsToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredPds == <span class="keyword">null</span>) &#123;</span><br><span class="line">filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">&#125;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*将完成依赖注入（合并后的pvs）的信息应用到实例上去*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.对man进行属性赋值的过程</span></span><br><span class="line"><span class="comment"> * 2.对women进行属性赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li><p>上来一套组合拳，先判断假如bean包装对象是空的，但是mbd中的属性还有值，那就说明需要抛出异常，因为没法给一个null赋值。</p></li><li><p>接下来就是在属性赋值之前，给任何实例化的bean后置处理器修改bean状态的机会。例如，这可以用来支持各种类型的属性注入。<code>**InstantiationAwareBeanPostProcessors**</code></p><blockquote><p>这里又是一个后置处理器的调用点，实例化之后的调用，调用的是后置处理器的<code>**afterInstantiation**</code>方法。这个处理器的返回值将决定当前bean实例是否要进行属性注入，返回false则表示直接返回，默认返回true。</p></blockquote></li><li><p>判断依赖注入按照名字注入还是按照类型注入，根据不同的选择走不同的处理逻辑。注意这里的处理并不是直接注入到bean中，而是解析到pvs中。</p><blockquote><p><strong>什么时候走这里？</strong><br><strong>必须显式的指定了配置了依赖，才会走这里。</strong></p></blockquote></li></ol><ul><li>如果是按照名字注入，就执行<code>**autowireByName()**</code>。</li><li>如果是按照类型注入，就执行<code>**autowireByType()**</code>。</li></ul><p>​</p><ol start="4"><li>判断当前是否还有<code>**InstantiationAwareBeanPostProcessors**</code>需要执行。</li><li>判断当前是否需要进行依赖检查、</li><li>如果还有<code>**InstantiationAwareBeanPostProcessors**</code>需要执行，循环执行后置处理器的方法</li><li>如果需要依赖检查，就走依赖检查的逻辑</li><li>如果合并后的依赖信息（pvs）不为空，就执行<code>**applyPropertyValues()**</code>进行属性赋值。</li></ol><p>​</p><p>接下来分析两种属性注入的方式，按照名字注入&amp;按照类型注入。</p><h2 id="2-autowireByName"><a href="#2-autowireByName" class="headerlink" title="2.autowireByName()"></a>2.autowireByName()</h2><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*bean实例中有该字段，且有该字段的setter方法，但是在bd中没有property属性。*/</span></span><br><span class="line">String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"><span class="comment">/*便利查找出来的集合，完成依赖注入。*/</span></span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="comment">/*条件成立说明beanFactory存在当前属性的bean实例，可以注入，说明找到对应的依赖信息数据了*/</span></span><br><span class="line"><span class="keyword">if</span> (containsBean(propertyName)) &#123;</span><br><span class="line"><span class="comment">/*拿到属性所对应的bean实例*/</span></span><br><span class="line">Object bean = getBean(propertyName);</span><br><span class="line"><span class="comment">/*在属性里面追加一个property*/</span></span><br><span class="line">pvs.add(propertyName, bean);</span><br><span class="line"><span class="comment">/*管理依赖信息*/</span></span><br><span class="line">registerDependentBean(propertyName, beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Added autowiring by name from bean name &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; via property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Not autowiring property &#x27;&quot;</span> + propertyName + <span class="string">&quot;&#x27; of bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; by name: no matching bean found&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：autowireByName主要完成以下逻辑：<br>​</p><ol><li><p>获取需要填充对象得非简单类型得属性名；</p></li><li><p>遍历第一步获取得属性名，调用getBean方法从容器中获取此属性名对应的object；</p></li><li><p>然后，如果能找到，则把此属性名和object对象保存到pvs的propertyValueList里面。</p><h2 id="3-autowireByType"><a href="#3-autowireByType" class="headerlink" title="3.autowireByType()"></a>3.autowireByType()</h2><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*获取类型转换器*/</span></span><br><span class="line">TypeConverter converter = getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/*拿到属性信息，循环遍历*/</span></span><br><span class="line">String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line"><span class="comment">// Don&#x27;t try autowiring by type for type Object: never makes sense,</span></span><br><span class="line"><span class="comment">// even if it technically is a unsatisfied, non-simple property.</span></span><br><span class="line"><span class="comment">/*如果不是Object类型*/</span></span><br><span class="line"><span class="keyword">if</span> (Object.class != pd.getPropertyType()) &#123;</span><br><span class="line"><span class="comment">/*拿到setter方法*/</span></span><br><span class="line">MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line"><span class="comment">// Do not allow eager init for type matching in case of a prioritized post-processor.</span></span><br><span class="line"><span class="keyword">boolean</span> eager = !(bw.getWrappedInstance() <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line"><span class="comment">/*包装成一个依赖描述信息对象*/</span></span><br><span class="line">DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line"><span class="comment">/*解析器根据依赖描述信息查找对象，或者 容器没有该对象实例的话，但是有该类型的bd的话，也会调用getBeanByType生成对象。*/</span></span><br><span class="line">Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line"><span class="comment">/*查询出来的依赖对象加入到pvs里面*/</span></span><br><span class="line"><span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs.add(propertyName, autowiredArgument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将查询到的依赖对象注册*/</span></span><br><span class="line"><span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Autowiring by type from bean name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; via property &#x27;&quot;</span> +</span><br><span class="line">propertyName + <span class="string">&quot;&#x27; to bean named &#x27;&quot;</span> + autowiredBeanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">autowiredBeanNames.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取当前对象的非简单类型的属性名数组propertyNames；</p></li><li><p>遍历属性名数组propertyNames，获取当前属性名多对应的类型filedType；</p></li><li><p>通过filedType找到匹配的候选Bean对象；</p></li><li><p>把属性名以及bean对象添加到pvs的propertyValueList里面。</p></li></ol><p>可以看到，无论是按照名字注入还是按照类型的注入方式，其实里面都会调用同一个公共的方法。<code>**unsatisfiedNonSimpleProperties()**</code>，接下来分析这个方法是做什么的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"><span class="comment">/*拿到配置的properties集合*/</span></span><br><span class="line">PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"><span class="comment">/*拿到bean的所有字段信息，然后便利所有的字段信息*/</span></span><br><span class="line">PropertyDescriptor[] pds = bw.getPropertyDescriptors();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 条件1成立说明 当前字段有setter方法</span></span><br><span class="line"><span class="comment"> * 条件2成立说明 当前字段类型是否在忽略自动注入列表中，条件成立，说明不在。</span></span><br><span class="line"><span class="comment"> * 条件3成立说明 当前字段不在xml或者其他方式的配置中配置过。</span></span><br><span class="line"><span class="comment"> * 条件4成立说明 当前字段类型是不是简单的八种基本数据类型。基本数据类型不允许自动注入。当前字段不是基本数据类型。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line"><span class="keyword">if</span> (pd.getWriteMethod() != <span class="keyword">null</span> &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;</span><br><span class="line">!BeanUtils.isSimpleProperty(pd.getPropertyType())) &#123;</span><br><span class="line">result.add(pd.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤出mbd中符合依赖注入条件的属性。</p><h2 id="4-applyPropertyValues"><a href="#4-applyPropertyValues" class="headerlink" title="4.applyPropertyValues()"></a>4.applyPropertyValues()</h2><p>大部分情况下，我们走属性注入的逻辑，其实都是对解析出来的依赖bean进行注入。我们来梳理一下大致的流程，看一下核心的逻辑即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为空直接返回</span></span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">mpvs = (MutablePropertyValues) pvs;</span><br><span class="line"><span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line"><span class="comment">// 如果已被设置转换完成，直接完成配置</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bw.setPropertyValues(mpvs);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">original = mpvs.getPropertyValueList();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">TypeConverter converter = getCustomTypeConverter();</span><br><span class="line"><span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">converter = bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建BeanDefinitionValueResolver解析器，用来解析未被解析的PropertyValue。</span></span><br><span class="line">BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始遍历检查original中的属性，对未被解析的先解析/已解析的直接加入deepCopy中，最后再填充到具体的Bean实例中</span></span><br><span class="line">List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br><span class="line"><span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">    <span class="comment">// 如果属性已经转化，直接添加</span></span><br><span class="line"><span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String propertyName = pv.getName();</span><br><span class="line">Object originalValue = pv.getValue();</span><br><span class="line"><span class="comment">// 核心逻辑，解析获取实际的值</span></span><br><span class="line"><span class="comment">// 对于RuntimeReference，会解析拿到具体的beanName,最终通过getBean(beanName)拿到具体的对象</span></span><br><span class="line">Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">Object convertedValue = resolvedValue;</span><br><span class="line"><span class="comment">// 判断是否可以转换</span></span><br><span class="line"><span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp;</span><br><span class="line">!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">    <span class="comment">// 尝试进行转换</span></span><br><span class="line">convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 避免需要重复转换，设定已转换</span></span><br><span class="line"><span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line"><span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">&#125;</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">!((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">!(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">pv.setConvertedValue(convertedValue);</span><br><span class="line">deepCopy.add(pv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">mpvs.setConverted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成设置</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Error setting property values&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p><p>主要是关心下，解析出来的依赖，如果注入到当前正在执行属性赋值的bean对象。<br>​</p><p><code>**valueResolver.resolveValueIfNecessary()**</code> 利用值解析器解析当前bean实例所依赖的bean实例。<br>​</p><p><code>**resolveReference()**</code>通过这个方法去拿到当前属性赋值的bean需要注入的bean。<br>​</p><p><code>**this.beanFactory.getBean()**</code> 最终这里又递归回到了getBean()去获取所需要的bean对象。<br>​</p><p><code>**registerDependentBean()**</code>在获取到bean对象之后，会将获取到的bean对象注册到当前bean所依赖的bean集合。<br>​</p><blockquote><p>至此，单实例bean的属性赋值大体流程我们就分析完了，下一篇我们将去分析单实例bean的初始化逻辑。</p></blockquote><p><br><br></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[五]createBean()</title>
      <link href="/2022/01/11/Spring/Spring%5B%E4%BA%94%5DcreateBean()/"/>
      <url>/2022/01/11/Spring/Spring%5B%E4%BA%94%5DcreateBean()/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上一篇中，分析了getBean()方法的详细流程，里面涉及到了单实例bean的创建，createBean(),本篇将分析这个方法，分析一下Spring中单实例对象时如何创建出来的。</p></blockquote><h2 id="1-createBean"><a href="#1-createBean" class="headerlink" title="1.createBean"></a>1.createBean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd,<span class="comment">/*按照传递的参数构建bean的实例并且返回，一般很少使用到参数*/</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建实例使用的bean定义信息</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查当前bean的定义信息是否有class信息，如果有的话返回class类型，如果没有的话，使用类加载器加载class实例加载到jvm，并返回class对象</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 条件一：拿到了bean定义信息 实例化时候需要的真实class对象</span></span><br><span class="line"><span class="comment">* 条件二：说明bean定义信息在解析bean对象之前（resolveBeanClass()）是没有class对象的</span></span><br><span class="line"><span class="comment">* 条件三：说明mbd有className</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 都成立之后就会去重新初始化mbd对象，进行一层包装。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 预处理 方法重写的逻辑。。 给重写的方法打一个标。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过后置处理器在这里返回一个代理的实例对象</span></span><br><span class="line"><span class="comment">* 这里的代理对象不是spring 的 aop 的实现。</span></span><br><span class="line"><span class="comment">* 实例化之前 并不是init执行前后   后置处理器的执行机会</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="comment">/*如果对象不为空，直接返回。*/</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 真正的创建bean的逻辑，spring里面真正干活的方法都是以do开头</span></span><br><span class="line"><span class="comment">* 创建bean实例  执行依赖注入  执行init  后置处理器的逻辑</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.第一次创建man的逻辑</span></span><br><span class="line"><span class="comment"> * 2.创建women</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>首先使用<code>**resolveBeanClass()**</code>解析出当前bean的类型</li><li>如果解析出的bean类型不为空，并且mbd里面没有bean的类型，并且mbd的className不为空</li></ol><ul><li>创建一个新的<code>**RootBeanDefinition**</code>,将Class类型设置进去</li></ul><ol start="3"><li>处理方法重写的逻辑<code>**prepareMethodOverrides()**</code></li><li><code>**resolveBeforeInstantiation() **</code>通过后置处理器在这里尝试返回一个代理对象，这里的代理并不是Aop的实现，此时是实例化之前，并不是<code>**init()**</code>执行前后</li><li>如果后置处理器成功返回了对象，直接返回</li><li>如果后置处理器没有返回一个代理对象，那就将创建bean的逻辑委派给<code>**doCreateBean()**</code>,返回创建好的bean实例对象。</li></ol><p>​</p><p>按照执行流程来分析，我们先分析<code>**resolveBeanClass()**</code>方法。</p><h2 id="2-resolveBeanClass"><a href="#2-resolveBeanClass" class="headerlink" title="2.resolveBeanClass()"></a>2.resolveBeanClass()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveBeanClass(RootBeanDefinition mbd, String beanName, Class&lt;?&gt;... typesToMatch)</span><br><span class="line"><span class="keyword">throws</span> CannotLoadBeanClassException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，这里其实又是一个委派模式。<code>**doResolveBeanClass()**</code>。<br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; doResolveBeanClass(RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch)</span><br><span class="line"><span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">ClassLoader beanClassLoader = getBeanClassLoader();</span><br><span class="line">ClassLoader dynamicLoader = beanClassLoader;</span><br><span class="line"><span class="keyword">boolean</span> freshResolve = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ObjectUtils.isEmpty(typesToMatch)) &#123;</span><br><span class="line"><span class="comment">// When just doing type checks (i.e. not creating an actual instance yet),</span></span><br><span class="line"><span class="comment">// use the specified temporary class loader (e.g. in a weaving scenario).</span></span><br><span class="line">ClassLoader tempClassLoader = getTempClassLoader();</span><br><span class="line"><span class="keyword">if</span> (tempClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">dynamicLoader = tempClassLoader;</span><br><span class="line">freshResolve = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (tempClassLoader <span class="keyword">instanceof</span> DecoratingClassLoader) &#123;</span><br><span class="line">DecoratingClassLoader dcl = (DecoratingClassLoader) tempClassLoader;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; typeToMatch : typesToMatch) &#123;</span><br><span class="line">dcl.excludeClass(typeToMatch.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String className = mbd.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object evaluated = evaluateBeanDefinitionString(className, mbd);</span><br><span class="line"><span class="keyword">if</span> (!className.equals(evaluated)) &#123;</span><br><span class="line"><span class="comment">// A dynamically resolved expression, supported as of 4.2...</span></span><br><span class="line"><span class="keyword">if</span> (evaluated <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line"><span class="keyword">return</span> (Class&lt;?&gt;) evaluated;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (evaluated <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">className = (String) evaluated;</span><br><span class="line">freshResolve = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid class name expression result: &quot;</span> + evaluated);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (freshResolve) &#123;</span><br><span class="line"><span class="comment">// When resolving against a temporary class loader, exit early in order</span></span><br><span class="line"><span class="comment">// to avoid storing the resolved Class in the bean definition.</span></span><br><span class="line"><span class="keyword">if</span> (dynamicLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dynamicLoader.loadClass(className);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Could not load class [&quot;</span> + className + <span class="string">&quot;] from &quot;</span> + dynamicLoader + <span class="string">&quot;: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ClassUtils.forName(className, dynamicLoader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resolve regularly, caching the result in the BeanDefinition...</span></span><br><span class="line"><span class="keyword">return</span> mbd.resolveBeanClass(beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面没有什么核心的逻辑，不作具体分析。关注一下重要的逻辑，在bean实例创建之前尝试返回一个代理对象。<br>​</p><h2 id="3-实例化之前尝试返回一个代理对象"><a href="#3-实例化之前尝试返回一个代理对象" class="headerlink" title="3.实例化之前尝试返回一个代理对象"></a>3.实例化之前尝试返回一个代理对象</h2><p><code>**resolveBeforeInstantiation()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Object bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="comment">// hasInstantiationAwareBeanPostProcessors() 看当前需要执行的集合里面</span></span><br><span class="line"><span class="comment">//是否有相关的后置处理器，如果有的话，条件成立  ，才能执行if 里面的逻辑</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行bean 实例化 前后的后置处理器 before 方法，默认是返回null，如果想要做特殊的逻辑处理</span></span><br><span class="line"><span class="comment">* 可以自己继承接口进行扩展。需要继承的接口：InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果bean真的在这里创建出来了，那么，下面就会执行bean实例化后的后置处理器逻辑</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>如果有<code>**InstantiationAwareBeanPostProcessors**</code>这个类型的后置处理器</li></ol><ul><li>获取被代理对象的类型</li></ul><ol start="2"><li>如果类型不为空</li></ol><ul><li>执行bean实例化前后的后置处理器的before()，默认是返回null。如果想要做特殊的逻辑处理，可以自己继承接口进行扩展。<code>**applyBeanPostProcessorsBeforeInstantiation()**</code></li></ul><p></p><ul><li>如果有特殊处理的逻辑，也就是返回了一个代理对象，那就执行bean实例化后的后置处理器方法。<code>**applyBeanPostProcessorsAfterInitialization()**</code></li><li>返回后置处理器创建的bean对象<h3 id="3-1-applyBeanPostProcessorsBeforeInstantiation"><a href="#3-1-applyBeanPostProcessorsBeforeInstantiation" class="headerlink" title="3.1 applyBeanPostProcessorsBeforeInstantiation()"></a>3.1 applyBeanPostProcessorsBeforeInstantiation()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">、<span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>遍历所有的后置处理器，执行后置处理器的前置方法，如果某一个后置处理器返回了一个不为空的对象，直接返回该对象，后面的后置处理器的方法不在执行。<h3 id="3-2-applyBeanPostProcessorsAfterInitialization"><a href="#3-2-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="3.2 applyBeanPostProcessorsAfterInitialization()"></a>3.2 applyBeanPostProcessorsAfterInitialization()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="comment">/*注意：</span></span><br><span class="line"><span class="comment">* 一旦某个后置处理器返回的结果为空</span></span><br><span class="line"><span class="comment">* 就返回上一个后置处理器的结果，后面的后置处理器方法不在执行*/</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>遍历所有的后置处理器，执行后置处理器的后置方法，如果某一个后置处理器返回了null，直接返回null，后面的后置处理器的方法不在执行。<br>​</li></ul><p><code>**InstantiationAwareBeanPostProcessors**</code>的逻辑可以看前面的Spring组件与注解篇，再次不再赘述。<br>​</p><h2 id="4-doCreateBean"><a href="#4-doCreateBean" class="headerlink" title="4.doCreateBean()"></a>4.doCreateBean()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanWrapper：一个包装的bean实例，继承了可配置的属性访问器</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*如果是单实例bean对象，清理缓存并返回该对象，这里正常情况下是拿不到的，因为还未创建bean对象实例。*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果上面的逻辑没拿到，说明还是正常的逻辑，执行创建bean实例的方法并且包装到wrapper中。*/</span></span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.第一次走到这里是去创建man</span></span><br><span class="line"><span class="comment"> * 2.创建women</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取包装好的bean实例对象*/</span></span><br><span class="line">Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"><span class="comment">/*拿到bean实例的Class类型*/</span></span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="comment">/*如果bean类型不为空，将bean类型设置到mergedBeanDefinition中*/</span></span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*允许post-processors 在此刻对 merged bean definition 进行修改*/</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="comment">/*如果后置处理器的逻辑还尚未执行，那就在此刻执行，执行之后将是否执行过修改为true，这也就限定了后置处理器只能执行一次。*/</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*执行后置处理器的核心逻辑：合并bd信息，接下来就是populate处理依赖。*/</span></span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 提前地缓存单例，以便能够解析循环引用，即使被生命周期接口(如BeanFactoryAware)触发。</span></span><br><span class="line"><span class="comment">* 其实这里的逻辑就是判断是否过早的暴露早期的bean实例，已经初始化，但是没实例化。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="comment">/*如果支持早期暴露单实例bean对象*/</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">/*日志打印*/</span></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加入到单例bean工厂，将早期bean&#x27;实例（已经实例化但是尚未初始化）的引用加入到第三级缓存</span></span><br><span class="line"><span class="comment">* getEarlyBeanReference（）*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.man现在刚创建出来，还没有进行属性赋值和初始化，此时将他放到第三级缓存</span></span><br><span class="line"><span class="comment"> * 2.此时的women也是通过反射刚刚创建出来，还没有进行属性赋值和初始化的逻辑，此时把他放到了三级缓存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*对bean进行属性赋值，依赖注入。*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.对man进行属性赋值</span></span><br><span class="line"><span class="comment"> * 2.对women进行属性赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">/*生命周期中的初始化方法的调用*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.women先经过这里</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//条件成立：说明当前bean实例是从二级缓存就获取到了</span></span><br><span class="line"><span class="comment">//说明产生了，循环依赖，三级缓存 当前对象的ObjectFactory.getObject()被调用过</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*什么时候相等呢？</span></span><br><span class="line"><span class="comment">* 1.当前的真实实例不需要被代理</span></span><br><span class="line"><span class="comment">* 2.当前实例已经被代理过，，，是在ObjectFactory.getObject()方法调用的时候，实现的增强代理*/</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line"><span class="comment">/*获取依赖当前bean的其他beanName*/</span></span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">/*如果依赖当前bean的bean已经创建完了，就把他加入到集合中去*/</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当前bean正在创建，但是依赖当前bean的bean已经创建完了，那说明指定是有问题，不对劲。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为什么有问题？</span></span><br><span class="line"><span class="comment"> * 因为当前对象的aop操作是在当前方法 initbean 完成的</span></span><br><span class="line"><span class="comment"> * 在这之前 ，外部其他bean持有的当前bean实例 都是尚未增强的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*判断当前bean是否需要注册一个容器关闭时候的析构函数回调*/</span></span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>如果是单实例bean对象，拿到该对象，并清理缓存，这里正常情况下是什么都拿不到的，因为还没有创建bean对象实例。</p></li><li><p>如果上面的逻辑什么也没有拿到，说明还是正常的情况，执行创建bean实例的方法并且包装到wrapper中。<code>**createBeanInstance()**</code></p></li><li><p>获取包装好的bean实例对象，拿到bean实例对象的class类型，将他设置到mbd中。</p></li><li><p>在属性赋值之前，给尚未执行的后置处理器最后一次机会来执行，执行之后修改执行过状态为true，这也就限定了后置处理器只能执行一次。<code>**applyMergedBeanDefinitionPostProcessors()**</code></p></li><li><p>判断是否允许过早的暴露早期bean实例的引用(已经初始化，但是尚未实例化)</p></li><li><p>将早期bean实例加入到三级缓存</p></li><li><p>对早期暴露的bean进行属性赋值<code>**populateBean()**</code></p></li><li><p>在属性赋值之后执行bean对象的初始化方法<code>**initializeBean()**</code></p></li><li><p>这里开始其实就是循环依赖的逻辑，首先判断是不是允许早期暴露的单实例bean对象，如果是的话</p></li><li><p>从缓存中拿到尝试获取bean，<code>**getSingleton()**</code></p></li><li><p>如果从缓存拿到bean了，说明当前bean实例是从二级缓存就获取到了，说明产生了循环依赖</p></li><li><p>如果依赖于当前bean其他bean对象，，如果依赖当前bean的对象都已经创建完了，那就吧他们加入到集合中。</p></li><li><p>当前bean正在创建，但是依赖他的bean都创建完了，那就说明逻辑上出现问题了</p><blockquote><p>为什么会出现问题？<br>因为当前对象的aop操作是在当前方法的init方法里面执行的，在这之前，其他对象拿到的bean都是尚未增强的bean。</p></blockquote></li><li><p>判断当前bean是否需要注册一个容器关闭时候执行的析构函数<code>**registerDisposableBeanIfNecessary()**</code></p></li></ol><p><br>这里面其实主要关注五个点：<code>**createBeanInstance()**</code>，<code>**applyMergedBeanDefinitionPostProcessors()**</code>，<code>**populateBean()**</code>，<code>**initializeBean()**</code>，<br><code>**registerDisposableBeanIfNecessary()**</code>。<br>​</p><h2 id="5-createBeanInstance"><a href="#5-createBeanInstance" class="headerlink" title="5.createBeanInstance()"></a>5.createBeanInstance()</h2><p>使用适当的实例化策略为指定的 bean 创建一个新实例：工厂方法，构造函数自动装配或简单实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 解析bean定义信息中的 bean 的实例类型</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 条件一：Class 实例不为空</span></span><br><span class="line"><span class="comment">* 条件二：Class实例的访问权限不是公开的</span></span><br><span class="line"><span class="comment">* 条件三：CLass实例的权限没打开，没打开就不能反射我记得。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*spring5新特性，没研究*/</span></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*说明bean标签配置了 factoryMethod属性：利用工厂创建对象的逻辑。*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建相同bean的时候，可以走捷径。解析构造器比较耗时，所以如果一个对象创建两次，可以不用那么麻烦。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* resolved：bd对应的构造信息是否已经解析成可以发射调用的构造方法信息</span></span><br><span class="line"><span class="comment">* autowireNecessary：是否自动匹配构造方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mbd.resolvedConstructorOrFactoryMethod != null</span></span><br><span class="line"><span class="comment">* 条件成立：说明bd的构造信息已经转化成可以反射调用的method，并且被缓存。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*说明已经解析过*/</span></span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">/*判断构造方法的参数是否已经被解析了，resolvedConstructorOrFactoryMethod 有值</span></span><br><span class="line"><span class="comment">* 且构造方法有参数，可以认为字段值就是true</span></span><br><span class="line"><span class="comment">* 设么情况下为false？</span></span><br><span class="line"><span class="comment">* 1.resolvedConstructorOrFactoryMethod == null</span></span><br><span class="line"><span class="comment">* 2.当resolvedConstructorOrFactoryMethod 表示的是默认的无参构造器的时候</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果已经解析过，</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="comment">/*并且可以自动匹配构造方法*/</span></span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="comment">/*自动匹配有参构造器*/</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*没有参数解析，也就是无参构造方法处理*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.第一次去创建man</span></span><br><span class="line"><span class="comment"> * 2.创建women</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置处理器的调用点：SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment">* 这个后置处理器里面默认是实现方法为空，想要执行这里的逻辑可以自己继承接口实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 典型应用 <span class="doctag">@Autowired</span> 打在了构造器方法上，就会用到后置处理器   AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 条件1：后置处理器指定了构造方法数组</span></span><br><span class="line"><span class="comment">* 条件2：一般不会成立。bean标签里面配置了autowired=constructor 才会触发</span></span><br><span class="line"><span class="comment">* 条件3：说明bean标签中配置了构造参数信息</span></span><br><span class="line"><span class="comment">* 条件4：getBean时，args有参数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断是否在beanDefinition里面配置偏好构造器，默认实现是null。*/</span></span><br><span class="line"><span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*大部分情况下都是走这里：未指定构造参数，未设定偏好，使用无参构造器创建bean实例。*/</span></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>解析bd中的bean类型</p></li><li><p>对类型做一些校验</p></li><li><p>判断如果配置了bean标签里面的<code>**factoryMethod**</code>属性，走利用工厂创建对象的逻辑。<code>**instantiateUsingFactoryMethod()**</code></p></li><li><p>进行一些属性判断，其实主要就是创建相同bean对象的时候，没有必要全部重新来做，可以走一些捷径</p></li><li><p>如果已经解析过&amp;可以自动匹配构造方法，那就走自动匹配有参构造器的逻辑。<code>**autowireConstructor()**</code></p></li><li><p>如果是已经解析过&amp;无参构造器的处理方法，那就走<code>**instantiateBean()**</code></p></li><li><p>接下来是一个后置处理器的调用点 <code>_**SmartInstantiationAwareBeanPostProcessor**_</code>，这个后置处理器里面默认实现为空，可以自己扩展。</p><blockquote><p>典型的应用就是 @Autowired 注解打在了构造器上，就会用到后置处理器<code>_**AutowiredAnnotationBeanPostProcessor**_</code>。</p></blockquote></li><li><p>判断是否需要执行构造器自动注入的逻辑 <code>**autowireConstructor()**</code></p></li><li><p>判断是否在beandefinition里面配置了偏好的构造器，默认实现是null，如果是的话，就走<code>**autowireConstructor()**</code>。</p></li><li><p>大部分情况下，其实会走<code>**instantiateBean()**</code>。（未指定构造参数，未设置偏好，使用无参构造器创建bean对象实例）</p></li></ol><p><br>这里主要关心三个方法<code>**instantiateBean()**</code>&amp;<code>**autowireConstructor()**</code>&amp;<code>**instantiateUsingFactoryMethod()**</code>。<br>​</p><h3 id="5-1-instantiateBean"><a href="#5-1-instantiateBean" class="headerlink" title="5.1 instantiateBean()"></a>5.1 <code>instantiateBean()</code></h3><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*获取实例化策略，调用实例化方法创建bean实例*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.反射去创建man</span></span><br><span class="line"><span class="comment"> * 2.反射去创建women</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">/*根据实例创建bean实例的包装器*/</span></span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line"><span class="comment">/*对包装器进行一些参数，工具设置*/</span></span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取到实例化的策略，反射去创建对象，根据bean去创建对象的包装器，对包装器进行赋能。<br><code>**instantiate()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line"><span class="comment">/*不考虑方法覆盖*/</span></span><br><span class="line"><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*实例化*/</span></span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="comment">/*方法覆盖的逻辑*/</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**instantiateClass()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(ctor);</span><br><span class="line"><span class="keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) &#123;</span><br><span class="line"><span class="keyword">return</span> KotlinDelegate.instantiateClass(ctor, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();</span><br><span class="line">Assert.isTrue(args.length &lt;= parameterTypes.length, <span class="string">&quot;Can&#x27;t specify more arguments than constructor parameters&quot;</span>);</span><br><span class="line"><span class="comment">/*这里的参数数组是为了防止某个类型传过来的值是null，如果是null，就是用默认的值*/</span></span><br><span class="line">Object[] argsWithDefaultValues = <span class="keyword">new</span> Object[args.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; args.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; parameterType = parameterTypes[i];</span><br><span class="line"><span class="comment">/*从这里就能看到是不是选用了默认值*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* DEFAULT_TYPE_VALUES :存各种基本数据类型的默认值。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">argsWithDefaultValues[i] = args[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*通过构造器来进行反射实例化创建bean实例。*/</span></span><br><span class="line"><span class="keyword">return</span> ctor.newInstance(argsWithDefaultValues);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is it an abstract class?&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Is the constructor accessible?&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Illegal arguments for constructor&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor, <span class="string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过单实例bean的构造器反射创建对象。</p><h3 id="5-2autowireConstructor"><a href="#5-2autowireConstructor" class="headerlink" title="5.2autowireConstructor()"></a>5.2<code>autowireConstructor()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*通过构造函数解析器的autowireConstructor方法来创建bean实例*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动装配构造函数行为。如果指定了显式的构造函数参数值，也可以，将所有剩余参数与来自bean工厂的bean匹配。这块对应于构造函数注入，在这种模式下spring的bean工厂能够承载期望基于构造函数的依赖项解析的组件。<br><code>**autowireConstructor()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*创建了一个bean包装器的实例*/</span></span><br><span class="line">BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line"><span class="comment">/*初始化bean包装器*/</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"><span class="comment">/*最终反射调用的构造器*/</span></span><br><span class="line">Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*holder持有的是：实例化的时候，真正用到的参数*/</span></span><br><span class="line">ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*实例化的时候使用到的参数*/</span></span><br><span class="line">Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*如果getbean传的参数不为空，使用到的参数就是指定的参数*/</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToUse = explicitArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">/*getBean的时候没有指定参数*/</span></span><br><span class="line"><span class="comment">/*表示构造器参数需要做类型转换，参数引用*/</span></span><br><span class="line">Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">/*到缓存去看看有没有缓存过构造器*/</span></span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="comment">/*缓存有解析好的构造器并且构造器参数已经被解析过  说明不是第一次通过bd生成实例*/</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line"><span class="comment">// Found a cached constructor...</span></span><br><span class="line">argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line"><span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立说明：resolvedConstructorArguments==null*/</span></span><br><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*解析构造参数*/</span></span><br><span class="line">argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立说明缓存机制失败，或者是第一次创建，需要匹配构造器。*/</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Take specified constructors, if any.</span></span><br><span class="line"><span class="comment">/*chosenCtors什么时候有值呢？构造器上有@Autowired注解的时候。*/</span></span><br><span class="line">Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line"><span class="comment">/*条件成立说明：外部程序调用方法的时候并没有指定可选用的构造器，需要通过class拿到构造器信息*/</span></span><br><span class="line"><span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*如果非公开的方法也允许访问就获取所有的构造器，否则获取可以访问的构造器。*/</span></span><br><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line"><span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行到这里，可选用的构造器列表已经转备好了，但是还没确定具体是哪一个*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果只有一个构造器并且getBean没有指定构造器参数，并且bean定义信息里面没有参数，那就是用默认的无参构造器*/</span></span><br><span class="line"><span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要解析到底是用哪一个构造器</span></span><br><span class="line"><span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> ||</span><br><span class="line">mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"><span class="comment">/*完成解析后的构造器参数值列表*/</span></span><br><span class="line">ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*构造器参数的个数*/</span></span><br><span class="line"><span class="keyword">int</span> minNrOfArgs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*从beanDefinition拿到构造器参数*/</span></span><br><span class="line">ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line"><span class="comment">/*将此 bean 的构造函数参数解析为 resolveValues 对象。 这可能涉及查找其他 bean。</span></span><br><span class="line"><span class="comment">此方法也用于处理静态工厂方法的调用。，*/</span></span><br><span class="line">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*给可选用的构造器数组排序，排序规则： public &gt; no public   more args &gt; no args*/</span></span><br><span class="line">AutowireUtils.sortConstructors(candidates);</span><br><span class="line"><span class="comment">/*这个值越低，说明当前构造器参数列表类型和构造参数的匹配值越高*/</span></span><br><span class="line"><span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">/*尚未筛选或者筛选完还未确定的构造器*/</span></span><br><span class="line">Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*筛选可选的构造方法，找出一个匹配度最高的构造函数*/</span></span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line"><span class="comment">/*获取当前处理的构造器参数个数*/</span></span><br><span class="line"><span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"><span class="comment">/*这里判断的指标都是上面循环筛选出来的东西</span></span><br><span class="line"><span class="comment">* 因为candidates是排过序的 排序规则：public &gt; no public &gt; 多参数的 &gt; 参数少的</span></span><br><span class="line"><span class="comment">* 当前筛选出来的构造器优先级一定是优先于后面的构造器的</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;</span><br><span class="line"><span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line"><span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="comment">/*表示当前构造器参数 小于 bd中配置了构造器参数个数，说明匹配不上。*/</span></span><br><span class="line"><span class="keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*构造器参数的持有对象*/</span></span><br><span class="line">ArgumentsHolder argsHolder;</span><br><span class="line"><span class="comment">/*拿到当前构造器的参数类型数组*/</span></span><br><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"><span class="comment">/*已经解析后的构造器参数值不为空，说明bd中是有参数的，需要做匹配逻辑*/</span></span><br><span class="line"><span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*根据构造器参数注解@ConstructorProperties拿到所有参数的名字*/</span></span><br><span class="line">String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line"><span class="comment">/*如果数组的名字是空,那么就都是默认的名字*/</span></span><br><span class="line"><span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"><span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swallow and try next constructor.</span></span><br><span class="line"><span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">causes = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">causes.add(ex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line"><span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*typeDiffWeight数值越高说明构造器与参数的匹配度越低。</span></span><br><span class="line"><span class="comment">* 计算出当前构造器参数类型与当前构造器参数匹配度*/</span></span><br><span class="line"><span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line"><span class="comment">/*条件成立说明：当前循环处理的构造器比上一次帅选出来的更合适*/</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">constructorToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立说明：当前处理的构造器 他计算出来的typeDiffWeight值与上一次筛选出来的最优先的构造器的值一致，有模棱两可的情况。加入到模棱两可集合。*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line"><span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">ambiguousConstructors.add(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line">ambiguousConstructors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立：没找到可用构造器，所以直接报错。*/</span></span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line"><span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Could not resolve matching constructor on bean class [&quot;</span> + mbd.getBeanClassName() + <span class="string">&quot;] &quot;</span> +</span><br><span class="line"><span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立：模棱两可的构造器集合有值，并且beanDefinition里面的构造器指定策略是狭窄策略，这个时候也要报错。*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Ambiguous constructor matches found on bean class [&quot;</span> + mbd.getBeanClassName() + <span class="string">&quot;] &quot;</span> +</span><br><span class="line"><span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">ambiguousConstructors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立：说明自动匹配成功了，需要进行缓存，方便后来者继续使用mergerdbeanDefinition来创建实例*/</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line"><span class="comment">/*根据上面选择的构造器和解析出来的参数，通过instantiate方法反射创建bean对象实例，最终将实例设置到beanWrapper的beanInstance实例里面。*/</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-instantiateUsingFactoryMethod"><a href="#5-3-instantiateUsingFactoryMethod" class="headerlink" title="5.3 instantiateUsingFactoryMethod()"></a>5.3 <code>instantiateUsingFactoryMethod()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"><span class="comment">//工厂模式创建对象的方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**instantiateUsingFactoryMethod()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个空的bean实例的包装器</span></span><br><span class="line">BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line"><span class="comment">//进行一些参数设置，给包装器赋能</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"><span class="comment">//工厂bean对象的引用</span></span><br><span class="line">Object factoryBean;</span><br><span class="line"><span class="comment">//工厂bean对象的类型</span></span><br><span class="line">Class&lt;?&gt; factoryClass;</span><br><span class="line"><span class="comment">//是不是静态工厂</span></span><br><span class="line"><span class="keyword">boolean</span> isStatic;</span><br><span class="line"><span class="comment">//获取工厂bean的名字</span></span><br><span class="line">String factoryBeanName = mbd.getFactoryBeanName();</span><br><span class="line"><span class="comment">//如果工厂bean的名字不为空</span></span><br><span class="line"><span class="keyword">if</span> (factoryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果工厂bean的名字和要创建的bean名字一样，那么说明出现问题了，这个时候要抛异常</span></span><br><span class="line"><span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;factory-bean reference points back to the same bean definition&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取工厂bean对象</span></span><br><span class="line">factoryBean = <span class="keyword">this</span>.beanFactory.getBean(factoryBeanName);</span><br><span class="line"><span class="comment">//如果mbd是单实例的 &amp;&amp; 当前一级缓存里面包含这个要创建的单实例bean</span></span><br><span class="line"><span class="comment">//这个时候说明不正常，为啥呢？我们要通过工厂模式创建的bean，被以其他方式创建出来了，非正常途径得到的bean</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ImplicitlyAppearedSingletonException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给当前要创建的bean实例对象注册一个依赖bean，这个依赖bean就是他的工厂bean</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory.registerDependentBean(factoryBeanName, beanName);</span><br><span class="line">factoryClass = factoryBean.getClass();</span><br><span class="line">isStatic = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="comment">//走到这里的情况就是工厂bean没有名字，什么情况会走到这里？通过静态工厂来创建对象</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a static factory method on the bean class.</span></span><br><span class="line"><span class="comment">//如果依赖静态工厂来创建bean实例对象的话，那么必须要有工厂bean的类型，否则没法创建</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;bean definition declares neither a bean class nor a factory-bean reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">factoryBean = <span class="keyword">null</span>;</span><br><span class="line">factoryClass = mbd.getBeanClass();</span><br><span class="line">isStatic = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建bean对象的工厂方法</span></span><br><span class="line">Method factoryMethodToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//持有创建对象需要的参数</span></span><br><span class="line">ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//创建对象需要使用的参数</span></span><br><span class="line">Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//getBean()方法传入的参数</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToUse = explicitArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//这里的逻辑就是getBean()的时候没有参数传递进来</span></span><br><span class="line">Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="comment">//获取已经解析过的工厂方法</span></span><br><span class="line">factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="comment">//如果工厂方法已经解析过，&amp;&amp; mbd的构造器参数也已经解析过</span></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line"><span class="comment">// Found a cached factory method...</span></span><br><span class="line"><span class="comment">//这里应该就是判断构造器参数有没有解析过，没有解析过的话，就去设置解析状态为准备解析</span></span><br><span class="line">argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line"><span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断构造器参数尚未解析过，就去解析构造器参数</span></span><br><span class="line"><span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果工厂方法为空 || 需要使用的参数为空</span></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Need to determine the factory method...</span></span><br><span class="line"><span class="comment">// Try all methods with this name to see if they match the given arguments.</span></span><br><span class="line"><span class="comment">//需要一个一个方法尝试，去找到创建bean所需要的工厂方法</span></span><br><span class="line">factoryClass = ClassUtils.getUserClass(factoryClass);</span><br><span class="line"></span><br><span class="line">List&lt;Method&gt; candidates = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//如果工厂方法是唯一的 &amp;&amp; 当前尚未有指定工厂方法</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isFactoryMethodUnique) &#123;</span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//获取mbd里面已经解析过的工厂方法</span></span><br><span class="line">factoryMethodToUse = mbd.getResolvedFactoryMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果mbd里面有已经解析好的工厂方法，把他放到集合</span></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">candidates = Collections.singletonList(factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果方法列表为空，有什么情况？</span></span><br><span class="line"><span class="comment">//可能是上面mbd里面没有已经指定的工厂方法</span></span><br><span class="line"><span class="comment">//也可能是工厂方法不是唯一的，一个类有多个工厂方法，这个时候工厂方法的名字都是一样的，只是方法形参不同</span></span><br><span class="line"><span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">candidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//拿到工厂里面的所有的方法</span></span><br><span class="line">Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);</span><br><span class="line"><span class="comment">//循环遍历，将满足条件的方法加入到集合</span></span><br><span class="line"><span class="comment">//满足什么条件？ 是静态的方法 &amp;&amp; 名字是指定的工厂方法的名字</span></span><br><span class="line"><span class="keyword">for</span> (Method candidate : rawCandidates) &#123;</span><br><span class="line"><span class="keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;</span><br><span class="line">candidates.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行到这里，其实可选用的方法列表已经都帅选出来了，但是还没有具体确定是哪一个*/</span></span><br><span class="line"><span class="comment">//如果恰好只匹配到一个方法    &amp;&amp;  参数为空   &amp;&amp; 要创建的单实例bean 的构造参数也为空  ，那这里就是使用无参构造器的情况</span></span><br><span class="line"><span class="keyword">if</span> (candidates.size() == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line"><span class="comment">//将这个方法指定为唯一的工厂方法</span></span><br><span class="line">Method uniqueCandidate = candidates.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//如果工厂方法没有形参</span></span><br><span class="line"><span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//将mbd的工厂方法指定为这个方法</span></span><br><span class="line">mbd.factoryMethodToIntrospect = uniqueCandidate;</span><br><span class="line"><span class="comment">//设置一些参数，给工厂方法创建对象赋能</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过这个匹配到的工厂方法 ，利用 无参的工厂方法/构造器创建对象</span></span><br><span class="line"><span class="comment">//其实本质上还是利用反射调用工厂bean的工厂方法</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果匹配到了多个方法 ，对匹配到的方法进行一个排序 排序规则 ： public &gt; no public &amp;&amp; more args &gt; no args</span></span><br><span class="line"><span class="keyword">if</span> (candidates.size() &gt; <span class="number">1</span>) &#123;  <span class="comment">// explicitly skip immutable singletonList</span></span><br><span class="line">candidates.sort(AutowireUtils.EXECUTABLE_COMPARATOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造参数</span></span><br><span class="line">ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//已解析的自动装配代码  == 指示自动装配可以满足的最贪婪的构造函数的常量</span></span><br><span class="line"><span class="comment">//需要解析到底是哪一个方法</span></span><br><span class="line"><span class="keyword">boolean</span> autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line"><span class="comment">//选择权重  值越低，表示匹配度越高</span></span><br><span class="line"><span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//模棱两可的构造器集合</span></span><br><span class="line">Set&lt;Method&gt; ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//通过getBean()传入的参数的个数/构造器参数的个数</span></span><br><span class="line"><span class="keyword">int</span> minNrOfArgs;</span><br><span class="line"><span class="comment">//如果通过getBean()传入的参数不为空 ，获取参数的个数</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">minNrOfArgs = explicitArgs.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// getBean()没有传入参数，这种情况下，我们就得自己去解析bd里面的构造器</span></span><br><span class="line"><span class="keyword">if</span> (mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line"><span class="comment">//从bd去拿到构造器</span></span><br><span class="line">ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line"><span class="comment">//将当前bean的方法参数或构造器参数解析  ，这里可能涉及到查找其他bean</span></span><br><span class="line">minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//这就是无参构造器的情况</span></span><br><span class="line">minNrOfArgs = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deque&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//遍历匹配到的多个方法</span></span><br><span class="line"><span class="keyword">for</span> (Method candidate : candidates) &#123;</span><br><span class="line"><span class="comment">//获取方法的参数个数</span></span><br><span class="line"><span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"><span class="comment">/*这里判断的指标都是上面循环筛选出来的东西</span></span><br><span class="line"><span class="comment"> * 因为candidates是排过序的 排序规则：public &gt; no public &gt; 多参数的 &gt; 参数少的</span></span><br><span class="line"><span class="comment"> * 当前筛选出来的构造器优先级一定是优先于后面的构造器的</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">if</span> (parameterCount &gt;= minNrOfArgs) &#123;</span><br><span class="line">ArgumentsHolder argsHolder;</span><br><span class="line"><span class="comment">//进行类型匹配</span></span><br><span class="line">Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line"><span class="comment">//如果显式参数不为空</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// bd中的参数个数 和 当前给定的参数个数匹配不上 ，直接淘汰当前方法</span></span><br><span class="line"><span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将显式参数放到holder里面</span></span><br><span class="line">argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//这里是显式参数为空的情况</span></span><br><span class="line"><span class="comment">// 已解析的构造函数参数:需要类型转换和/或自动注入</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//存放方法的参数名数组</span></span><br><span class="line">String[] paramNames = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//参数解析器</span></span><br><span class="line">ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line"><span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//解析方法的参数名字</span></span><br><span class="line">paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对参数进行封装</span></span><br><span class="line">argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,</span><br><span class="line">paramTypes, paramNames, candidate, autowiring, candidates.size() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Ignoring factory method [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swallow and try next overloaded factory method.</span></span><br><span class="line"><span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">causes = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">causes.add(ex);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算当前方法参数和当前方法的匹配度</span></span><br><span class="line"><span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line"><span class="comment">// 条件成立，说明本次的匹配度高于上一轮</span></span><br><span class="line"><span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">factoryMethodToUse = candidate;</span><br><span class="line">argsHolderToUse = argsHolder;</span><br><span class="line">argsToUse = argsHolder.arguments;</span><br><span class="line">minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 了解模糊性:对于具有相同参数数量的方法，如果存在相同类型的差异权重，则收集这样的候选项，并最终引发模糊性异常。</span></span><br><span class="line"><span class="comment">* 但是，只在非宽松的构造函数解析模式下执行该检查，并显式忽略重写的方法(具有相同的参数签名)。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*条件成立说明：当前处理的构造器 他计算出来的typeDiffWeight值与上一次筛选出来的最优先的构造器的值一致，有模棱两可的情况。加入到模棱两可集合*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;</span><br><span class="line">!mbd.isLenientConstructorResolution() &amp;&amp;</span><br><span class="line">paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;</span><br><span class="line">!Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;</span><br><span class="line"><span class="comment">//如果模棱两可的构造方法为空，就创建一个新的集合，   把满足条件的 构造器收集起来</span></span><br><span class="line"><span class="keyword">if</span> (ambiguousFactoryMethods == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">ambiguousFactoryMethods = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">ambiguousFactoryMethods.add(factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存模棱两可的构造方法</span></span><br><span class="line">ambiguousFactoryMethods.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要使用的工厂方法为空  或  要使用的参数为空，意思就是没找到创建对象的方法，那就得报错了；</span></span><br><span class="line"><span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果有异常信息，记录异常信息</span></span><br><span class="line"><span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line"><span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; argTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(minNrOfArgs);</span><br><span class="line"><span class="comment">//走到这里就是可用的方法为空，参数不为空</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//保存参数类型</span></span><br><span class="line"><span class="keyword">for</span> (Object arg : explicitArgs) &#123;</span><br><span class="line">argTypes.add(arg != <span class="keyword">null</span> ? arg.getClass().getSimpleName() : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果构造器解析出的参数不为空，记录构造器参数的类型</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">Set&lt;ValueHolder&gt; valueHolders = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());</span><br><span class="line">valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());</span><br><span class="line">valueHolders.addAll(resolvedValues.getGenericArgumentValues());</span><br><span class="line"><span class="keyword">for</span> (ValueHolder value : valueHolders) &#123;</span><br><span class="line">String argType = (value.getType() != <span class="keyword">null</span> ? ClassUtils.getShortName(value.getType()) :</span><br><span class="line">(value.getValue() != <span class="keyword">null</span> ? value.getValue().getClass().getSimpleName() : <span class="string">&quot;null&quot;</span>));</span><br><span class="line">argTypes.add(argType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则就要抛出异常了</span></span><br><span class="line">String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;No matching factory method found on class [&quot;</span> + factoryClass.getName() + <span class="string">&quot;]: &quot;</span> +</span><br><span class="line">(mbd.getFactoryBeanName() != <span class="keyword">null</span> ?</span><br><span class="line"><span class="string">&quot;factory bean &#x27;&quot;</span> + mbd.getFactoryBeanName() + <span class="string">&quot;&#x27;; &quot;</span> : <span class="string">&quot;&quot;</span>) +</span><br><span class="line"><span class="string">&quot;factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() + <span class="string">&quot;(&quot;</span> + argDesc + <span class="string">&quot;)&#x27;. &quot;</span> +</span><br><span class="line"><span class="string">&quot;Check that a method with the specified name &quot;</span> +</span><br><span class="line">(minNrOfArgs &gt; <span class="number">0</span> ? <span class="string">&quot;and arguments &quot;</span> : <span class="string">&quot;&quot;</span>) +</span><br><span class="line"><span class="string">&quot;exists and that it is &quot;</span> +</span><br><span class="line">(isStatic ? <span class="string">&quot;static&quot;</span> : <span class="string">&quot;non-static&quot;</span>) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果工厂方法没有返回值，那指定不对，抛异常</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">void</span>.class == factoryMethodToUse.getReturnType()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Invalid factory method &#x27;&quot;</span> + mbd.getFactoryMethodName() + <span class="string">&quot;&#x27; on class [&quot;</span> +</span><br><span class="line">factoryClass.getName() + <span class="string">&quot;]: needs to have a non-void return type!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果模棱两可的方法不为空，抛异常</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ambiguousFactoryMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Ambiguous factory method matches found on class [&quot;</span> + factoryClass.getName() + <span class="string">&quot;] &quot;</span> +</span><br><span class="line"><span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">ambiguousFactoryMethods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立：说明自动匹配成功了，需要进行缓存，方便后来者继续使用mergerdbeanDefinition来创建实例*/</span></span><br><span class="line"><span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbd.factoryMethodToIntrospect = factoryMethodToUse;</span><br><span class="line">argsHolderToUse.storeCache(mbd, factoryMethodToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*根据上面选择的构造器和解析出来的参数，通过instantiate方法反射创建bean对象实例，最终将实例设置到beanWrapper的beanInstance实例里面。*/</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-applyMergedBeanDefinitionPostProcessors"><a href="#6-applyMergedBeanDefinitionPostProcessors" class="headerlink" title="6.applyMergedBeanDefinitionPostProcessors()"></a>6.applyMergedBeanDefinitionPostProcessors()</h2><p><br>遍历所有的后置处理器进行方法调用，典型应用：如果开启了自动依赖注入，那么就会将相关的bean加入到集合中。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) &#123;</span><br><span class="line"><span class="comment">/*这里是后置处理器中的方法执行的逻辑</span></span><br><span class="line"><span class="comment">* 做了一件事情：提取出当前beanType类型整个继承体系内的@Autowired @Value @Inject 信息 并且包装成一个InjectionMetadata的一个对象</span></span><br><span class="line"><span class="comment">* 存放到 AutowiredAnnotationBeanPostProcessor 的缓存中，key是beanName。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**MergedBeanDefinitionPostProcessor**</code></p><h2 id="7-registerDisposableBeanIfNecessary"><a href="#7-registerDisposableBeanIfNecessary" class="headerlink" title="7.registerDisposableBeanIfNecessary()"></a>7.registerDisposableBeanIfNecessary()</h2><p>判断当前bean是否需要注册一个需要在容器关闭的时候执行的析构函数<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*条件一：原型模式的bean不会注册析构函数</span></span><br><span class="line"><span class="comment">* 条件二：判断当前bean是否需要注册析构函数*/</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) &#123;</span><br><span class="line"><span class="comment">/*如果当前bean对象时单例模式*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">// Register a DisposableBean implementation that performs all destruction</span></span><br><span class="line"><span class="comment">// work for the given bean: DestructionAwareBeanPostProcessors,</span></span><br><span class="line"><span class="comment">// DisposableBean interface, custom destroy method.</span></span><br><span class="line"><span class="comment">/*给当前单实例bean注册回调适配器。适配器内 根据当前bean实例是继承接口还是通过自定义来决定具体调用哪个方法，完成析构操作。*/</span></span><br><span class="line">registerDisposableBean(beanName, <span class="keyword">new</span> DisposableBeanAdapter(</span><br><span class="line">bean, beanName, mbd, getBeanPostProcessorCache().destructionAware));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*这是自定义作用域的逻辑，压根用不到*/</span></span><br><span class="line"><span class="comment">// A bean with a custom scope...</span></span><br><span class="line">Scope scope = <span class="keyword">this</span>.scopes.get(mbd.getScope());</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + mbd.getScope() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">scope.registerDestructionCallback(beanName, <span class="keyword">new</span> DisposableBeanAdapter(</span><br><span class="line">bean, beanName, mbd, getBeanPostProcessorCache().destructionAware));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会进行条件过滤，原型模式的bean排除，不需要注册的bean排除，我们只关心单实例bean的注册逻辑，其他作用域的处理逻辑不需要关注，判断如果是单实例bean对象，给当前的bean对象注册回调适配器。在适配器里面根据当前bean实例是继承接口还是通过自定义来决定具体调用哪个方法完成析构操作。<br>​</p><p><code>**DisposableBeanAdapter**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line"><span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Invoking destroy() on bean with name &#x27;&quot;</span> + <span class="keyword">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((DisposableBean) <span class="keyword">this</span>.bean).destroy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">String msg = <span class="string">&quot;Invocation of destroy method failed on bean with name &#x27;&quot;</span> + <span class="keyword">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.warn(msg, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.warn(msg + <span class="string">&quot;: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">Method methodToInvoke = determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line"><span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下，其实就是创建对象的时候分为三种情况：无参构造器，有参构造器，工厂方法，创建完对象之后，在执行对应的后置处理器(<code>**MergedBeanDefinitionPostProcessor**</code>),<br>最终在判断创建的bean实例是不是需要注册一个析构函数，在容器关闭的时候回调，如果需要就创建并保存。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[四]getBean方法内幕</title>
      <link href="/2022/01/11/Spring/Spring%5B%E5%9B%9B%5DgetBean%E6%96%B9%E6%B3%95%E5%86%85%E5%B9%95/"/>
      <url>/2022/01/11/Spring/Spring%5B%E5%9B%9B%5DgetBean%E6%96%B9%E6%B3%95%E5%86%85%E5%B9%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回顾一下前面，在<code>**AbstractApplicationContext**</code>中，<code>**refresh()**</code>完成了整个IOC容器的刷新，上回我们分析到了初始化剩下所有的单实例bean，这里面有几个核心的地方，<code>**getBean(),createBean(),populateBean()**</code>,三级缓存与循环依赖，完成这些后，整个IOC容器的大体流程就分析完了。本篇我们来分析Spring的<code>**getBean()**</code>。</p></blockquote><h2 id="1-初始化所有的单实例bean对象"><a href="#1-初始化所有的单实例bean对象" class="headerlink" title="1.初始化所有的单实例bean对象"></a>1.初始化所有的单实例bean对象</h2><p><code>**finishBeanFactoryInitialization()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 为此上下文初始化转换服务</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果容器里面没有字符串转换器，初始化一个字符串转换器放到容器中。</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽早初始化LoadTimeWeaverAware beans，以便尽早注册它们的转换器。</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止使用临时类加载器进行类型匹配</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许缓存所有bean定义元数据，不期望进一步的更改，冻结bd信息，冻结之后就无法往bf注册bd了</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化所有剩余的单实例bean</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冻结bd的信息实际上就是通过一个状态位来控制的，这里面最核心的一个方法或者说步骤就是实例化所有剩余的单实例bean对象。<code>**beanFactory.preInstantiateSingletons()**</code><br><strong>​</strong></p><h2 id="2-preInstantiateSingletons"><a href="#2-preInstantiateSingletons" class="headerlink" title="2.preInstantiateSingletons()"></a>2.<strong>preInstantiateSingletons()</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//日志打印</span></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*拿过来所有的beanDefinition names 信息*/</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发所有的非懒加载的单例bean的初始化</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//获取bean的定义信息</span></span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// bean不是抽象的   是单例的   不是懒加载的</span></span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="comment">//如果是工厂bean</span></span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"><span class="comment">//通过getBean方法获取bean  前缀 &amp;  拿到的是工厂bean</span></span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="comment">//如果拿到的bean确定是工厂bean</span></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="comment">//判断这个工厂bean是否期望被初始化</span></span><br><span class="line"> <span class="comment">/*判断逻辑：SmartFactoryBean里面有一个isEagerInit方法，这个方法为true就表示这个工厂bean是需要现在创建的*/</span></span><br><span class="line"><span class="keyword">boolean</span> isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line"><span class="comment">//如果期望被初始化</span></span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line"><span class="comment">//通过getBean走创建bean的逻辑</span></span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//执行到这里，说明就是普通的单实例bean，不是工厂bean，直接通过getBean创建bean</span></span><br><span class="line"><span class="comment">//三级缓存解决循环依赖的入口：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * eg：man 和 women 产生循环依赖</span></span><br><span class="line"><span class="comment"> * 1.第一次来到这里是首先去创建man</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发所有的单实例bean的初始化后的回调逻辑</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//从一级缓存获取单实例bean</span></span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">//类型断言，执行回调</span></span><br><span class="line"><span class="comment">/*SmartInitializingSingleton里面有一个方法 afterSingletonsInstantiated 这个方法需要在创建好单实例bean之后调用一下*/</span></span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.beans.smart-initialize&quot;</span>)</span><br><span class="line">.tag(<span class="string">&quot;beanName&quot;</span>, beanName);</span><br><span class="line">SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="comment">//这里就是触发初始化后的回调逻辑</span></span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">smartInitialize.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里拿到所有的<code>**beanDefinition**</code>的名字，然后循环判断：【不是抽象的，单实例的，非懒加载的】，然后根据拿到的bean定义信息，再分为<code>**FactoryBean**</code>和<code>**Bean**</code>两种情况进行处理。</p><p>梳理一下这里的重点逻辑：<br>​</p><ol><li>合并<code>**beanDefinition**</code>信息  <code>**getMergedLocalBeanDefinition(beanName)**</code></li><li>获取bean对象 <code>**getBean() **</code></li><li><code>**SmartInitializingSingleton**</code>回调<code>**afterSingletonsInstantiated() **</code>触发单实例bean初始化后的回调逻辑</li></ol><p><br>接下来先来分析，如何合并bean的定义信息。<br>​</p><h2 id="3-getMergedLocalBeanDefinition-beanName"><a href="#3-getMergedLocalBeanDefinition-beanName" class="headerlink" title="3. getMergedLocalBeanDefinition(beanName)"></a>3. getMergedLocalBeanDefinition(beanName)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line"><span class="comment">/*从缓存获取*/</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line"><span class="comment">/*缓存有，直接返回*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*真正的合并 bd 的逻辑*/</span></span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会先尝试从缓存来获取<code>**beanDefinition**</code>的信息，如果缓存有，就直接返回，否则就要触发合并bd的逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String beanName, BeanDefinition bd, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line"><span class="comment">/*合并后的bd信息</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*表示当前beanname对应的过期的mbd信息*/</span></span><br><span class="line">RootBeanDefinition previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line"><span class="comment">/*null==null*/</span></span><br><span class="line"><span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*从缓存拿信息*/</span></span><br><span class="line">mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立说明mbd==null或者 过期...*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || mbd.stale) &#123;</span><br><span class="line"><span class="comment">/*表示当前beanname对应的过期的mbd信息*/</span></span><br><span class="line">previous = mbd;</span><br><span class="line"><span class="comment">/*没有当前beanName 对应的 bd 没有使用继承  那么就不用处理继承  */</span></span><br><span class="line"><span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line"><span class="comment">/*如果 mbd 是 root bean*/</span></span><br><span class="line"><span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line"><span class="comment">/*克隆一份保存*/</span></span><br><span class="line">mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*否则直接创建一个root bean*/</span></span><br><span class="line">mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*说明当前beanName 对应的 beanDefinition 存在继承关系*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*表示bd 的父信息*/</span></span><br><span class="line">BeanDefinition pbd;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*处理beanName 拿到处理了别名和&amp;的真是父bd beanName 名称*/</span></span><br><span class="line">String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line"><span class="comment">/*条件成立  说明 子 bd 和父 bd 名称不一样，就是普通情况*/</span></span><br><span class="line"><span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line"><span class="comment">/*递归当前方法，最终返回父 bd 信息*/</span></span><br><span class="line">pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">/*特殊：父子bd名称一样*/</span></span><br><span class="line">BeanFactory parent = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line"><span class="string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照父bd信息创建 mbd 对象</span></span><br><span class="line">mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line"><span class="comment">// 用子bd 覆盖mbd信息，以子bd 为基准 父 bd为辅</span></span><br><span class="line">mbd.overrideFrom(bd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line"><span class="comment">// Let&#x27;s correct this on the fly here, since this might be the result of</span></span><br><span class="line"><span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line"><span class="comment">// definition will not have inherited the merged outer bean&#x27;s singleton status.</span></span><br><span class="line"><span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">mbd.setScope(containingBd.getScope());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line"><span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line"><span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line"><span class="comment">/*缓存合并后的 mbd信息*/</span></span><br><span class="line"><span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面需要关注的点有两个：<br>​</p><ol><li>如何处理bean的名字    <code>**transformedBeanName()**</code></li><li>如何合并bd信息        <code>**getMergedBeanDefinition()**</code></li></ol><p><strong>​</strong></p><h2 id="4-处理bean的名字"><a href="#4-处理bean的名字" class="headerlink" title="4.处理bean的名字"></a>4.处理bean的名字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">transformedBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回 BeanFactoryUtils.transformedBeanName(name) 处理完的bean name ，这里也可能是别名。</span></span><br><span class="line"><span class="comment">* spring的bean别名是通过aliasMap保存的。</span></span><br><span class="line"><span class="comment">* &#123;C:B,B:A&#125; a有一个别名叫做 b  b有一个别名叫做 c</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 通过这个方法canonicalName 去处理 bean的名字 和别名之间的关系  ，最终返回的是  bean 的真实名字。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">return</span> canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-canonicalName"><a href="#4-1-canonicalName" class="headerlink" title="4.1 canonicalName()"></a>4.1 canonicalName()</h3><p>处理bean的名字与别名。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*假设传入c*/</span></span><br><span class="line">String canonicalName = name;</span><br><span class="line"><span class="comment">// Handle aliasing...</span></span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/*根据c会从map拿到b*/</span></span><br><span class="line">resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line"><span class="comment">/*如果获取到的结果不是null*/</span></span><br><span class="line"><span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*赋值再次循环拿*/</span></span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*当resolvedName是空的时候，那么此时的canonicalName一定是最终的名字，返回即可。*/</span></span><br><span class="line"><span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-BeanFactoryUtils-transformedBeanName-name"><a href="#4-2-BeanFactoryUtils-transformedBeanName-name" class="headerlink" title="4.2 BeanFactoryUtils.transformedBeanName(name)"></a>4.2 BeanFactoryUtils.transformedBeanName(name)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transformedBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*断言*/</span></span><br><span class="line">Assert.notNull(name, <span class="string">&quot;&#x27;name&#x27; must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*如果当前bean对象不是 &amp; 开头 （说明是正常bean对象实例） 直接返回*/</span></span><br><span class="line"><span class="keyword">if</span> (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里是拿工厂bean的逻辑：</span></span><br><span class="line"><span class="comment">* transformedBeanNameCache：缓存处理完&amp;开头的beanName，提升性能</span></span><br><span class="line"><span class="comment">* map.computeIfAbsent(k,v) 说明：</span></span><br><span class="line"><span class="comment">* 当map中对应的k ==null || v ==null 这次写操作就会成功，并且返回 k v，</span></span><br><span class="line"><span class="comment">* 否则就会失败，并且返回原有的k v。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设bean name = &amp;abc</span></span><br><span class="line"><span class="comment"> * 判断如果name不是以 &amp;开头  跳出循环  最终会返回 abc。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line"><span class="keyword">return</span> beanName;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-合并bd信息"><a href="#5-合并bd信息" class="headerlink" title="5.合并bd信息"></a>5.合并bd信息</h2><p><code>**getMergedBeanDefinition()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line"><span class="comment">/*从缓存获取*/</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line"><span class="comment">/*缓存有，直接返回*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*真正的合并 bd 的逻辑*/</span></span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(String beanName, BeanDefinition bd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, bd, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下其实又回到了上面的<code>**getMergedBeanDefinition()**</code>，递归去处理bd信息。</p><p>合并完bd信息之后就是判断是否是工厂bean的逻辑，想要获取工厂bean，在前面提到过，需要在bean的名字前面加一个 &amp; 。<br>​</p><p>默认情况下，我们要看单实例bean的获取过程，此时我们去看 <code>**getBean()**</code>。<br>​</p><h2 id="6-获取单实例bean对象"><a href="#6-获取单实例bean对象" class="headerlink" title="6.获取单实例bean对象"></a>6.获取单实例bean对象</h2><p><code>**getBean()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">/*真正加载bean的方法*/</span></span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**doGetBean()**</code>    返回一个指定的bean实例，这个bean可以是共享的，也可以是单例的。<br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 处理转换bean名字，可能是一个别名，也可能是一个带着&amp; 开头的beanName</span></span><br><span class="line"><span class="comment">* 别名：重定向出来真的beanName</span></span><br><span class="line"><span class="comment">* &amp;开头：说明要获取的bean实例对象实际上是一个工厂bean</span></span><br><span class="line"><span class="comment">* FactoryBean ：如果某个bean的配置特别复杂，使用spring管理不容易...不够灵活，想要使用编码的形式去构建它，</span></span><br><span class="line"><span class="comment">* 那么你就可以提供一个构建该bean实例的工厂，这个工厂就是factoryBean接口</span></span><br><span class="line"><span class="comment">* factoryBean接口的实现类还是需要spring来管理的。</span></span><br><span class="line"><span class="comment">* 这里就涉及到两种对象：一种是beanFactory实现类   另一个是FactoryBean内部管理的对象。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 如果要获取工厂bean，需要获取 &amp;</span></span><br><span class="line"><span class="comment">* 如果要拿factoryBean内部管理的对象，直接传name 不需要带着 &amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String beanName = transformedBeanName(name);</span><br><span class="line"><span class="comment">//保留返回值的</span></span><br><span class="line">Object beanInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*到缓存中获取共享单实例  第一次去缓存拿*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.第一次经过这里是创建man的时候，首先去缓存获取，但是这个时候，man对象时第一次创建，所以什么都拿不到</span></span><br><span class="line"><span class="comment"> * 2.此时man在第三级缓存，然后去拿women，这个时候women还没创建，所以锤子也拿不到</span></span><br><span class="line"><span class="comment"> * 3.第三次经过这里的时候，实际上就是women创建完了，放到三级缓存了，然后发现属性赋值的时候需要man，又通过getBean来拿，</span></span><br><span class="line"><span class="comment"> * 这个时候，在第三级缓存拿到了早期对象的引用，然后并对man进行一个缓存升级 ，从 三级缓存升级到了二级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">/*此时的逻辑应该是从二级缓存拿到了早期暴露的bean实例，并且属性没有填充*/</span></span><br><span class="line"><span class="comment">/*这里如果是第一次创建bean实例，上面从一级缓存实际上是啥也没拿到，所以走到这里，实例是null。*/</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里为什么又要包装一层呢？</span></span><br><span class="line"><span class="comment">* 从ioc中拿到的对象可能是普通的单实例，也可能是FactoryBean实例</span></span><br><span class="line"><span class="comment">* 如果是FactoryBean实例，还要考虑进行处理  主要看name带不带 &amp;</span></span><br><span class="line"><span class="comment">* 带&amp;说明这次getBean想要拿工厂bean，否则想要拿 FactoryBean 内部管理的 bean 实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.走到这里是什么时候？创建man，然后对man进行属性赋值，发现需要women，然后递归去创建women，然后对women进行属性赋值，</span></span><br><span class="line"><span class="comment"> * 然后发现需要man，然后从缓存拿，恰好此时从三级缓存拿到了，早期man对象的引用，这个时候，这里啥也没干，直接return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行到这里的情况：sharedInstance == null || args != null</span></span><br><span class="line"><span class="comment">* 1. 二级缓存未拿到bean实例</span></span><br><span class="line"><span class="comment">* 2. 二级缓存拿到了bean实例，但是属性已经填充完了    ！！！这是不可能的，这样的话就在一级缓存了。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 缓存没有想要的数据</span></span><br><span class="line"><span class="comment">* 1.原型循环依赖问题的判定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 原型循环依赖的判定</span></span><br><span class="line"><span class="comment">* eg： a(prototype) - b  b - a (prototype)</span></span><br><span class="line"><span class="comment">* 1.会像正在创建中的原型集合添加 a</span></span><br><span class="line"><span class="comment">* 2.创建 a 早期对象  二级缓存</span></span><br><span class="line"><span class="comment">* 3.处理 a的依赖 发现 a 依赖 b 类型</span></span><br><span class="line"><span class="comment">* 4.触发 spring getBeab(b.class) 的操作</span></span><br><span class="line"><span class="comment">* 5.根据 b 的构造方法 反射创建  b 的早期实例</span></span><br><span class="line"><span class="comment">* 6.spring 处理 b 对象的依赖发现依赖了 a</span></span><br><span class="line"><span class="comment">* 7.所以spring砖头回来再次获取 a getBean(a.class)</span></span><br><span class="line"><span class="comment">* 8.程序再次来到这里会判断当前要获取的a对象是不是正在创建中   如果是循环依赖  会返回true ，最终抛出异常 结束了循环依赖注入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*父子容器相关的处理逻辑*/</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*穿的是false就成立*/</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将指定的 bean 标记为已创建（或即将创建）。</span></span><br><span class="line"><span class="comment">* 允许 bean 工厂优化其缓存以重复创建指定 bean。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.第一次创建man的时候，经过这里，标记man正在创建中</span></span><br><span class="line"><span class="comment"> * 2.第二次经过这里的时候，就是对man进行属性赋值的过程中，发现依赖women，所以去走getBean逻辑。这个时候去标记women也是正在被创建中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line">StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">.tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取合并beanDefinition信息</span></span><br><span class="line"><span class="comment">* 为什么需要合并？</span></span><br><span class="line"><span class="comment">* bd 支持继承  子 会 继承 父亲 的所有 信息</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">/*判断当前mbd是不是抽象的，如果是抽象的，需要抛出异常，因为抽象的bd不能创建实例，只能作为模板让子bd继承*/</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* depends-on 属性处理</span></span><br><span class="line"><span class="comment">* &lt;bean name=&quot;A&quot; depends-on=&quot;B&quot; /&gt;</span></span><br><span class="line"><span class="comment">* &lt;bean name=&quot;B&quot; /&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 循环依赖问题   b - a  a - b</span></span><br><span class="line"><span class="comment">* spring是处理不了这种情况的，需要报错</span></span><br><span class="line"><span class="comment">* spring需要发现这种情况的产生：</span></span><br><span class="line"><span class="comment">* 如何发现？依靠两个map</span></span><br><span class="line"><span class="comment">* 1.dependentBeanMap 记录依赖当前beanName的其他beanName</span></span><br><span class="line"><span class="comment">* 2.dependenciesForBeanMap 记录当前bean依赖的其他bean集合</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="comment">/*判断循环依赖*/</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册依赖关系</span></span><br><span class="line"><span class="comment">* 1.记录a依赖了谁</span></span><br><span class="line"><span class="comment">* 2.记录谁依赖了b</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建单实例</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"><span class="comment">/*第二个 getSingthon() 创建实例并返回*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.第一次经过这里是去创建man对象</span></span><br><span class="line"><span class="comment"> * 2.创建women对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里为什么不直接返回 ，还调用 这个方法？</span></span><br><span class="line"><span class="comment">* 创建出来的单实例bean也可能是工厂bean对象，所以需要根据名字判断到底返回</span></span><br><span class="line"><span class="comment">* bean对象还是工厂bean</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*多例bean的创建*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*记录当前线程相关的正在创建的原型对象beanName*/</span></span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="comment">/*创建对象*/</span></span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">/*从正在创建中的集合中移除*/</span></span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*other作用域： 略 ....*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">beanCreation.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.走到这里的逻辑：对man进行属性赋值，递归创建women，对women进行属性赋值，然后从缓存拿到了man</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑有点多，进行一个简单的梳理：<br>​</p><ol><li>首先上来先处理bean的名字 <code>**transformedBeanName(name)**</code></li><li>然后尝试通过 <code>**getSingleton(beanName) **</code>去一级缓存拿数据，但是这个时候这个bean对象还没有创建过，此时是拿不到数据的。</li></ol><ul><li>如果说拿到了bean对象，那么就再通过  <code>**getObjectForBeanInstance() **</code>对bean对象进行一层包装。<blockquote><p>这里为什么又要包装一层呢？<br>从IOC中拿到的对象可能是普通单实例bean对象，也可能是一个工厂bean对象。<br>如果是工厂bean对象，还需要考虑是不是需要处理，主要是看名字里面带不带 &amp; 。<br>如果带 &amp; ，就是想要拿工厂本身，如果不带 &amp; ，其实就是想拿工厂bean生产的对象。</p></blockquote></li></ul><ol start="3"><li>正常第一次去获取bean对象的时候，是在缓存拿不到数据的，所以会走else的逻辑。</li><li>判断是不是原型模式的循环依赖，如果是的话，抛出异常。</li><li>然后就是护理父子容器相关的逻辑</li><li>如果是第一次创建bean，就会通过一个状态位来标记bean正在创建中</li><li>获取合并后的bd信息</li><li>判断当前bean对象是不是抽象的，如果是抽象的，需要跑出异常，因为抽象的bean是模板bean，不能创建实例</li><li>判断是不是发生互相依赖，注意是互相依赖，不是循环依赖，如果是发生了互相依赖，则抛出异常。<blockquote><p>互相依赖：bean标签或者@Bean 注解里面配置了 <code>**depends-on=&quot;B&quot;  a-&gt;b , b-&gt;a**</code><br>​</p></blockquote></li></ol><blockquote><p>循环依赖：a里面有个属性叫做b，b里面有个属性a<br></p></blockquote><ol start="10"><li>注册依赖关系，记录当前bean依赖了谁，谁依赖了当前bean</li><li>判断如果是单实例bean，这次就会通过<code>**getSingleton()-&gt;createBean()**</code>去创建bean对象</li><li> 然后再通过<code>**getObjectForBeanInstance() **</code>对bean对象进行一层包装</li><li>如果是原型实例的bean对象，就会走多实例bean创建的流程，其实还是通过<code>**createBean()**</code>去创建对象，只是不会被一级缓存所缓存。</li><li>对于其他作用域的bean对象，则走他们的创建逻辑，再次不作为重点内容分析。</li><li>最终的逻辑<code>**adaptBeanInstance()**</code>其实就是对循环依赖的处理，对 A对象属性赋值的时候，发现需要B对象。然后从一级缓存拿发现没有，就走这里递归去创建B对象，从缓存拿到A对象，对B对象进行属性赋值。</li></ol><h2 id="7-getSingleton"><a href="#7-getSingleton" class="headerlink" title="7.getSingleton()"></a>7.getSingleton()</h2><p>看一下这个方法，从缓存来获取bean。这个方法在 <code>**DefaultSingletonRegistry**</code> 中。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*方法重载   allowEarlyReference  是否允许拿到早期引用*/</span></span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发生了方法重载。这个方法挺叼的，根据名称来返回单实例bean对象，能够解决循环依赖。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*通过名字去一级缓存拿单实例bean对象*/</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="comment">/*如果拿到的对象实例是null，有几种情况？</span></span><br><span class="line"><span class="comment">* 1.单实例确实没创建呢</span></span><br><span class="line"><span class="comment">* 2. 当前正在创建中，发生了循环依赖了，这个时候实例其实在二级缓存</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 循环依赖：</span></span><br><span class="line"><span class="comment">* A-&gt;B  B-&gt;A</span></span><br><span class="line"><span class="comment">* 单实例的循环依赖有几种？</span></span><br><span class="line"><span class="comment">* 1.构造方法   无解</span></span><br><span class="line"><span class="comment">* 2.setter    有解   通过三级缓存</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 三级缓存实际上如何解决的循环依赖？</span></span><br><span class="line"><span class="comment">* 利用bean的中间状态 ：已经实例化但是还未初始化</span></span><br><span class="line"><span class="comment">* A-B  B-&gt;A  setter依赖</span></span><br><span class="line"><span class="comment">* 1. 假设spring先实例化A，首先拿到A的构造方法，反射创建A的早期实例对象，这个早期对象被包装了一下，</span></span><br><span class="line"><span class="comment">* 变成ObjectFactory对象，放到三级缓存。</span></span><br><span class="line"><span class="comment">* 2. 处理A的依赖数据，检查发现 A依赖B ，所以，spring 根据 B的类型去容器中去getBean(B.class) ,这里就是递归了</span></span><br><span class="line"><span class="comment">* 3. 首先拿到B的构造方法，反射创建B的早期实例对象，把B包装成ObjectFactory对象，放到三级缓存。</span></span><br><span class="line"><span class="comment">* 4. 处理Bde 依赖数据，检查发现，B依赖对象A，所以接下来，spring就会根据A类型去容器去getBean(A.class) 对象，这个时候又递归了</span></span><br><span class="line"><span class="comment">* 5. 程序还会走到当前方法getSingleton</span></span><br><span class="line"><span class="comment">* 6. 条件一成立，条件二成立。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">/*从二级缓存拿数据*/</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="comment">/*条件成立说明二级缓存没有  去三级缓存拿*/</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* spring为什么需要有三级缓存，而不是只有二级缓存？</span></span><br><span class="line"><span class="comment">* AOP 靠什么实现呢？动态代理  jdk cglib</span></span><br><span class="line"><span class="comment">* 代理：静态代理：需要手动写代码实现新的JAVA文件，这个JAV类需要和代理对象实现同一个接口，内部维护一个被代理对象</span></span><br><span class="line"><span class="comment">* 代理类在接口调用原生对象前后可以加一些逻辑。</span></span><br><span class="line"><span class="comment">* 代理对象和被代理对象是两个不同的内存地址，一定是不一样的</span></span><br><span class="line"><span class="comment">*    动态代理：... 不需要人为写代码了，而是依靠字节码框架动态生成字节码文件，然后jvm在进行加载，然后也是一样</span></span><br><span class="line"><span class="comment">* 也是去new代理对象，这个代理对象没啥特殊的，也是内部保留了原生对象，然后再调用原生对象前后实现的字节码增强。</span></span><br><span class="line"><span class="comment">* 两者共同点：代理对象和被代理对象实际上都不是同一内存地址</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 三级缓存在这里有什么意义呢？</span></span><br><span class="line"><span class="comment">* 三级缓存里面保存的是对象工厂，这个对象工厂内部保留着原生对象的引用，ObjectFactory的实现类，getObject方法，</span></span><br><span class="line"><span class="comment">* 需要考虑一个问题：到底是返回原生的，还是增强的？</span></span><br><span class="line"><span class="comment">* getObject会判断当前早期实例是否需要被增强，如果是 那么提前完成动态代理增强，返回代理对象，否则，返回原生对象。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*从一级缓存拿*/</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*从二级缓存拿*/</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*从三级缓存拿*/</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="comment">/*条件成立：说明第三级缓存有数据。这里就涉及到了缓存的升级 ，很简单 ，从三级挪到二级 ，再反手干掉三级的。*/</span></span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理一下这个方法的大体逻辑：(我们现在走的是单实例bean创建的流程，所以假设我们正在创建一个单实例bean，执行到了这里，三级缓存与循环依赖的问题会在后续文章分析。)<br>​</p><ol><li>先根据名字去一级缓存拿bean，此时是拿不到的。</li><li>判断当前bean，是不是单实例bean对象，是不是正在创建中？<blockquote><p>走这里的逻辑就是发生了循环依赖：</p><ol><li>假设spring先实例化A，首先拿到A的构造方法，反射创建A的早期实例对象，这个早期对象被包装了一下，变成ObjectFactory对象，放到三级缓存。<br><br>2. 处理A的依赖数据，检查发现 A依赖B ，所以，spring 根据 B的类型去容器中去getBean(B.class) ,这里就是递归了<br></li><li>首先拿到B的构造方法，反射创建B的早期实例对象，把B包装成ObjectFactory对象，放到三级缓存。<br></li><li>处理Bde 依赖数据，检查发现，B依赖对象A，所以接下来，spring就会根据A类型去容器去getBean(A.class) 对象，这个时候又递归了<br></li><li>程序还会走到当前方法getSingleton<br></li></ol></blockquote></li></ol><ul><li>首先去二级缓存拿数据，这个时候二级缓存是拿不到数据的，所以会继续往下走</li><li>再次尝试从一级缓存和二级缓存拿，这个时候其实还是拿不到的，所以从三级缓存来拿</li><li>如果三级缓存拿到了数据，那就进行缓存的升级<blockquote><p>把三级缓存的对象拿到二级缓存，三级缓存的对象干掉。</p></blockquote></li></ul><p>​</p><h2 id="8-思考与沉淀"><a href="#8-思考与沉淀" class="headerlink" title="8.思考与沉淀"></a>8.思考与沉淀</h2><p><strong>spring为什么需要有三级缓存，而不是只有二级缓存？</strong><br>AOP 靠什么实现呢？动态代理  jdk cglib<br>代理：静态代理：需要手动写代码实现新的JAVA文件，这个JAV类需要和代理对象实现同一个接口，内部维护一个被代理对象<br>    代理类在接口调用原生对象前后可以加一些逻辑。<br>    代理对象和被代理对象是两个不同的内存地址，一定是不一样的<br>       动态代理：… 不需要人为写代码了，而是依靠字节码框架动态生成字节码文件，然后jvm在进行加载，然后也是一样<br>    也是去new代理对象，这个代理对象没啥特殊的，也是内部保留了原生对象，然后再调用原生对象前后实现的字节码增强。<br>两者共同点：代理对象和被代理对象实际上都不是同一内存地址<br>​</p><p><strong>三级缓存在这里有什么意义呢？</strong><br>三级缓存里面保存的是对象工厂，这个对象工厂内部保留着原生对象的引用，ObjectFactory的实现类，getObject方法，<br>需要考虑一个问题：到底是返回原生的，还是增强的？<br>getObject会判断当前早期实例是否需要被增强，如果是 那么提前完成动态代理增强，返回代理对象，否则，返回原生对象。<br>​</p><h2 id="9-getObjectForBeanInstance"><a href="#9-getObjectForBeanInstance" class="headerlink" title="9.getObjectForBeanInstance()"></a>9.getObjectForBeanInstance()</h2><p>这个方法是获取给定的bean实例对象，如果是工厂bean，则根据名字返回工厂本身或者其创建的对象。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取给定 bean 实例的对象，如果是 FactoryBean，则是 bean 实例本身或其创建的对象。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanInstance   共享单实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name  未处理 &amp; 的 name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName  处理过&amp; 和别名后的name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition  合并过后的beanDefinition信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object to expose for the bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*判断当前的name是不是&amp;开始的，条件成立，说明当前要获取的是工厂bean对象*/</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*条件成立：说明但实例对象不是工厂bean接口的实现类  直接报错*/</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*打标  给当前bean对应的mbd打标，记录他表达的实例是一个工厂bean*/</span></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行到这里有几种情况？</span></span><br><span class="line"><span class="comment">* 1.当前bean实例是普通单实例</span></span><br><span class="line"><span class="comment">* 2.当前bean实例是工厂bean接口实现类，但是当前要获取的是工厂内部管理的bean实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*保存工厂bean实例的getobject值得*/</span></span><br><span class="line">Object object = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*尝试到缓存获取工厂bean*/</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*此时说明缓存没有，需要到工厂bean getObject 获取*/</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Return bean instance from factory.</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">// 条件一几乎恒成立   条件二：判断spring中当前是否有当前beanName的bd信息</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">/*拿到合并后的bd信息</span></span><br><span class="line"><span class="comment">* 为什么是合并后的呢？</span></span><br><span class="line"><span class="comment">* 因为bd支持继承的，合并后的bd信息是包含继承回来的bd</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*synthetic默认值是false ，表示这是一个用户对象  如果是 true 表示是系统对象*/</span></span><br><span class="line"><span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line"><span class="comment">/*到这里说明  说明真正的去执行 getBean() 的逻辑   time 【51：32】*/</span></span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><ol><li>判断当前的name是不是 &amp; 开始的，条件成立，说明当前要获取的是工厂bean对象</li></ol><ul><li>如果当前bean独享没有实现工厂bean接口，直接报错</li><li>打标：给当前bean对应的mbd打标，记录他表达的实例是一个工厂bean对象</li><li>返回bean实例</li></ul><ol start="2"><li>判断如果当前bean没有实现工厂bean接口，（思考一下，走到这里的逻辑，其实要么是单实例bean，要么是获取工厂bean创建的对象），既然没有实现工厂bean接口，所以这里的逻辑就是处理单实例bean的。</li></ol><ul><li>直接返回就行了</li></ul><ol start="3"><li>走到这里的逻辑就是一种情况：获取工厂bean创建的bean对象。</li></ol><ul><li>在mbd打标，表示是一个工厂bean对象</li><li>如果缓存里面没有当前bean工厂生产的对象，需要通过工厂bean的<code>**getBean()**</code>去获取。</li><li>判断有没有bd信息，如果没有就合并bd信息得到mbd信息</li><li>然后再通过<code>**getObjectFromFactoryBean() **</code>根据mbd信息去获取bean对象</li></ul><p></p><h3 id="9-1-getObjectFromFactoryBean"><a href="#9-1-getObjectFromFactoryBean" class="headerlink" title="9.1 getObjectFromFactoryBean()"></a>9.1 getObjectFromFactoryBean()</h3><p>这个方法的逻辑上存在问题，但是不影响分析。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*如果是已经存在的单实例bean对象*/</span></span><br><span class="line"><span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">/*加锁 内部逻辑是串行化的，不存在并发*/</span></span><br><span class="line"><span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line"><span class="comment">/*先从缓存获取*/</span></span><br><span class="line">Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*这里已经是空了*/</span></span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line"><span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="comment">/*这里一定是空，因为是串行化的方法，所以逻辑有问题*/</span></span><br><span class="line"><span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="comment">/*判断当前实例是否被创建    逻辑有问题    明明上面就是没创建 */</span></span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*执行后置处理器的逻辑*/</span></span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*工厂bean对象内部维护的对象不是单实例，每次都是一个新对象*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*直接拿*/</span></span><br><span class="line">Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*后置处理器的逻辑*/</span></span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if里面的判断是不会成立的，所以直接看else的逻辑。<br>​</p><p>通过委派模式委派给<code>**doGetObjectFromFactoryBean()**</code>去拿bean对象，然后再执行后置处理器的逻辑。<br>​</p><p>继续往下分析：<br>​</p><h3 id="9-2-doGetObjectFromFactoryBean"><a href="#9-2-doGetObjectFromFactoryBean" class="headerlink" title="9.2 doGetObjectFromFactoryBean()"></a>9.2 doGetObjectFromFactoryBean()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;FactoryBean threw exception on object creation&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not accept a null value for a FactoryBean that&#x27;s not fully</span></span><br><span class="line"><span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">beanName, <span class="string">&quot;FactoryBean which is currently in creation returned null from getObject&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">object = <span class="keyword">new</span> NullBean();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的核心代码其实就是只有一句：调用工厂bean的<code>**factory.getObject()**</code> 获取bean对象。<br>​</p><p>剩余的<code>**createBean()**</code> &amp;  <code>**adaptBeanInstance()**</code>，<code>**createBean()**</code>创建bean的逻辑会在下一篇中深入分析，<code>**adaptBeanInstance()**</code>循环依赖相关的逻辑会在后续的三级缓存与循环依赖篇中分析，与本次的创建单实例bean对象关系并不大。至此，整个<code>**getBean()**</code>就分析完了。<br>​</p><h2 id="10-触发所有单实例bean初始化后的回调逻辑"><a href="#10-触发所有单实例bean初始化后的回调逻辑" class="headerlink" title="10.触发所有单实例bean初始化后的回调逻辑"></a>10.触发所有单实例bean初始化后的回调逻辑</h2><p>在<code>**preInstantiateSingletons()**</code>里面通过 getBean() 方法实例化完所有的单实例bean以后，就会触发所有 <code>**SmartInitializingSingleton**</code> 的 <code>**afterSingletonsInstantiated()**</code>。<br><br>这个组件具体的作用，在前面的Spring组件与注解篇里面已经详细介绍过，在此不再赘述。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发所有的单实例bean的初始化后的回调逻辑</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="comment">//从一级缓存获取单实例bean</span></span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="comment">//类型断言，执行回调</span></span><br><span class="line"><span class="comment">/*SmartInitializingSingleton里面有一个方法 afterSingletonsInstantiated 这个方法需要在创建好单实例bean之后调用一下*/</span></span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">StartupStep smartInitialize = <span class="keyword">this</span>.getApplicationStartup().start(<span class="string">&quot;spring.beans.smart-initialize&quot;</span>)</span><br><span class="line">.tag(<span class="string">&quot;beanName&quot;</span>, beanName);</span><br><span class="line">SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="comment">//这里就是触发初始化后的回调逻辑</span></span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">smartInitialize.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一篇，我们将继续分析bean对象的创建逻辑 <code>**createBean()**</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[三]解析配置文件</title>
      <link href="/2022/01/11/Spring/Spring%5B%E4%B8%89%5D%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2022/01/11/Spring/Spring%5B%E4%B8%89%5D%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本来这一篇是要写如何加载所有的单实例bean对象，但是回顾第二篇，发现对于解析xml文件加载bean定义信息的部分理解表达的并不是很好，所以在此补充一篇Spring解析配置文件，加载bean定义信息的文章。</p></blockquote><p>​</p><h2 id="1-以refresh-作为抓手"><a href="#1-以refresh-作为抓手" class="headerlink" title="1.以refresh()作为抓手"></a>1.以refresh()作为抓手</h2><p><code>**refresh()**</code>作为容器的刷新方法，重要性不必多说，在里面的第二个方法<code>**obtainFreshBeanFactory()**</code>里面，解析了xml配置文件或注解，载入bean定义资源信息，返回了一个全新的bean工厂。接下来来分析<code>**obtainFreshBeanFactory()**</code>。<br>​</p><h2 id="2-obtainFreshBeanFactory"><a href="#2-obtainFreshBeanFactory" class="headerlink" title="2.obtainFreshBeanFactory()"></a>2.obtainFreshBeanFactory()</h2><p>解析xml文件或者注解，加载bean 的定义信息，创建一个全新的bean工厂。<br>​</p><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//刷新bean工厂</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="comment">/**返回bean工厂*/</span></span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="3-refreshBeanFactory"><a href="#3-refreshBeanFactory" class="headerlink" title="3.refreshBeanFactory()"></a>3.refreshBeanFactory()</h2><p>这里面主要就是判断当前有没有bean工厂，如果有的话，就把工厂关了，重新造一个，如果没有的话，直接造一个。总之一定要造一个新的工厂。<code>**createBeanFactory()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">/*如果已经有了bean工厂，通常情况下并不会，什么情况下会有？通过applicationContext直接调用refresh方法*/</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line"><span class="comment">/*销毁里面的所有bean*/</span></span><br><span class="line">destroyBeans();</span><br><span class="line"><span class="comment">/*关闭bean工厂*/</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//不管上面是否已经有bean工厂存在，最终都会走到这里，去创建一个bean工厂</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line"><span class="comment">/*设置序列化id*/</span></span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">/*对工厂进行一些定制化设置*/</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">/*加载bean的定义信息*/</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="comment">/*将当前类的bean工厂引用指向创建的bean工厂*/</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**createBeanFactory()**</code><br>返回一个全新的bean工厂。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次容器刷新的时候尝试调用此方法。默认创建一个<code>**DefaultListableBeanFactory**</code>，并将此上下文父级的内部bean工厂作为父bean工厂。<br>​</p><p>可以再子类中覆盖，例如自定义<code>**DefaultListableBeanFactory**</code>的设置。<br>​</p><p>创建完工厂了，就要往工厂里面放东西，<code>** loadBeanDefinitions(beanFactory)**</code>。<br>​</p><h2 id="4-loadBeanDefinitions-beanFactory"><a href="#4-loadBeanDefinitions-beanFactory" class="headerlink" title="4.loadBeanDefinitions(beanFactory)"></a>4.loadBeanDefinitions(beanFactory)</h2><p>载入bean的定义信息 <code>**beanDefinition**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个xml 的beanDefinition加载器 这个玩意里面持有一个beanFactory的引用</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给beanDefinition 加载器设置上下文环境  资源加载器   实体解析器*/</span></span><br><span class="line"><span class="comment">/*这玩意我记得都是用的默认的*/</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化beanDefinition加载器*/</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"><span class="comment">/*使用beanDefinition加载器加载beanDefinitions*/</span></span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了一个bean定义信息的加载器 <code>**XmlBeanDefinitionReader**</code>，用来解析xml文件。<br>​</p><p>然后给<code>**XmlBeanDefinitionReader**</code>设置一些相关信息。<br>​</p><p>然后初始化 <code>**XmlBeanDefinitionReader**</code>。<code>**initBeanDefinitionReader(beanDefinitionReader)**</code><br>​</p><p>最后使用<code>**XmlBeanDefinitionReader**</code>加载bean的定义信息。<code>**loadBeanDefinitions(beanDefinitionReader)**</code><br></p><h2 id="5-bean定义信息加载器"><a href="#5-bean定义信息加载器" class="headerlink" title="5.bean定义信息加载器"></a>5.bean定义信息加载器</h2><p><code>**XmlBeanDefinitionReader**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器里面传入了一个<code>**BeanDefinitionRegistry**</code>，给父类<code>**AbstractBeanDefinitionReader**</code>的属性赋值。<br>​</p><p>​</p><h2 id="6-Bean定义信息注册器"><a href="#6-Bean定义信息注册器" class="headerlink" title="6.Bean定义信息注册器"></a>6.Bean定义信息注册器</h2><p><code>**BeanDefinitionRegistry**</code><br><strong>​</strong></p><p>持有bean定义的注册表接口。例如<code>_**RootBeanDefinition**_</code>_ 和 <em><code>_**ChildBeanDefinition**_</code></em> 实例。_<br><em>​</em></p><p><em>通常由在内部使用</em><code>_**AbstractBeanDefinition**_</code>层次结构的<code>**beanFactory**</code>实现。<br>​</p><p>这是spring的bean工厂中唯一封装<code>**BeanDefinitionRegistry**</code>的接口。标准的<code>**BeanFactory**</code>接口仅仅涵盖对完全配置的工厂的工厂实例的访问。<br>​</p><p>spring的<code>**BeanDefinitionRegistry**</code>期待作用于该接口的实现。spring中已经有的实现是<code>_**DefaultListableBeanFactory**_</code>_ &amp; _<code>_**GenericApplicationContext**_</code><em>。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*注册一个bean的定义信息，支持指定bean的名字*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据bean的名字移除掉已经注册的beanDefinition*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据名字查找BeanDefinition*/</span></span><br><span class="line"><span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="comment">/*判断是否包含给定名字的BeanDefinition信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"><span class="comment">/*返回已经注册的BeanDefinition名字列表*/</span></span><br><span class="line">String[] getBeanDefinitionNames();</span><br><span class="line"><span class="comment">/*返回已经注册的BeanDefinition数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*确定给定的bean名称是否已经在注册中心使用， 怎么判断是否使用呢？就是是否有别名注册在此名称下，或者已经有注册在这里的bean。*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-初始化beanDefinition的加载器"><a href="#7-初始化beanDefinition的加载器" class="headerlink" title="7.初始化beanDefinition的加载器"></a>7.初始化beanDefinition的加载器</h2><p><code>**initBeanDefinitionReader(beanDefinitionReader)**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化用于加载次上下文的beanDefinition的beanDefinitionReader。默认实现为空。可以再子类中覆盖，例如关闭xml验证或使用不同的<code>_**XmlBeanDefinitionParser**_</code>实现。<br>​</p><h2 id="8-加载bean的定义信息"><a href="#8-加载bean的定义信息" class="headerlink" title="8.加载bean的定义信息"></a>8.加载bean的定义信息</h2><p><code>**loadBeanDefinitions(beanDefinitionReader)**</code><br><strong>​</strong></p><p>使用给定的<code>_**XmlBeanDefinitionReader**_</code>加载<code>**beanDefinition**</code>。<br>​</p><p><code>**BeanFactory**</code>的生命周期由<code>_**refreshBeanFactory() **_</code>处理，因此此方法仅用于加载和注册<code>**beanDefinition**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">/*这里实际上是一个钩子方法，经典的模板模式，子类根据需要对方法进行重写，实际上加载xml的时候，这里锤子也没拿到*/</span></span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="comment">/*如果资源不为空，走这里的逻辑，但是上面已经分析过，实际上锤子也没拿到，所以走下面的逻辑*/</span></span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取配置文件位置*/</span></span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="comment">/*此时读取到了我们在配置文件指定的配置文件 beans.xml*/</span></span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里我们注意两个方法：<br>​</p><ol><li><code>**getConfigLocations()**</code>   获取到配置文件的位置</li><li><code>**reader.loadBeanDefinitions(configLocations)**</code> 使用bean定义信息的加载器加载<code>**beanDefinition**</code>。</li></ol><p><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> String[] getConfigLocations() &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.configLocations != <span class="keyword">null</span> ? <span class="keyword">this</span>.configLocations : getDefaultConfigLocations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回一个资源位置数组，指的是构建此上下文应用的时候使用的 xml配置文件。还可以包括位置模式，这将通过<code>_**ResourcePatternResolver**_</code>处理。默认实现返回null。子类可以重写这个方法用来提供一组资源位置来加载<code>**beanDefinition**</code>。<br>​</p><h2 id="9-reader-loadBeanDefinitions-configLocations"><a href="#9-reader-loadBeanDefinitions-configLocations" class="headerlink" title="9.reader.loadBeanDefinitions(configLocations)"></a>9.reader.loadBeanDefinitions(configLocations)</h2><p>用bean定义信息的加载器加载<code>**beanDefinition**</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">/*断言 判空*/</span></span><br><span class="line">Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*记录beanDefinition的数量*/</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*迭代加载beanDefinition*/</span></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">count += loadBeanDefinitions(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是根据配置文件的位置数组进行循环迭代加载并记录<code>**beanDefinition**</code>的数量。<br>​</p><p>来到了<code>**AbstractBeanDefinitionReader**</code>的<code>**loadBeanDefinitions()**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">/*获取资源加载器*/</span></span><br><span class="line">ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line"><span class="comment">/*如果资源加载器为空，抛异常*/</span></span><br><span class="line"><span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果资源加载器是资源模式解析器类型的*/</span></span><br><span class="line"><span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line"><span class="comment">// Resource pattern matching available.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将xml配置文件加载到resources中，resource其实就是spring底层封装了很多的细节，</span></span><br><span class="line"><span class="comment">抽象出来的资源顶层接口</span></span><br><span class="line"><span class="comment">让开发人员不必专注于底层配置文件的加载细节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="comment">/*加载beanDefinition*/</span></span><br><span class="line"><span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line"><span class="comment">/*这玩意不知道是啥，反正是空，没啥锤子用*/</span></span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">Collections.addAll(actualResources, resources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*走到这里说明资源加载器肯定不是资源模式解析器类型的*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 只能通过绝对网址加载单个资源</span></span><br><span class="line">Resource resource = resourceLoader.getResource(location);</span><br><span class="line"><span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualResources.add(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取到资源的加载器，如果加载器是空，那就说明程序无法往下执行了，直接抛异常。<br>​</p><p>如果资源加载器是资源解析器模式的，加载xml文件到<code>**Resource**</code>数组中，<code>**Resource**</code>是什么在上一篇中已经介绍过了，在此不再赘述。<br>​</p><p>此时在根据<code>**Resource**</code>数组去加载<code>**beanDefinition**</code>，最后返回加载的<code>**beanDefinition**</code>的数量。（注意：这里走的是else的逻辑，因为默认我们不是位置模式。）<br>​</p><p>注意这个时候思路已经很明确了，准备了这么多实际上到这里就分为了两步：<br>​</p><ol><li>加载xml配置文件        <code>**getResource(location)**</code></li><li>通过xml配置文件去加载<code>**beanDefinition**</code>    <code>**loadBeanDefinitions(resource)**</code></li></ol><p><strong>​</strong></p><h2 id="10-加载xml配置文件"><a href="#10-加载xml配置文件" class="headerlink" title="10.加载xml配置文件"></a>10.加载xml配置文件</h2><p>来到<code>**DefaultResourceLoader**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);</span><br><span class="line"><span class="comment">//循环遍历使用解析器解析该location的资源，如果资源不为空，直接返回</span></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以/开头那么根据path去寻找*/</span></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*以classpath开头，那么抽象为ClassPathResource*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*其他情况采用urlResource来加载*/</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line"><span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是加载<code>**beanDefinition**</code>信息。<br></p><h2 id="11-加载beanDefinition"><a href="#11-加载beanDefinition" class="headerlink" title="11.加载beanDefinition"></a>11.加载beanDefinition</h2><p><code>**loadBeanDefinitions(resource)**</code><br><strong>​</strong></p><p>来到了 <code>**XmlBeanDefinitionReader**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//1.将resource包装成带有编码格式的EncodedResource</span></span><br><span class="line"><span class="comment">//2.重载调用loadBeanDefinitions()</span></span><br><span class="line"><span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来到重载的方法。<code>**loadBeanDefinitions(resource)**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//跳过断言  日志</span></span><br><span class="line">Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取引用：当前线程已经加载过的encodingResource资源</span></span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="comment">//将当前的encodingResource加入到threadlocal的set中，加入失败说明当前资源已经加载过了，不能重复加载，需要抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//jdk新版本的语法糖   拿到资源的输入流</span></span><br><span class="line"><span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line"><span class="comment">//因为接下来要使用 sax解析器，解析xml文件 ，所以需要将输入流包装成inputsource，</span></span><br><span class="line"><span class="comment">//inputsource是sax中表示资源的对象</span></span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="comment">//设置字符编码   spring源码中判断逻辑特别多  ，稳定化的框架并不相信一切外部的输入</span></span><br><span class="line"><span class="comment">//这也是软件架构原则中的规范之一  稳定性体现</span></span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正干活的逻辑  ，加载beanDefinition的入口</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//因为resourcesCurrentlyBeingLoaded表示当前线程正在加载的redource</span></span><br><span class="line"><span class="comment">//执行到这里说明资源已经加载完了或者失败了</span></span><br><span class="line"><span class="comment">//所以需要将当前资源移除出去</span></span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="comment">//set没有数据了，说明没啥乱用了，清理一下内存   防止threadlocal内存泄漏</span></span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了一个委派模式，将真正干活的逻辑交给了<code>**doLoadBeanDefinitions()**</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//把 resource 转换成程序层面可以识别的有层次结构的document对象</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">//解析文档对象，生成beanDefinition注册到beanFactory中，最终返回新注册到beanFactory的beanDefinition数量</span></span><br><span class="line"><span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="comment">//日志打印</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回新注册 bean定义信息的数量</span></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里省略部分catch的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再次分成了两步：<br>​</p><ol><li>将<code>**Resource**</code>转换成<code>**Document**</code>。        <code>**doLoadDocument(inputSource, resource)**</code></li><li>解析文档对象，生成<code>**beanDefinition**</code>注册到<code>**BeanFactory**</code>。        <code>**registerBeanDefinitions(doc, resource)**</code></li></ol><p>​</p><h2 id="12-Resource转化成Document"><a href="#12-Resource转化成Document" class="headerlink" title="12.Resource转化成Document"></a>12.Resource转化成Document</h2><p><code>**doLoadDocument(inputSource, resource)**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//这个方法就是将inputSource转化成可以识别的文档对象</span></span><br><span class="line"><span class="comment">//通过文档加载器来转化的</span></span><br><span class="line"><span class="comment">//1. getEntityResolver？ 这个实体解析器</span></span><br><span class="line"><span class="comment">//spring官网说明：如果sax应用程序中需要实现自定义处理外部实体，则必须实现此接口并使用setEntityResolver方法向sax驱动器注册一个实例</span></span><br><span class="line"><span class="comment">//也就是说，对于解析一个xml，sax首先读取xml文档上的声明，根据声明去寻找相应的DTD/XSD定义，以便对文档进行一个校验。</span></span><br><span class="line"><span class="comment">//默认的寻找校验规则，即通过网络来下载响应的DTD/XSD声明，在进行校验。并且下载的过程是一个漫长且不可控的过程，当下在失败后，这里还会抛出异常</span></span><br><span class="line"><span class="comment">//那么有什么办法可以避免直接从网络上下载呢？使用EntityResolver</span></span><br><span class="line"><span class="comment">//EntityResolver的作用是项目本身可以提供一个如何寻找DTD/XSD声明的方法，即让程序来实现寻找定义声明的过程，比如我们将定义文件</span></span><br><span class="line"><span class="comment">//放到项目的某个地方，在实现时直接将此文件读取并返回给sax即可，这样避免了通过网络来寻找对应的声明。</span></span><br><span class="line"><span class="comment">//2.验证模式是怎么获取的？getValidationModeForResource()</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**getValidationModeForResource(resource)**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getValidationModeForResource</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取默认的validationMode</span></span><br><span class="line"><span class="keyword">int</span> validationModeToUse = getValidationMode();</span><br><span class="line"><span class="comment">//条件成立：说明set过默认值，一般情况下，不会走这里，都是使用自动检测</span></span><br><span class="line"><span class="keyword">if</span> (validationModeToUse != VALIDATION_AUTO) &#123;</span><br><span class="line"><span class="keyword">return</span> validationModeToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动检查xml使用的是哪种验证模式？由这个方法决定</span></span><br><span class="line"><span class="keyword">int</span> detectedMode = detectValidationMode(resource);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detectedMode != VALIDATION_AUTO) &#123;</span><br><span class="line"><span class="keyword">return</span> detectedMode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hmm, we didn&#x27;t get a clear indication... Let&#x27;s assume XSD,</span></span><br><span class="line"><span class="comment">// since apparently no DTD declaration has been found up until</span></span><br><span class="line"><span class="comment">// detection stopped (before finding the document&#x27;s root tag).</span></span><br><span class="line"><span class="keyword">return</span> VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**documentLoader.loadDocument()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="params"><span class="function">ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"><span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**DocumentBuilder.parse() **</code>就是真正的解析逻辑。<br>​</p><h2 id="13-解析文档对象注册到BeanFactory"><a href="#13-解析文档对象注册到BeanFactory" class="headerlink" title="13.解析文档对象注册到BeanFactory"></a>13.解析文档对象注册到BeanFactory</h2><p><code>**registerBeanDefinitions()**</code> 解析文档对象，生成beanDefinition注册到beanFactory中，最终返回新注册到beanFactory的beanDefinition数量。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">//创建一个 BeanDefinitionDocumentReader   一对一处理    每个文档对象都会创建一个 BeanDefinitionDocumentReader 对象</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="comment">//getRegistry 会返回程序创建的beanFactory实例</span></span><br><span class="line"><span class="comment">//countBefore 解析doc之前，bf中已经有的bd数量</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//解析文档，并且注册到bf中</span></span><br><span class="line"><span class="comment">//xmlReaderContext :包含最主要的参数是当前 this -&gt; xmlBeanDefinitionReader  -&gt; bf</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="comment">//返回值 返回新注册的bd数量    最新的 - 注册之前的</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看重载的方法<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//引用上下文对象</span></span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line"><span class="comment">//doc.getDocumentElement()  拿出文档代表的xml的顶层标签  &lt;beans&gt;&lt;/beans&gt;</span></span><br><span class="line"><span class="comment">/*真正的解析xml的逻辑*/</span></span><br><span class="line">doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是一个委派模式，终于来到了解析xml的逻辑，这里的逻辑其实没有什么可以学习的点，追到这里主要是为了串起来整个解析xml文件的流程，具体解析xml的过程不做重点说明。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line"><span class="comment">//方法返回一个beans标签 解析器对象</span></span><br><span class="line"><span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"><span class="comment">//解析器对象去判断是不是默认的命名空间  一般情况下  条件成立</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">//获取 profile 属性， 环境  Dev  prod  test</span></span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="comment">//条件成立   说明 beans 标签上 有 profile 属性</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line"><span class="comment">//将属性值按照,拆分成字符串数组</span></span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line"><span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line"><span class="comment">// Environment.acceptsProfiles(String [] args) 条件成立  ：说明beans 标签可以继续解析 bd</span></span><br><span class="line"><span class="comment">//这里取反  ，所以   就是 if里面整个条件成立  ，说明该 beans 标签不在继续解析  ，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line"><span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是留给子类的扩展点</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line"><span class="comment">//这里也是留给子类扩展  体现的软件设计模式的开闭原则</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已经走到了这里，大概看一下里面的逻辑。<br>​</p><p><code>**parseBeanDefinitions(root, this.delegate)**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*条件成立说明root是spring缺省的命名空间*/</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">/*这里获取的，大部分情况下，其实都是bean标签*/</span></span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="comment">/*迭代处理每一个子标签*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="comment">/*说明子标签也是默认的spring标签*/</span></span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"><span class="comment">/*默认标签解析逻辑 step into*/</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;<span class="comment">/*自定义标签解析逻辑*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*root不是默认的命名空间，解析自定义标签逻辑*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们没有自定义标签，所以看默认标签的解析逻辑 <code>**parseDefaultElement(ele, delegate)**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*条件成立，说明此时是import标签*/</span></span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;<span class="comment">/*条件成立说明是alias别名标签*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;<span class="comment">/*此时说明是bean标签*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">/*解析bean标签*/</span></span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;<span class="comment">/*说明是嵌套beans标签*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// 递归到上层重新来了</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看一下bean标签的解析逻辑<code>**processBeanDefinition(ele, delegate)**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*用解析器对象解析标签  hodler里面包含三个属性：beanDefinition，beanName，Alias别名信息*/</span></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*如果当前hodler需要被装饰，执行装饰逻辑 主要是处理自定义属性*/</span></span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Register the final decorated instance.</span></span><br><span class="line"><span class="comment">/*注册当前bean倒容器中 通过readerContext拿到XMLBeanDefinition拿到beanFactory*/</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send registration event.</span></span><br><span class="line"><span class="comment">/*发送一个bean注册完成的事件*/</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**BeanDefinitionReaderUtils.registerBeanDefinition()**</code> 单实例bean的注册逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终将<code>**beanDefinition**</code>放到了<code>**beanDefinitionMap**</code>里面，至此整个解析xml配置文件，加载<code>**beanDefinition**</code>并返回全新<code>**BeanFactory**</code>的逻辑结束了。<br>​</p><p>​</p><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[二]IOC容器初始化</title>
      <link href="/2022/01/11/Spring/Spring%5B%E4%BA%8C%5DIoc%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/01/11/Spring/Spring%5B%E4%BA%8C%5DIoc%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从上层视角入手，观测Spring容器的初始化工作。</p></blockquote><h2 id="1-初始准备"><a href="#1-初始准备" class="headerlink" title="1.初始准备"></a>1.初始准备</h2><p>首先在Spring的源码工程里面创建一段代码，通过简单的运行代码，来追踪Spring ioc 容器的整个启动流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IocMainTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_LOCATION = <span class="string">&quot;applicationContext.xml&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义 ioc 容器进行扩展</span></span><br><span class="line">testDiyIoc();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDiyIoc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClassPathXmlApplicationContext ioc = <span class="keyword">new</span> MyClassPathXmlApplicationContext(CONFIG_LOCATION);</span><br><span class="line">Person person = ioc.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">ClassPathXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClassPathXmlApplicationContext</span><span class="params">(String...configLocations)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(configLocations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initPropertySources</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是我自己定义的ioc容器&quot;</span>);</span><br><span class="line"><span class="comment">//getEnvironment().setRequiredProperties(&quot;ES_HOME&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序启动之后，首先会进入自定义的ioc容器，然后通过构造器显式调用<code>**super()**</code>方法来到<code>**ClassPathXmlApplicationContext**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//调用父类的构造方法，AbstractApplicationContext</span></span><br><span class="line"><span class="comment">/*模板方法模式 和 钩子方法  易于扩展  开闭原则*/</span></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">//解析配置文件路径</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="comment">/*refresh 是表示一个容器是否刷新过得标识符，如果容器还没有刷新过就进行容器刷新，实际上这里是一个双端检测锁*/</span></span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line"><span class="comment">/*spring ioc 容器刷新方法*/</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面主要是做了两件事：<br>​</p><ol><li>解析配置文件路径    <code>**setConfigLocations()**</code></li><li>判断容器是否刷新过，如果尚未刷新，那么刷新ioc容器    <code>**refresh()**</code></li></ol><p><strong>​</strong></p><h2 id="2-解析配置文件"><a href="#2-解析配置文件" class="headerlink" title="2.解析配置文件"></a>2.解析配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(<span class="meta">@Nullable</span> String... locations)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*如果location！=null 也就是说配置文件不为空，spring扫描到了配置文件，那么我们就可以以xml的形式启动spring容器*/</span></span><br><span class="line"><span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*断言：配置文件所在位置不能为空*/</span></span><br><span class="line">Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*引用*/</span></span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line"><span class="comment">/*迭代解析路径*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line"><span class="comment">/*解析路径*/</span></span><br><span class="line"><span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们程序是有xml的spring配置文件，那么该文件被扫描到以后，（当然可能不止一个)，回去迭代解析配置文件的路径。    <code>**resolvePath()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析给定的路径，如果有必要的话，用相应的环境属性值替换占位符，应用于配置位置。<code>**resolveRequiredPlaceholders()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="comment">/*占位符解析器解析并替换占位符*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertyResolver.resolveRequiredPlaceholders(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是将解析的逻辑交给了属性解析器。<code>**resolveRequiredPlaceholders()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*如果占位符解析器为空，就创建一个占位符解析器*/</span></span><br><span class="line"><span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*真正去解析占位符的操作*/</span></span><br><span class="line"><span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个抽象的解析器里面又通过委派模式委派给了真正的解析占位符操作的方法。    <code>**doResolvePlaceholders()**</code><br>​</p><p>这里为什么要这么设计？这其实是两个扩展点，开发人员可以自己继承这两个抽象类，重写对应的方法，来实现定制化的解析占位符的逻辑。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*使用传入的属性占位符解析器去解析并替换占位符*/</span></span><br><span class="line"><span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">this</span>::getPropertyAsRawString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里交给了真正的属性解析器<code>**PropertyPlaceholderHelper**</code>去解析属性占位符。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">Assert.notNull(value, <span class="string">&quot;&#x27;value&#x27; must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*解析字符串类型的值*/</span></span><br><span class="line"><span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有格式的<code>**$&#123;name&#125;**</code>占位符替换为从提供的<code>**PropertyPlaceHolderHelper**</code>，<code>**PlaceHolderResolver**</code>返回的值。<br>​</p><p>再往下就是具体的解析字符串的逻辑，没有什么继续的必要。<br>​</p><p>这里面主要体现的就是利用<code>**抽象类**</code> 和 <code>**委派模式**</code> 提供了默认的属性解析器实现，当然我们也可以提供自己的解析器，只需要继承相应的抽象类，实现相应的抽象方法。<br>​</p><h2 id="3-容器刷新"><a href="#3-容器刷新" class="headerlink" title="3.容器刷新"></a>3.容器刷新</h2><p>解析完配置文件路径以后，就是判断容器是否已经刷新过，如果尚未刷新，就会进行容器的刷新动作。    <code>**AbstractApplicationContext.refresh()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="comment">//加锁是因为ioc容器只能有一个，防止重复创建</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">//准备开始容器刷新</span></span><br><span class="line">StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前系统的时间，给容器设置同步锁标识</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析xml配置文件或注解 bean定义资源的载入，获取一个全新的bean工厂</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给容器中注册一些组件，添加切面，类加载器，表达式解析器，注解解析器，事件处理器</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为容器的某些子类指定后置处理器，子类可以通过重写这个方法，</span></span><br><span class="line"><span class="comment">// 在bean工厂创建并预备完成以后做进一步的设置</span></span><br><span class="line"><span class="comment">/*可以在bd创建出实例之前，对bd信息做进一步的修改*/</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行bean工厂的后置处理器，先执行bean定义注册后置处理器，在执行bean工厂的后置处理器。</span></span><br><span class="line"><span class="comment"> * 执行顺序：先执行实现了优先级接口的，在执行带有order的，最后执行其他的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的后置处理器，先注册带优先级的，在注册带order的，</span></span><br><span class="line"><span class="comment">// 在注册剩下的。注册一个ApplicationListenerDetector，</span></span><br><span class="line"><span class="comment">// 在bean完成创建后检查是是否是ApplicationListener，如果是，添加到容器。</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">beanPostProcess.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些国际化相关的操作</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化事件派发器：获取beanFactory，</span></span><br><span class="line"><span class="comment">// 从beanFactory获取事件派发器，如果没有，创建一个放到容器中。</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 留给子容器，子容器可以再容器刷新的时候加入自己的逻辑。</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为事件派发器注册事件监听器，派发一些早期事件。</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化剩下的所有的非懒加载的单实例bean。</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化容器的生命周期事件处理器，</span></span><br><span class="line"><span class="comment">// 回调onRefresh()，并发布容器的生命周期事件。</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line"><span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">contextRefresh.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>​</strong></p><p>这个方法很长，也可以说是ioc容器的核心，这里面涉及到的关于Spring的额外的知识也比较繁多，在此会对相关内容进行一一列举。</p><h2 id="4-属性资源设置与校验"><a href="#4-属性资源设置与校验" class="headerlink" title="4.属性资源设置与校验"></a>4.属性资源设置与校验</h2><p>​</p><p>首先会去获取当前系统的时间，给容器设置同步锁标识。    <code>**prepareRefresh()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前系统的时间</span></span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//关闭状态设置为false</span></span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//激活状态设置为true</span></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//日志打印</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 留给子类扩展：可以做一些资源初始化</span></span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验必须有环境变量 ，结合上面的方法可以设置哪些属性是必填的</span></span><br><span class="line"><span class="comment">/*demo：MyClassPathXmlApplicationContext*/</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容器早期的事件监听器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果已经有了，就先清空 在push</span></span><br><span class="line"><span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line"><span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许这些早期事件在容器刷新之后发布出去</span></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br>这里面可以关注一下几个扩展点：<br>​</p><ol><li>可以再子类做一些资源初始化的方法    <code>**initPropertySources()**</code></li><li>对上一步设置的属性变量进行校验        <code>**validateRequiredProperties()**</code></li></ol><p><strong>​</strong></p><p>随后会获取到容器早期的一些事件监听器，这些早期事件会在容器刷新成功之后发布出去。<br>​</p><h2 id="5-解析配置文件"><a href="#5-解析配置文件" class="headerlink" title="5.解析配置文件"></a>5.解析配置文件</h2><p>这一步主要的操作就是解析Spring的配置文件或者注解标识的配置类，加载bean的定义信息 <code>**BeanDefinition**</code>，简称bd。最后创建一个<code>**BeanFactory**</code>，简称bf。<br>​</p><p><code>**obtainFreshBeanFactory()**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//刷新bean工厂</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="comment">/**返回bean工厂*/</span></span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面主要的逻辑就在于bean工厂的刷新。    <code>**refreshBeanFactory()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">/*如果已经有了bean工厂，通常情况下并不会，什么情况下会有？通过applicationContext直接调用refresh方法*/</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line"><span class="comment">/*销毁里面的所有bean*/</span></span><br><span class="line">destroyBeans();</span><br><span class="line"><span class="comment">/*关闭bean工厂*/</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//不管上面是否已经有bean工厂存在，最终都会走到这里，去创建一个bean工厂</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line"><span class="comment">/*设置序列化id*/</span></span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line"><span class="comment">/*对工厂进行一些定制化设置*/</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"><span class="comment">/*加载bean的定义信息*/</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="comment">/*将当前类的bean工厂引用指向创建的bean工厂*/</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以关注两点：<br>​</p><ol><li>如何创建一个bean工厂        <code>**createBeanFactory()**</code></li><li>加载bd的信息        <code>**loadBeanDefinitions(beanFactory)**</code></li></ol><p>​</p><h3 id="5-1-创建bean工厂"><a href="#5-1-创建bean工厂" class="headerlink" title="5.1 创建bean工厂"></a>5.1 创建bean工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为当前的容器上下文创建了一个内部bean工厂，每次刷新的时候会尝试调用当前方法。默认是创建了一个<code>_**DefaultListableBeanFactory**_</code>，并且将此上下文父级的内部bean作为父 bean工厂。可以再子类中覆盖，例如自定义<code>_**DefaultListableBeanFactory**_</code>的设置。<br>​</p><h3 id="5-2-BeanFactory"><a href="#5-2-BeanFactory" class="headerlink" title="5.2 BeanFactory"></a>5.2 BeanFactory</h3><p>上面提到了一个<code>**DefaultListableBeanFactory**</code>，那么都有哪些bean工厂呢？为什么有这么多bean工厂呢？<br>​</p><p>来到<code>**BeanFactory**</code>的顶层接口，<code>**BeanFactory**</code> 作为顶层接口，提供了一些列操作工厂内对象的方法，有一点需要注意的。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对FactoryBean的转义定义，因为如果使用bean的名字检索 FactoryBean 得到的对象</span></span><br><span class="line"><span class="comment"> * 是工厂生成的对象，如果想要得到工厂本身，需要转义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br></pre></td></tr></table></figure><p>这是决定你获取当前工厂还是当前工厂内对象的一个重要标识符号，切记。<code>**&amp;**</code><br><strong>​</strong></p><p>接下来再去看 <code>**BeanFactory**</code>的继承关系，作为顶层接口，我们自然是从上往下看。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1638753617394-38ac0d9a-55be-4897-9ca3-096027d48e99.jpeg#clientId=u276e0da5-9fca-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua08f44a2&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=749&originWidth=1737&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141808&status=done&style=none&taskId=u2f903892-54ed-4e79-a45c-da25cc4b6c4&title=" alt="1.jpg"><br>这里面列举了几个重要的Bean工厂，同时也可以看到，<code>**DefaultListableBeanFactory**</code>本身其实是bean工厂的重要实现类。<br>​</p><p>从图上的继承关系可以看出：<code>**ListableBeanFactory**</code>、<code>**HierarchicalBeanFactory**</code> 和 <code>**AutowireCapableBeanFactory**</code>。<br>​</p><p><strong>为什么要定义这么多层次的接口呢？</strong><br>​</p><p>主要是为了区分在Spring内部操作过程中对象的传递和转化过程，对对象的数据访问所做的一些限制。这三个接口共同定义了 Bean的集合，Bean之间关系，Bean行为。<br>​</p><p>在 <code>**BeanFactory**</code> 里只对 IOC 容器的基本行为作了定义，根本不关心你的 Bean 是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。要知道工厂是如何产生对象的，需要看具体的 IOC 容器实现，Spring 提供了许多 IOC 容器的 实 现 。</p><p><code>**ApplicationContext**</code>是Spring提供的一个高级的ioc容器，他除了能够提供ioc容器的基本功能以外，还未用户提供了一些附加的服务：<br>​</p><ol><li>支持信息源，可以实现国际化。    <code>**MessageSource**</code></li><li>访问资源    <code>**ResourcePatternResolver**</code></li><li>支持应用事件    <code>**ApplicationEventPublisher**</code></li></ol><p>​</p><p><strong>容器本身其实也是扩展点，支持我们通过类的继承来做一些定制化实现。</strong><br>​</p><h3 id="5-3加载BeanDefinition"><a href="#5-3加载BeanDefinition" class="headerlink" title="5.3加载BeanDefinition"></a>5.3加载BeanDefinition</h3><p><code>**loadBeanDefinitions(beanFactory)**</code>在<code>**AbstractApplicationContext**</code>其实也是一个空方法，交给子类去实现。找到具体的实现<code>**AbstractXmlApplicationContext**</code>。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个xml 的beanDefinition加载器 这个玩意里面持有一个beanFactory的引用</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*给beanDefinition 加载器设置上下文环境  资源加载器   实体解析器*/</span></span><br><span class="line"><span class="comment">/*这玩意我记得都是用的默认的*/</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化beanDefinition加载器*/</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"><span class="comment">/*使用beanDefinition加载器加载beanDefinitions*/</span></span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面需要关注两个方法：</p><ol><li>初始化<code>**beanDefinition**</code>加载器        <code>**initBeanDefinitionReader()**</code></li><li>使用<code>**beanDefinition**</code>加载器加载<code>**beanDefinitions**</code>        <code>**loadBeanDefinitions()**</code></li></ol><p>​</p><p>不过在分析这两个方法之前，先明确一下<code>**BeanDefinition**</code>。<br>​</p><h3 id="5-4BeanDefinition"><a href="#5-4BeanDefinition" class="headerlink" title="5.4BeanDefinition"></a>5.4BeanDefinition</h3><h4 id="什么是BeanDefinition？"><a href="#什么是BeanDefinition？" class="headerlink" title="什么是BeanDefinition？"></a>什么是<code>BeanDefinition</code>？</h4><p>​</p><p><code>**BeanDefinition**</code>作为定义Spring Bean 文件中bean的接口，可以说是bean的抽象的数据结构，它包括属性参数，构造器参数，以及其他具体的参数。<br>​</p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1638756640671-79341b44-e0c9-44b2-8cf5-2da26d2189fe.png#clientId=u276e0da5-9fca-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5c0e7c34&margin=%5Bobject%20Object%5D&name=beanDefinition-uml.png&originHeight=489&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67764&status=done&style=none&taskId=u58370129-7195-41cf-978c-8da5c8013ed&title=" alt="beanDefinition-uml.png"><br><code>**BeanDefinition**</code>继承了<code>**AttributeAccessor**</code>和<code>**BeanMetaDataElement**</code>接口，拥有了对元数据访问的功能。<br>​</p><h4 id="看一下具体的代码"><a href="#看一下具体的代码" class="headerlink" title="看一下具体的代码"></a>看一下具体的代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"><span class="comment">/*单例的作用域*/</span></span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"><span class="comment">/*多例作用域*/</span></span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用户*/</span></span><br><span class="line"><span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*某些复杂的配置*/</span></span><br><span class="line"><span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*完全内部使用*/</span></span><br><span class="line"><span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置父类的名字*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(<span class="meta">@Nullable</span> String parentName)</span></span>;</span><br><span class="line"><span class="comment">/*获取父类的名字*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置class类型名*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(<span class="meta">@Nullable</span> String beanClassName)</span></span>;</span><br><span class="line"><span class="comment">/*返回当前bean的名字（并不是准确的名字，有些childBeanDefinition是继承自父bean的名字）*/</span></span><br><span class="line"><span class="comment">/*所以不能依靠该名字确定class的类型*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置作用域*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(<span class="meta">@Nullable</span> String scope)</span></span>;</span><br><span class="line"><span class="comment">/*获取作用域*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置懒加载*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"><span class="comment">/*判断是否懒加载*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置依赖的bean*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(<span class="meta">@Nullable</span> String... dependsOn)</span></span>;</span><br><span class="line"><span class="comment">/*依赖的bean*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">String[] getDependsOn();</span><br><span class="line"><span class="comment">/*设置优先注入其他bean*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"><span class="comment">/*是否优先注入其他bean*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置优先自动装配*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"><span class="comment">/*这个bean是否优先自动装配*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置工厂bean的名字*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(<span class="meta">@Nullable</span> String factoryBeanName)</span></span>;</span><br><span class="line"><span class="comment">/*返回工厂bean的名字*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置工厂方法名*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(<span class="meta">@Nullable</span> String factoryMethodName)</span></span>;</span><br><span class="line"><span class="comment">/*返回工厂方法名*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*获取构造函数的值*/</span></span><br><span class="line"><span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*判断是否有构造器参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取参数的值*/</span></span><br><span class="line"><span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*判断是否有属性参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置初始化方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitMethodName</span><span class="params">(<span class="meta">@Nullable</span> String initMethodName)</span></span>;</span><br><span class="line"><span class="comment">/*获取初始化方法的名字*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getInitMethodName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置销毁方法的名字*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDestroyMethodName</span><span class="params">(<span class="meta">@Nullable</span> String destroyMethodName)</span></span>;</span><br><span class="line"><span class="comment">/*获取销毁方法的名字*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getDestroyMethodName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置角色*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRole</span><span class="params">(<span class="keyword">int</span> role)</span></span>;</span><br><span class="line"><span class="comment">/*获取角色*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*设置描述信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(<span class="meta">@Nullable</span> String description)</span></span>;</span><br><span class="line"><span class="comment">/*获取描述信息*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read-only attributes</span></span><br><span class="line"></span><br><span class="line"><span class="function">ResolvableType <span class="title">getResolvableType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*是否是单例的*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*是否是多例的*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*是否是抽象bean*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*获取资源描述*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*有些beanDeFInition会使用beanDefinitionResource进行包装，将beanDefinition描述为一个资源*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>​</p><ol><li><code>**RootBeanDefinition**</code>、<code>**GenericBeanDefinition**</code>、<code>**ChildBeanDefinition**</code></li></ol><p><code>**RootBeanDefinition**</code>是最常用的实现类，它对应一般性的元素标签，<code>**GenericBeanDefinition**</code>是自2.5以后新加入的bean文件配置属性定义类，是一站式服务类。在配置文件中可以定义父和子，父用<code>**RootBeanDefinition**</code>表示，而子用<code>**ChildBeanDefiniton**</code>表示，而没有父的就使用<code>**RootBeanDefinition**</code>表示。</p><ol start="2"><li><code>**AnnotatedGenericBeanDefinition**</code></li></ol><p>以<code>**@Configuration**</code>注解标记的会解析为<code>**AnnotatedGenericBeanDefinition**</code>。</p><ol start="3"><li><code>**ConfigurationClassBeanDefinition**</code></li></ol><p>以<code>**@Bean**</code>注解标记的会解析为<code>**ConfigurationClassBeanDefinition**</code>。</p><ol start="4"><li><code>**ScannedGenericBeanDefinition**</code></li></ol><p>以<code>**@Component**</code>注解标记的会解析为<code>**ScannedGenericBeanDefinition**</code>。<br>​</p><p>​</p><p><strong>总结一下：如果把ioc容器看成是一个飞机场，那么里面的bean对象就是一个个的飞机，bd则是对应的造飞机用的图纸，我们首先要拿到图纸，根据图纸才能造飞机。</strong><br>​</p><h3 id="5-5-初始化BeanDefinition加载器"><a href="#5-5-初始化BeanDefinition加载器" class="headerlink" title="5.5 初始化BeanDefinition加载器"></a>5.5 初始化BeanDefinition加载器</h3><p><code>**initBeanDefinitionReader()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化加载此上下文的bean定义信息的bean定义读取器，默认实现为空。可以在子类中覆盖，例如关闭xml验证或者使用不同的<code>_**XmlBeanDefinitionParser**_</code>_ 实现。_<br><em>​</em></p><h3 id="5-6-加载bean定义信息"><a href="#5-6-加载bean定义信息" class="headerlink" title="5.6 加载bean定义信息"></a>5.6 加载bean定义信息</h3><p><code>**loadBeanDefinitions()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">/*这里实际上是一个钩子方法，经典的模板模式，子类根据需要对方法进行重写，实际上加载xml的时候，这里锤子也没拿到*/</span></span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="comment">/*如果资源不为空，走这里的逻辑，但是上面已经分析过，实际上锤子也没拿到，所以走下面的逻辑*/</span></span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取配置文件位置*/</span></span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="comment">/*此时读取到了我们在配置文件指定的配置文件 beans.xml*/</span></span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">/*断言 判空*/</span></span><br><span class="line">Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line"><span class="comment">/*记录beanDefinition的数量*/</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*迭代加载beanDefinition*/</span></span><br><span class="line"><span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">count += loadBeanDefinitions(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">/*方法重载*/</span></span><br><span class="line"><span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">/*获取资源加载器*/</span></span><br><span class="line">ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line"><span class="comment">/*如果资源加载器为空，抛异常*/</span></span><br><span class="line"><span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Cannot load bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果资源加载器是资源模式解析器类型的*/</span></span><br><span class="line"><span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line"><span class="comment">// Resource pattern matching available.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将xml配置文件加载到resources中，resource其实就是spring底层封装了很多的细节，</span></span><br><span class="line"><span class="comment">抽象出来的资源顶层接口</span></span><br><span class="line"><span class="comment">让开发人员不必专注于底层配置文件的加载细节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="comment">/*加载beanDefinition*/</span></span><br><span class="line"><span class="keyword">int</span> count = loadBeanDefinitions(resources);</span><br><span class="line"><span class="comment">/*这玩意不知道是啥，反正是空，没啥锤子用*/</span></span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">Collections.addAll(actualResources, resources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">/*走到这里说明资源加载器肯定不是资源模式解析器类型的*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 只能通过绝对网址加载单个资源</span></span><br><span class="line">Resource resource = resourceLoader.getResource(location);</span><br><span class="line"><span class="keyword">int</span> count = loadBeanDefinitions(resource);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualResources.add(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="comment">/*断言*/</span></span><br><span class="line">Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*迭代遍历加载*/</span></span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">count += loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终将加载到的所有<code>**beanDefinition**</code>信息注册到<code>**BeanDefinitionRegistry**</code>。这个<code>**BeanDefinitionRegistry**</code>被<code>**AbstractBeanDefinitionReader**</code>持有。</p><h3 id="5-7-Resource"><a href="#5-7-Resource" class="headerlink" title="5.7 Resource"></a>5.7 Resource</h3><p>这里面涉及到了一个对象，<code>**Resource**</code>。<br>​</p><p>Spring把其资源做了一个抽象，底层使用统一的资源访问接口来访问Spring的所有资源。即：不管什么格式的文件，也不管文件在哪里，到Spring底层，都只有一个访问接口，<code>**Resource**</code>。<br>​</p><h4 id="类结构图"><a href="#类结构图" class="headerlink" title="类结构图"></a>类结构图</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1638790361346-1a7fe5e2-8e0e-4761-bdf7-60acaf9a501d.png#clientId=udf82f357-269c-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6d361d44&margin=%5Bobject%20Object%5D&name=1.png&originHeight=770&originWidth=3494&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69985&status=done&style=none&taskId=u5f4fe1f0-e816-4844-bc8a-5be8862eade&title=" alt="1.png"></p><h4 id="类和接口的分析"><a href="#类和接口的分析" class="headerlink" title="类和接口的分析"></a>类和接口的分析</h4><ol><li><p>可以看到有四个比较重要的接口：<code>**InputStreamSource**</code>、<code>**Resource**</code>、<code>**WritableResource**</code>、<code>**ContextResource**</code>。</p></li><li><p><code>**InputStreamSource**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>**Resource**</code>接口</p></li></ol><p>​</p><p>接口中定义了对于资源的判断、对资源的获取、对资源描述的获取。通过该接口可以对资源进行有效的操作。但是<code>**Resource**</code>接口注重于对资源的读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口中定义了对于资源的判断、对资源的获取、对资源描述的获取。通过该接口可以对资源进行有效的操作。但是Resource接口注重于对资源的读取。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断是否存在*/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*判断是否可读*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> exists();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断是否可以重复读取，如果为true表示不可以重复读取，在读取完成之后，需要关闭流*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*判断是否是文件*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取URL地址*/</span></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*获取URL地址*/</span></span><br><span class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*获取文件*/</span></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*默认通过输入流获取nio的只读字节流管道*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*资源长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*上次更新时间*/</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*根据资源的当前位置，获取相对位置的其他资源*/</span></span><br><span class="line"><span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*返回资源名称*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*返回资源描述*/</span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>**WritableResource**</code></li></ol><p>因为Resource接口主要是注重对资源的读取，当我们对资源进行写入的时候，需要获取对应的判断和输出流。WritableResource接口主要定义了对写入的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableResource</span> <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"><span class="comment">/*返回资源是否可以被写入*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*获取资源的写入流*/</span></span><br><span class="line"><span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="comment">/*默认提供的支持写的nio字节管道*/</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> WritableByteChannel <span class="title">writableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Channels.newChannel(getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>**ContextResource**</code></li></ol><p>有些资源是相对于当前容器的，用来获取容器中的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContextResource</span> <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getPathWithinContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>存在一个<code>**AbstractResource**</code>的抽象类，所有的对于资源获取都继承自<code>**AbstractResource**</code>抽象类。</li><li>其余的都是具体的实现类，用来加载指定的资源。</li></ol><p>​</p><h4 id="对资源的加载"><a href="#对资源的加载" class="headerlink" title="对资源的加载"></a>对资源的加载</h4><p>​</p><p>Spring框架为了更方便的获取资源，尽量弱化程序员对各个<code>**Resource**</code>接口的实现类的感知，定义了另一个<code>**ResourceLoader**</code>接口。接口有一个特别重要的方法：<code>**Resource getResource(String location);**</code> 返回<code>**Resource**</code>实例。因此程序猿在使用spring容器的时候，可以不去过于计较比较底层的<code>**Resource**</code>实现，也不需要自己创建<code>**Resource**</code>的实现类，而是直接使用<code>**ResourceLoader**</code>获取到bean容器本身的<code>**Resource**</code>，进而获取到相关的资源信息。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1638790506854-43e3aef4-8113-4dc5-a85d-5ad9f51b4137.png#clientId=udf82f357-269c-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uffe9ce7f&margin=%5Bobject%20Object%5D&name=1.png&originHeight=566&originWidth=2220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75303&status=done&style=none&taskId=u913ac74e-5fea-4604-aa0e-4b8b23ffe67&title=" alt="1.png"></p><ol><li><code>**ResourceLoader**</code></li></ol><p>只能对<code>**classpath**</code>路径下面的资源进行加载，并且只会加载指定的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring框架为了更方便的获取资源，尽量弱化程序员对各个Resource接口的实现类的感知，定义了另一个ResourceLoader接口。</span></span><br><span class="line"><span class="comment"> * 接口有一个特别重要的方法：Resource getResource(String location)，返回Resource实例。因此程序员在使用Spring容器时，</span></span><br><span class="line"><span class="comment"> * 可以不去过于计较底层Resource的实现，也不需要自己创建Resource实现类，而是直接使用ReourceLoader，获取到bean容器本身的Resource，</span></span><br><span class="line"><span class="comment"> * 进而取到相关的资源信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot;. */</span></span><br><span class="line">String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用来根据location来获取指定的资源*/</span></span><br><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</span><br><span class="line"><span class="comment">/*获取类加载器*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>**ResourcePatternResolver**</code></li></ol><p>表示会加载所有路径下面的文件，包括jar包中的文件。同时<code>**locationPattern**</code>可以设置为表达式来加载对应的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*表示会加载所有路径下面的文件，包括jar包中的文件。同时locationPattern可以设置为表达式来加载对应的文件。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示会加载所有路径下面的文件，包括jar包中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CLASSPATH_ALL_URL_PREFIX = <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别：<br>​</p><p><code>**classpath**:</code> ：表示从类路径中加载资源，<code>**classpath**</code>:和<code>**classpath**</code>:/是等价的，都是相对于类的根路径。资源文件库标准的在文件系统中，也可以在JAR或ZIP的类包中。<br>​</p><p><code>**classpath**:*</code>：假设多个JAR包或文件系统类路径都有一个相同的配置文件，<code>**classpath**</code>:只会在第一个加载的类路径下查找，而<code>**classpath**</code>*:会扫描所有这些JAR包及类路径下出现的同名文件。<br>​</p><p><code>**DefaultResourceLoader**</code></p><p>spring实现的默认的加载器，一般其他的加载器会继承该类，并重写<code>**getResourceByPath**</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(location, <span class="string">&quot;Location must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">//循环遍历使用解析器解析该location的资源，如果资源不为空，直接返回</span></span><br><span class="line">    <span class="keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">        Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*以/开头那么根据path去寻找*/</span></span><br><span class="line">    <span class="keyword">if</span> (location.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*以classpath开头，那么抽象为ClassPathResource*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*其他情况采用urlResource来加载*/</span></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">            <span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            <span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line">            <span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**PathMatchingResourcePatternResolver**</code><br>​</p><p>Spring提供了一个<code>**ResourcePatternResolver**</code>实现<code>**PathMatchingResourcePatternResolver**</code>，它是基于模式匹配的，默认使用<code>**AntPathMatcher**</code>进行路径匹配，它除了支持<code>**ResourceLoader**</code>支持的前缀外，还额外支持“<code>**classpath**</code><em>:”用于加载所有匹配的类路径<code>**Resource**</code>，<code>**ResourceLoader**</code>不支持前缀“<code>**classpath**</code></em>:”。<br>​</p><h2 id="6-prepareBeanFactory-beanFactory"><a href="#6-prepareBeanFactory-beanFactory" class="headerlink" title="6.prepareBeanFactory(beanFactory)"></a>6.prepareBeanFactory(beanFactory)</h2><p>给容器中注册一些组件，添加切面，类加载器，表达式解析器，注解解析器，事件处理器。 <code>**prepareBeanFactory()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line"><span class="comment">/*类加载器*/</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"><span class="keyword">if</span> (!shouldIgnoreSpel) &#123;</span><br><span class="line"><span class="comment">/*表达式解析器*/</span></span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*属性编辑器*/</span></span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给当前工厂设置上下文回调</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory接口未在普通工厂中注册为可解析类型。</span></span><br><span class="line"><span class="comment">// 注册消息资源的解析器</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将用于检测内部beans的早期后置处理器注册为ApplicationListeners。</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-postProcessBeanFactory-beanFactory"><a href="#7-postProcessBeanFactory-beanFactory" class="headerlink" title="7.postProcessBeanFactory(beanFactory)"></a>7.postProcessBeanFactory(beanFactory)</h2><p>​</p><p>为容器的某些子类指定后置处理器，子类可以通过重写这个方法，在bean工厂创建并预备完成以后做进一步的设置，可以在bd创建出实例对象之前，对bd信息做进一步修改。<code>**postProcessBeanFactory()**</code> 这也是spring提供的一个扩展点。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-执行bean工厂的后置处理器"><a href="#8-执行bean工厂的后置处理器" class="headerlink" title="8.执行bean工厂的后置处理器"></a>8.执行bean工厂的后置处理器</h2><p>执行bean工厂的后置处理器，先执行bean定义注册后置处理器，在执行bean工厂的后置处理器。执行顺序：先执行实现了优先级接口的，在执行带有order的，最后执行其他的。<br>​</p><p><code>**invokeBeanFactoryPostProcessors(beanFactory)**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">//执行bean工厂的后置处理器</span></span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**invokeBeanFactoryPostProcessors()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个set列表，存储已经执行过的beanName</span></span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//类型断言：如果是BeanDefinitionRegistry类型的</span></span><br><span class="line"><span class="comment">//意思就是：当前 beanFactory 是 beanDefinition 的注册中心 ， bd 全部注册到 bf。</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line"><span class="comment">//类型转换 bf -&gt; bd注册中心</span></span><br><span class="line">BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"><span class="comment">//存储BeanFactoryPostProcessor</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/*存储BeanDefinitionRegistryPostProcessor*/</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 之间的关系 ？</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistryPostProcessor 是 BeanFactoryPostProcessor 的子类。</span></span><br><span class="line"><span class="comment"> * 它里面 搞了一个新的方法  postProcessBeanDefinitionRegistry ，可以往容器中注册更多的bd信息。</span></span><br><span class="line"><span class="comment"> * 扩展点：</span></span><br><span class="line"><span class="comment"> * ①BeanFactoryPostProcessor 对bd信息进行修改</span></span><br><span class="line"><span class="comment"> * ②postProcessBeanDefinitionRegistry 添加更多的bd信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理ApplicationContext里面硬编码注册的beanFactoryPostProcessor</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="comment">/*如果当前后置处理器的类型是BeanDefinitionRegistryPostProcessor*/</span></span><br><span class="line"><span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line"><span class="comment">/*将后置处理器转换为BeanDefinitionRegistryPostProcessor类型*/</span></span><br><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"><span class="comment">/*执行后置处理器的方法   这里又是一个后置处理器的调用点*/</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line"><span class="comment">/*将执行完的后置处理器加入到集合中*/</span></span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">/*此时说明后置处理器是一个BeanFactoryPostProcessor，直接加入到BeanFactoryPostProcessor的集合中。后续统一执行。*/</span></span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里不要初始化FactoryBeans:我们需要保留所有常规bean的未初始化状态，</span></span><br><span class="line"><span class="comment">// 让bean工厂的后处理器应用于它们！在实现优先级的bean definition registry后处理器、</span></span><br><span class="line"><span class="comment">// Ordered、Ordered等之间进行分离。</span></span><br><span class="line"><span class="comment">/*当前阶段的registry后置处理器集合*/</span></span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先执行实现了主排序接口的后置处理器  PriorityOrdered</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">/*判断对应的bean是否实现了主排序接口，如果实现了，就让该后置处理器添加到集合。*/</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line"><span class="comment">/*已经执行的后置处理器名字集合，因为接下来马上要执行这些后置处理器了。*/</span></span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对后置处理器进行排序  根据 getOrder() 返回的值进行升序排序*/</span></span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"><span class="comment">/*注册所有的后置处理器*/</span></span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"><span class="comment">/*调用当前后置处理器的相关接口方法 执行 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry()*/</span></span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line"><span class="comment">/*清空当前阶段临时的集合*/</span></span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着执行实现了Ordered接口的后置处理器 这里的后置处理器是普通排序后置处理器</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">/*确保每一个后置处理器只执行一次*/</span></span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将剩下的后置处理器逐个执行</span></span><br><span class="line"><span class="comment">/*这个变量控制是否需要循环*/</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/*从bean工厂拿BeanDefinitionRegistryPostProcessor的后置处理器*/</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">/*循环判断执行没执行过得*/</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line"><span class="comment">/*这里为什么吧变量设置为true？因为新注册的后置处理器，可能也是往容器中注册的 registry 类型的后置处理器*/</span></span><br><span class="line">reiterate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里是执行BeanDefinitionRegistryPostProcessor 的父类 BeanFactoryPostProcessor 的方法*/</span></span><br><span class="line"><span class="comment">// 上面重复三遍是为了执行 BeanDefinitionRegistryPostProcessor 的方法，</span></span><br><span class="line"><span class="comment">// 但是，BeanDefinitionRegistryPostProcessor 还继承了 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">// 这里是为了执行所有后置处理器的</span></span><br><span class="line"><span class="comment">// （BeanFactoryPostProcessor）的 postProcessBeanFactory方法。</span></span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"><span class="comment">/*这个方法就是执行BeanFactoryPostProcessor的方法*/</span></span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理不是 BeanDefinitionRegistry 类型的后置处理器*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 调用上下文实例注册的后置处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上面处理的是硬编码的BeanDefinitionRegistry和BeanFactoryPostProcessor的后置处理器。</span></span><br><span class="line"><span class="comment"> * 下面处理器的是普通的后置处理器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要在这里初始化FactoryBeans:我们需要保留所有常规beans未初始化以让bean工厂后处理器应用于它们！</span></span><br><span class="line"><span class="comment">/*获取容器内注册的所有BeanFactoryPostProcessor集合。还是处理主排序，普通排序，为排序的后置处理器集合*/</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实现优先级有序、有序和其他的BeanFactoryPostProcessors之间进行分离。</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="comment">/*包含说明已经执行过了，直接啥也不做跳过即可*/</span></span><br><span class="line"><span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line"><span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，执行带有优先级接口的</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着执行实现了order接口的</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后执行其他剩余的</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存清理，帮助GC</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思考：为什么spring要把这里代码逻辑写的这么麻烦？为了框架的健壮性，提供更好的扩展性，方便在不同阶段，针对不同的需求进行扩展。*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-注册后置处理器"><a href="#9-注册后置处理器" class="headerlink" title="9.注册后置处理器"></a>9.注册后置处理器</h2><p>获取所有的后置处理器，先注册实现主排序接口的，在注册实现Order接口的，最后注册剩下的。<br>​</p><p>注册一个<code>**ApplicationListenerDetector**</code>，在bean完成创建后检查是否是<code>**ApplicationListener**</code>，如果是，添加到容器。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并注册所有 BeanPostProcessor bean，如果给出，则遵守显式顺序。</span></span><br><span class="line"><span class="comment"> * 必须在应用程序 bean 的任何实例化之前调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注册所有的后置处理器</span></span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**registerBeanPostProcessors()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到所有的BeanPostProcessor后置处理器的beanName数组</span></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册bean后置处理器检查器，当bean在bean后置处理器实例化期间创建时，</span></span><br><span class="line"><span class="comment">// 即当bean不适合被所有bean后置处理器处理时，它会记录一条信息。</span></span><br><span class="line"><span class="comment">/*后置处理器数量，计算方式beanFactory已经有的数量+1+后注册的。1？下面一行手动硬加的*/</span></span><br><span class="line"><span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line"><span class="comment">/*BeanPostProcessorChecker？ step into 检查创建bean实例的时候，后置处理器是否已经全部注册完毕，如果未完毕，日志提示。*/</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分离 实现了主排序接口的后置处理器</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/*存放mergedBeanDefinition后置处理器*/</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/*普通排序接口的*/</span></span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/*没有实现排序接口的*/</span></span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/*循环将所有的后置处理器进行分离存放*/</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">priorityOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先注册实现了优先级接口的后置处理器</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次，注册实现了order接口的后置处理器</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终，注册所有剩下的所有后置处理器</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册后置处理器的逻辑 step into</span></span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，再次处理internalPostProcessors，确保存放mergedBeanDefinition后置处理器在链表的末尾</span></span><br><span class="line">sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新注册后处理器时，将内部beans检测为ApplicationListeners，将其移动到处理器链的末端(用于获取代理等)。</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-initMessageSource"><a href="#10-initMessageSource" class="headerlink" title="10.initMessageSource()"></a>10.initMessageSource()</h2><p><br>做一些国际化相关的操作。<code>**initMessageSource()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"><span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line"><span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line"><span class="comment">// registered already.</span></span><br><span class="line">hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line"><span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-初始化事件派发器"><a href="#11-初始化事件派发器" class="headerlink" title="11.初始化事件派发器"></a>11.初始化事件派发器</h2><p><code>**initApplicationEventMulticaster()**</code><br><br>初始化事件派发器，获取bean工厂，从bean工厂获取事件派发器，如果没有，创建一个放到容器中。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取bean工厂</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">//判断容器是否有事件派发器</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="comment">//如果有就获取到引用 （用户自定义了一个事件多播器）</span></span><br><span class="line"><span class="comment">/*可以实现APPLICATION_EVENT_MULTICASTER接口来自己实现一个事件派发器,通过bean的方式传递给spring*/</span></span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//走到这里的前提是容器中没有事件派发器,需要使用spring框架默认提供的事件派发器。</span></span><br><span class="line"><span class="comment">//直接造一个事件派发器</span></span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line"><span class="comment">//将事件派发器注册到一级缓存，事件派发器是单例的全局通用的。</span></span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line"><span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-onRefresh"><a href="#12-onRefresh" class="headerlink" title="12.onRefresh()"></a>12.onRefresh()</h2><p><br>留给子容器，子容器可以在容器刷新的时候加入自己的逻辑。<code>**onRefresh()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-注册监听器"><a href="#13-注册监听器" class="headerlink" title="13.注册监听器"></a>13.注册监听器</h2><p>为事件派发器注册事件监听器，派发一些早期事件。<code>**registerListeners()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将所有的事件监听器（硬编码的）注册到事件派发器</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册通过bean配置提供的监听器 ，用户可以通过 bd 的方式 提供listener</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过事件派发器派发容器早期应用程序事件 这里可以通过重写onRefresh方法直接往earlyApplicationEvents的set集合里面加。</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>关注一下：<code>**ApplicationEventMulticaster.multicastEvent(earlyEvent)**</code>   派发事件。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*事件类型为空就是用默认的事件类型解析器*/</span></span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="comment">/*获取事件多波器的线程池*/</span></span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="comment">/*拿到当前事件的所有监听器，伦轮训所有的监听器，对事件进行派发。*/</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p><code>**invokeListener()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(ApplicationListener&lt;?&gt; listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*获取到错误处理器的引用*/</span></span><br><span class="line">ErrorHandler errorHandler = getErrorHandler();</span><br><span class="line"><span class="keyword">if</span> (errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*真正执行派发事件的逻辑*/</span></span><br><span class="line">doInvokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">errorHandler.handleError(err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">doInvokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**doInvokeListener()**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*监听器发布事件*/</span></span><br><span class="line">listener.onApplicationEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">String msg = ex.getMessage();</span><br><span class="line"><span class="keyword">if</span> (msg == <span class="keyword">null</span> || matchesClassCastMessage(msg, event.getClass()) ||</span><br><span class="line">(event <span class="keyword">instanceof</span> PayloadApplicationEvent &amp;&amp;</span><br><span class="line">matchesClassCastMessage(msg, ((PayloadApplicationEvent) event).getPayload().getClass()))) &#123;</span><br><span class="line"><span class="comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span></span><br><span class="line"><span class="comment">// -&gt; let&#x27;s suppress the exception.</span></span><br><span class="line">Log loggerToUse = <span class="keyword">this</span>.lazyLogger;</span><br><span class="line"><span class="keyword">if</span> (loggerToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">loggerToUse = LogFactory.getLog(getClass());</span><br><span class="line"><span class="keyword">this</span>.lazyLogger = loggerToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (loggerToUse.isTraceEnabled()) &#123;</span><br><span class="line">loggerToUse.trace(<span class="string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-1-ApplicationListener"><a href="#13-1-ApplicationListener" class="headerlink" title="13.1 ApplicationListener"></a>13.1 ApplicationListener</h3><h4 id="ApplicationListener-amp-amp-ApplicationEvent"><a href="#ApplicationListener-amp-amp-ApplicationEvent" class="headerlink" title="ApplicationListener &amp;&amp; ApplicationEvent"></a>ApplicationListener &amp;&amp; ApplicationEvent</h4><p>通过自定义不同类型的事件，使用不同的监听器监听不同类型的事件，做到jvm进程内的消息队列，事件驱动，解耦。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   String message;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(source);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source,String message)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(source);</span><br><span class="line">      <span class="keyword">this</span>.message=message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;发布了一个事件：&quot;</span>+message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">      event.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试spring 的 ioc 容器的事件发布</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPublishEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(CONFIG_LOCATION);</span><br><span class="line">   ioc.publishEvent(<span class="keyword">new</span> MyEvent(<span class="string">&quot;&quot;</span>, <span class="string">&quot;这是我自定义的一个事件&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h4><p>对上面写法的一个优化，更加简洁，开发量更少，懒人必备神器。<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ioc.publishEvent(<span class="keyword">new</span> ApplicationEvent(<span class="string">&quot;hello，spring&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.getSource();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@EventListener(classes = ApplicationEvent.class)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;event = &quot;</span> + event);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-初始化剩下所有的单实例bean"><a href="#14-初始化剩下所有的单实例bean" class="headerlink" title="14.初始化剩下所有的单实例bean"></a>14.初始化剩下所有的单实例bean</h2><p><code>**finishBeanFactoryInitialization(beanFactory)**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 为此上下文初始化转换服务</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果容器里面没有字符串转换器，初始化一个字符串转换器放到容器中。</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽早初始化LoadTimeWeaverAware beans，以便尽早注册它们的转换器。</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止使用临时类加载器进行类型匹配</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许缓存所有bean定义元数据，不期望进一步的更改，冻结bd信息，冻结之后就无法往bf注册bd了</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化所有剩余的单实例bean</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何冻结bd信息的？<code>**beanFactory.freezeConfiguration()**</code><br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*这个字段如果是true，name就不能往容器中添加新的beanDefinition了*/</span></span><br><span class="line"><span class="keyword">this</span>.configurationFrozen = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = StringUtils.toStringArray(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**beanFactory.preInstantiateSingletons()**</code><br><strong>​</strong></p><p>这个方法内容过多且偏核心内容，留在下一篇分析，跳过这里，加载完所有的单实例bean之后，看还要做什么操作。<br>​</p><h2 id="15-finishRefresh"><a href="#15-finishRefresh" class="headerlink" title="15.finishRefresh()"></a>15.finishRefresh()</h2><p>初始化容器的生命周期事件处理器，回调<code>**onRefresh()**</code>,并发布容器的生命周期事件。<code>**finishRefresh() **</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 清除上下文级资源缓存(例如来自扫描的ASM元数据)。</span></span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为此上下文初始化生命周期处理器。</span></span><br><span class="line"><span class="comment">/*案例演示：lifecycle package</span></span><br><span class="line"><span class="comment">* 两者的区别：</span></span><br><span class="line"><span class="comment">* smart：正常情况下就会执行</span></span><br><span class="line"><span class="comment">* 普通的：必须显示调用容器.start()/.stop()</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先将刷新传播到生命周期处理器。回调 onRefresh</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布容器创建完成事件</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册容器上下文</span></span><br><span class="line"><span class="keyword">if</span> (!NativeDetector.inNativeImage()) &#123;</span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-1-为此上下文初始化生命周期事件处理器"><a href="#15-1-为此上下文初始化生命周期事件处理器" class="headerlink" title="15.1 为此上下文初始化生命周期事件处理器"></a>15.1 为此上下文初始化生命周期事件处理器</h3><p><code>**initLifecycleProcessor()**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*获取bean工厂*/</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="comment">/*判断工厂是否已经有生命周期处理器，有的话直接获取引用*/</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using LifecycleProcessor [&quot;</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*此时就是工厂目前还没有的逻辑，那么就需要自动创建一个*/</span></span><br><span class="line">DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line"><span class="comment">/*注册到一级缓存*/</span></span><br><span class="line">beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + LIFECYCLE_PROCESSOR_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line"><span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.lifecycleProcessor.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-2-生命周期事件处理器"><a href="#15-2-生命周期事件处理器" class="headerlink" title="15.2 生命周期事件处理器"></a>15.2 生命周期事件处理器</h3><p><code>**Lifecycle**</code> &amp;&amp; <code>**SmartLifecycle**</code><br><strong>​</strong></p><p>容器创建完成之后的回调，<em>传递的参数</em><code>_**autoStartUpOnly**_</code><em>是干嘛的？</em><br><em>​</em></p><p><em>表示只启动</em><code>_**SmartLifeCycle**_</code><em>生命周期对象，并且启动的对象</em><code>_**autoStartUpOnly**_</code><em>必须是true，不会启动普通的生命周期对象，false的时候，会启动全部的生命周期对象。</em><br><em>​</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoLifeCycle</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> running =<span class="keyword">false</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">true</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo one start!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">false</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo one stop!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> running;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoSmartLifeCycle</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">false</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">true</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo two start!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.running=<span class="keyword">false</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;demo two stop!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> running;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-回调onRefresh"><a href="#15-3-回调onRefresh" class="headerlink" title="15.3 回调onRefresh()"></a>15.3 回调onRefresh()</h3><p><code>**onRefresh()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*传递的参数autoStartUpOnly是干嘛的？</span></span><br><span class="line"><span class="comment">* 表示只启动SmartLifeCycle生命周期对象，并且启动的对象autoStartUpOnly必须是true，</span></span><br><span class="line"><span class="comment">* 不会启动普通的生命周期对象，</span></span><br><span class="line"><span class="comment">* false的时候，会启动全部的生命周期对象。*/</span></span><br><span class="line">startBeans(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**startBeans(true)**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*获取到所有实现了生命周期接口的对象，包装到map内 k：beanName v: 生命周期对象*/</span></span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line"><span class="comment">/*因为生命周期对象可能依赖其他生命周期对象的执行结果，所以需要执行顺序，依靠 smart生命周期接口实现的另一个接口 ，方法返回值越低，优先级越高  */</span></span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"><span class="comment">/*遍历判断满足条件加入到集合</span></span><br><span class="line"><span class="comment"> * 条件1：SmartLifecycle</span></span><br><span class="line"><span class="comment"> * 条件2：自启动</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line"><span class="comment">/*排序值*/</span></span><br><span class="line"><span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">phases.computeIfAbsent(</span><br><span class="line">phase,</span><br><span class="line">p -&gt; <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly)</span><br><span class="line">).add(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*轮训启动所有的生命周期处理器*/</span></span><br><span class="line"><span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">phases.values().forEach(LifecycleGroup::start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**start()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*members？看上面的add方法，相当于判断生命周期事件处理器是不是空，如果是空的话就没必要向下执行了。*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.members.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Starting beans in phase &quot;</span> + <span class="keyword">this</span>.phase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对生命周期事件处理器进行一个排序*/</span></span><br><span class="line">Collections.sort(<span class="keyword">this</span>.members);</span><br><span class="line"><span class="keyword">for</span> (LifecycleGroupMember member : <span class="keyword">this</span>.members) &#123;</span><br><span class="line"><span class="comment">/*真正执行启动的逻辑*/</span></span><br><span class="line">doStart(<span class="keyword">this</span>.lifecycleBeans, member.name, <span class="keyword">this</span>.autoStartupOnly);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**doStart()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的 bean 作为给定的 Lifecycle bean 集的一部分启动，确保首先启动它所依赖的任何 bean。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lifecycleBeans a Map with bean name as key and Lifecycle instance as value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to start</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, String beanName, <span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*确保每一个生命周期处理器智只能被启动一次，在一个分组内被启动，其他分组内就看不到这个生命周期处理器*/</span></span><br><span class="line">Lifecycle bean = lifecycleBeans.remove(beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">/*获取当前即将要被启动的生命周期处理器锁依赖的其他beanName*/</span></span><br><span class="line">String[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);</span><br><span class="line"><span class="comment">/*先启动当前生命周期处理器所依赖的其他lifeCycle*/</span></span><br><span class="line"><span class="keyword">for</span> (String dependency : dependenciesForBean) &#123;</span><br><span class="line">doStart(lifecycleBeans, dependency, autoStartupOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 条件成立：执行start方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span> (!bean.isRunning() &amp;&amp;</span><br><span class="line">(!autoStartupOnly || !(bean <span class="keyword">instanceof</span> SmartLifecycle) || ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Starting bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; of type [&quot;</span> + bean.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*启动当前lifeCycle*/</span></span><br><span class="line">bean.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Failed to start bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Successfully started bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了启动，再看一下停止。<br>​</p><p><code>**stop()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停止所有注册的bean实现Lifecycle和当前正在运行。</span></span><br><span class="line"><span class="comment"> * 任何实现SmartLifecycle bean 都将在其“阶段”内停止，</span></span><br><span class="line"><span class="comment"> * 并且所有阶段都将从最高值到最低值排序。</span></span><br><span class="line"><span class="comment"> * 所有未实现SmartLifecycle将在默认阶段 0 中停止。</span></span><br><span class="line"><span class="comment"> * 声明为依赖另一个 bean 的 bean 将在依赖 bean 之前停止，无论声明的阶段如何。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*停止所有的bean*/</span></span><br><span class="line">stopBeans();</span><br><span class="line"><span class="keyword">this</span>.running = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**stopBeans()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*这里其实和启动的时候的逻辑是一样的。*/</span></span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line"><span class="keyword">int</span> shutdownPhase = getPhase(bean);</span><br><span class="line">LifecycleGroup group = phases.get(shutdownPhase);</span><br><span class="line"><span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">group = <span class="keyword">new</span> LifecycleGroup(shutdownPhase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, <span class="keyword">false</span>);</span><br><span class="line">phases.put(shutdownPhase, group);</span><br><span class="line">&#125;</span><br><span class="line">group.add(beanName, bean);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;(phases.keySet());</span><br><span class="line"><span class="comment">/*注意这里是反向排序，启动的时候  1 2 3 4 5  关闭的时候就是 5 4 3 2 1*/</span></span><br><span class="line">keys.sort(Collections.reverseOrder());</span><br><span class="line"><span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line"><span class="comment">/*真正的核心逻辑在这里*/</span></span><br><span class="line">phases.get(key).stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>**stop()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*如果为空，说明没有必要往下走了，直接返回。*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.members.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Stopping beans in phase &quot;</span> + <span class="keyword">this</span>.phase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*反向排序*/</span></span><br><span class="line"><span class="keyword">this</span>.members.sort(Collections.reverseOrder());</span><br><span class="line"><span class="comment">/*并发关闭smartLifeCycle*/</span></span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="keyword">this</span>.smartMemberCount);</span><br><span class="line"><span class="comment">/*保存当前正处于关闭中的smartLifeCycle*/</span></span><br><span class="line">Set&lt;String&gt; countDownBeanNames = Collections.synchronizedSet(<span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line"><span class="comment">/*all 处理器*/</span></span><br><span class="line">Set&lt;String&gt; lifecycleBeanNames = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="keyword">this</span>.lifecycleBeans.keySet());</span><br><span class="line"><span class="comment">/*处理本分组内需要关闭的生命周期处理器*/</span></span><br><span class="line"><span class="keyword">for</span> (LifecycleGroupMember member : <span class="keyword">this</span>.members) &#123;</span><br><span class="line"><span class="keyword">if</span> (lifecycleBeanNames.contains(member.name)) &#123;</span><br><span class="line"><span class="comment">/*真正执行关闭的逻辑*/</span></span><br><span class="line">doStop(<span class="keyword">this</span>.lifecycleBeans, member.name, latch, countDownBeanNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (member.bean <span class="keyword">instanceof</span> SmartLifecycle) &#123;</span><br><span class="line"><span class="comment">// Already removed: must have been a dependent bean from another phase</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*关闭主线程会在这里等待所有异步关闭的线程关闭完*/</span></span><br><span class="line">latch.await(<span class="keyword">this</span>.timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (latch.getCount() &gt; <span class="number">0</span> &amp;&amp; !countDownBeanNames.isEmpty() &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Failed to shut down &quot;</span> + countDownBeanNames.size() + <span class="string">&quot; bean&quot;</span> +</span><br><span class="line">(countDownBeanNames.size() &gt; <span class="number">1</span> ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>) + <span class="string">&quot; with phase value &quot;</span> +</span><br><span class="line"><span class="keyword">this</span>.phase + <span class="string">&quot; within timeout of &quot;</span> + <span class="keyword">this</span>.timeout + <span class="string">&quot;ms: &quot;</span> + countDownBeanNames);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>**doStop()**</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStop</span><span class="params">(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, <span class="keyword">final</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">final</span> CountDownLatch latch, <span class="keyword">final</span> Set&lt;String&gt; countDownBeanNames)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*吧要关闭的处理器从全局的集合移除掉并返回*/</span></span><br><span class="line">Lifecycle bean = lifecycleBeans.remove(beanName);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*获取依赖当前bean的处理器*/</span></span><br><span class="line">String[] dependentBeans = getBeanFactory().getDependentBeans(beanName);</span><br><span class="line"><span class="comment">/*递归关闭依赖的bean*/</span></span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">doStop(lifecycleBeans, dependentBean, latch, countDownBeanNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean.isRunning()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> SmartLifecycle) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Asking bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; of type [&quot;</span> +</span><br><span class="line">bean.getClass().getName() + <span class="string">&quot;] to stop&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将当前的处理器名添加到countDownBeanNames内，这个集合表示正在关闭的smart bean*/</span></span><br><span class="line">countDownBeanNames.add(beanName);</span><br><span class="line"><span class="comment">/*执行smart bean的关闭逻辑，看这个stop可以异步关闭，回调，999*/</span></span><br><span class="line">((SmartLifecycle) bean).stop(() -&gt; &#123;</span><br><span class="line">latch.countDown();</span><br><span class="line">countDownBeanNames.remove(beanName);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; completed its stop procedure&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Stopping bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; of type [&quot;</span> +</span><br><span class="line">bean.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*普通生命周期处理器的关闭逻辑*/</span></span><br><span class="line">bean.stop();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Successfully stopped bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果是已经关闭的smart bean，直接跳过了，相当于...*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> SmartLifecycle) &#123;</span><br><span class="line"><span class="comment">// Don&#x27;t wait for beans that aren&#x27;t running...</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Failed to stop bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-4-发布容器创建完成事件"><a href="#15-4-发布容器创建完成事件" class="headerlink" title="15.4 发布容器创建完成事件"></a>15.4 发布容器创建完成事件</h3><p><code>**publishEvent(new ContextRefreshedEvent(this))**</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">ApplicationEvent applicationEvent;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">applicationEvent = (ApplicationEvent) event;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line"><span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-5-注册容器上下文"><a href="#15-5-注册容器上下文" class="headerlink" title="15.5 注册容器上下文"></a>15.5 注册容器上下文</h3><p><code>**LiveBeansView.**_**registerApplicationContext**_**(this)**</code><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerApplicationContext</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">String mbeanDomain = applicationContext.getEnvironment().getProperty(MBEAN_DOMAIN_PROPERTY_NAME);</span><br><span class="line"><span class="keyword">if</span> (mbeanDomain != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (applicationContexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (applicationContexts.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">applicationName = applicationContext.getApplicationName();</span><br><span class="line">server.registerMBean(<span class="keyword">new</span> LiveBeansView(),</span><br><span class="line"><span class="keyword">new</span> ObjectName(mbeanDomain, MBEAN_APPLICATION_KEY, applicationName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;Failed to register LiveBeansView MBean&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">applicationContexts.add(applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个<code>**refresh()**</code>的主流程已经完成。对于初始化所有的单实例bean，我将会在下一篇尽量做一个完整的分析。此外针对AOP，事务，三级缓存与循环依赖，加载spring mvc的组件，web环境下一个请求的执行流程，我都会在后续逐行分析源代码，做一些归纳总结。Spring发展至今，已经不单单是一个Java的框架，更是一个生态。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring[一]初始化WEB组件</title>
      <link href="/2022/01/11/Spring/Spring%5B%E4%B8%80%5D%E5%88%9D%E5%A7%8B%E5%8C%96Web%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
      <url>/2022/01/11/Spring/Spring%5B%E4%B8%80%5D%E5%88%9D%E5%A7%8B%E5%8C%96Web%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC最后是通过Tomcat来进行部署的。当在Servlet中进行进行应用部署时，主要步骤为:<br>When a web application is deployed into a container, the following steps must be performed, in this order, before the web application begins processing client requests.</p><ul><li>Instantiate an instance of each event listener identified by a element in the deployment descriptor.</li><li>For instantiated listener instances that implement ServletContextListener , call the contextInitialized() method.</li><li>Instantiate an instance of each filter identified by a element in the deployment descriptor and call each filter instance’s init() method.</li><li>Instantiate an instance of each servlet identified by a element that includes a element in the order defined by the load-on-startup element values, and call each servlet instance’s init() method.</li></ul><p>当应用部署到容器时，在应用相应客户的请求之前，需要执行以下步骤：</p><ul><li> 创建并初始化由元素标记的事件监听器。 </li><li> 对于事件监听器，如果实现了ServletContextListener接口，那么调用其contextInitialized()方法。 </li><li> 创建和初始化由元素标记的过滤器，并调用其init()方法。 </li><li> 根据中定义的顺序创建和初始化由元素标记的servlet，并调用其init()方法。所以在Tomcat下部署的应用，会先初始化listener，然后初始化filter，最后初始化servlet。 </li></ul><p>现在根据配置文件和Oracle所说的初始化流程分析一下，SpringMVC是如何来一步步启动容器，并加载相关信息的。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--告诉加载器，去这个位置去加载spring的相关配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--解决乱码问题的filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-初始化Listener"><a href="#1-初始化Listener" class="headerlink" title="1.初始化Listener"></a>1.初始化Listener</h2><p>我们在配置文件定义的Listener类是ContextLoaderListener.</p><p>继承关系：ContextLoaderListener 类继承了 ContextLoader 类并且实现了 ServletContextListener 接口，按照启动程序，会调用其 contextInitialized() 方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这个方法：初始化应用上下文</span><br><span class="line"> * @param event</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">//这里就进入了初始化web容器的核心</span><br><span class="line">initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 初始化web应用的上下文</span><br><span class="line"> * ServletContext官方叫servlet上下文。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。</span><br><span class="line"> * 这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。</span><br><span class="line"> * @param servletContext servlet 上下文</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line">/*</span><br><span class="line">* 首先通过 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 这个String类型的静态变量获取一个Root ioc 容器，</span><br><span class="line">* 根据 ioc 容器作为全局变量存储在 application 对象中，如果存在则有且只能有一个</span><br><span class="line">*</span><br><span class="line">* 如果在初始化 Root WebApplicationContext 即， Root ioc 容器的时候发现已经存在，则直接抛出异常，</span><br><span class="line">* 因此web.xml中只允许存在一个ContextLoader类或其子类对象。</span><br><span class="line">* */</span><br><span class="line">if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Cannot initialize context because there is already a root application context present - &quot; +</span><br><span class="line">&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</span><br><span class="line">Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">if (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(&quot;Root WebApplicationContext: initialization started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">/*如果context不存在，则直接进行创建*/</span><br><span class="line">if (this.context == null) &#123;</span><br><span class="line">/*step into*/</span><br><span class="line">this.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line">if (this.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;</span><br><span class="line">if (!cwac.isActive()) &#123;</span><br><span class="line">// The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">// setting the parent context, setting the application context id, etc</span><br><span class="line">if (cwac.getParent() == null) &#123;</span><br><span class="line">// The context instance was injected without an explicit parent -&gt;</span><br><span class="line">// determine parent for root web application context, if any.</span><br><span class="line">ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">cwac.setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line">/*配置并刷新应用的root ioc 容器，这里会进行bean的创建和初始化工作，</span><br><span class="line">* 这里最终会调用 AbstractApplicationContext的refresh方法。</span><br><span class="line">* 并且ioc容器中的bean类会被放在application中。*/</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//以属性的配置方式将application配置servletContext中，因为servletContext是整个应用唯一的，所以可以根据key值获取到application，从而能够获取到应用的所有信息</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line"></span><br><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">if (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">currentContext = this.context;</span><br><span class="line">&#125;</span><br><span class="line">else if (ccl != null) &#123;</span><br><span class="line">currentContextPerThread.put(ccl, this.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (logger.isInfoEnabled()) &#123;</span><br><span class="line">long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">logger.info(&quot;Root WebApplicationContext initialized in &quot; + elapsedTime + &quot; ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return this.context;</span><br><span class="line">&#125;</span><br><span class="line">catch (RuntimeException | Error ex) &#123;</span><br><span class="line">logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;</span><br><span class="line">if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">// The application context id is still set to its original default value</span><br><span class="line">// -&gt; assign a more useful id based on available information</span><br><span class="line">String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">if (idParam != null) &#123;</span><br><span class="line">wac.setId(idParam);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// Generate default id...</span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//将ServletContext设置到application的属性中</span><br><span class="line">wac.setServletContext(sc);</span><br><span class="line">//获取web.xml中配置的contextConfigLocation参数值</span><br><span class="line">String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">if (configLocationParam != null) &#123;</span><br><span class="line">wac.setConfigLocation(configLocationParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span><br><span class="line">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">// use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(sc, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customizeContext(sc, wac);</span><br><span class="line">//调用应用的refresh方法，进行IOC容器的装载</span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思考与沉淀"><a href="#思考与沉淀" class="headerlink" title="思考与沉淀"></a>思考与沉淀</h3><p>我们在web.xml配置文件定义的Listener类是ContextLoaderListener类.继承关系：ContextLoaderListener 类继承了 ContextLoader 类并且实现了 ServletContextListener 接口，按照启动程序，会调用其 contextInitialized() 方法。这个方法主要是调用了initWebApplicationContext()来初始化web应用的上下文，再通过configureAndRefreshWebApplicationContext()加载web.xml里面指定的配置文件，然后调用ioc容器的刷新方法。</p><h2 id="2-初始化Filter"><a href="#2-初始化Filter" class="headerlink" title="2.初始化Filter"></a>2.初始化Filter</h2><p>在完成了对于 listener 的初始化操作以后，会进行 filter 的创建和初始化操作。我们这里使用的是 CharacterEncodingFilter 。我们先看一下这个类的具体类图信息 ctrl+H。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1638717825844-44181c05-8a29-4d1c-bb7a-82897e0b58ca.png#crop=0&crop=0&crop=1&crop=1&height=237&id=uf1dded83&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=1648&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52246&status=done&style=none&title=&width=824" alt="image.png"></p><p>因为其实现了 Filter 接口，所以会调用其对应的 init(FilterConfig filterConfig) 方法。在其父类 GenericFilterBean 中有该方法的实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * filter的初始化方法</span><br><span class="line"> * @param filterConfig</span><br><span class="line"> * @throws ServletException</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public final void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">Assert.notNull(filterConfig, &quot;FilterConfig must not be null&quot;);</span><br><span class="line"></span><br><span class="line">this.filterConfig = filterConfig;</span><br><span class="line"></span><br><span class="line">// 将设置的初始化参数信息设置到pvs中</span><br><span class="line">PropertyValues pvs = new FilterConfigPropertyValues(filterConfig, this.requiredProperties);</span><br><span class="line">if (!pvs.isEmpty()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//将具体的filter类进行包装</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</span><br><span class="line">//创建对应的资源加载器</span><br><span class="line">ResourceLoader resourceLoader = new ServletContextResourceLoader(filterConfig.getServletContext());</span><br><span class="line">Environment env = this.environment;</span><br><span class="line">if (env == null) &#123;</span><br><span class="line">env = new StandardServletEnvironment();</span><br><span class="line">&#125;</span><br><span class="line">bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, env));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, true);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">String msg = &quot;Failed to set bean properties on filter &#x27;&quot; +</span><br><span class="line">filterConfig.getFilterName() + &quot;&#x27;: &quot; + ex.getMessage();</span><br><span class="line">logger.error(msg, ex);</span><br><span class="line">throw new NestedServletException(msg, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交给子类实现</span><br><span class="line">initFilterBean();</span><br><span class="line"></span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Filter &#x27;&quot; + filterConfig.getFilterName() + &quot;&#x27; configured for use&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void initFilterBean() throws ServletException &#123;</span><br><span class="line">//这里并未进行任何的初始化操作。其实Filter的主要作用还是在有请求过来时，进行的 doFilter() 中的处理，在启动阶段，处理比较少。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考与沉淀-1"><a href="#思考与沉淀-1" class="headerlink" title="思考与沉淀"></a>思考与沉淀</h3><p>在完成了对于 listener 的初始化操作以后，会进行 filter 的创建和初始化操作。通常在web.xml文件配置的是：CharacterEncodingFilter 。通过这个类的继承关系，再结合实际源码分析：因为其实现了 Filter 接口，所以会调用其对应的 init(FilterConfig filterConfig) 方法。在其父类 GenericFilterBean 中有该方法的实现。然后又交给了子类，但是实际上啥也没做，其实Filter的主要作用还是在有请求过来时，进行的 doFilter() 中的处理，在启动阶段，处理比较少。</p><h2 id="3-初始化Servlet"><a href="#3-初始化Servlet" class="headerlink" title="3.初始化Servlet"></a>3.初始化Servlet</h2><p>web应用启动的最后一个步骤就是创建和初始化 Servlet ，我们就从我们使用的 DispatcherServlet 这个类来进行分析，这个类是前端控制器，主要用于分发用户请求到具体的实现类，并返回具体的响应信息。</p><p><em>这里面有一个看源码的技巧，当分析到某一个类的时候，不知道如何再往下分析了，也就是缺少相应的抓手，怎么办？</em></p><p><em>1.看类的继承关系，从类的继承关系触发，寻找相应的方法</em></p><p><em>2.看初始化这种的方法</em></p><p><em>ctrl+H 查看类的继承关系，DispatcherServlet 实现了Servlet 接口，所以按照加载过程，最终会调用其 init(ServletConfig config)方法。从DispatcherServlet中寻找init方法发现没有，这个时候怎么办？按照类的继承关系，逐步向上寻找。最终定位到 GenericServlet 中，但是这里什么也没有做，只是交给了子类去实现，那就继续寻找，最终定位到抓手：HttpServletBean。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法几乎是web-ioc容器的核心入口</span></span><br><span class="line"><span class="comment"> * 当前类是DispatcherServlet的爷爷类</span></span><br><span class="line"><span class="comment"> * 加载DispatcherServlet的时候，他的爷爷类会先加载的并且 init方法会执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性信息</span></span><br><span class="line">PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//使用装饰器模式，对具体的实现类进行一个包装</span></span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line"><span class="comment">//将web.xml里面的属性信息设置到 bw 里面。</span></span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line"><span class="comment">//交给子类来实现</span></span><br><span class="line">initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到子类：FrameworkServlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">getServletContext().log(<span class="string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Initializing Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//初始化web应用容器</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line"><span class="comment">//初始化框架servlet</span></span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line"><span class="string">&quot;shown which may lead to unsafe logging of potentially sensitive data&quot;</span> :</span><br><span class="line"><span class="string">&quot;masked to prevent unsafe logging of potentially sensitive data&quot;</span>;</span><br><span class="line">logger.debug(<span class="string">&quot;enableLoggingRequestDetails=&#x27;&quot;</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line"><span class="string">&quot;&#x27;: request parameters and headers will be &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Completed initialization in &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里主要是进行了web应用容器上下文的创建，并进行了初始化工作。</span></span><br><span class="line"><span class="comment"> * 跟踪一下初始化的具体流程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取到 root ioc 容器</span></span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//将 root ioc 容器设置成 servlet 的ioc容器的父类</span></span><br><span class="line"><span class="comment">//如果当前servlet存在一个 WebApplicationContext 即：子IOC容器</span></span><br><span class="line"><span class="comment">//并且上下文获取的root ioc 容器存在，则将root ioc 容器作为子 ioc 容器的父容器</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置并刷新子容器，加载子容器中对应的bean实体类</span></span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前servlet中不存在子ioc容器，则去查找</span></span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line"><span class="comment">//如果查找不到，就去创建一个</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"><span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line"><span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line"><span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line"><span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line"><span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line"><span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据类信息初始化一个ConfigurableWebApplicationContext对象</span></span><br><span class="line">ConfigurableWebApplicationContext wac =</span><br><span class="line">(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"><span class="comment">//设置web上下文环境信息</span></span><br><span class="line">wac.setEnvironment(getEnvironment());</span><br><span class="line"><span class="comment">//设置其父类为root ioc 容器，root ioc 容器是整个应用唯一的。</span></span><br><span class="line">wac.setParent(parent);</span><br><span class="line"><span class="comment">//设置其具体的配置信息的位置，这里是 classpath:spring-mvc.xml</span></span><br><span class="line">String configLocation = getContextConfigLocation();</span><br><span class="line"><span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">wac.setConfigLocation(configLocation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置并刷新web应用的ioc容器</span></span><br><span class="line">configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line"><span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line"><span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Generate default id...</span></span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">&#x27;/&#x27;</span> + getServletName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置容器的相关信息</span></span><br><span class="line">wac.setServletContext(getServletContext());</span><br><span class="line">wac.setServletConfig(getServletConfig());</span><br><span class="line">wac.setNamespace(getNamespace());</span><br><span class="line"><span class="comment">//配置容器应用加载的监听器</span></span><br><span class="line">wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// The wac environment&#x27;s #initPropertySources will be called in any case when the context</span></span><br><span class="line"><span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line"><span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line"><span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postProcessWebApplicationContext(wac);</span><br><span class="line"><span class="comment">//应用初始化信息</span></span><br><span class="line">applyInitializers(wac);</span><br><span class="line"><span class="comment">//刷新加载里面的bean实体类</span></span><br><span class="line">wac.refresh();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里其实可以看到，在这个其实主要是根据配置文件信息进行类加载的工作，并且配置了一个容器加载信息的监听器 SourceFilteringListener。在最后通过 refresh 方法进行了容器中实体类的加载过程。这个refresh方法和我们在listener中实现类的初始化过程使用的是同一个方法。到此为止，在我们应用中配置的所有的类都能够扫描到，并且配置了我们的ioc容器中。因为我们配置了相关的容器加载的监听器，在refresh方法中调用了 finishRefresh 方法时，发送对应的容器加载完成广播信息，从而能够调用我们所注册的监听器 SourceFilteringListener。看一下里面的逻辑~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onApplicationEventInternal</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">&quot;Must specify a delegate object or override the onApplicationEventInternal method&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的delegate，是传入的具体的代理类，所以在此回到了我们的FrameworkServlet</span></span><br><span class="line"><span class="keyword">this</span>.delegate.onApplicationEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.refreshEventReceived = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line"><span class="comment">//最终调用了FrameworkServlet的onApplicationEvent方法</span></span><br><span class="line">onRefresh(event.getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 又是一个扩展点，交给子类去实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于来到了我们的DispatcherServlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过重写父类的扩展点来到这里</span></span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化servlet使用的策略信息，子类可以通过覆写该方法类增加更多的呃策略方法</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化MultipartResolver,可以支持文件的上传</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line"><span class="comment">//初始化本地解析器</span></span><br><span class="line">initLocaleResolver(context);</span><br><span class="line"><span class="comment">//初始化主题解析器</span></span><br><span class="line">initThemeResolver(context);</span><br><span class="line"><span class="comment">//处理器映射器，将请求和方法进行映射关联</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line"><span class="comment">//处理器适配器</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line"><span class="comment">//处理器异常解析器</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line"><span class="comment">//从请求到视图名的转换器</span></span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line"><span class="comment">//视图解析器</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line"><span class="comment">//FlashMap管理器</span></span><br><span class="line">initFlashMapManager(context);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 可以看到里面主要是初始化了我们的所使用到的一些解析器和处理器等。</span></span><br><span class="line"><span class="comment">* 当接收到请求后，就可以根据这些解析器来进行请求的解析处理、方法的调用、异常的处理等等。</span></span><br><span class="line"><span class="comment">* 到此为止，Servlet的初始化工作就整个完成了。想当的复杂，主要是将很多的方法实现在父类中进行了处理。层级比较复杂，需要一点点跟踪分析。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考与沉淀-2"><a href="#思考与沉淀-2" class="headerlink" title="思考与沉淀"></a>思考与沉淀</h3><p>web应用启动的最后一个步骤就是创建和初始化 Servlet ，我们就从我们使用的 DispatcherServlet 这个类来进行分析，这个类是前端控制器，主要用于分发用户请求到具体的实现类，并返回具体的响应信息。看这个类的继承关系：在HttpServlet（他的爷爷类）中，实现了servlet的init方法（其实再往里追源码，实际是从源码里面实现的，算是一个扩展点吧），这里主要是委派给了子类FrameworkServlet（dispatcherServlet的父类）的initServletBean()，这个方法主要是初始化web应用。通过initWebApplicationContext()配置并刷新子容器，这里其实可以看到，在这个其实主要是根据配置文件信息进行类加载的工作，并且配置了一个容器加载信息的监听器 SourceFilteringListener。在最后通过 refresh 方法进行了容器中实体类的加载过程。这个refresh方法和我们在listener中实现类的初始化过程使用的是同一个方法。到此为止，在我们应用中配置的所有的类都能够扫描到，并且配置了我们的ioc容器中。因为我们配置了相关的容器加载的监听器，在refresh方法中调用了 finishRefresh 方法时，发送对应的容器加载完成广播信息，从而能够调用我们所注册的监听器 SourceFilteringListener。看一下里面的逻辑~这里面实际上又调用了传入的代理类的onRefresh()。这个代理类是谁？其实就是DispatcherServlet。他的onRefresh()实际上就是调用了initStrategies()，可以看到里面主要是初始化了我们的所使用到的一些解析器和处理器等。当接收到请求后，就可以根据这些解析器来进行请求的解析处理、方法的调用、异常的处理等等。到此为止，Servlet的初始化工作就整个完成了。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1638722489754-2a718227-6aae-4f53-a4f1-f2ea39eed5f0.png#crop=0&crop=0&crop=1&crop=1&height=1278&id=u766cf921&margin=%5Bobject%20Object%5D&name=spring-web%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png&originHeight=1278&originWidth=1681&originalType=binary&ratio=1&rotation=0&showTitle=false&size=226332&status=done&style=none&title=&width=1681" alt="spring-web三大组件的加载流程.png"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十四]redo日志</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一，什么是redo日志"><a href="#一，什么是redo日志" class="headerlink" title="一，什么是redo日志"></a>一，什么是redo日志</h1><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们的CRUD操作其实都是在访问页面。在真正访问页面之前，需要把磁盘中的页加载到内存的BufferPool，之后才能访问，但是因为事务要保持持久性，如果我们仅仅在内存的缓冲池修改了页面，假设事务提交后突然发生故障，导致内存的数据都消失了，那么这个已经提交的事务在数据库做的更改就丢失了。</p><p>如何保证持久性呢？可以在事务提交完成之前，把事务修改的所有页面都刷新到磁盘。不过这样做存在一些问题：</p><ol><li>刷新一个完整的数据页过于浪费</li><li>随机IO效率比较低</li></ol><p>事实上仅仅是为了保证事务的持久性，没有必要每次提交事务的时候就把该事务在内存修改过的全部页面刷新到磁盘，只需要把修改的内容记录一下就好，这样在事务提交的时候，就会把这个记录刷新到磁盘。即使系统因为崩溃而重启只需要按照记录的内容重新更新数据页即可恢复数据，上述记录修改的内容就叫做重做日志（redo log）。</p><p>相比于在事务提交的时候将所有修改过的内存中的页面刷新到磁盘，重做日志有以下好处：</p><ol><li>redo日志占用空间小：在存储表空间ID，页号，偏移量以及需要更新的值时，需要的存储空间很小。</li><li>redo日志是顺序写入磁盘的：在执行事务过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li></ol><h1 id="二，redo日志格式"><a href="#二，redo日志格式" class="headerlink" title="二，redo日志格式"></a>二，redo日志格式</h1><p>重做日志本质上仅仅是记录了一下事务对数据库进行了哪些修改。针对事务对数据库的不同修改场景MySQL定义了很多种重做日志，但是大部分类型的重做日志都有以下的通用结构。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864487599-72623029-d1bd-486a-93d7-f34d2fe58221.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufbd9f38f&margin=%5Bobject%20Object%5D&name=1.png&originHeight=354&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112563&status=done&style=none&taskId=ue7c47d23-75ab-4475-8af2-31b72226448&title=" alt="1.png"></p><table><thead><tr><th>type</th><th>重做日志的类型</th></tr></thead><tbody><tr><td>space ID</td><td>表空间ID</td></tr><tr><td>page number</td><td>页号</td></tr><tr><td>Data</td><td>日志的具体内容</td></tr></tbody></table><h2 id="1-简单的redo日志类型"><a href="#1-简单的redo日志类型" class="headerlink" title="1. 简单的redo日志类型"></a>1. 简单的redo日志类型</h2><p>行格式里面有一个隐藏列叫做row_id。为row_id进行赋值的方式如下：</p><ol><li>服务器会在内存中维护一个全局变量，每当像某个包含row_id隐藏列的表插入一条记录的时候，就会把这个全局变量的值当做新记录row_id的值，并且把这个全局变量自增1。</li><li>每当这个全局变量的值是256的整数倍的时候，就会把这个变量的值刷新到系统表空间页号为7的页面中一个叫做Max Row ID的属性中。</li><li>当系统启动的时候，会将Max Row ID属性加载到内存，并把这个值加上256之后赋值给前面提到的全局变量。</li></ol><p>这个Max Row ID占用的存储空间是8字节。当某个事务向某个包含row_id的表插入一条记录并且该记录分配的row_id值为256的整数倍的时候，就会像系统表空间页号为7的页面的相应偏移量处写入8字节的值。但是这个写入操作实际上是在内存缓冲区完成的，我们需要把这次修改以redo日志的形式记录下来，这样在事务提交之后，即使系统崩溃，也可以将该页面恢复成崩溃前的状态。在这种对页面的修改特别简单的时候，重做日志仅仅需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体修改后的内容是什么就可以了。这也叫做物理日志。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864497144-c6bbeee2-d119-4f70-a1cd-8f30e19a648f.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63b5c32f&margin=%5Bobject%20Object%5D&name=2.png&originHeight=346&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128345&status=done&style=none&taskId=ucca73287-3001-4a4e-9fcf-6be09c76605&title=" alt="2.png"></p><blockquote><p>offset表示页面中的偏移量。如果写入的是字节序列类型的重做日志，还需要有一个len属性记录实际写入的长度。</p></blockquote><h2 id="2-复杂的redo日志类型"><a href="#2-复杂的redo日志类型" class="headerlink" title="2.复杂的redo日志类型"></a>2.复杂的redo日志类型</h2><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）。</p><p>这时我们如果使用简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p><ul><li> 方案一：在每个修改的地方都记录一条<code>redo</code>日志。<br>也就是有多少个修改的记录，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多。 </li><li> 方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。<br><code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中太浪费了。 </li></ul><p>正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，<code>InnoDB</code>提出了一些新的<code>redo</code>日志类型。</p><p>这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p><ul><li>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</li><li>逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640864506052-682d177e-e56e-41a2-ae87-d0b12033c1a1.jpeg#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u21fe8e28&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=502&originWidth=2551&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155669&status=done&style=none&taskId=ud78277be-d3e8-4dbf-8c90-73c67ad2679&title=" alt="3.jpg"></p><p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了什么，<code>PAGE_HEAP_TOP</code>的值修改为了什么，<code>PAGE_N_HEAP</code>的值修改为了什么等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统崩溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p><blockquote><p>日志格式说了一堆核心其实就是：<strong>重做日志会把事务执行过程中对数据库所做的所有修改都记录下来，在之后系统因为崩溃而重启后可以把事务所做的任何修改都恢复过来。</strong></p><p>为了节省重做日志占用的空间大小，InnoDB还对重做日志中的某些数据进行了压缩处理，比如表空间ID&amp;page number 一般占用4字节来存储，但是经过压缩之后占用的空间就更小了。</p></blockquote><h1 id="三，Mini-Transcation"><a href="#三，Mini-Transcation" class="headerlink" title="三，Mini-Transcation"></a>三，Mini-Transcation</h1><h2 id="1-以组的形式写入redo日志"><a href="#1-以组的形式写入redo日志" class="headerlink" title="1.以组的形式写入redo日志"></a>1.以组的形式写入redo日志</h2><p>语句在执行过程中可能修改若干个页面。比如我们前边说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被<code>InnoDB</code>人为的划分成了若干个不可分割的组，比如：</p><ul><li>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</li><li>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li><li>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</li></ul><p>怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p><ul><li> 情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864518399-d8ca4351-4d13-4bd4-9d2f-d2f8b9cf827f.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u216a45d8&margin=%5Bobject%20Object%5D&name=4.png&originHeight=1184&originWidth=2626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=682116&status=done&style=none&taskId=ufb2d27cf-ca13-47d8-8933-70b4495df9c&title=" alt="4.png"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864527311-d990febe-3bbf-430d-8193-c555bfcb6a28.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u77a21299&margin=%5Bobject%20Object%5D&name=5.png&originHeight=1214&originWidth=2736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=716516&status=done&style=none&taskId=u9acd0af1-5494-4f70-a01c-37f3834f243&title=" alt="5.png"> </li><li> 情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864555961-e408cdd7-cfe0-4ca8-9abd-3f23e263791a.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua72872eb&margin=%5Bobject%20Object%5D&name=6.png&originHeight=1166&originWidth=2628&originalType=binary&ratio=1&rotation=0&showTitle=false&size=114382&status=done&style=none&taskId=u3f7aabf6-811a-44fb-9762-57c4045b0a9&title=" alt="6.png"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864564352-6b5aea0c-fbaa-4b8b-bdd6-94c83b589b89.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uafb41cc9&margin=%5Bobject%20Object%5D&name=7.png&originHeight=1202&originWidth=2652&originalType=binary&ratio=1&rotation=0&showTitle=false&size=786814&status=done&style=none&taskId=u060ba959-ed05-4ba7-aa1c-1f0b67f001f&title=" alt="7.png"><br>如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表等，我们在介绍表空间那一篇中介绍过的各种东西），反正总共需要记录的<code>redo</code>日志有二、三十条。 </li></ul><blockquote><p>其实不光是悲观插入一条记录会生成许多条redo日志，InnoDB为了其他的一些功能，在乐观插入时也可能产生多条redo日志。</p></blockquote><p><code>InnoDB</code>认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统崩溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统崩溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是<code>InnoDB</code>所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统崩溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p><ul><li> 有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。<br>如何把这些<code>redo</code>日志划分到一个组里边儿呢？<code>InnoDB</code>做了一个很简单的操作，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864573578-9668a610-aeba-4131-87cd-fbe9ab8dfa1b.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7b288267&margin=%5Bobject%20Object%5D&name=8.png&originHeight=268&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50315&status=done&style=none&taskId=u9fe14e16-5e51-4acd-a72b-547c4eed975&title=" alt="8.png"><br>所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864581619-ef9856b6-4148-4179-a2c0-6ef3fac46de2.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uebe2359f&margin=%5Bobject%20Object%5D&name=9.png&originHeight=684&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81836&status=done&style=none&taskId=u0b4690f2-55d0-46d3-824c-1a896362c67&title=" alt="9.png"><br>这样在系统崩溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前边解析到的<code>redo</code>日志。 </li><li> 有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。<br>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，<code>InnoDB</code>不想浪费一个比特位。虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864589834-ee10f8e7-b2d5-49be-883f-bb87c130c80a.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uce73ec9d&margin=%5Bobject%20Object%5D&name=10.png&originHeight=640&originWidth=1704&originalType=binary&ratio=1&rotation=0&showTitle=false&size=287797&status=done&style=none&taskId=u91331d85-1eb9-47fd-bb64-955a160bd0e&title=" alt="10.png"><br>如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。 </li></ul><h2 id="2-Mini-Transaction"><a href="#2-Mini-Transaction" class="headerlink" title="2.Mini-Transaction"></a>2.Mini-Transaction</h2><p><code>MySQL</code>把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864597409-0355aaab-6e93-4e2a-ba36-16219408aa78.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u065b9c9e&margin=%5Bobject%20Object%5D&name=11.png&originHeight=1380&originWidth=1764&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103182&status=done&style=none&taskId=ue8afcf6a-afa4-4881-8189-394a28a5db0&title=" alt="11.png"></p><h1 id="四，redo日志的写入过程"><a href="#四，redo日志的写入过程" class="headerlink" title="四，redo日志的写入过程"></a>四，redo日志的写入过程</h1><h2 id="1-redo-log-block"><a href="#1-redo-log-block" class="headerlink" title="1.redo log block"></a>1.redo log block</h2><p><code>InnoDB</code>为了更好的进行系统崩溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>。一个<code>redo log block</code>的示意图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641864021669-f9e4073a-fe36-4537-be44-a395924f907f.png#clientId=u243d2ae4-ef44-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf4c03a91&margin=%5Bobject%20Object%5D&name=image.png&originHeight=764&originWidth=1306&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71145&status=done&style=none&taskId=uab13cea9-5436-42a0-8b3f-16678b944c2&title=" alt="image.png"></p><p>真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641864242219-2be35389-a760-41ab-a7fe-b3eafe265d4e.png#clientId=u243d2ae4-ef44-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufe5375ac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149840&status=done&style=none&taskId=ua653d992-91b4-40fa-b171-5b2a8010523&title=" alt="image.png"></p><p>其中<code>log block header</code>的几个属性的意思分别如下：</p><ul><li><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li></ul><p><code>log block trailer</code>中属性的意思如下：</p><ul><li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li></ul><h2 id="2-redo-日志缓冲区"><a href="#2-redo-日志缓冲区" class="headerlink" title="2.redo 日志缓冲区"></a>2.redo 日志缓冲区</h2><p><code>InnoDB</code>为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864625032-625f8c90-46bb-4a14-a50c-ad70e7dce61c.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8bcc1d13&margin=%5Bobject%20Object%5D&name=14.png&originHeight=864&originWidth=2838&originalType=binary&ratio=1&rotation=0&showTitle=false&size=553662&status=done&style=none&taskId=ud5c09ca4-6b88-4de9-a09b-d3967214a4d&title=" alt="14.png"></p><p>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p><h2 id="3-redo-log-日志写入log-buffer"><a href="#3-redo-log-日志写入log-buffer" class="headerlink" title="3.redo log 日志写入log buffer"></a>3.redo log 日志写入log buffer</h2><p>向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以<code>InnoDB</code>特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864634044-307e6617-8881-422a-a1b4-6b65a460cde3.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u29330ff2&margin=%5Bobject%20Object%5D&name=15.png&originHeight=1024&originWidth=2828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=706746&status=done&style=none&taskId=u3bbeba33-8aa5-49d0-9f2a-f71c2f269e8&title=" alt="15.png"></p><p>一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p><ul><li>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</li><li>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</li></ul><p>每个<code>mtr</code>都会产生一组<code>redo</code>日志，不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864644524-f2d41097-c851-43f7-9284-f213732bd421.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5a52634d&margin=%5Bobject%20Object%5D&name=16.png&originHeight=1094&originWidth=2818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=762512&status=done&style=none&taskId=ub1ed7d29-40e2-4d9a-bebf-0937e001a43&title=" alt="16.png"></p><p>从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p><h1 id="五，redo-日志文件"><a href="#五，redo-日志文件" class="headerlink" title="五，redo 日志文件"></a>五，redo 日志文件</h1><h2 id="1-redo日志刷盘时机"><a href="#1-redo日志刷盘时机" class="headerlink" title="1.redo日志刷盘时机"></a>1.redo日志刷盘时机</h2><p><code>mtr</code>运行过程中产生的一组<code>redo</code>日志在<code>mtr</code>结束时会被复制到<code>log buffer</code>中，在一些情况下它们会被刷新到磁盘里，比如：</p><ul><li> <code>log buffer</code>空间不足时<br><code>log buffer</code>的大小是有限的（通过系统变量<code>innodb_log_buffer_size</code>指定），如果不停的往这个有限大小的<code>log buffer</code>里塞入日志，很快它就会被填满。<code>InnoDB</code>认为如果当前写入<code>log buffer</code>的<code>redo</code>日志量已经占满了<code>log buffer</code>总容量的大约一半左右，就需要把这些日志刷新到磁盘上。 </li><li> 事务提交时<br>之所以使用<code>redo</code>日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的<code>Buffer Pool</code>页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的<code>redo</code>日志刷新到磁盘。 </li><li> 将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中（再一次 强调，redo 日志是顺序刷新的，所以在将某个脏页对应的 redo 日志从 redo log buffer 刷新到磁盘时，也会保证将在其之前产生的 redo 日志也刷新到磁盘）。 </li><li> 后台线程不停的刷<br>后台有一个线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo</code>日志到磁盘。 </li><li> 正常关闭服务器时 </li><li> 做所谓的<code>checkpoint</code>时 </li><li> 其他的一些情况… </li></ul><h2 id="2-redo日志文件组"><a href="#2-redo日志文件组" class="headerlink" title="2.redo日志文件组"></a>2.redo日志文件组</h2><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，<code>log buffer</code>中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的<code>redo</code>日志文件不满意，可以通过下边几个启动参数来调节：</p><ul><li> <code>innodb_log_group_home_dir</code><br>该参数指定了<code>redo</code>日志文件所在的目录，默认值就是当前的数据目录。 </li><li> <code>innodb_log_file_size</code><br>该参数指定了每个<code>redo</code>日志文件的大小，在<code>MySQL 5.7.21</code>这个版本中的默认值为<code>48MB</code>， </li><li> <code>innodb_log_files_in_group</code><br>该参数指定<code>redo</code>日志文件的个数，默认值为2，最大值为100。 </li></ul><p>磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0</code>、<code>1</code>、<code>2</code>…）的形式进行命名。在将<code>redo</code>日志写入<code>日志文件组</code>时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写，同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864656682-963826be-2fa2-4598-9033-606039356e57.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uaa3d5ef3&margin=%5Bobject%20Object%5D&name=17.png&originHeight=586&originWidth=1734&originalType=binary&ratio=1&rotation=0&showTitle=false&size=311573&status=done&style=none&taskId=u051c8364-6b34-4392-9b9d-e1f31520ad8&title=" alt="17.png"></p><p>总共的<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p><blockquote><p>如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的redo日志覆盖掉前边写的redo日志？当然可能了！所以InnoDB提出了checkpoint的概念。</p></blockquote><h2 id="3-redo日志文件格式"><a href="#3-redo日志文件格式" class="headerlink" title="3.redo日志文件格式"></a>3.redo日志文件格式</h2><p><code>log buffer</code>本质上是一片连续的内存空间，被划分成了若干个<code>512</code>字节大小的<code>block</code>。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的block组成。</p><p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</li></ul><p>所以我们前边所说的<code>循环</code>使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864666580-772cbeb7-f939-4dd8-8478-efea9d4151a6.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2dc0fb0c&margin=%5Bobject%20Object%5D&name=18.png&originHeight=1024&originWidth=2806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=591545&status=done&style=none&taskId=uf7825917-db29-4e0d-b498-ccb3858542a&title=" alt="18.png"></p><p>普通block的格式我们在了解<code>log buffer</code>的时候都说过了，就是<code>log block header</code>、<code>log block body</code>、<code>log block trialer</code>这三个部分。这里需要介绍一下每个<code>redo</code>日志文件前2048个字节，也就是前4个特殊block的格式都是什么作用。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864675232-a3665df8-b4a1-46f9-98f4-64fc979f9e51.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7b53cd73&margin=%5Bobject%20Object%5D&name=19.png&originHeight=1136&originWidth=2802&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132931&status=done&style=none&taskId=u77c738bc-8c15-4c0f-906a-0e806683b7d&title=" alt="19.png"><br>从图中可以看出来，这4个block分别是：</p><ul><li><p> <code>log file header</code>：描述该<code>redo</code>日志文件的一些整体属性<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640864685580-5d17b490-ff01-4e39-a31b-ef6c2ff624d5.jpeg#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue90cf3d3&margin=%5Bobject%20Object%5D&name=20.jpg&originHeight=1593&originWidth=2467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183282&status=done&style=none&taskId=u7f79975e-ede8-444b-8dff-d57bf42876f&title=" alt="20.jpg"><br>各个属性的具体释义如下：  </p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_HEADER_FORMAT</code></td><td><code>4</code></td><td><code>redo</code>日志的版本，在<code>MySQL 5.7.21</code>中该值永远为1</td></tr><tr><td><code>LOG_HEADER_PAD1</code></td><td><code>4</code></td><td>做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td><code>LOG_HEADER_START_LSN</code></td><td><code>8</code></td><td>标记本<code>redo</code>日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值。</td></tr><tr><td><code>LOG_HEADER_CREATOR</code></td><td><code>32</code></td><td>一个字符串，标记本<code>redo</code>日志文件的创建者是谁。正常运行时该值为<code>MySQL</code>的版本号，比如：<code>&quot;MySQL 5.7.21&quot;</code>，使用<code>mysqlbackup</code>命令创建的<code>redo</code>日志文件的该值为<code>&quot;ibbackup&quot;</code>和创建时间。</td></tr><tr><td><code>LOG_BLOCK_CHECKSUM</code></td><td><code>4</code></td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table></li><li><p> <code>checkpoint1</code>：记录关于<code>checkpoint</code>的一些属性，看一下它的结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640864698163-e1185f2f-8cfa-429f-a4a2-404ec8518c4c.jpeg#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u32a54e19&margin=%5Bobject%20Object%5D&name=21.jpg&originHeight=1593&originWidth=2467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=222295&status=done&style=none&taskId=u61cbdb66-d4ec-4f02-b6bd-32dcd7c3766&title=" alt="21.jpg"><br>各个属性的具体释义如下：  </p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_CHECKPOINT_NO</code></td><td><code>8</code></td><td>服务器做<code>checkpoint</code>的编号，每做一次<code>checkpoint</code>，该值就加1。</td></tr><tr><td><code>LOG_CHECKPOINT_LSN</code></td><td><code>8</code></td><td>服务器做<code>checkpoint</code>结束时对应的<code>LSN</code>值，系统崩溃恢复时将从该值开始。</td></tr><tr><td><code>LOG_CHECKPOINT_OFFSET</code></td><td><code>8</code></td><td>上个属性中的<code>LSN</code>值在<code>redo</code>日志文件组中的偏移量</td></tr><tr><td><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code></td><td><code>8</code></td><td>服务器在做<code>checkpoint</code>操作时对应的<code>log buffer</code>的大小</td></tr><tr><td><code>LOG_BLOCK_CHECKSUM</code></td><td><code>4</code></td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table></li><li><p> 第三个block未使用，忽略 </p></li><li><p> <code>checkpoint2</code>：结构和<code>checkpoint1</code>一样。 </p></li></ul><h1 id="六，Log-Sequence-Number"><a href="#六，Log-Sequence-Number" class="headerlink" title="六，Log Sequence Number"></a>六，Log Sequence Number</h1><p>自系统开始运行，就不断的在修改页面，也就意味着会不断的生成<code>redo</code>日志。<code>redo</code>日志的量在不断的递增。<code>InnoDB</code>为记录已经写入的<code>redo</code>日志量，设计了一个称之为<code>Log Sequence Number</code>的全局变量，翻译过来就是：<code>日志序列号</code>，简称<code>lsn</code>。<code>InnoDB</code>规定初始的<code>lsn</code>值为<code>8704</code>（也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值为<code>8704</code>）。</p><p>在向<code>log buffer</code>中写入<code>redo</code>日志时不是一条一条写入的，而是以一个<code>mtr</code>生成的一组<code>redo</code>日志为单位进行写入的。而且实际上是把日志内容写在了<code>log block body</code>处。但是在统计<code>lsn</code>的增长量时，是按照实际写入的日志量加上占用的<code>log block header</code>和<code>log block trailer</code>来计算的。我们来看一个例子：</p><ul><li> 系统第一次启动后初始化<code>log buffer</code>时，<code>buf_free</code>（就是标记下一条<code>redo</code>日志应该写入到<code>log buffer</code>的位置的变量）就会指向第一个<code>block</code>的偏移量为12字节（<code>log block header</code>的大小）的地方，那么<code>lsn</code>值也会跟着增加12：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864709610-a13d0013-b7b9-43b7-a161-151236b0596c.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u175705fd&margin=%5Bobject%20Object%5D&name=22.png&originHeight=692&originWidth=2600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=437626&status=done&style=none&taskId=u4cbca53f-ec16-496f-b610-d49ea0b6378&title=" alt="22.png"> </li><li> 如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864719076-5bbd616f-afe0-4a71-a152-6d8a29a70f27.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6f691c2a&margin=%5Bobject%20Object%5D&name=23.png&originHeight=612&originWidth=2654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=426566&status=done&style=none&taskId=u4e68bd52-b1e9-42ad-a8f9-158c6e867f2&title=" alt="23.png"><br>我们假设上图中<code>mtr_1</code>产生的<code>redo</code>日志量为200字节，那么<code>lsn</code>就要在<code>8716</code>的基础上增加<code>200</code>，变为<code>8916</code>。 </li><li> 如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较大，也就是待插入的block剩余空闲空间不足以容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数加上额外占用的<code>log block header</code>和<code>log block trailer</code>的字节数，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864728936-2a814700-924e-4236-9a03-81213c71844b.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9f9ca8d5&margin=%5Bobject%20Object%5D&name=24.png&originHeight=996&originWidth=2828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=755556&status=done&style=none&taskId=uc07adc05-b654-4c52-9ac6-3930c7e8ac1&title=" alt="24.png"><br>我们假设上图中<code>mtr_2</code>产生的<code>redo</code>日志量为1000字节，为了将<code>mtr_2</code>产生的<code>redo</code>日志写入<code>log buffer</code>，我们不得不额外多分配两个block，所以<code>lsn</code>的值需要在<code>8916</code>的基础上增加<code>1000 + 12×2 + 4 × 2 = 1032</code>。 </li></ul><p>从上边的描述中可以看出来，每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p><h2 id="1-flushed-to-disk-lsn"><a href="#1-flushed-to-disk-lsn" class="headerlink" title="1.flushed_to_disk_lsn"></a>1.flushed_to_disk_lsn</h2><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。所以<code>InnoDB</code>提出了一个称之为<code>buf_next_to_write</code>的全局变量，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864739527-34db3929-710e-4041-b4ef-1becced73694.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u94e6ad2a&margin=%5Bobject%20Object%5D&name=25.png&originHeight=696&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=379537&status=done&style=none&taskId=u77b5d0e0-b522-4178-a11d-062b2a18075&title=" alt="25.png"></p><p><code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，<code>InnoDB</code>提出了一个表示刷新到磁盘中的<code>redo</code>日志量的全局变量，称之为<code>flushed_to_disk_lsn</code>。系统第一次启动时，该变量的值和初始的<code>lsn</code>值是相同的，都是<code>8704</code>。随着系统的运行，<code>redo</code>日志被不断写入<code>log buffer</code>，但是并不会立即刷新到磁盘，<code>lsn</code>的值就和<code>flushed_to_disk_lsn</code>的值拉开了差距。我们推理一下：</p><ul><li>系统第一次启动后，向<code>log buffer</code>中写入了<code>mtr_1</code>、<code>mtr_2</code>、<code>mtr_3</code>这三个<code>mtr</code>产生的<code>redo</code>日志，假设这三个<code>mtr</code>开始和结束时对应的lsn值分别是： <ul><li><code>mtr_1</code>：8716 ～ 8916</li><li><code>mtr_2</code>：8916 ～ 9948</li><li><code>mtr_3</code>：9948 ～ 10000</li></ul></li></ul><p>此时的<code>lsn</code>已经增长到了10000，但是由于没有刷新操作，所以此时<code>flushed_to_disk_lsn</code>的值仍为<code>8704</code>，如图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864750935-f12dffd0-0d76-4929-9bff-9dcbb2d5be9e.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u57283172&margin=%5Bobject%20Object%5D&name=26.png&originHeight=1034&originWidth=1634&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93271&status=done&style=none&taskId=u3eabb779-7af8-4b51-8e36-7fa0072c2a1&title=" alt="26.png"></p><ul><li> 随后进行将<code>log buffer</code>中的block刷新到<code>redo</code>日志文件的操作，假设将<code>mtr_1</code>和<code>mtr_2</code>的日志刷新到磁盘，那么<code>flushed_to_disk_lsn</code>就应该增长<code>mtr_1</code>和<code>mtr_2</code>写入的日志量，所以<code>flushed_to_disk_lsn</code>的值增长到了<code>9948</code>，如图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864761524-39c96423-198f-41cf-b64d-f5848258dd62.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5694f54c&margin=%5Bobject%20Object%5D&name=27.png&originHeight=1054&originWidth=1680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=545789&status=done&style=none&taskId=u2b41f4eb-1206-4f50-81a3-517bb8a0cd1&title=" alt="27.png"> </li></ul><p>综上所述，当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p><blockquote><p>应用程序向磁盘写入文件时其实是先写到操作系统的缓冲区中去，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的<code>fsync</code>函数。其实只有当系统执行了<code>fsync</code>函数后，<code>flushed_to_disk_lsn</code>的值才会跟着增长，当仅仅把<code>log buffer</code>中的日志写入到操作系统缓冲区却没有显式的刷新到磁盘时，另外的一个称之为<code>write_lsn</code>的值跟着增长。</p></blockquote><h2 id="2-lsn值和redo日志文件偏移量的对应关系"><a href="#2-lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="2.lsn值和redo日志文件偏移量的对应关系"></a>2.lsn值和redo日志文件偏移量的对应关系</h2><p>因为<code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（当然有时候要加上<code>log block header</code>和<code>log block trailer</code>的大小），这样<code>mtr</code>产生的日志写到磁盘中时，很容易计算某一个<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864772681-83ca98a1-2b47-451c-b72a-d04b22f534a3.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u146be48e&margin=%5Bobject%20Object%5D&name=28.png&originHeight=582&originWidth=1578&originalType=binary&ratio=1&rotation=0&showTitle=false&size=258385&status=done&style=none&taskId=udbf909f0-a3fe-4128-b50e-f6ddc90ae87&title=" alt="28.png"></p><p>初始时的<code>LSN</code>值是<code>8704</code>，对应文件偏移量<code>2048</code>，之后每个<code>mtr</code>向磁盘中写入多少字节日志，<code>lsn</code>的值就增长多少。</p><h2 id="3-flush链表中的LSN"><a href="#3-flush链表中的LSN" class="headerlink" title="3.flush链表中的LSN"></a>3.flush链表中的LSN</h2><p>一个<code>mtr</code>代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的<code>redo</code>日志，在<code>mtr</code>结束时，会把这一组<code>redo</code>日志写入到<code>log buffer</code>中。除此之外，在<code>mtr</code>结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p><p>当第一次修改某个缓存在<code>Buffer Pool</code>中的页面时，就会把这个页面对应的控制块插入到<code>flush链表</code>的头部，之后再修改该页面时由于它已经在<code>flush</code>链表中了，就不再次插入了。也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p><ul><li><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</li><li><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</li></ul><p>接着上边<code>flushed_to_disk_lsn</code>的例子看一下：</p><ul><li> 假设<code>mtr_1</code>执行过程中修改了<code>页a</code>，那么在<code>mtr_1</code>执行结束时，就会将<code>页a</code>对应的控制块加入到<code>flush链表</code>的头部。并且将<code>mtr_1</code>开始时对应的<code>lsn</code>，也就是<code>8716</code>写入<code>页a</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_1</code>结束时对应的<code>lsn</code>，也就是8916写入<code>页a</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下（<code>oldest_modification</code>缩写成了<code>o_m</code>，<code>newest_modification</code>缩写成了<code>n_m</code>）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864784232-afbab3ff-b849-464a-903f-e9451b29bda7.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua2732566&margin=%5Bobject%20Object%5D&name=29.png&originHeight=850&originWidth=1592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=359132&status=done&style=none&taskId=u9746ce10-ff17-4ac3-a16f-94f116746e9&title=" alt="29.png"> </li><li> 接着假设<code>mtr_2</code>执行过程中又修改了<code>页b</code>和<code>页c</code>两个页面，那么在<code>mtr_2</code>执行结束时，就会将<code>页b</code>和<code>页c</code>对应的控制块都加入到<code>flush链表</code>的头部。并且将<code>mtr_2</code>开始时对应的<code>lsn</code>，也就是8916写入<code>页b</code>和<code>页c</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_2</code>结束时对应的<code>lsn</code>，也就是9948写入<code>页b</code>和<code>页c</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864792670-4fff07de-c242-4435-abd1-a395d7cb0212.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6d749ce4&margin=%5Bobject%20Object%5D&name=30.png&originHeight=638&originWidth=2310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=400105&status=done&style=none&taskId=uf40efa4b-706f-44dc-86a8-84e2098a814&title=" alt="30.png"><br>从图中可以看出来，每次新插入到<code>flush链表</code>中的节点都是被放在了头部，也就是说<code>flush链表</code>中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早。 </li><li> 接着假设<code>mtr_3</code>执行过程中修改了<code>页b</code>和<code>页d</code>，不过<code>页b</code>之前已经被修改过了，所以它对应的控制块已经被插入到了<code>flush</code>链表，所以在<code>mtr_3</code>执行结束时，只需要将<code>页d</code>对应的控制块都加入到<code>flush链表</code>的头部即可。所以需要将<code>mtr_3</code>开始时对应的<code>lsn</code>，也就是9948写入<code>页d</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_3</code>结束时对应的<code>lsn</code>，也就是10000写入<code>页d</code>对应的控制块的<code>newest_modification</code>属性中。另外，由于<code>页b</code>在<code>mtr_3</code>执行过程中又发生了一次修改，所以需要更新<code>页b</code>对应的控制块中<code>newest_modification</code>的值为10000。画个图表示一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864803589-2d9a04e5-51e2-49c9-8e11-14e59db61c53.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7f465b43&margin=%5Bobject%20Object%5D&name=31.png&originHeight=646&originWidth=2866&originalType=binary&ratio=1&rotation=0&showTitle=false&size=472625&status=done&style=none&taskId=u47725c53-d335-4b69-8639-00da9b1a978&title=" alt="31.png"> </li></ul><p>总结一下上边说的，就是：<strong>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</strong></p><h1 id="七，checkpoint"><a href="#七，checkpoint" class="headerlink" title="七，checkpoint"></a>七，checkpoint</h1><p><code>redo</code>日志文件组容量是有限的，我们不得不选择循环使用<code>redo</code>日志文件组中的文件，但是这会造成最后写的<code>redo</code>日志与最开始写的<code>redo</code>日志<code>追尾</code>，这时应该想到：redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说：判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。我们看一下前边的那个例子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864814179-88627650-6c19-452b-af5c-923e0a1c7ab9.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u68f75a23&margin=%5Bobject%20Object%5D&name=32.png&originHeight=1232&originWidth=1946&originalType=binary&ratio=1&rotation=0&showTitle=false&size=570522&status=done&style=none&taskId=u97475867-1c62-4084-b6ff-37bdd8e87ce&title=" alt="32.png"></p><p>如图，虽然<code>mtr_1</code>和<code>mtr_2</code>生成的<code>redo</code>日志都已经被写到了磁盘上，但是它们修改的脏页仍然留在<code>Buffer Pool</code>中，所以它们生成的<code>redo</code>日志在磁盘上的空间是不可以被覆盖的。之后随着系统的运行，如果<code>页a</code>被刷新到了磁盘，那么它对应的控制块就会从<code>flush链表</code>中移除，就像这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864822121-4553e8b1-d602-4486-878d-0245450abd51.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua0dba545&margin=%5Bobject%20Object%5D&name=33.png&originHeight=1234&originWidth=1602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=508938&status=done&style=none&taskId=ua087ec5f-573d-4b0e-8dcf-0680cf0a109&title=" alt="33.png"></p><p>这样<code>mtr_1</code>生成的<code>redo</code>日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。<code>InnoDB</code>提出了一个全局变量<code>checkpoint_lsn</code>来代表当前系统中可以被覆盖的<code>redo</code>日志总量是多少，这个变量初始值也是<code>8704</code>。</p><p>比方说现在<code>页a</code>被刷新到了磁盘，<code>mtr_1</code>生成的<code>redo</code>日志就可以被覆盖了，所以我们可以进行一个增加<code>checkpoint_lsn</code>的操作，我们把这个过程称之为做一次<code>checkpoint</code>。做一次<code>checkpoint</code>其实可以分为两个步骤：</p><ul><li> 步骤一：计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。<br><code>redo</code>日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的<code>oldest_modification</code>值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的<code>oldest_modification</code>赋值给<code>checkpoint_lsn</code>。<br>比方说当前系统中<code>页a</code>已经被刷新到磁盘，那么<code>flush链表</code>的尾节点就是<code>页c</code>，该节点就是当前系统中最早修改的脏页了，它的<code>oldest_modification</code>值为8916，我们就把8916赋值给<code>checkpoint_lsn</code>（也就是说在redo日志对应的lsn值小于8916时就可以被覆盖掉）。 </li><li> 步骤二：将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。<br><code>InnoDB</code>维护了一个目前系统做了多少次<code>checkpoint</code>的变量<code>checkpoint_no</code>，每做一次<code>checkpoint</code>，该变量的值就加1。我们前边说过计算一个<code>lsn</code>值对应的<code>redo</code>日志文件组偏移量是很容易的，所以可以计算得到该<code>checkpoint_lsn</code>在<code>redo</code>日志文件组中对应的偏移量<code>checkpoint_offset</code>，然后把这三个值都写到<code>redo</code>日志文件组的管理信息中。<br>我们说过，每一个<code>redo</code>日志文件都有<code>2048</code>个字节的管理信息，但是上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。不过我们是存储到<code>checkpoint1</code>中还是<code>checkpoint2</code>中呢？<code>InnoDB</code>规定，当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中。 </li></ul><p>记录完<code>checkpoint</code>的信息之后，<code>redo</code>日志文件组中各个<code>lsn</code>值的关系就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864832987-8aa99b0b-ad9f-4c2b-9a44-18c2563e5b18.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u793e2893&margin=%5Bobject%20Object%5D&name=34.png&originHeight=578&originWidth=1380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66537&status=done&style=none&taskId=u30aa57b3-7511-4be2-ae70-8b231c862bf&title=" alt="34.png"></p><h2 id="1-批量从flush链表中刷出脏页"><a href="#1-批量从flush链表中刷出脏页" class="headerlink" title="1.批量从flush链表中刷出脏页"></a>1.批量从flush链表中刷出脏页</h2><p>一般情况下都是后台的线程在对<code>LRU链表</code>和<code>flush链表</code>进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统<code>lsn</code>值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘，这样这些脏页对应的<code>redo</code>日志就没用了，然后就可以去做<code>checkpoint</code>了。</p><h2 id="2-查看系统中的各种LSN值"><a href="#2-查看系统中的各种LSN值" class="headerlink" title="2.查看系统中的各种LSN值"></a>2.查看系统中的各种LSN值</h2><p>我们可以使用<code>SHOW ENGINE INNODB STATUS</code>命令查看当前<code>InnoDB</code>存储引擎中的各种<code>LSN</code>值的情况，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 124476971</span><br><span class="line">Log flushed up to   124099769</span><br><span class="line">Pages flushed up to 124052503</span><br><span class="line">Last checkpoint at  124052494</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">24 log i/o&#x27;s done, 2.00 log i/o&#x27;s/second</span><br><span class="line">----------------------</span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Log sequence number</code>：代表系统中的<code>lsn</code>值，也就是当前系统已经写入的<code>redo</code>日志量，包括写入<code>log buffer</code>中的日志。</li><li><code>Log flushed up to</code>：代表<code>flushed_to_disk_lsn</code>的值，也就是当前系统已经写入磁盘的<code>redo</code>日志量。</li><li><code>Pages flushed up to</code>：代表<code>flush链表</code>中被最早修改的那个页面对应的<code>oldest_modification</code>属性值。</li><li><code>Last checkpoint at</code>：当前系统的<code>checkpoint_lsn</code>值。</li></ul><h2 id="3-innodb-flush-log-at-trx-commit的用法"><a href="#3-innodb-flush-log-at-trx-commit的用法" class="headerlink" title="3.innodb_flush_log_at_trx_commit的用法"></a>3.innodb_flush_log_at_trx_commit的用法</h2><p>为了保证事务的<code>持久性</code>，用户线程在事务提交时需要将该事务执行过程中产生的所有<code>redo</code>日志都刷新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能。如果对事务的<code>持久性</code>要求不是那么强烈的话，可以选择修改一个称为<code>innodb_flush_log_at_trx_commit</code>的系统变量的值，该变量有3个可选的值：</p><ul><li> <code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志，这个任务是交给后台线程做的。<br>这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将<code>redo</code>日志刷新到磁盘，那么该事务对页面的修改会丢失。 </li><li> <code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘，可以保证事务的<code>持久性</code>。<code>1</code>也是<code>innodb_flush_log_at_trx_commit</code>的默认值。 </li><li> <code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。<br>这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了。 </li></ul><h1 id="八，崩溃恢复"><a href="#八，崩溃恢复" class="headerlink" title="八，崩溃恢复"></a>八，崩溃恢复</h1><p>在服务器不挂的情况下，<code>redo</code>日志不仅没用，反而让性能变得更差。但是万一数据库挂了，我们就可以在重启时根据<code>redo</code>日志中的记录就可以将页面恢复到系统崩溃前的状态。我们接下来大致看一下恢复过程。</p><h2 id="1-确定恢复的起点"><a href="#1-确定恢复的起点" class="headerlink" title="1.确定恢复的起点"></a>1.确定恢复的起点</h2><p><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖，也就是说这些<code>redo</code>日志对应的脏页都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。对于<code>checkpoint_lsn</code>之后的<code>redo</code>日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从<code>checkpoint_lsn</code>开始读取<code>redo</code>日志来恢复页面。</p><p>当然，<code>redo</code>日志文件组的第一个文件的管理信息中有两个block都存储了<code>checkpoint_lsn</code>的信息，我们当然是要选取最近发生的那次checkpoint的信息。衡量<code>checkpoint</code>发生时间早晚的信息就是所谓的<code>checkpoint_no</code>，只要把<code>checkpoint1</code>和<code>checkpoint2</code>这两个block中的<code>checkpoint_no</code>值读出来比一下大小，哪个的<code>checkpoint_no</code>值更大，说明哪个block存储的就是最近的一次<code>checkpoint</code>信息。这样我们就能拿到最近发生的<code>checkpoint</code>对应的<code>checkpoint_lsn</code>值以及它在<code>redo</code>日志文件组中的偏移量<code>checkpoint_offset</code>。</p><h2 id="2-确定恢复的终点"><a href="#2-确定恢复的终点" class="headerlink" title="2.确定恢复的终点"></a>2.确定恢复的终点</h2><p><code>redo</code>日志恢复的起点确定了，那终点是哪个呢？这个还得从block的结构说起。在写<code>redo</code>日志的时候都是顺序写的，写满了一个block之后会再往下一个block中写。</p><p>普通block的<code>log block header</code>部分有一个称之为<code>LOG_BLOCK_HDR_DATA_LEN</code>的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为<code>512</code>。如果该属性的值不为<code>512</code>，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。</p><h2 id="3-怎么恢复"><a href="#3-怎么恢复" class="headerlink" title="3.怎么恢复"></a>3.怎么恢复</h2><p>确定了需要扫描哪些<code>redo</code>日志进行崩溃恢复之后，接下来就是怎么进行恢复了。假设现在的<code>redo</code>日志文件中有5条<code>redo</code>日志，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864845397-5c752767-6330-4db0-a29f-7ca86577f27f.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u52381dfe&margin=%5Bobject%20Object%5D&name=35.png&originHeight=484&originWidth=1588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52404&status=done&style=none&taskId=ua678c768-0959-4cae-92d2-3d95bf42085&title=" alt="35.png"></p><p>由于<code>redo 0</code>在<code>checkpoint_lsn</code>后前边，恢复时可以不管它。现在可以按照<code>redo</code>日志的顺序依次扫描<code>checkpoint_lsn</code>之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。这样没什么问题，不过<code>InnoDB</code>还是想了一些办法加快这个恢复的过程：</p><ul><li> 使用哈希表<br>根据<code>redo</code>日志的<code>space ID</code>和<code>page number</code>属性计算出散列值，把<code>space ID</code>和<code>page number</code>相同的<code>redo</code>日志放到哈希表的同一个槽里，如果有多个<code>space ID</code>和<code>page number</code>都相同的<code>redo</code>日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864854531-b5649b49-9232-483a-97d5-f3e93563f711.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u38ebf05a&margin=%5Bobject%20Object%5D&name=36.png&originHeight=878&originWidth=1506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=487842&status=done&style=none&taskId=u290553e7-6d79-4869-adac-78da4fffc0b&title=" alt="36.png"><br>之后就可以遍历哈希表，因为对同一个页面进行修改的<code>redo</code>日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO），这样可以加快恢复速度。另外需要注意一点的是，同一个页面的<code>redo</code>日志是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复，如果不按照生成时间顺序进行排序的话，那么可能出现错误。比如原先的修改操作是先插入一条记录，再删除该条记录，如果恢复时不按照这个顺序来，就可能变成先删除一条记录，再插入一条记录，这显然是错误的。 </li><li> 跳过已经刷新到磁盘的页面<br><code>checkpoint_lsn</code>之前的<code>redo</code>日志对应的脏页确定都已经刷到磁盘了，但是<code>checkpoint_lsn</code>之后的<code>redo</code>日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次<code>checkpoint</code>后，可能后台线程又不断的从<code>LRU链表</code>和<code>flush链表</code>中将一些脏页刷出<code>Buffer Pool</code>。这些在<code>checkpoint_lsn</code>之后的<code>redo</code>日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据<code>redo</code>日志的内容修改该页面了。<br>那在恢复时怎么知道某个<code>redo</code>日志对应的脏页是否在崩溃发生时已经刷新到磁盘了呢？这还得从页面的结构说起，每个页面都有一个称之为<code>File Header</code>的部分，在<code>File Header</code>里有一个称之为<code>FIL_PAGE_LSN</code>的属性，该属性记载了最近一次修改页面时对应的<code>lsn</code>值（其实就是页面控制块中的<code>newest_modification</code>值）。如果在做了某次<code>checkpoint</code>之后有脏页被刷新到磁盘中，那么该页对应的<code>FIL_PAGE_LSN</code>代表的<code>lsn</code>值肯定大于<code>checkpoint_lsn</code>的值，凡是符合这种情况的页面就不需要重复执行lsn值小于<code>FIL_PAGE_LSN</code>的redo日志了，所以更进一步提升了崩溃恢复的速度。 </li></ul><h1 id="九，LOG-BLOCK-HDR-NO是如何计算的"><a href="#九，LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="九，LOG_BLOCK_HDR_NO是如何计算的"></a>九，LOG_BLOCK_HDR_NO是如何计算的</h1><p>对于实际存储<code>redo</code>日志的普通的<code>log block</code>来说，在<code>log block header</code>处有一个称之为<code>LOG_BLOCK_HDR_NO</code>的属性，我们说这个属性代表一个唯一的标号。这个属性是初次使用该block时分配的，跟当时的系统<code>lsn</code>值有关。使用下边的公式计算该block的<code>LOG_BLOCK_HDR_NO</code>值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864865474-9b8bdc06-3e44-4a51-93aa-be1366ae7520.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf2818478&margin=%5Bobject%20Object%5D&name=37.png&originHeight=420&originWidth=2580&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51118&status=done&style=none&taskId=u29b43df7-e13a-4c7e-8b6f-d4c848c7347&title=" alt="37.png"></p><p>从图中可以看出，<code>0x3FFFFFFFUL</code>对应的二进制数的前2位为0，后30位的值都为<code>1</code>。一个二进制位与0做与运算（<code>&amp;</code>）的结果肯定是0，一个二进制位与1做与运算（<code>&amp;</code>）的结果就是原值。让一个数和<code>0x3FFFFFFFUL</code>做与运算的意思就是要将该值的前2个比特位的值置为0，这样该值就肯定小于或等于<code>0x3FFFFFFFUL</code>了。这也就说明了，不论lsn多大，<code>((lsn / 512) &amp; 0x3FFFFFFFUL)</code>的值肯定在<code>0``~~0x3FFFFFFFUL~~</code><del>之间，再加1的话肯定在</del><code>~~1~~``0x40000000UL</code>之间。而<code>0x40000000UL</code>这个值就代表着<code>1GB</code>。也就是说系统最多能产生不重复的<code>LOG_BLOCK_HDR_NO</code>值只有<code>1GB</code>个。InnoDB规定<code>redo</code>日志文件组中包含的所有文件大小总和不得超过512GB，一个block大小是512字节，也就是说redo日志文件组中包含的block块最多为1GB个，所以有1GB个不重复的编号值也就够用了。</p><p>另外，<code>LOG_BLOCK_HDR_NO</code>值的第一个比特位比较特殊，称之为<code>flush bit</code>，如果该值为1，代表着本block是在某次将<code>log buffer</code>中的block刷新到磁盘的操作中的第一个被刷入的block。</p><h1 id="十，double-write"><a href="#十，double-write" class="headerlink" title="十，double write"></a>十，double write</h1><p><strong>​</strong></p><h2 id="1-脏页刷盘风险"><a href="#1-脏页刷盘风险" class="headerlink" title="1.脏页刷盘风险"></a>1.脏页刷盘风险</h2><p>​</p><p>关于IO的最小单位：</p><ol><li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li><li>文件系统IO的最小单位是4K（也有1K的）</li><li>磁盘IO的最小单位是512字节</li></ol><p>因此，存在IO写入导致page损坏的风险：<br>​</p><p>​<img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641862404239-30566dce-d370-47b7-9867-76a9d4cb6daf.png#clientId=u49cb4bc4-7246-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc6fbd209&margin=%5Bobject%20Object%5D&originHeight=386&originWidth=472&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u24e449ed-e0a1-48ab-9270-c44159416df&title="><br>​</p><h2 id="2-doublewrite：两次写"><a href="#2-doublewrite：两次写" class="headerlink" title="2.doublewrite：两次写"></a>2.doublewrite：两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。<br>​</p><h3 id="2-1-Double-write解决了什么问题"><a href="#2-1-Double-write解决了什么问题" class="headerlink" title="2.1 Double write解决了什么问题"></a>2.1 Double write解决了什么问题</h3><p>​</p><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。<br>​</p><h3 id="2-2使用情景"><a href="#2-2使用情景" class="headerlink" title="2.2使用情景"></a>2.2使用情景</h3><p>​</p><p>当数据库正在从内存想磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。<br>​</p><h3 id="2-3-double-write工作流程"><a href="#2-3-double-write工作流程" class="headerlink" title="2.3 double write工作流程"></a>2.3 double write工作流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641862404231-823dd86f-17a6-4811-986d-18bb15f62fd0.png#clientId=u49cb4bc4-7246-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2f315b90&margin=%5Bobject%20Object%5D&originHeight=460&originWidth=650&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3b87208b-8e06-405e-b283-ee617200e0d&title="></p><p>doublewrite由两部分组成，一部分为内存中的<code>doublewrite buffer</code>，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p><ol><li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的<code>doublewrite buffer</code>中；</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li><li>待第二步完成后，再将<code>doublewrite buffer</code>中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li></ol><h3 id="2-4-doublewrite的崩溃恢复"><a href="#2-4-doublewrite的崩溃恢复" class="headerlink" title="2.4 doublewrite的崩溃恢复"></a>2.4 doublewrite的崩溃恢复</h3><p>​</p><p>如果操作系统在将页写入磁盘的过程中发生崩溃，在恢复过程中，<code>innodb</code>存储引擎可以从共享表空间的<code>doublewrite</code>中找到该页的一个最近的副本，将其复制到表空间文件，再应用<code>redo log</code>，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</p><blockquote><p><em>Q：为什么</em><code>_log write_</code><em>不需要</em><code>_doublewrite_</code><em>的支持？</em><br><em>A：因为</em><code>_redolog_</code><em>写入的单位就是512字节，也就是磁盘IO的最小单位，所以无所谓数据损坏。</em></p></blockquote><p>​</p><h2 id="3-doublewrite的副作用"><a href="#3-doublewrite的副作用" class="headerlink" title="3.doublewrite的副作用"></a>3.doublewrite的副作用</h2><h3 id="3-1-double-write带来的写负载"><a href="#3-1-double-write带来的写负载" class="headerlink" title="3.1 double write带来的写负载"></a>3.1 double write带来的写负载</h3><ol><li>double write是一个buffer, 但其实它是开在物理文件上的一个buffer, 其实也就是file, 所以它会导致系统有更多的fsync操作, 而硬盘的fsync性能是很慢的, 所以它会降低mysql的整体性能。</li><li>但是，doublewrite buffer写入磁盘共享表空间这个过程是连续存储，是顺序写，性能非常高，(约占写的10%)，牺牲一点写性能来保证数据页的完整还是很有必要的。<h3 id="3-2-监控double-write工作负载"><a href="#3-2-监控double-write工作负载" class="headerlink" title="3.2 监控double write工作负载"></a>3.2 监控double write工作负载</h3></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">&#x27;%dblwr%&#x27;</span>;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Innodb_dblwr_pages_written | <span class="number">7</span>     |</span><br><span class="line">| Innodb_dblwr_writes        | <span class="number">3</span>     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>关注点：Innodb_dblwr_pages_written / Innodb_dblwr_writes<br>​</p><p>开启doublewrite后，每次脏页刷新必须要先写doublewrite，而doublewrite存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。<br>​</p><p>而根据以上系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，大概在3左右，远远还没到64(如果约等于64，那么说明系统的写压力非常大，有大量的脏页要往磁盘上写)，所以从这个角度也可以看出，系统写入压力并不高。<br>​</p><h3 id="3-3-关闭double-write适合的场景"><a href="#3-3-关闭double-write适合的场景" class="headerlink" title="3.3 关闭double write适合的场景"></a>3.3 关闭double write适合的场景</h3><ol><li>海量DML</li><li>不惧怕数据损坏和丢失</li><li>系统写负载成为主要负载<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;%double%&#x27;</span>;</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| Variable_name      | Value |</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| innodb_doublewrite | ON    |</span><br><span class="line">+--------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br></pre></td></tr></table></figure>作为InnoDB的一个关键特性，doublewrite功能默认是开启的，但是在上述特殊的一些场景也可以视情况关闭，来提高数据库写性能。静态参数，配置文件修改，重启数据库。<h3 id="3-4-为什么没有把double-write里面的数据写到data-page里面呢？"><a href="#3-4-为什么没有把double-write里面的数据写到data-page里面呢？" class="headerlink" title="3.4 为什么没有把double write里面的数据写到data page里面呢？"></a>3.4 为什么没有把double write里面的数据写到data page里面呢？</h3></li></ol><ol><li>double write里面的数据是连续的，如果直接写到data page里面，而data page的页又是离散的，写入会很慢。</li><li>double write里面的数据没有办法被及时的覆盖掉，导致double write的压力很大；短时间内可能会出现double write溢出的情况。<h1 id="十一，总结"><a href="#十一，总结" class="headerlink" title="十一，总结"></a>十一，总结</h1></li></ol><p>redo日志记录了事务执行过程中都修改了哪些内容。</p><p>事务提交时只将执行过程中产生的redo日志刷新到磁盘，而不是将所有修改过的页面都刷新到磁盘。这样做有两个好处：</p><ol><li>redo日志占用的空间非常小</li><li>redo日志是顺序写入磁盘的</li></ol><p>一条redo日志由下面几部分组成。</p><ol><li>type：这条redo日志的类型</li><li>space ID:表空间ID</li><li>page number :页号</li><li>data：这条redo日志的具体内容</li></ol><p>redo日志的类型有简单和复杂之分。简单类型的redo日志是纯粹的物理日志，复杂类型的redo日志兼有物理日志和逻辑日志的特性。</p><p>一个MTR可以包含一组redo日志。在进行崩溃恢复时，这一组redo日志作为一个不可分割的整体来处理。</p><p>redo日志存放在大小为512字节的block中。每一个block被分为3部分：</p><ol><li>log block header</li><li>log block body</li><li>log block trailer</li></ol><p>redo日志缓冲区是一片连续的内存空间，由若干个block组成；可以通过启动选项innodb_log_buffer_size 来调整他的大小。</p><p>redo日志文件组由若干个日志文件组成，这些redo日志文件是被循环使用的。redo日志文件组中每个文件的大小都一样，格式也一样，都是由两部分组成的：</p><ol><li>前2048字节用来存储一些管理信息</li><li>从第2048字节往后的字节用来存储log buffer中的block镜像</li></ol><p>lsn指已经写入的redo日志量，flushed_to_disk_lsn指刷新到磁盘中的redo日志量，flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的lsn值进行排序。被多次更新的页面不会重复插入到flush链表，但是会更新newest_modification属性的值。checkpoint_lsn表示当前系统中可以被覆盖的redo日志总量是多少。</p><p>redo日志占用的磁盘空间在他对应的脏页已经被刷新到磁盘后即可被覆盖。执行一次checkpoint的意思就是增加checkpoint_lsn的值，然后把相关信息放到日志文件的管理信息中。</p><p>innodb_flush_log_at_trx_commit系统变量控制着在事务提交时是否将该事务运行过程中产生的redo刷新到磁盘。</p><p>在崩溃恢复过程中，从redo日志文件组第一个文件的管理信息中取出最近发生的那次checkpoint信息，然后从checkpoint_lsn在日志文件组中对应的偏移量开始，一直扫描日志文件中的block，直到某个block的LOG_BLOCK_HDR_DATA_LEN值不等于512为止。再恢复过程中，使用hash表可加快恢复过程，并且会跳过已经刷新到磁盘的页面。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十三]事务</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%89%5D%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%89%5D%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一，事务的起源"><a href="#一，事务的起源" class="headerlink" title="一，事务的起源"></a>一，事务的起源</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h3><p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。设计数据库的大叔们把这种要么全做，要么全不做的规则称之为<code>原子性</code>。但是在现实世界中的一个不可分割的操作却可能对应着数据库世界若干条不同的操作，数据库中的一条操作也可能被分解成若干个步骤（比如先修改缓存页，之后再刷新到磁盘等），最要命的是在任何一个可能的时间都可能发生意想不到的错误（可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的）而使操作执行不下去。为了保证在数据库世界中某些操作的原子性，MySQL需要保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子。</p><h3 id="2-隔离性（Isolation）"><a href="#2-隔离性（Isolation）" class="headerlink" title="2.隔离性（Isolation）"></a>2.隔离性（Isolation）</h3><p>现实世界中的两次状态转换应该是互不影响的，所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以<code>原子性</code>的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为<code>隔离性</code>。这时MySQL就需要采取一些措施来让访问相同数据的不同状态转换对应的数据库操作的执行顺序有一定规律。</p><h3 id="3-一致性（Consistency）"><a href="#3-一致性（Consistency）" class="headerlink" title="3.一致性（Consistency）"></a>3.一致性（Consistency）</h3><p>我们生活的这个世界存在着形形色色的约束，比如身份证号不能重复，性别只能是男或者女，高考的分数只能在0～750之间，人民币面值最大只能是100（现在是2019年），红绿灯只有3种颜色，房价不能为负的。 只有符合这些约束的数据才是有效的。数据库世界只是现实世界的一个映射，现实世界中存在的约束当然也要在数据库世界中有所体现。如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合<code>一致性</code>的。</p><p>如何保证数据库中数据的一致性（就是符合所有现实世界的约束）呢？这其实靠两方面的努力：</p><ul><li><p> 数据库本身能为我们保证一部分一致性需求（就是数据库自身可以保证一部分现实世界的约束永远有效）。<br>我们知道<code>MySQL</code>数据库可以为表建立主键、唯一索引、外键、声明某个列为<code>NOT NULL</code>来拒绝<code>NULL</code>值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么<code>MySQL</code>就会报错并且拒绝插入。除了这些我们已经非常熟悉的保证一致性的功能，<code>MySQL</code>还支持<code>CHECK</code>语法来自定义约束，比如这样：<br>上述例子中的<code>CHECK</code>语句本意是想规定<code>balance</code>列不能存储小于0的数字，对应的现实世界的意思就是银行账户余额不能小于0。但是很遗憾，MySQL仅仅支持CHECK语法，但实际上并没有一点卵用，也就是说即使我们使用上述带有<code>CHECK</code>子句的建表语句来创建<code>account</code>表，那么在后续插入或更新记录时，<code>MySQL</code>并不会去检查<code>CHECK</code>子句中的约束是否成立。<br>虽然<code>CHECK</code>子句对一致性检查没什么卵用，但是我们还是可以通过定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    name VARCHAR(100) COMMENT &#x27;客户名称&#x27;,</span><br><span class="line">    balance INT COMMENT &#x27;余额&#x27;,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    CHECK (balance &gt;= 0) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>其它的一些数据库，比如SQL Server或者Oracle支持的CHECK语法是有实实在在的作用的，每次进行插入或更新记录之前都会检查一下数据是否符合CHECK子句中指定的约束条件是否成立，如果不成立的话就会拒绝插入或更新。</p></blockquote></li><li><p> 更多的一致性需求需要靠写业务代码的程序员自己保证。<br>为建立现实世界和数据库世界的对应关系，理论上应该把现实世界中的所有约束都反应到数据库世界中，但是在更改数据库数据时进行一致性检查是一个耗费性能的工作，比方说我们为<code>account</code>表建立了一个触发器，每当插入或者更新记录时都会校验一下<code>balance</code>列的值是不是大于0，这就会影响到插入或更新的速度。仅仅是校验一行记录符不符合一致性需求倒也不是什么大问题，有的一致性需求简直变态，比方说银行会建立一张代表账单的表，里边儿记录了每个账户的每笔交易，每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。如果在数据库层面实现这个一致性需求的话，每次发生交易时，都需要将所有的收入加起来减去所有的支出，再将所有的账户余额加起来，看看两个值相不相等。如果账单表里有几亿条记录，光是这个校验的过程可能就要跑好几个小时，这样的性能代价是完全承受不起的。<br>现实生活中复杂的一致性需求比比皆是，而由于性能问题把一致性需求交给数据库去解决这是不现实的，所以这个锅就甩给了业务端程序员。比方说我们的<code>account</code>表，我们也可以不建立触发器，只要编写业务的程序员在自己的业务代码里判断一下，当某个操作会将<code>balance</code>列的值更新为小于0的值时，就不执行该操作就好了！ </p></li></ul><p><code>原子性</code>和<code>隔离性</code>都会对<code>一致性</code>产生影响，比如我们现实世界中转账操作完成后，有一个<code>一致性</code>需求就是参与转账的账户的总的余额是不变的。如果数据库不遵循<code>原子性</code>要求，也就是转了一半就不转了，那最后就是不符合一致性需求的；类似的，如果数据库不遵循<code>隔离性</code>要求，也就是说可能不符合<code>一致性</code>需求了。所以说，数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。那满足<code>原子性</code>和<code>隔离性</code>的操作一定就满足<code>一致性</code>么？那倒也不一定，那不满足<code>原子性</code>和<code>隔离性</code>的操作就一定不满足<code>一致性</code>么？这也不一定，只要最后的结果符合所有现实世界中的约束，那么就是符合<code>一致性</code>的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4.持久性（Durability）"></a>4.持久性（Durability）</h3><p>当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则被MySQL称为<code>持久性</code>。当把现实世界的状态转换映射到数据库世界时，<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉。</p><h2 id="二，事务的概念"><a href="#二，事务的概念" class="headerlink" title="二，事务的概念"></a>二，事务的概念</h2><p>我们把<code>原子性</code>（<code>Atomicity</code>）、<code>隔离性</code>（<code>Isolation</code>）、<code>一致性</code>（<code>Consistency</code>）和<code>持久性</code>（<code>Durability</code>）这四个词对应的英文单词首字母提取出来就是<code>A</code>、<code>I</code>、<code>C</code>、<code>D</code>，稍微变换一下顺序可以组成一个完整的英文单词：<code>ACID</code>。MySQL叔为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称之为一个<code>事务</code>（英文名是：<code>transaction</code>）。</p><p>我们现在知道<code>事务</code>是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把<code>事务</code>大致上划分成了这么几个状态：</p><ul><li> 活动的（active）<br>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。 </li><li> 部分提交的（partially committed）<br>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在<code>部分提交的</code>状态。 </li><li> 失败的（failed）<br>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。 </li><li> 中止的（aborted）<br>如果事务执行了半截而变为<code>失败的</code>状态，那么就需要把已经修改的数据调整为未修改之前的数据，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。 </li><li> 提交的（committed）<br>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了<code>提交的</code>状态。 </li></ul><p>随着事务对应的数据库操作执行到不同阶段，事务的状态也在不断变化，一个基本的状态转换图如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640695115396-9200b034-6e54-4ad3-8d79-7811c0764acd.png#clientId=ufeb1ac38-ae67-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud43f14a4&margin=%5Bobject%20Object%5D&name=%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B.png&originHeight=894&originWidth=1664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=510408&status=done&style=none&taskId=u8bfc0302-fd35-429e-ae45-62b1c3a155d&title=" alt="事务流程.png"></p><p>从图中大家也可以看出了，只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p><h2 id="三，MySQL中事务的语法"><a href="#三，MySQL中事务的语法" class="headerlink" title="三，MySQL中事务的语法"></a>三，MySQL中事务的语法</h2><p>我们说<code>事务</code>的本质其实只是一系列数据库操作，只不过这些数据库操作符合<code>ACID</code>特性而已，那么<code>MySQL</code>中如何将某些操作放到一个事务里去执行的呢？</p><h3 id="1-开启事务"><a href="#1-开启事务" class="headerlink" title="1.开启事务"></a>1.开启事务</h3><p>我们可以使用下边两种语句之一来开启一个事务：</p><ul><li><p> <code>BEGIN [WORK];</code><br><code>BEGIN</code>语句代表开启一个事务，后边的单词<code>WORK</code>可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure></li><li><p><code>START TRANSACTION;</code><br><code>START TRANSACTION</code>语句和<code>BEGIN</code>语句有着相同的功效，都标志着开启一个事务，比如这样：<br>不过比<code>BEGIN</code>语句牛逼一点儿的是，可以在<code>START TRANSACTION</code>语句后边跟随几个<code>修饰符</code>，就是它们几个： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure><ul><li><p> <code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。  </p><blockquote><p>其实只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TMEPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。</p></blockquote></li><li><p> <code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。 </p></li><li><p> <code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。 </p></li></ul></li></ul><p>比如我们想开启一个只读事务的话，直接把<code>READ ONLY</code>这个修饰符加在<code>START TRANSACTION</code>语句后边就好，比如这样： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY;</span><br></pre></td></tr></table></figure><p>如果我们想在<code>START TRANSACTION</code>后边跟随多个<code>修饰符</code>的话，可以使用逗号将<code>修饰符</code>分开，比如开启一个只读事务和一致性读，就可以这样写： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;</span><br></pre></td></tr></table></figure><p>或者开启一个读写事务和一致性读，就可以这样写： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT</span><br></pre></td></tr></table></figure><p>不过这里需要注意的一点是，<code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为<code>只读</code>的也设置为<code>读写</code>的，所以我们不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式。 </p><h3 id="2-提交事务"><a href="#2-提交事务" class="headerlink" title="2.提交事务"></a>2.提交事务</h3><p>开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT [WORK]</span><br></pre></td></tr></table></figure><p><code>COMMIT</code>语句就代表提交一个事务，后边的<code>WORK</code>可有可无。转账举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="3-手动中止事务"><a href="#3-手动中止事务" class="headerlink" title="3.手动中止事务"></a>3.手动中止事务</h3><p>如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK]</span><br></pre></td></tr></table></figure><p><code>ROLLBACK</code>语句就代表中止并回滚一个事务，后边的<code>WORK</code>可有可无类似的。转账举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里需要强调一下，<code>ROLLBACK</code>语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</p><blockquote><p>我们这里所说的开启、提交、中止事务的语法只是针对使用黑框框时通过mysql客户端程序与服务器进行交互时控制事务的语法，如果大家使用的是别的客户端程序，比如JDBC之类的，那需要参考相应的文档来看看如何控制事务。</p></blockquote><h3 id="4-支持事务的存储引擎"><a href="#4-支持事务的存储引擎" class="headerlink" title="4.支持事务的存储引擎"></a>4.支持事务的存储引擎</h3><p><code>MySQL</code>中并不是所有存储引擎都支持事务的功能，目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持（NDB存储引擎不是我们的重点），如果某个事务中包含了修改使用不支持事务的存储引擎的表，那么对该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。比方说我们有两个表，<code>tbl1</code>使用支持事务的存储引擎<code>InnoDB</code>，<code>tbl2</code>使用不支持事务的存储引擎<code>MyISAM</code>，它们的建表语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl1 (</span><br><span class="line">    i int</span><br><span class="line">) engine=InnoDB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl2 (</span><br><span class="line">    i int</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>我们看看先开启一个事务，写一条插入语句后再回滚该事务，<code>tbl1</code>和<code>tbl2</code>的表现有什么不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl1 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，对于使用支持事务的存储引擎的<code>tbl1</code>表来说，我们在插入一条记录再回滚后，<code>tbl1</code>就恢复到没有插入记录时的状态了。再看看<code>tbl2</code>表的表现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl2 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">+------+</span><br><span class="line">| i    |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，虽然我们使用了<code>ROLLBACK</code>语句来回滚事务，但是插入的那条记录还是留在了<code>tbl2</code>表中。</p><h3 id="5-自动提交"><a href="#5-自动提交" class="headerlink" title="5.自动提交"></a>5.自动提交</h3><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>可以看到它的默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。假如我们在转账时不以<code>START TRANSACTION</code>或者<code>BEGIN</code>语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下边两种方法之一：</p><ul><li> 显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。<br>这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。 </li><li> 把系统变量<code>autocommit</code>的值设置为<code>OFF</code>，就像这样：<br>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-隐式提交"><a href="#6-隐式提交" class="headerlink" title="6.隐式提交"></a>6.隐式提交</h3><p>当我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为<code>OFF</code>时，事务就不会进行<code>自动提交</code>，但是如果我们输入了某些语句之后就会<code>悄悄的</code>提交掉，就像我们输入了<code>COMMIT</code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为<code>隐式提交</code>，这些会导致事务隐式提交的语句包括：</p><ul><li><p> 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：<code>DDL</code>）。<br>所谓的数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等等这些东西。当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p> 隐式使用或修改<code>mysql</code>数据库中的表<br>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。 </p></li><li><p> 事务控制或关于锁定的语句<br>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：<br>或者当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会隐式的提交前边语句所属的事务。<br>或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p> 加载数据的语句<br>比如我们使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。 </p></li><li><p> 关于<code>MySQL</code>复制的一些语句<br>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时也会隐式的提交前边语句所属的事务。 </p></li><li><p> 其它的一些语句<br>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、 <code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前边语句所属的事务。 </p></li></ul><h3 id="7-保存点"><a href="#7-保存点" class="headerlink" title="7.保存点"></a>7.保存点</h3><p>如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用<code>ROLLBACK</code>语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。所以MySQL提出了一个<code>保存点</code>（英文：<code>savepoint</code>）的概念，就是在事务对应的数据库语句中打几个点，我们在调用<code>ROLLBACK</code>语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词<code>WORK</code>和<code>SAVEPOINT</code>是可有可无的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br></pre></td></tr></table></figure><p>不过如果<code>ROLLBACK</code>语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</p><p>如果我们想删除某个保存点，可以使用这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><p>下边还是以转账的例子展示一下<code>保存点</code>的用法，在执行完扣除第一个账户的钱<code>10</code>元的语句之后打一个<code>保存点</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SAVEPOINT s1;    # 一个保存点</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2; # 更新错了</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK TO s1;  # 回滚到保存点s1处</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十二]InnoDB之BufferPool</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%BA%8C%5DInnoDB%E4%B9%8BBufferPool/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%BA%8C%5DInnoDB%E4%B9%8BBufferPool/</url>
      
        <content type="html"><![CDATA[<h1 id="一，缓存的重要性"><a href="#一，缓存的重要性" class="headerlink" title="一，缓存的重要性"></a>一，缓存的重要性</h1><p>对于使用<code>InnoDB</code>作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以<code>页</code>的形式存放在<code>表空间</code>中的，而所谓的<code>表空间</code>只不过是<code>InnoDB</code>对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是磁盘太慢了，所以<code>InnoDB</code>存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其<code>缓存</code>起来，这样将来有请求再次访问该页面时，就可以省去磁盘<code>IO</code>的开销了。</p><h1 id="二，InnoDB的Buffer-Pool"><a href="#二，InnoDB的Buffer-Pool" class="headerlink" title="二，InnoDB的Buffer Pool"></a>二，InnoDB的Buffer Pool</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640692719739-2a4a2c42-463b-4bb9-9628-5f513cf6af7a.jpeg#clientId=ubc6de47a-2285-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf96ce3e6&margin=%5Bobject%20Object%5D&name=BufferPool.jpg&originHeight=3134&originWidth=2791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=670441&status=done&style=none&taskId=ua4826271-d9b1-4095-8d82-d0212d81af6&title=" alt="BufferPool.jpg"></p><h3 id="1-啥是个Buffer-Pool"><a href="#1-啥是个Buffer-Pool" class="headerlink" title="1.啥是个Buffer Pool"></a>1.啥是个Buffer Pool</h3><p>为了缓存磁盘中的页，在<code>MySQL</code>服务器启动的时候就向操作系统申请了一片连续的内存，叫做<code>Buffer Pool</code>（中文名是<code>缓冲池</code>）。那它有多大呢？这个其实看我们机器的配置，默认情况下<code>Buffer Pool</code>只有<code>128M</code>大小，但是可以在启动服务器的时候配置<code>innodb_buffer_pool_size</code>参数的值，它表示<code>Buffer Pool</code>的大小，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure><p>其中，<code>268435456</code>的单位是字节，也就是我指定<code>Buffer Pool</code>的大小为<code>256M</code>。需要注意的是，<code>Buffer Pool</code>也不能太小，最小值为<code>5M</code>(当小于该值时会自动设置成<code>5M</code>)。</p><h3 id="2-Buffer-Pool内部组成"><a href="#2-Buffer-Pool内部组成" class="headerlink" title="2.Buffer Pool内部组成"></a>2.Buffer Pool内部组成</h3><p><code>Buffer Pool</code>中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是<code>16KB</code>。为了更好的管理这些在<code>Buffer Pool</code>中的缓存页，<code>InnoDB</code>为每一个缓存页都创建了一些所谓的<code>控制信息</code>，这些控制信息包括该页所属的表空间编号、页号、缓存页在<code>Buffer Pool</code>中的地址、链表节点信息、一些锁信息以及<code>LSN</code>信息（锁和<code>LSN</code>先忽略），当然还有一些别的控制信息，暂时省略。</p><p>每个缓存页对应的控制信息占用的内存大小是相同的，我们就把每个页对应的控制信息占用的一块内存称为一个<code>控制块</code>，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边。</p><p>每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，这个用不到的那点儿内存空间就被称为<code>碎片</code>。当然，如果把<code>Buffer Pool</code>的大小设置的刚刚好的话，也可能不会产生<code>碎片</code>。</p><blockquote><p>每个控制块大约占用缓存页大小的5%，在MySQL5.7.21这个版本中，每个控制块占用的大小是808字节。而我们设置的innodb_buffer_pool_size并不包含这部分控制块占用的内存空间大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，这片连续的内存空间一般会比innodb_buffer_pool_size的值大5%左右。</p></blockquote><h3 id="3-free链表的管理"><a href="#3-free链表的管理" class="headerlink" title="3.free链表的管理"></a>3.free链表的管理</h3><p>当我们最初启动<code>MySQL</code>服务器的时候，需要完成对<code>Buffer Pool</code>的初始化过程，就是先向操作系统申请<code>Buffer Pool</code>的内存空间，然后把它划分成若干对控制块和缓存页。但是此时并没有真实的磁盘页被缓存到<code>Buffer Pool</code>中（因为还没有用到），之后随着程序的运行，会不断的有磁盘上的页被缓存到<code>Buffer Pool</code>中。那么问题来了，从磁盘上读取一个页到<code>Buffer Pool</code>中的时候该放到哪个缓存页的位置呢？或者说怎么区分<code>Buffer Pool</code>中哪些缓存页是空闲的，哪些已经被使用了呢？我们最好在某个地方记录一下Buffer Pool中哪些缓存页是可用的，我们可以把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code>（或者说空闲链表）。刚刚完成初始化的<code>Buffer Pool</code>中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到<code>free链表</code>中。</p><p>为了管理好这个<code>free链表</code>，特意为这个链表定义了一个<code>基节点</code>，里边儿包含着链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。这里需要注意的是，链表的基节点占用的内存空间并不包含在为<code>Buffer Pool</code>申请的一大片连续内存空间之内，而是单独申请的一块内存空间。</p><blockquote><p>链表基节点占用的内存空间并不大，在MySQL5.7.21这个版本里，每个基节点只占用40字节大小。后边我们即将介绍许多不同的链表，它们的基节点和free链表的基节点的内存分配方式是一样的，都是单独申请的一块40字节大小的内存空间，并不包含在为Buffer Pool申请的一大片连续内存空间之内。</p></blockquote><p>有了这个<code>free链表</code>之后，每当需要从磁盘中加载一个页到<code>Buffer Pool</code>中时，就从<code>free链表</code>中取一个空闲的缓存页，并且把该缓存页对应的<code>控制块</code>的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的<code>free链表</code>节点从链表中移除，表示该缓存页已经被使用了。</p><h3 id="4-缓存页的哈希处理"><a href="#4-缓存页的哈希处理" class="headerlink" title="4.缓存页的哈希处理"></a>4.缓存页的哈希处理</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？难不成需要依次遍历<code>Buffer Pool</code>中各个缓存页么？</p><p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p><p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p><h3 id="5-flush链表的管理"><a href="#5-flush链表的管理" class="headerlink" title="5.flush链表的管理"></a>5.flush链表的管理</h3><p>如果我们修改了<code>Buffer Pool</code>中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为<code>脏页</code>（英文名：<code>dirty page</code>）。最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，我们一般一般异步同步磁盘。</p><p>但是如果不立即同步到磁盘的话，那之后再同步的时候我们怎么知道<code>Buffer Pool</code>中哪些页是<code>脏页</code>，哪些页从来没被修改过呢？创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<code>flush链表</code>。链表的构造和<code>free链表</code>差不多。</p><h3 id="6-LRU链表的管理"><a href="#6-LRU链表的管理" class="headerlink" title="6.LRU链表的管理"></a>6.LRU链表的管理</h3><h4 id="6-1-缓存不够的窘境"><a href="#6-1-缓存不够的窘境" class="headerlink" title="6.1 缓存不够的窘境"></a>6.1 缓存不够的窘境</h4><p><code>Buffer Pool</code>对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了<code>Buffer Pool</code>大小，也就是<code>free链表</code>中已经没有多余的空闲缓存页咋办？当然是把某些旧的缓存页从<code>Buffer Pool</code>中移除，然后再把新的页放进来， 那么移除哪些缓存页呢？</p><p>我们设立<code>Buffer Pool</code>的初衷就是想减少和磁盘的<code>IO</code>交互，最好每次在访问某个页的时候它都已经被缓存到<code>Buffer Pool</code>中了。假设我们一共访问了<code>n</code>次页，那么被访问的页已经在缓存中的次数除以<code>n</code>就是所谓的<code>缓存命中率</code>，我们的期望就是让<code>缓存命中率</code>越高越好。所以是留下最近很频繁使用的。</p><h4 id="6-2简单的LRU链表"><a href="#6-2简单的LRU链表" class="headerlink" title="6.2简单的LRU链表"></a>6.2简单的LRU链表</h4><p>管理<code>Buffer Pool</code>的缓存页其实也是这个道理，当<code>Buffer Pool</code>中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。怎么知道哪些缓存页最近频繁使用，哪些最近很少使用呢？我们可以再创建一个链表，由于这个链表是为了<code>按照最近最少使用</code>的原则去淘汰缓存页的，所以这个链表可以被称为<code>LRU链表</code>（LRU的英文全称：Least Recently Used）。当我们需要访问某个页时，可以这样处理<code>LRU链表</code>：</p><ul><li>如果该页不在<code>Buffer Pool</code>中，在把该页从磁盘加载到<code>Buffer Pool</code>中的缓存页时，就把该缓存页对应的<code>控制块</code>作为节点塞到链表的头部。</li><li>如果该页已经缓存在<code>Buffer Pool</code>中，则直接把该页对应的<code>控制块</code>移动到<code>LRU链表</code>的头部。</li></ul><p>也就是说：只要我们使用到某个缓存页，就把该缓存页调整到<code>LRU链表</code>的头部，这样<code>LRU链表</code>尾部就是最近最少使用的缓存页了。 所以当<code>Buffer Pool</code>中的空闲缓存页使用完时，到<code>LRU链表</code>的尾部找些缓存页淘汰。</p><h4 id="6-3划分区域的LRU链表"><a href="#6-3划分区域的LRU链表" class="headerlink" title="6.3划分区域的LRU链表"></a>6.3划分区域的LRU链表</h4><p>上边的这个简单的<code>LRU</code>链表有问题，因为存在这两种比较尴尬的情况：</p><ul><li><p>情况一：<code>InnoDB</code>提供了一个服务——<code>预读</code>（英文名：<code>read ahead</code>）。所谓<code>预读</code>，就是<code>InnoDB</code>认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到<code>Buffer Pool</code>中。根据触发方式的不同，<code>预读</code>又可以细分为下边两种： </p><ul><li><p> 线性预读<br><code>InnoDB</code>提供了一个系统变量<code>innodb_read_ahead_threshold</code>，如果顺序访问了某个区（<code>extent</code>）的页面超过这个系统变量的值，就会触发一次<code>异步</code>读取下一个区中全部的页面到<code>Buffer Pool</code>的请求，<code>异步</code>读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常执行。这个<code>innodb_read_ahead_threshold</code>系统变量的值默认是<code>56</code>，我们可以在服务器启动时通过启动参数或者服务器运行过程中直接调整该系统变量的值，不过它是一个全局变量，注意使用<code>SET GLOBAL</code>命令来修改。  </p><blockquote><p>InnoDB是怎么实现异步读取的呢？在Windows或者Linux平台上，可能是直接调用操作系统内核提供的AIO接口，在其它类Unix操作系统中，使用了一种模拟AIO接口的方式来实现异步读取，其实就是让别的线程去读取需要预读的页面。</p></blockquote></li><li><p> 随机预读<br>如果<code>Buffer Pool</code>中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次<code>异步</code>读取本区中所有其的页面到<code>Buffer Pool</code>的请求。<code>InnoDB</code>同时提供了<code>innodb_random_read_ahead</code>系统变量，它的默认值为<code>OFF</code>，也就意味着<code>InnoDB</code>并不会默认开启随机预读的功能，如果我们想开启该功能，可以通过修改启动参数或者直接使用<code>SET GLOBAL</code>命令把该变量的值设置为<code>ON</code>。 </p></li></ul></li></ul><p>如果预读到<code>Buffer Pool</code>中的页成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢？这些预读的页都会放到<code>LRU</code>链表的头部，但是如果此时<code>Buffer Pool</code>的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在<code>LRU链表</code>尾部的一些缓存页会很快的被淘汰掉，也就是所谓的<code>劣币驱逐良币</code>，会大大降低缓存命中率。 </p><ul><li> 情况二：有一些扫描全表的查询语句（比如没有建立合适的索引或者压根儿没有WHERE子句的查询）。<br>扫描全表意味着将访问到该表所在的所有页！假设这个表中记录非常多的话，那该表会占用特别多的<code>页</code>，当需要访问这些页时，会把它们统统都加载到<code>Buffer Pool</code>中，这也就意味着<code>Buffer Pool</code>中的所有页都被换了一次，其他查询语句在执行时又得执行一次从磁盘加载到<code>Buffer Pool</code>的操作。而这种全表扫描的语句执行的频率也不高，每次执行都要把<code>Buffer Pool</code>中的缓存页换一次，这严重的影响到其他查询对 <code>Buffer Pool</code>的使用，从而大大降低了缓存命中率。 </li></ul><p>总结一下上边说的可能降低<code>Buffer Pool</code>的两种情况：</p><ul><li>加载到<code>Buffer Pool</code>中的页不一定被用到。</li><li>如果非常多的使用频率偏低的页被同时加载到<code>Buffer Pool</code>时，可能会把那些使用频率非常高的页从<code>Buffer Pool</code>中淘汰掉。</li></ul><p>因为有这两种情况的存在，所以<code>InnoDB</code>把这个<code>LRU链表</code>按照一定比例分成两截，分别是：</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做<code>热数据</code>，或者称<code>young区域</code>。</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做<code>冷数据</code>，或者称<code>old区域</code>。</li></ul><p>我们是按照某个比例将LRU链表分成两半的，不是某些节点固定是young区域的，某些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。那这个划分成两截的比例怎么确定呢？对于<code>InnoDB</code>存储引擎来说，我们可以通过查看系统变量<code>innodb_old_blocks_pct</code>的值来确定<code>old</code>区域在<code>LRU链表</code>中所占的比例，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;innodb_old_blocks_pct&#x27;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_old_blocks_pct | 37    |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出来，默认情况下，<code>old</code>区域在<code>LRU链表</code>中所占的比例是<code>37%</code>，也就是说<code>old</code>区域大约占<code>LRU链表</code>的<code>3/8</code>。这个比例我们是可以设置的，我们可以在启动时修改<code>innodb_old_blocks_pct</code>参数来控制<code>old</code>区域在<code>LRU链表</code>中所占的比例，比方说这样修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct = 40</span><br></pre></td></tr></table></figure><p>这样我们在启动服务器后，<code>old</code>区域占<code>LRU链表</code>的比例就是<code>40%</code>。当然，如果在服务器运行期间，我们也可以修改这个系统变量的值，不过需要注意的是，这个系统变量属于<code>全局变量</code>，一经修改，会对所有客户端生效，所以我们只能这样修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL innodb_old_blocks_pct = 40;</span><br></pre></td></tr></table></figure><p>有了这个被划分成<code>young</code>和<code>old</code>区域的<code>LRU</code>链表之后，<code>InnoDB</code>就可以针对我们上边提到的两种可能降低缓存命中率的情况进行优化：</p><ul><li> 针对预读的页面可能不进行后续访问情况的优化<br><code>InnoDB</code>规定，当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。这样针对预读到<code>Buffer Pool</code>却不进行后续访问的页面就会被逐渐从<code>old</code>区域逐出，而不会影响<code>young</code>区域中被使用比较频繁的缓存页。 </li><li> 针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化<br>在进行全表扫描时，虽然首次被加载到<code>Buffer Pool</code>的页被放到了<code>old</code>区域的头部，但是后续会被马上访问到，每次进行访问的时候又会把该页放到<code>young</code>区域的头部，这样仍然会把那些使用频率比较高的页面给顶下去。<br>全表扫描有一个特点，那就是它的执行频率非常低，而且在执行全表扫描的过程中，即使某个页面中有很多条记录，也就是去多次访问这个页面所花费的时间也是非常少的。所以我们只需要规定，在对某个处在<code>old</code>区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部。上述的这个间隔时间是由系统变量<code>innodb_old_blocks_time</code>控制的： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;innodb_old_blocks_time&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| innodb_old_blocks_time | 1000  |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这个<code>innodb_old_blocks_time</code>的默认值是<code>1000</code>，它的单位是毫秒，也就意味着对于从磁盘上被加载到<code>LRU</code>链表的<code>old</code>区域的某个页来说，如果第一次和最后一次访问该页面的时间间隔小于<code>1s</code>（很明显在一次全表扫描的过程中，多次访问一个页面中的时间不会超过<code>1s</code>），那么该页是不会被加入到<code>young</code>区域的。 当然，像<code>innodb_old_blocks_pct</code>一样，我们也可以在服务器启动或运行时设置<code>innodb_old_blocks_time</code>的值。 这里需要注意的是，如果我们把<code>innodb_old_blocks_time</code>的值设置为<code>0</code>，那么每次我们访问一个页面时就会把该页面放到<code>young</code>区域的头部。</p><p>综上所述，正是因为将<code>LRU</code>链表划分为<code>young</code>和<code>old</code>区域这两个部分，又添加了<code>innodb_old_blocks_time</code>这个系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读页面以及全表扫描的页面都只会被放到<code>old</code>区域，而不影响<code>young</code>区域中的缓存页。</p><h4 id="6-4-更进一步优化LRU链表"><a href="#6-4-更进一步优化LRU链表" class="headerlink" title="6.4 更进一步优化LRU链表"></a>6.4 更进一步优化LRU链表</h4><p>对于<code>young</code>区域的缓存页来说，我们每次访问一个缓存页就要把它移动到<code>LRU链表</code>的头部，这样开销太大了，毕竟在<code>young</code>区域的缓存页都是热点数据，也就是可能被经常访问的，这样频繁的对<code>LRU链表</code>进行节点移动操作不太好，为了解决这个问题其实我们还可以提出一些优化策略，比如只有被访问的缓存页位于<code>young</code>区域的<code>1/4</code>的后边，才会被移动到<code>LRU链表</code>头部，这样就可以降低调整<code>LRU链表</code>的频率，从而提升性能（也就是说如果某个缓存页对应的节点在<code>young</code>区域的<code>1/4</code>中，再次访问该缓存页时也不会将其移动到<code>LRU</code>链表头部）。</p><blockquote><p>介绍随机预读的时候曾说，如果Buffer Pool中有某个区的13个连续页面就会触发随机预读，这其实是不严谨的（但是MySQL文档就是这么说的），其实还要求这13个页面是非常热的页面，所谓的非常热，指的是这些页面在整个young区域的头1/4处。</p></blockquote><p>还有针对<code>LRU链表</code>的优化措施，核心就是尽量高效的提高 <strong><em>Buffer Pool</em></strong> 的缓存命中率。</p><h3 id="7-其他的一些链表"><a href="#7-其他的一些链表" class="headerlink" title="7.其他的一些链表"></a>7.其他的一些链表</h3><p>为了更好的管理<code>Buffer Pool</code>中的缓存页，除了我们上边提到的一些措施，<code>InnoDB</code>还引进了其他的一些<code>链表</code>，比如<code>unzip LRU链表</code>用于管理解压页，<code>zip clean链表</code>用于管理没有被解压的压缩页，<code>zip free数组</code>中每一个元素都代表一个链表，它们组成所谓的<code>伙伴系统</code>来为压缩页提供内存空间等等，为了更好的管理这个<code>Buffer Pool</code>引入了各种链表或其他数据结构。</p><h3 id="8-刷新脏页到磁盘"><a href="#8-刷新脏页到磁盘" class="headerlink" title="8.刷新脏页到磁盘"></a>8.刷新脏页到磁盘</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：</p><ul><li> 从<code>LRU链表</code>的冷数据中刷新一部分页面到磁盘。<br>后台线程会定时从<code>LRU链表</code>尾部开始扫描一些页面，扫描的页面数量可以通过系统变量<code>innodb_lru_scan_depth</code>来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为<code>BUF_FLUSH_LRU</code>。 </li><li> 从<code>flush链表</code>中刷新一部分页面到磁盘。<br>后台线程也会定时从<code>flush链表</code>中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为<code>BUF_FLUSH_LIST</code>。 </li></ul><p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到<code>Buffer Pool</code>时没有可用的缓存页，这时就会尝试看看<code>LRU链表</code>尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将<code>LRU链表</code>尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为<code>BUF_FLUSH_SINGLE_PAGE</code>。</p><p>当然，有时候系统特别繁忙时，也可能出现用户线程批量的从<code>flush链表</code>中刷新脏页的情况，很显然在处理用户请求过程中去刷新脏页是一种严重降低处理速度的行为，这属于一种迫不得已的情况。</p><h3 id="9-多个Buffer-Pool实例"><a href="#9-多个Buffer-Pool实例" class="headerlink" title="9.多个Buffer Pool实例"></a>9.多个Buffer Pool实例</h3><p><code>Buffer Pool</code>本质是<code>InnoDB</code>向操作系统申请的一块连续的内存空间，在多线程环境下，访问<code>Buffer Pool</code>中的各种链表都需要加锁处理，在<code>Buffer Pool</code>特别大而且多线程并发访问特别高的情况下，单一的<code>Buffer Pool</code>可能会影响请求的处理速度。所以在<code>Buffer Pool</code>特别大的时候，我们可以把它们拆分成若干个小的<code>Buffer Pool</code>，每个<code>Buffer Pool</code>都称为一个<code>实例</code>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表，所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。我们可以在服务器启动的时候通过设置<code>innodb_buffer_pool_instances</code>的值来修改<code>Buffer Pool</code>实例的个数，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure><p>这样就表明我们要创建2个<code>Buffer Pool</code>实例。</p><p>每个<code>Buffer Pool</code>实例实际占多少内存空间呢？其实使用这个公式算出来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><p>也就是总共的大小除以实例的个数，结果就是每个<code>Buffer Pool</code>实例占用的大小。</p><p>不过也不是说<code>Buffer Pool</code>实例创建的越多越好，分别管理各个<code>Buffer Pool</code>也是需要性能开销的，<code>InnoDB</code>规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。而MySQL希望在<code>Buffer Pool</code>大于或等于1G的时候设置多个<code>Buffer Pool</code>实例。</p><h3 id="10-innodb-buffer-pool-chunk-size"><a href="#10-innodb-buffer-pool-chunk-size" class="headerlink" title="10.innodb_buffer_pool_chunk_size"></a>10.innodb_buffer_pool_chunk_size</h3><p>在<code>MySQL 5.7.5</code>之前，<code>Buffer Pool</code>的大小只能在服务器启动时通过配置<code>innodb_buffer_pool_size</code>启动参数来调整大小，在服务器运行过程中是不允许调整该值的。不过<code>MySQL</code>在<code>5.7.5</code>以及之后的版本中支持了在服务器运行过程中调整<code>Buffer Pool</code>大小的功能，但是有一个问题，就是每次当我们要重新调整<code>Buffer Pool</code>大小时，都需要重新向操作系统申请一块连续的内存空间，然后将旧的<code>Buffer Pool</code>中的内容复制到这一块新空间，这是极其耗时的。所以<code>MySQL</code>决定不再一次性为某个<code>Buffer Pool</code>实例向操作系统申请一大片连续的内存空间，而是以一个所谓的<code>chunk</code>为单位向操作系统申请空间。也就是说一个<code>Buffer Pool</code>实例其实是由若干个<code>chunk</code>组成的，一个<code>chunk</code>就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块。</p><p>正是因为发明了这个<code>chunk</code>的概念，我们在服务器运行期间调整<code>Buffer Pool</code>的大小时就是以<code>chunk</code>为单位增加或者删除内存空间，而不需要重新向操作系统申请一片大的内存，然后进行缓存页的复制。这个所谓的<code>chunk</code>的大小是我们在启动操作<code>MySQL</code>服务器时通过<code>innodb_buffer_pool_chunk_size</code>启动参数指定的，它的默认值是<code>134217728</code>，也就是<code>128M</code>。不过需要注意的是，innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的。</p><blockquote><p>为什么不允许在服务器运行过程中修改innodb_buffer_pool_chunk_size的值？因为innodb_buffer_pool_chunk_size的值代表InnoDB向操作系统申请的一片连续的内存空间的大小，如果你在服务器运行过程中修改了该值，就意味着要重新向操作系统申请连续的内存空间并且将原先的缓存页和它们对应的控制块复制到这个新的内存空间中，这是十分耗时的操作！ 另外，这个innodb_buffer_pool_chunk_size的值并不包含缓存页对应的控制块的内存空间大小，所以实际上InnoDB向操作系统申请连续内存空间时，每个chunk的大小要比innodb_buffer_pool_chunk_size的值大一些，约5%。</p></blockquote><h3 id="11-配置Buffer-Pool时的注意事项"><a href="#11-配置Buffer-Pool时的注意事项" class="headerlink" title="11.配置Buffer Pool时的注意事项"></a>11.配置Buffer Pool时的注意事项</h3><ul><li><p> <code>innodb_buffer_pool_size</code>必须是<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的倍数（这主要是想保证每一个<code>Buffer Pool</code>实例中包含的<code>chunk</code>数量相同）。<br>假设我们指定的<code>innodb_buffer_pool_chunk_size</code>的值是<code>128M</code>，<code>innodb_buffer_pool_instances</code>的值是<code>16</code>，那么这两个值的乘积就是<code>2G</code>，也就是说<code>innodb_buffer_pool_size</code>的值必须是<code>2G</code>或者<code>2G</code>的整数倍。比方说我们在启动<code>MySQL</code>服务器是这样指定启动参数的：<br>默认的<code>innodb_buffer_pool_chunk_size</code>值是<code>128M</code>，指定的<code>innodb_buffer_pool_instances</code>的值是<code>16</code>，所以<code>innodb_buffer_pool_size</code>的值必须是<code>2G</code>或者<code>2G</code>的整数倍，上边例子中指定的<code>innodb_buffer_pool_size</code>的值是<code>8G</code>，符合规定，所以在服务器启动完成之后我们查看一下该变量的值就是我们指定的<code>8G</code>（8589934592字节）：<br>如果我们指定的<code>innodb_buffer_pool_size</code>大于<code>2G</code>并且不是<code>2G</code>的整数倍，那么服务器会自动的把<code>innodb_buffer_pool_size</code>的值调整为<code>2G</code>的整数倍，比方说我们在启动服务器时指定的<code>innodb_buffer_pool_size</code>的值是<code>9G</code>：<br>那么服务器会自动把<code>innodb_buffer_pool_size</code>的值调整为<code>10G，</code>10737418240字节。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size=8G --innodb-buffer-pool-instances=16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| Variable_name           | Value      |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| innodb_buffer_pool_size | 8589934592 |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size=9G --innodb-buffer-pool-instances=16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">+-------------------------+-------------+</span><br><span class="line">| Variable_name           | Value       |</span><br><span class="line">+-------------------------+-------------+</span><br><span class="line">| innodb_buffer_pool_size | 10737418240 |</span><br><span class="line">+-------------------------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p> 如果在服务器启动时，<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的值已经大于<code>innodb_buffer_pool_size</code>的值，那么<code>innodb_buffer_pool_chunk_size</code>的值会被服务器自动设置为<code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code>的值。<br>比方说我们在启动服务器时指定的<code>innodb_buffer_pool_size</code>的值为<code>2G</code>，<code>innodb_buffer_pool_instances</code>的值为16，<code>innodb_buffer_pool_chunk_size</code>的值为<code>256M</code>：<br>由于<code>256M × 16 = 4G</code>，而<code>4G &gt; 2G</code>，所以<code>innodb_buffer_pool_chunk_size</code>值会被服务器改写为<code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code>的值，也就是：<code>2G/16 = 128M</code>（134217728字节）。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size=2G --innodb-buffer-pool-instances=16 --innodb-buffer-pool-chunk-size=256M</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| Variable_name           | Value      |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| innodb_buffer_pool_size | 2147483648 |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_chunk_size&#x27;;</span><br><span class="line">+-------------------------------+-----------+</span><br><span class="line">| Variable_name                 | Value     |</span><br><span class="line">+-------------------------------+-----------+</span><br><span class="line">| innodb_buffer_pool_chunk_size | 134217728 |</span><br><span class="line">+-------------------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-Buffer-Pool中存储的其它信息"><a href="#12-Buffer-Pool中存储的其它信息" class="headerlink" title="12.Buffer Pool中存储的其它信息"></a>12.Buffer Pool中存储的其它信息</h3><p><code>Buffer Pool</code>的缓存页除了用来缓存磁盘上的页面以外，还可以存储锁信息、自适应哈希索引等信息。</p><h3 id="13-查看Buffer-Pool的状态信息"><a href="#13-查看Buffer-Pool的状态信息" class="headerlink" title="13.查看Buffer Pool的状态信息"></a>13.查看Buffer Pool的状态信息</h3><p><code>MySQL</code>给我们提供了<code>SHOW ENGINE INNODB STATUS</code>语句来查看关于<code>InnoDB</code>存储引擎运行过程中的一些状态信息，其中就包括<code>Buffer Pool</code>的一些信息，我们看一下（为了突出重点，我们只把输出中关于<code>Buffer Pool</code>的部分提取了出来）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total memory allocated 13218349056;</span><br><span class="line">Dictionary memory allocated 4014231</span><br><span class="line">Buffer pool size   786432</span><br><span class="line">Free buffers       8174</span><br><span class="line">Database pages     710576</span><br><span class="line">Old database pages 262143</span><br><span class="line">Modified db pages  124941</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 6195930012, not young 78247510485</span><br><span class="line">108.18 youngs/s, 226.15 non-youngs/s</span><br><span class="line">Pages read 2748866728, created 29217873, written 4845680877</span><br><span class="line">160.77 reads/s, 3.80 creates/s, 190.16 writes/s</span><br><span class="line">Buffer pool hit rate 956 / 1000, young-making rate 30 / 1000 not 605 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 710576, unzip_LRU len: 118</span><br><span class="line">I/O sum[134264]:cur[144], unzip sum[16]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">(...省略后边的许多状态)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>我们来详细看一下这里边的每个值都代表什么意思：</p><ul><li> <code>Total memory allocated</code>：代表<code>Buffer Pool</code>向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。 </li><li> <code>Dictionary memory allocated</code>：为数据字典信息分配的内存空间大小，注意这个内存空间和<code>Buffer Pool</code>没啥关系，不包括在<code>Total memory allocated</code>中。 </li><li> <code>Buffer pool size</code>：代表该<code>Buffer Pool</code>可以容纳多少缓存<code>页</code>，注意，单位是<code>页</code>！ </li><li> <code>Free buffers</code>：代表当前<code>Buffer Pool</code>还有多少空闲缓存页，也就是<code>free链表</code>中还有多少个节点。 </li><li> <code>Database pages</code>：代表<code>LRU</code>链表中的页的数量，包含<code>young</code>和<code>old</code>两个区域的节点数量。 </li><li> <code>Old database pages</code>：代表<code>LRU</code>链表<code>old</code>区域的节点数量。 </li><li> <code>Modified db pages</code>：代表脏页数量，也就是<code>flush链表</code>中节点的数量。 </li><li> <code>Pending reads</code>：正在等待从磁盘上加载到<code>Buffer Pool</code>中的页面数量。<br>当准备从磁盘中加载某个页面时，会先为这个页面在<code>Buffer Pool</code>中分配一个缓存页以及它对应的控制块，然后把这个控制块添加到<code>LRU</code>的<code>old</code>区域的头部，但是这个时候真正的磁盘页并没有被加载进来，<code>Pending reads</code>的值会跟着加1。 </li><li> <code>Pending writes LRU</code>：即将从<code>LRU</code>链表中刷新到磁盘中的页面数量。 </li><li> <code>Pending writes flush list</code>：即将从<code>flush</code>链表中刷新到磁盘中的页面数量。 </li><li> <code>Pending writes single page</code>：即将以单个页面的形式刷新到磁盘中的页面数量。 </li><li> <code>Pages made young</code>：代表<code>LRU</code>链表中曾经从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。<br>这里需要注意，一个节点每次只有从<code>old</code>区域移动到<code>young</code>区域头部时才会将<code>Pages made young</code>的值加1，也就是说如果该节点本来就在<code>young</code>区域，由于它符合在<code>young</code>区域1/4后边的要求，下一次访问这个页面时也会将它移动到<code>young</code>区域头部，但这个过程并不会导致<code>Pages made young</code>的值加1。 </li><li> <code>Page made not young</code>：在将<code>innodb_old_blocks_time</code>设置的值大于0时，首次访问或者后续访问某个处在<code>old</code>区域的节点时由于不符合时间间隔的限制而不能将其移动到<code>young</code>区域头部时，<code>Page made not young</code>的值会加1。<br>这里需要注意，对于处在<code>young</code>区域的节点，如果由于它在<code>young</code>区域的1/4处而导致它没有被移动到<code>young</code>区域头部，这样的访问并不会将<code>Page made not young</code>的值加1。 </li><li> <code>youngs/s</code>：代表每秒从<code>old</code>区域被移动到<code>young</code>区域头部的节点数量。 </li><li> <code>non-youngs/s</code>：代表每秒由于不满足时间限制而不能从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。 </li><li> <code>Pages read</code>、<code>created</code>、<code>written</code>：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。 </li><li> <code>Buffer pool hit rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到<code>Buffer Pool</code>了。 </li><li> <code>young-making rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到<code>young</code>区域的头部了。</li></ul><p><strong>需要注意的一点是，这里统计的将页面移动到</strong><code>**young**</code><strong>区域的头部次数不仅仅包含从</strong><code>**old**</code><strong>区域移动到</strong><code>**young**</code><strong>区域头部的次数，还包括从</strong><code>**young**</code><strong>区域移动到</strong><code>**young**</code><strong>区域头部的次数（访问某个</strong><code>**young**</code><strong>区域的节点，只要该节点在</strong><code>**young**</code><strong>区域的1/4处往后，就会把它移动到</strong><code>**young**</code><strong>区域的头部）。</strong> </p><ul><li> <code>not (young-making rate)</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到<code>young</code>区域的头部。</li></ul><p><strong>需要注意的一点是，这里统计的没有将页面移动到</strong><code>**young**</code><strong>区域的头部次数不仅仅包含因为设置了</strong><code>**innodb_old_blocks_time**</code><strong>系统变量而导致访问了</strong><code>**old**</code><strong>区域中的节点但没把它们移动到</strong><code>**young**</code><strong>区域的次数，还包含因为该节点在</strong><code>**young**</code><strong>区域的前1/4处而没有被移动到</strong><code>**young**</code><strong>区域头部的次数。</strong> </p><ul><li> <code>LRU len</code>：代表<code>LRU链表</code>中节点的数量。 </li><li> <code>unzip_LRU</code>：代表<code>unzip_LRU链表</code>中节点的数量。 </li><li> <code>I/O sum</code>：最近50s读取磁盘页的总数。 </li><li> <code>I/O cur</code>：现在正在读取的磁盘页数量。 </li><li> <code>I/O unzip sum</code>：最近50s解压的页面数量。 </li><li> <code>I/O unzip cur</code>：正在解压的页面数量。 </li></ul><h1 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h1><ol><li> 磁盘太慢，用内存作为缓存很有必要。 </li><li> <code>Buffer Pool</code>本质上是<code>InnoDB</code>向操作系统申请的一段连续的内存空间，可以通过<code>innodb_buffer_pool_size</code>来调整它的大小。 </li><li> <code>Buffer Pool</code>向操作系统申请的连续内存由控制块和缓存页组成，每个控制块和缓存页都是一一对应的，在填充足够多的控制块和缓存页的组合后，<code>Buffer Pool</code>剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为<code>碎片</code>。 </li><li> <code>InnoDB</code>使用了许多<code>链表</code>来管理<code>Buffer Pool</code>。 </li><li> <code>free链表</code>中每一个节点都代表一个空闲的缓存页，在将磁盘中的页加载到<code>Buffer Pool</code>时，会从<code>free链表</code>中寻找空闲的缓存页。 </li><li> 为了快速定位某个页是否被加载到<code>Buffer Pool</code>，使用<code>表空间号 + 页号</code>作为<code>key</code>，缓存页作为<code>value</code>，建立哈希表。 </li><li> 在<code>Buffer Pool</code>中被修改的页称为<code>脏页</code>，脏页并不是立即刷新，而是被加入到<code>flush链表</code>中，待之后的某个时刻同步到磁盘上。 </li><li> <code>LRU链表</code>分为<code>young</code>和<code>old</code>两个区域，可以通过<code>innodb_old_blocks_pct</code>来调节<code>old</code>区域所占的比例。首次从磁盘上加载到<code>Buffer Pool</code>的页会被放到<code>old</code>区域的头部，在<code>innodb_old_blocks_time</code>间隔时间内访问该页不会把它移动到<code>young</code>区域头部。在<code>Buffer Pool</code>没有可用的空闲缓存页时，会首先淘汰掉<code>old</code>区域的一些页。 </li><li> 我们可以通过指定<code>innodb_buffer_pool_instances</code>来控制<code>Buffer Pool</code>实例的个数，每个<code>Buffer Pool</code>实例中都有各自独立的链表，互不干扰。 </li><li> 自<code>MySQL 5.7.5</code>版本之后，可以在服务器运行过程中调整<code>Buffer Pool</code>大小。每个<code>Buffer Pool</code>实例由若干个<code>chunk</code>组成，每个<code>chunk</code>的大小可以在服务器启动时通过启动参数调整。 </li><li> 可以用下边的命令查看<code>Buffer Pool</code>的状态信息：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十一]高性能MySQL调优实战</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%80%5D%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%80%5D%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一，数据库应该如何优化"><a href="#一，数据库应该如何优化" class="headerlink" title="一，数据库应该如何优化"></a>一，数据库应该如何优化</h1><p>数据库优化有很多层面。</p><h2 id="1-SQL与索引"><a href="#1-SQL与索引" class="headerlink" title="1.SQL与索引"></a>1.SQL与索引</h2><p>因为 SQL 语句是在我们的应用端编写的，所以第一步，我们可以在程序中对 SQL 语句进行优化，最终的目标是用到索引。这个是容易的也是最常用的优化手段。</p><h2 id="2-表与存储引擎"><a href="#2-表与存储引擎" class="headerlink" title="2.表与存储引擎"></a>2.表与存储引擎</h2><p>数据是存放在表里面的，表又是以不同的格式存放在存储引擎中的，所以我们可以选用特定的存储引擎，或者对表进行分区，对表结构进行拆分或者冗余处理，或者对表结构比如字段的定义进行优化。</p><h2 id="3-架构"><a href="#3-架构" class="headerlink" title="3.架构"></a>3.架构</h2><p>对于数据库的服务，我们可以对它的架构进行优化。如果只有一台数据库的服务器，我们可以运行多个实例，做集群的方案，做负载均衡。或者基于主从复制实现读写分离，让写的服务都访问 master 服务器，读的请求都访问从服务器，slave 服务器自动 master 主服务器同步数据。或者在数据库前面加一层缓存，达到减少数据库的压力，提升访问速度的目的。为了分散数据库服务的存储压力和访问压力，我们也可以把不同的数据分布到不同的服务节点，这个就是分库分表（scale out）。</p><p>注意主从（replicate）和分片（shard）的区别：</p><ol><li> 主从通过数据冗余实现高可用，和实现读写分离。 </li><li> 分片通过拆分数据分散存储和访问压力。 </li></ol><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4.配置"></a>4.配置</h2><p>数据库配置的优化，比如连接数，缓冲区大小等等，优化配置的目的都是为了更高效地利用硬件。</p><h2 id="5-操作系统与硬件"><a href="#5-操作系统与硬件" class="headerlink" title="5.操作系统与硬件"></a>5.操作系统与硬件</h2><p>从上往下，成本收益比慢慢地在增加。所以肯定不是查询一慢就堆硬件，堆硬件叫做向上的扩展（scale up）。</p><h1 id="二，慢日志查询"><a href="#二，慢日志查询" class="headerlink" title="二，慢日志查询"></a>二，慢日志查询</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。<code>long_query_time</code>的默认值为10，意思是运行10秒以上的语句。由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p><h2 id="2-实操"><a href="#2-实操" class="headerlink" title="2.实操"></a>2.实操</h2><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><h3 id="2-1查看及开启"><a href="#2-1查看及开启" class="headerlink" title="2.1查看及开启"></a>2.1查看及开启</h3><h4 id="①日志"><a href="#①日志" class="headerlink" title="①日志"></a>①日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow_query_log%&#x27;;</span><br></pre></td></tr></table></figure><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=1;</span><br></pre></td></tr></table></figure><p>只对窗口生效，重启服务失效。</p><h4 id="②时间"><a href="#②时间" class="headerlink" title="②时间"></a>②时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL long_query_time=0.1;</span><br></pre></td></tr></table></figure><p>全局变量设置，对所有客户端有效。但必须是设置后进行登录的客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION long_query_time=0.1; #session可省略</span><br></pre></td></tr></table></figure><p>对当前会话连接立即生效，对其他客户端无效。</p><p><strong>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。</strong></p><h4 id="③永久生效"><a href="#③永久生效" class="headerlink" title="③永久生效"></a>③永久生效</h4><p>修改配置文件my.cnf（其它系统变量也是如此）</p><p>[mysqld]下增加或修改参数</p><p>slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件 <a href="#fn1">[1]</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =1</span><br><span class="line">slow_query_log_file=/var/lib/mysql/yhd-slow.log </span><br><span class="line">long_query_time=3</span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><h3 id="2-2Case"><a href="#2-2Case" class="headerlink" title="2.2Case"></a>2.2Case</h3><p>记录慢SQL并后续分析</p><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="3-日志分析工具-mysqldumpslow"><a href="#3-日志分析工具-mysqldumpslow" class="headerlink" title="3.日志分析工具-mysqldumpslow"></a>3.日志分析工具-mysqldumpslow</h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code>。</p><p>查看mysqldumpslow的帮助信息（windows下需要安装perl环境）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure><blockquote><p>-a: 不将数字抽象成N，字符串抽象成S<br>-s: 是表示按照何种方式排序；<br>c: 访问次数<br>l: 锁定时间<br>r: 返回记录<br>t: 查询时间<br>al:平均锁定时间<br>ar:平均返回记录数<br>at:平均查询时间<br>-t: 即为返回前面多少条的数据；<br>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p></blockquote><h3 id="3-1常用SQL"><a href="#3-1常用SQL" class="headerlink" title="3.1常用SQL"></a>3.1常用SQL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/yhd-slow.log</span><br><span class="line">得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/yhd-slow.log</span><br><span class="line">得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/yhd-slow.log</span><br><span class="line">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/yhd-slow.log | more</span><br></pre></td></tr></table></figure><h2 id="4-SHOW-PROCESSLIST"><a href="#4-SHOW-PROCESSLIST" class="headerlink" title="4.SHOW PROCESSLIST"></a>4.SHOW PROCESSLIST</h2><p>作用：查询所有用户正在干什么。</p><p>如果出现不顺眼的：kill [id]</p><h1 id="三，EXPLAIN调优实战"><a href="#三，EXPLAIN调优实战" class="headerlink" title="三，EXPLAIN调优实战"></a>三，EXPLAIN调优实战</h1><h2 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1.准备数据"></a>1.准备数据</h2><p>员工表插入500w数据，部门表插入10w数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept`</span><br><span class="line">(</span><br><span class="line">    `id`       <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `address`  <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `ceo`      <span class="type">INT</span>     <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp`</span><br><span class="line">(</span><br><span class="line">    `id`     <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `empno`  <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name`   <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age`    <span class="type">INT</span>(<span class="number">3</span>)      <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `deptId` <span class="type">INT</span>(<span class="number">11</span>)     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">    #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line">#生成随机字符串</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n</span><br><span class="line">        DO</span><br><span class="line">            <span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建往emp表中插入数据的存储过程</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_emp(<span class="keyword">START</span> <span class="type">INT</span>, max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT</span><br><span class="line">        #循环</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (empno, NAME, age, deptid)</span><br><span class="line">        <span class="keyword">VALUES</span> ((<span class="keyword">START</span> <span class="operator">+</span> i), rand_string(<span class="number">6</span>), rand_num(<span class="number">30</span>, <span class="number">50</span>), rand_num(<span class="number">1</span>, <span class="number">10000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">        <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建往dept表中插入数据的存储过程</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `insert_dept`(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (deptname, address, ceo) <span class="keyword">VALUES</span> (rand_string(<span class="number">8</span>), rand_string(<span class="number">10</span>), rand_num(<span class="number">1</span>, <span class="number">500000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">        <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#执行存储过程，往dept表添加<span class="number">10</span>万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">100000</span>);</span><br><span class="line">#执行存储过程，往emp表添加<span class="number">500</span>万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_emp(<span class="number">100000</span>, <span class="number">5000000</span>);</span><br></pre></td></tr></table></figure><h2 id="2-批量删除索引"><a href="#2-批量删除索引" class="headerlink" title="2.批量删除索引"></a>2.批量删除索引</h2><p><strong>建立好的索引在哪里？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> t_emp ; <span class="comment">-- 只能查看索引，但不能删除。</span></span><br><span class="line">information_schema.STATISTICS <span class="comment">-- 存储索引的表（元数据库，统计表），我们可以对表数据进行删除操作。</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong></p><ol><li>删除某一个索引</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_xxx ON emp</span><br></pre></td></tr></table></figure><ol start="2"><li>查出该表有哪些索引，索引名–&gt;集合</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> t_emp</span><br><span class="line"><span class="comment">-- 元数据：meta DATA  描述数据的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> index_name</span><br><span class="line"><span class="keyword">FROM</span> information_schema.STATISTICS</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;t_emp&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> table_schema <span class="operator">=</span> <span class="string">&#x27;mydb&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> index_name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> seq_in_index <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="3-单表使用索引"><a href="#3-单表使用索引" class="headerlink" title="3.单表使用索引"></a>3.单表使用索引</h2><p>建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,NAME);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> emp(NAME);</span><br></pre></td></tr></table></figure><h3 id="3-1-全值匹配"><a href="#3-1-全值匹配" class="headerlink" title="3.1 全值匹配"></a>3.1 全值匹配</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 单表查询<span class="operator">-</span>全值匹配</span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.age <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">  <span class="keyword">and</span> deptid <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.age <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">  <span class="keyword">and</span> deptid <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491456170-c377987c-20e4-48d3-8c57-1c281333f915.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u99be6438&margin=%5Bobject%20Object%5D&name=1.png&originHeight=669&originWidth=1627&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72502&status=done&style=none&taskId=u55d8c0c7-c4a1-426d-9c8a-ac028ee5610&title=" alt="1.png"></p><h3 id="3-2-最左前缀法则"><a href="#3-2-最左前缀法则" class="headerlink" title="3.2 最左前缀法则"></a>3.2 最左前缀法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 单表查询-左前缀法则</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=1 AND deptid=1 AND NAME=&#x27;aaa&#x27;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=1 AND deptid=1;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=1 AND NAME=&#x27;aaa&#x27; AND deptid=1;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE deptid=1 AND NAME =&#x27;aaa&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491464294-700567fe-de9c-4bec-a160-19f057af9664.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uad589f02&margin=%5Bobject%20Object%5D&name=2.png&originHeight=370&originWidth=1675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77031&status=done&style=none&taskId=u84a1a60b-a4c9-431b-aab3-390a731d305&title=" alt="2.png"></p><p><strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong></p><h3 id="3-3-索引列上计算-函数导致索引失效"><a href="#3-3-索引列上计算-函数导致索引失效" class="headerlink" title="3.3 索引列上计算/函数导致索引失效"></a>3.3 索引列上计算/函数导致索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 单表查询-操作索引列导致索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name  LIKE &#x27;abc%&#x27;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE LEFT(emp.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491470761-e9ab9bf0-b0fd-466b-a22e-78f9db05ac18.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0f50ef69&margin=%5Bobject%20Object%5D&name=3.png&originHeight=212&originWidth=1776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40690&status=done&style=none&taskId=ubc30bbc7-0caa-4576-8310-56d52ce4621&title=" alt="3.png"></p><h3 id="3-4-范围查询导致的索引失效"><a href="#3-4-范围查询导致的索引失效" class="headerlink" title="3.4 范围查询导致的索引失效"></a>3.4 范围查询导致的索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line">SELECT </span><br><span class="line">  SQL_NO_CACHE * </span><br><span class="line">FROM</span><br><span class="line">  emp </span><br><span class="line">WHERE emp.name = &#x27;abc&#x27;</span><br><span class="line">  AND emp.deptId &gt; 20 </span><br><span class="line">  AND  emp.age = 30 ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491478562-2407f3a6-238e-4a41-9c40-f13d878a64be.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0fd297ca&margin=%5Bobject%20Object%5D&name=4.png&originHeight=278&originWidth=1778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30777&status=done&style=none&taskId=u447c694d-200e-4a12-9594-cdfab0c4284&title=" alt="4.png"></p><p><strong>应用开发中范围查询，例如： 金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。</strong></p><h3 id="3-5-不等于-或者-lt-gt-索引失效"><a href="#3-5-不等于-或者-lt-gt-索引失效" class="headerlink" title="3.5  不等于(!= 或者&lt;&gt;)索引失效"></a>3.5  不等于(!= 或者&lt;&gt;)索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name &lt;&gt;  &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491485131-265339c4-634a-4f9d-85ff-425d9bf11bbd.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ueb6021dc&margin=%5Bobject%20Object%5D&name=5.png&originHeight=83&originWidth=1769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19058&status=done&style=none&taskId=u795a528f-33c3-4c30-ae8e-f7b4a90376e&title=" alt="5.png"></p><h3 id="3-6-is-not-null无法使用索引，is-null可使用索引"><a href="#3-6-is-not-null无法使用索引，is-null可使用索引" class="headerlink" title="3.6 is not null无法使用索引，is null可使用索引"></a>3.6 is not null无法使用索引，is null可使用索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age IS NULL;</span><br><span class="line">#用到索引  </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age IS NOT NULL;</span><br><span class="line">#未用到索引</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491492669-05d3cbe9-c4fc-46b6-976d-47d7ad05f8da.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63f28bbf&margin=%5Bobject%20Object%5D&name=6.png&originHeight=193&originWidth=1780&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37313&status=done&style=none&taskId=u4db37747-2dc5-4415-accd-910c1ea3e91&title=" alt="6.png"></p><h3 id="3-7-like以-开头索引失效"><a href="#3-7-like以-开头索引失效" class="headerlink" title="3.7 like以%开头索引失效"></a>3.7 like以%开头索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE NAME LIKE &#x27;%aaa&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491500063-fb3c4a33-f97d-4266-a05c-86fde429b288.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubdad3760&margin=%5Bobject%20Object%5D&name=7.png&originHeight=216&originWidth=1803&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24797&status=done&style=none&taskId=ub22f6bde-0c42-4eec-b801-c53dbdc66c9&title=" alt="7.png"></p><h3 id="3-8-类型转换导致索引失效"><a href="#3-8-类型转换导致索引失效" class="headerlink" title="3.8 类型转换导致索引失效"></a>3.8 类型转换导致索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE NAME=123;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491506837-e3685860-d2c5-4f77-894b-268f1612d6e8.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u969914ec&margin=%5Bobject%20Object%5D&name=8.png&originHeight=224&originWidth=1812&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25560&status=done&style=none&taskId=uda038af4-3c43-413f-a932-5e758817a2c&title=" alt="8.png"></p><p><strong>设计实体类属性时，一定要与数据库字段类型相对应，否则会出现类型转换的情况，导致索引失效。</strong></p><h2 id="4-关联查询优化"><a href="#4-关联查询优化" class="headerlink" title="4. 关联查询优化"></a>4. 关联查询优化</h2><h3 id="4-1-左外连接"><a href="#4-1-左外连接" class="headerlink" title="4.1 左外连接"></a>4.1 左外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp left join dept on emp.deptId=dept.id;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491513538-f2345fca-602d-43eb-b2fe-5b2e4fe417a0.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubd7e078b&margin=%5Bobject%20Object%5D&name=9.png&originHeight=267&originWidth=1765&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27831&status=done&style=none&taskId=ub2ea1fc8-943f-4fe1-a479-e7462d30827&title=" alt="9.png"></p><p>这种情况下，驱动表无法避免全表扫描，但是因为被驱动表的主键存在索引并且是两张表关联查询的关联条件，所以可以避免被驱动表的全表扫描。</p><h3 id="4-2-内连接-TODO"><a href="#4-2-内连接-TODO" class="headerlink" title="4.2 内连接(TODO)"></a>4.2 内连接(TODO)</h3><p>内连接MySQL会自动为我们选择驱动表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain  select * from dept  straight_join emp on emp.deptId=dept.id;</span><br><span class="line">## 1. dept 全表扫描   10w</span><br><span class="line">## 2. emp deptid  ref</span><br><span class="line">explain    select * from dept join emp on emp.deptId=dept.id;</span><br><span class="line">## 1. emp 500w</span><br><span class="line">## 2. dept id ref</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491521056-21c44295-fdf0-48cd-af31-2727388d6406.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf7b1a531&margin=%5Bobject%20Object%5D&name=10.png&originHeight=256&originWidth=1768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47117&status=done&style=none&taskId=u15296664-5f58-4728-9a31-6cf5d2f00e3&title=" alt="10.png"></p><ol><li> 保证被驱动表的join字段被索引 </li><li> left join 时，选择小表作为驱动表，大表作为被驱动表 </li><li> inner join 时，mysql会自动将小结果集的表选为驱动表。选择相信mysql优化策略。 </li><li> 子查询尽量不要放在被驱动表，衍生表建不了索引。 </li><li> 能够直接多表关联的尽量直接关联，不用子查询。 </li><li> 两张表的连接查询，比方说 left join  right、inner join 等，他们的连表方式是什么？ </li><li> 连表查询一共三种算法：nlj  bnl  bka 算法 。 </li><li> right join 底层，会给你转化为left join。 </li></ol><h3 id="4-3-子查询优化"><a href="#4-3-子查询优化" class="headerlink" title="4.3 子查询优化"></a>4.3 子查询优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#①不推荐</span><br><span class="line">explain SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  emp</span><br><span class="line">WHERE emp.id NOT IN   -- not in 导致无法对in进行优化，用不了exists</span><br><span class="line">  (SELECT</span><br><span class="line">    dept.ceo</span><br><span class="line">  FROM</span><br><span class="line">    dept</span><br><span class="line">  WHERE dept.ceo IS NOT NULL) ; -- is not null 导致索引失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②推荐</span><br><span class="line">explain SELECT</span><br><span class="line">  emp.*</span><br><span class="line">FROM</span><br><span class="line">  emp</span><br><span class="line">  LEFT JOIN dept</span><br><span class="line">    ON emp.id = dept.ceo  -- 如果ceo没有索引，两张表都是全表扫描，如果ceo有索引，被驱动表就是ref级别</span><br><span class="line">WHERE dept.id IS NULL ;</span><br><span class="line"># 尝试在ceo创建索引后，确实是  create index idx_ceo on dept(ceo);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491529644-b74d14b2-2509-40c7-8b55-901771849bcd.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u913673e1&margin=%5Bobject%20Object%5D&name=11.png&originHeight=687&originWidth=1774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66874&status=done&style=none&taskId=ua21a55b1-35c9-405e-96fd-65dc0b7e4de&title=" alt="11.png"></p><p><strong>尽量不要使用not in  或者 not exists，会使索引失效。</strong></p><p>MySQL自动做出的子查询优化，物化子查询，转为半连接</p><p>物化子查询：把子查询的结果查出来后，建立一个临时表，“物化”-&gt;变成一张内存临时表</p><p>半连接：把子查询转化为类似连接查询的方式，但又不是真正的连接查询，所以叫 半 连接优化</p><h2 id="5-排序分组优化"><a href="#5-排序分组优化" class="headerlink" title="5.排序分组优化"></a>5.排序分组优化</h2><h3 id="5-1-无过滤，不索引"><a href="#5-1-无过滤，不索引" class="headerlink" title="5.1 无过滤，不索引"></a>5.1 无过滤，不索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY age,deptid; </span><br><span class="line">#没用上索引，Using filesort </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY age,deptid LIMIT 10; </span><br><span class="line">#使用上索引 null</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491536353-0bd6fd69-2673-476c-b248-b2e80fcbffcb.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u24d10f43&margin=%5Bobject%20Object%5D&name=12.png&originHeight=183&originWidth=1582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37338&status=done&style=none&taskId=u1edba00b-5e34-4259-95c8-083f2f0c62f&title=" alt="12.png"></p><p>因为<code>order by</code>的字段顺序和索引的顺序一样，所以此时会先尝试内存排序，但是因为上面的sql没有limit，导致内存放不下，使用了文件排序（文件系统级别，相当于在磁盘做排序），所以第一条sql效率更低。</p><p><strong>order后面的字段想要使用索引，必须要有过滤条件，limit也行。</strong></p><h3 id="5-2顺序错，必排序"><a href="#5-2顺序错，必排序" class="headerlink" title="5.2顺序错，必排序"></a>5.2顺序错，必排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid;</span><br><span class="line"></span><br><span class="line"># Using index condition</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid,NAME;</span><br><span class="line"></span><br><span class="line"># Using index condition</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid,empno;</span><br><span class="line"></span><br><span class="line"># Using index condition; Using filesort</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY NAME,deptid;</span><br><span class="line"></span><br><span class="line"># Using index condition; Using filesort</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE deptid=45 ORDER BY age;</span><br><span class="line"># Using where; Using filesort</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491544580-01f4c526-3629-4473-a484-3a22cb9faaa0.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u54b993fc&margin=%5Bobject%20Object%5D&name=13.png&originHeight=419&originWidth=1785&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105747&status=done&style=none&taskId=ubcd427eb-7240-496b-9649-1864b3852cf&title=" alt="13.png">在SQL语句中的顺序一定要和定义索引中的字段顺序完全一致。</p><h3 id="5-3-方向反，必排序"><a href="#5-3-方向反，必排序" class="headerlink" title="5.3 方向反，必排序"></a>5.3 方向反，必排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid DESC, NAME DESC ;</span><br><span class="line">#Using where</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid ASC, NAME DESC ;</span><br><span class="line">#Using index condition; Using filesort</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491551554-8a74b76b-19e2-46fe-a3a3-7035195101c4.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8058c6b1&margin=%5Bobject%20Object%5D&name=14.png&originHeight=183&originWidth=1778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44088&status=done&style=none&taskId=u5310533d-7e53-441e-ae67-7c0797b75c8&title=" alt="14.png"></p><p><strong>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</strong></p><p>要么全升序、要么全降序。有升有降无法使用索引。</p><h3 id="5-4-索引的选择"><a href="#5-4-索引的选择" class="headerlink" title="5.4 索引的选择"></a>5.4 索引的选择</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640502174193-eabb2dc2-2270-4142-87a8-15983e19f611.png#clientId=u74e58dfd-b4b5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u33361d21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=367&originWidth=1779&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79336&status=done&style=shadow&taskId=u89a45289-9231-4915-8ba6-b6af12a6b1b&title=" alt="image.png"></p><p><strong>两个索引同时存在，mysql自动选择最优的方案，但是，随着数据量的变化，选择的索引也会随之变化的。</strong></p><p>所有的排序都是在条件过滤之后才执行的，所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。</p><p>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围（过滤条件）字段上。反之，亦然。</p><p>扫描行数的多少，就是explain里的rows，可以说明一个需要扫描的行数多，一个扫描行数少，扫描行数多，代表成本高，扫描行数少代表成本少。优化器最终是对比成本值的大小来选取索引的。准确的说，是MySQL基于成本，优化器是在server层。</p><p>有时候优化器会选择错索引为什么？</p><ol><li><p>主要是出在优化器预估行数上，这个涉及到了一条sql的执行流程，语法分析，词法分析之后，进入优化阶段，由优化器进行优化，在优化阶段，会尽可能的生成全部的执行计划，然后对比一下哪一个成本值最低，就选它，所以优化器有一个选择索引，选择表的连接顺序的过程，索引不同，成本不同，读表顺序不同，成本不同，索引的选取，需要存储引擎提供统计信息，innodb中，统计信息是随机采样，随机选取8个索引页，取平均值，当做该索引的全部情况，也就是部分代表整体，也就是最终导致rows那里是个预估值，而不是准确的。所以有时候MySQL选错了索引，有一定概率，是由于这个随机采样造成的。而随机采样的不准确，是由于数据不断添加导致索引页的分裂，导致有些页内数据较少。  </p><blockquote><p>解决方案：</p><ol><li> 执行一下alter table +表名 就可以使统计信息稍微准确点，他会重新构建索引，使索引页保持紧凑，这个就是B+树的分裂。 </li><li> 调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。 </li></ol></blockquote></li><li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。  </p><blockquote><p>解决方案：</p><ol><li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li><li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。</li></ol></blockquote></li></ol><h3 id="5-5-双路排序-amp-单路排序"><a href="#5-5-双路排序-amp-单路排序" class="headerlink" title="5.5  双路排序&amp;单路排序"></a>5.5  双路排序&amp;单路排序</h3><p>如果不在索引列上，filesort有两种算法： mysql就要启动双路排序和单路排序。</p><p><strong>双路排序</strong></p><p>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p><p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p><p>取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p><p><strong>单路排序</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论</strong></p><p>由于单路是后出的，总体而言好过双路。</p><p>但是用单路有问题：</p><p>在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I/O。</p><p>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><p><strong>优化策略</strong></p><p>增大sort_buffer_size参数的设置</p><p>增大max_length_for_sort_data参数的设置</p><p>减少select 后面的查询的字段。</p><p><strong>提高order by的速度</strong></p><ol><li>Order by时select * 是一个大忌。只Query需要的字段， 这点非常重要。</li></ol><blockquote><p>当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</p><p>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</p></blockquote><ol start="2"><li>尝试提高 sort_buffer_size</li></ol><blockquote><p>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的  1M-8M之间调整。 MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%sort_buffer_size%&#x27;;</span><br></pre></td></tr></table></figure><ol start="3"><li>尝试提高 max_length_for_sort_data</li></ol><blockquote><p>提高这个参数， 会增加用改进算法的概率。</p><p>但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%max_length_for_sort_data%&#x27;; #默认1024字节</span><br></pre></td></tr></table></figure><h3 id="5-6-分组优化"><a href="#5-6-分组优化" class="headerlink" title="5.6 分组优化"></a>5.6 分组优化</h3><p>group by 使用索引的原则几乎跟order by一致 ，唯一区别：</p><p>group by 先排序再分组，遵照索引建的最佳左前缀法则</p><p>当无法使用索引列，增大max_length_for_sort_data和sort_buffer_size参数的设置</p><p>where高于having,能写在where限定的条件就不要写在having中了</p><p>group by没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引。</p><h2 id="6-覆盖索引"><a href="#6-覆盖索引" class="headerlink" title="6. 覆盖索引"></a>6. 覆盖索引</h2><p>禁止使用select *，禁止查询与业务无关字段，尽量使用覆盖索引，防止回表。</p><p><strong>覆盖索引减少了 IO 次数，减少了数据的访问量，可以大大地提升查询效率。</strong></p><h1 id="四，追踪优化器"><a href="#四，追踪优化器" class="headerlink" title="四，追踪优化器"></a>四，追踪优化器</h1><p>前面的原理篇详细分析过，在此不再赘述。</p><h1 id="五，-分库分表"><a href="#五，-分库分表" class="headerlink" title="五， 分库分表"></a>五， 分库分表</h1><p>从维度来说分成两种，一种是垂直，一种是水平。</p><p>垂直切分：基于表或字段划分，表结构不同。我们有单库的分表，也有多库的分库。</p><p>水平切分：基于数据划分，表结构相同，数据不同，也有同库的水平切分和多库的切分。</p><h2 id="1-垂直切分"><a href="#1-垂直切分" class="headerlink" title="1.垂直切分"></a>1.垂直切分</h2><p>垂直分表有两种，一种是单库的，一种是多库的。</p><h3 id="1-1-单库垂直分表"><a href="#1-1-单库垂直分表" class="headerlink" title="1.1 单库垂直分表"></a>1.1 单库垂直分表</h3><p>单库分表，比如：商户信息表，拆分成基本信息表，联系方式表，结算信息表，附件表等等。</p><p>可以考虑根据冷热点字段拆分，是否经常发生修改操作拆分，根据字段功能拆分。</p><h3 id="1-2-多库垂直分表"><a href="#1-2-多库垂直分表" class="headerlink" title="1.2 多库垂直分表"></a>1.2 多库垂直分表</h3><p>多库垂直分表就是把原来存储在一个库的不同的表，拆分到不同的数据库。</p><p>比如电商平台的消费系统：一开始，商品表，商品详情表，订单表，用户表，支付记录表，库存表，风控表都在一个库里面，随着数据的增长和业务的扩张，可以考虑将商品和商品详情表单独放到一个库，订单表单独放到一个库，支付记录单独放到一个库，库存表单独放到一个库，风控表单独放到一个库。</p><p>当我们对原来的一张表做了分库的处理，如果某些业务系统的数据还是有一个非常快的增长速度，比如说订单数据库的订单表，数据量达到了几个亿，这个时候硬件限制导致的性能问题还是会出现，所以从这个角度来说垂直切分并没有从根本上解决单库单表数据量过大的问题。在这个时候，我们还需要对我们的数据做一个水平的切分。</p><h2 id="2-水平拆分"><a href="#2-水平拆分" class="headerlink" title="2.水平拆分"></a>2.水平拆分</h2><p>当我们的客户表数量已经到达数千万甚至上亿的时候，单表的存储容量和查询效率都会出现问题，我们需要进一步对单张表的数据进行水平切分。水平切分的每个数据库的表结构都是一样的，只是存储的数据不一样，比如每个库存储 1000 万的数据。</p><p>水平切分也可以分成两种，一种是单库的，一种是多库的。</p><h3 id="2-1-单库水平分表"><a href="#2-1-单库水平分表" class="headerlink" title="2.1 单库水平分表"></a>2.1 单库水平分表</h3><p>银行的交易流水表，所有进出的交易都需要登记这张表，因为绝大部分时候客户都是查询当天的交易和一个月以内的交易数据，所以我们根据使用频率把这张表拆分成三张表：</p><p>当天表：只存储当天的数据。</p><p>当月表：在夜间运行一个定时任务，前一天的数据，全部迁移到当月表。用的是 insert into select，然后 delete。</p><p>历史表：同样是通过定时任务，把登记时间超过 30 天的数据，迁移到 history历史表（历史表的数据非常大，我们按照月度，每个月建立分区）。</p><p>跟分区一样，这种方式虽然可以一定程度解决单表查询性能的问题，但是并不能解决单机存储瓶颈的问题。</p><h3 id="2-2-多库水平分表"><a href="#2-2-多库水平分表" class="headerlink" title="2.2 多库水平分表"></a>2.2 多库水平分表</h3><p>比如客户表，我们拆分到多个库存储，表结构是完全一样的。</p><p><img src="https://img-blog.csdnimg.cn/2021022621260117.jpg#pic_center#crop=0&crop=0&crop=1&crop=1&id=KoEDL&originHeight=171&originWidth=643&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>一般我们说的分库分表都是跨库的分表。</p><h2 id="3-分库分表带来的问题"><a href="#3-分库分表带来的问题" class="headerlink" title="3. 分库分表带来的问题"></a>3. 分库分表带来的问题</h2><h3 id="3-1-跨库关联查询"><a href="#3-1-跨库关联查询" class="headerlink" title="3.1 跨库关联查询"></a>3.1 跨库关联查询</h3><p>比如查询合同信息的时候要关联客户数据，由于是合同数据和客户数据是在不同的数据库，那么我们肯定不能直接使用 join 的这种方式去做关联查询。</p><p><strong>解决方案</strong></p><h4 id="①字段冗余"><a href="#①字段冗余" class="headerlink" title="①字段冗余"></a>①字段冗余</h4><p>比如我们查询合同库的合同表的时候需要关联客户库的客户表，我们可以直接把一些经常关联查询的客户字段放到合同表，通过这种方式避免跨库关联查询的问题。</p><h4 id="②数据同步"><a href="#②数据同步" class="headerlink" title="②数据同步"></a>②数据同步</h4><p>比如商户系统要查询产品系统的产品表，我们干脆在商户系统创建一张产品表，通过 ETL 或者其他方式定时同步产品数据。</p><h4 id="③全局表（广播表）"><a href="#③全局表（广播表）" class="headerlink" title="③全局表（广播表）"></a>③全局表（广播表）</h4><p>比如行名行号信息被很多业务系统用到，如果我们放在核心系统，每个系统都要去关联查询，这个时候我们可以在所有的数据库都存储相同的基础数据。</p><h4 id="④ER表"><a href="#④ER表" class="headerlink" title="④ER表"></a>④ER表</h4><p>我们有些表的数据是存在逻辑的主外键关系的，比如订单表 order_info，存的是汇总的商品数，商品金额；订单明细表 order_detail，是每个商品的价格，个数等等。或者叫做从属关系，父表和子表的关系。他们之间会经常有关联查询的操作，如果父表的数据和子表的数据分别存储在不同的数据库，跨库关联查询也比较麻烦。所以我们能不能把父表的数据和从属于父表的数据落到一个节点上呢？</p><p>比如 order_id=1001 的数据在 node1，它所有的明细数据也放到 node1；order_id=1002 的数据在 node2，它所有的明细数据都放到 node2，这样在关联查询的时候依然是在一个数据库。</p><p>上面的思路都是通过合理的数据分布避免跨库关联查询，实际上在我们的业务中，也是尽量不要用跨库关联查询，如果出现了这种情况，就要分析一下业务或者数据拆分是不是合理。如果还是出现了需要跨库关联的情况，那我们就只能用最后一种办法。</p><h4 id="⑤系统层组装"><a href="#⑤系统层组装" class="headerlink" title="⑤系统层组装"></a>⑤系统层组装</h4><p>在不同的数据库节点把符合条件数据的数据查询出来，然后重新组装，返回给客户端。</p><h3 id="3-2-分布式事务"><a href="#3-2-分布式事务" class="headerlink" title="3.2 分布式事务"></a>3.2 分布式事务</h3><p>具体分布式事务会单独写一篇文章</p><h3 id="3-3-排序，翻页，函数计算问题"><a href="#3-3-排序，翻页，函数计算问题" class="headerlink" title="3.3 排序，翻页，函数计算问题"></a>3.3 排序，翻页，函数计算问题</h3><p>跨节点多库进行查询时，会出现 limit 分页，order by 排序的问题。比如有两个节点，节点 1 存的是奇数 id=1,3,5,7,9……；节点 2 存的是偶数 id=2,4,6,8,10……</p><p>执行 select * from user_info order by id limit 0,10</p><p>需要在两个节点上各取出 10 条，然后合并数据，重新排序。</p><p>max、min、sum、count 之类的函数在进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。</p><h3 id="3-4-全局主键避重"><a href="#3-4-全局主键避重" class="headerlink" title="3.4 全局主键避重"></a>3.4 全局主键避重</h3><p>MySQL 的数据库里面字段有一个自增的属性，Oracle 也有 Sequence 序列。如果是一个数据库，那么可以保证 ID 是不重复的，但是水平分表以后，每个表都按照自己的规律自增，肯定会出现 ID 重复的问题，这个时候我们就不能用本地自增的方式了。</p><p><strong>解决方案</strong></p><h4 id="①UUID"><a href="#①UUID" class="headerlink" title="①UUID"></a>①UUID</h4><p>UUID 标准形式包含 32 个 16 进制数字，分为 5 段，形式为 8-4-4-4-12 的 36 个字符，例如：c4e7956c-03e7-472c-8909-d733803e79a9。</p><p>UUID 是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显，由于 UUID 非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在 InnoDB 中，UUID 的无序性会引起数据位置频繁变动，导致分页。</p><h4 id="②数据库"><a href="#②数据库" class="headerlink" title="②数据库"></a>②数据库</h4><p>把序号维护在数据库的一张表中。这张表记录了全局主键的类型、位数、起始值，当前值。当其他应用需要获得全局 ID 时，先 for update 锁行，取到值+1 后并且更新后返回。并发性比较差。</p><h4 id="③redis"><a href="#③redis" class="headerlink" title="③redis"></a>③redis</h4><p>基于 Redis 的 INT 自增的特性，使用批量的方式降低数据库的写压力，每次获取一段区间的 ID 号段，用完之后再去数据库获取，可以大大减轻数据库的压力。</p><h4 id="④雪花算法"><a href="#④雪花算法" class="headerlink" title="④雪花算法"></a>④雪花算法</h4><p>优点：毫秒数在高位，生成的 ID 整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上 QPS 约为 409.6w/s(1000*2^12)，并且整个分布式系统内不会产生 ID 碰撞；可根据自身业务灵活分配 bit 位。</p><p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成 ID 重复。</p><h2 id="4-多数据源-读写数据源的解决方案"><a href="#4-多数据源-读写数据源的解决方案" class="headerlink" title="4. 多数据源/读写数据源的解决方案"></a>4. 多数据源/读写数据源的解决方案</h2><p>分析一下 SQL 执行经过的流程：</p><p>DAO——Mapper（ORM）——JDBC——代理——数据库服务</p><h3 id="4-1-客户端DAO-层"><a href="#4-1-客户端DAO-层" class="headerlink" title="4.1 客户端DAO 层"></a>4.1 客户端DAO 层</h3><p>在我们连接到某一个数据源之前，我们先根据配置的分片规则，判断需要连接到哪些节点，再建立连接。</p><p>Spring 中提供了一个抽象类 AbstractRoutingDataSource，可以实现数据源的动态切换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）aplication.properties 定义多个数据源</span><br><span class="line">2）创建@TargetDataSource 注解</span><br><span class="line">3）创建 DynamicDataSource 继承 AbstractRoutingDataSource</span><br><span class="line">4）多数据源配置类 DynamicDataSourceConfig</span><br><span class="line">5）创建切面类 DataSourceAspect，对添加了@TargetDataSource 注解的</span><br><span class="line">类进行拦截设置数据源。</span><br><span class="line">6）在 启 动 类 上 自 动 装 配 数 据 源 配 置</span><br><span class="line">@Import(&#123;DynamicDataSourceConfig.class&#125;)</span><br><span class="line">7）在 实 现 类 上 加 上 注 解 ， 如 @TargetDataSource(name =</span><br><span class="line">DataSourceNames.SECOND)，调用</span><br></pre></td></tr></table></figure><p>在 DAO 层实现的优势：不需要依赖 ORM 框架，即使替换了 ORM 框架也不受影响。实现简单（不需要解析 SQL 和路由规则），可以灵活地定制。</p><p>缺点：不能复用，不能跨语言。</p><h3 id="4-2-ORM框架层"><a href="#4-2-ORM框架层" class="headerlink" title="4.2 ORM框架层"></a>4.2 ORM框架层</h3><p>比如我们用 MyBatis 连接数据库，也可以指定数据源。我们可以基于 MyBatis 插件的拦截机制（拦截 query 和 update 方法），实现数据源的选择。</p><h3 id="4-3-驱动层"><a href="#4-3-驱动层" class="headerlink" title="4.3 驱动层"></a>4.3 驱动层</h3><p>不管是MyBatis还是Hibernate，还是Spring的JdbcTemplate，本质上都是对JDBC的封装，所以第三层就是驱动层。比如 Sharding-JDBC，就是对 JDBC 的对象进行了封装。JDBC 的核心对象：</p><p>DataSource：数据源</p><p>Connection：数据库连接</p><p>Statement：语句对象</p><p>ResultSet：结果集</p><p>那我们只要对这几个对象进行封装或者拦截或者代理，就可以实现分片的操作。</p><h3 id="4-4-代理层"><a href="#4-4-代理层" class="headerlink" title="4.4 代理层"></a>4.4 代理层</h3><p>前面三种都是在客户端实现的，也就是说不同的项目都要做同样的改动，不同的编程语言也有不同的实现，所以我们能不能把这种选择数据源和实现路由的逻辑提取出来，做成一个公共的服务给所有的客户端使用呢？</p><p>这个就是第四层，代理层。比如 Mycat 和 Sharding-Proxy，都是属于这一层。</p><h3 id="4-5-数据库服务"><a href="#4-5-数据库服务" class="headerlink" title="4.5 数据库服务"></a>4.5 数据库服务</h3><p>某些特定的数据库或者数据库的特定版本可以实现这个功能。</p><h1 id="六，主从复制"><a href="#六，主从复制" class="headerlink" title="六，主从复制"></a>六，主从复制</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/20210226212524335.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70%23pic_center&sign=b2cf46d51564b6f2c46bcffc3adcd48b84ede22cae502691d18e85e1cd079c10#crop=0&crop=0&crop=1&crop=1&id=zSBEv&originHeight=282&originWidth=566&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>MySQL复制过程分成三步：</p><ol><li> master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events； </li><li> slave将master的binary log events拷贝到它的中继日志（relay log）； </li><li> slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，slave会从master读取binlog来进行数据同步。 </li></ol><h2 id="2-与Redis主从复制的差别"><a href="#2-与Redis主从复制的差别" class="headerlink" title="2.与Redis主从复制的差别"></a>2.与Redis主从复制的差别</h2><ol><li> redis主从复制是将主机的所有数据都拷贝给从机，并且是近乎实时的。 </li><li> mysql主从复制不会将建立连接以前的数据发送给从机，并且是异步，且串行化的。 </li></ol><h2 id="3-复制的基本原则"><a href="#3-复制的基本原则" class="headerlink" title="3.复制的基本原则"></a>3.复制的基本原则</h2><p>每个slave只有一个master</p><p>每个slave只能有一个唯一的服务器ID</p><p>每个master可以有多个salve</p><h2 id="4-复制的最大问题"><a href="#4-复制的最大问题" class="headerlink" title="4.复制的最大问题"></a>4.复制的最大问题</h2><p>延时</p><p>全同步可以避免，但性能会极差，正常情况下半同步，且容忍一部分数据不一致。如果不容忍数据不一致，只有强制读主。</p><h2 id="5-一主一从常见配置"><a href="#5-一主一从常见配置" class="headerlink" title="5.一主一从常见配置"></a>5.一主一从常见配置</h2><ol><li>MySQL版本一致且后台以服务运行</li><li>主从配置都在【mysqld】节点下，且全部小写</li><li>主机修改my.ini文件</li></ol><blockquote><ol><li> 主服务器唯一ID server-id=1 </li><li> 启用二进制日志  </li><li> 设置不要复制的数据库  </li><li> 设置需要复制的数据库  </li><li> 设置logbin格式  </li></ol></blockquote><blockquote><p>log-bin=自己的本地路径/data/mysqlbin</p></blockquote><blockquote><p>binlog-ignore-db=mysql</p></blockquote><blockquote><p>binlog-do-db=需要复制的主数据库名字</p></blockquote><blockquote><p>binlog_fromat=STATEMENT(默认)</p></blockquote><h1 id="七，硬件层面的配置"><a href="#七，硬件层面的配置" class="headerlink" title="七，硬件层面的配置"></a>七，硬件层面的配置</h1><h2 id="1-选择合适的CPU"><a href="#1-选择合适的CPU" class="headerlink" title="1.选择合适的CPU"></a>1.选择合适的CPU</h2><p>数据库分为两大类，在线事务处理和在线分析处理。</p><p>InnoDB储存引擎一般应用于OLTP的数据库应用，这种应用的特点如下：</p><ol><li> 用户操作的并发量大 </li><li> 事务处理时间一般比较短 </li><li> 查询的语句较为简单，一般都走索引 </li><li> 复杂查询比较少 </li></ol><p>在当前的MySQL数据库版本中，一条SQL语句只能在一个CPU工作，并不支持多CPU。若cpu支持多核，innodb版本应该选择1.1或者更高。另外如果是多核cpu，可以通过修改参数innodb_read_io_threads和innodb_write_io_threads来增大IO的线程，这样也可以更充分的利用cpu的多核性能。</p><h2 id="2-内存的重要性"><a href="#2-内存的重要性" class="headerlink" title="2.内存的重要性"></a>2.内存的重要性</h2><p>内存大小直接反映数据库的性能。Innodb存储引擎既缓存数据，又缓存索引，并且将它们缓存于一个很大的缓冲池中，即InnoDB Buffer Pool。因此，内存的大小直接影像数据库的性能。</p><h2 id="3-磁盘对数据库性能的影响"><a href="#3-磁盘对数据库性能的影响" class="headerlink" title="3.磁盘对数据库性能的影响"></a>3.磁盘对数据库性能的影响</h2><h2 id="4-合理设置RAID类型"><a href="#4-合理设置RAID类型" class="headerlink" title="4.合理设置RAID类型"></a>4.合理设置RAID类型</h2><h2 id="5-操作系统的选择"><a href="#5-操作系统的选择" class="headerlink" title="5.操作系统的选择"></a>5.操作系统的选择</h2><h2 id="6-文件系统的选择"><a href="#6-文件系统的选择" class="headerlink" title="6.文件系统的选择"></a>6.文件系统的选择</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十]Explain&amp;optimizer trace</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%5DExplain&amp;optimizer%20trace/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%5DExplain&amp;optimizer%20trace/</url>
      
        <content type="html"><![CDATA[<h1 id="一，Explain"><a href="#一，Explain" class="headerlink" title="一，Explain"></a>一，Explain</h1><p>一条查询语句在经过<code>MySQL</code>查询优化器的各种基于成本和规则的优化会后生成一个所谓的<code>执行计划</code>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个<code>EXPLAIN</code>，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280260945-c936b3bf-33bc-4f56-8d2c-3b3a37fe7a08.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63d468a1&margin=%5Bobject%20Object%5D&name=1.png&originHeight=112&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3820&status=done&style=none&taskId=u13c516c3-ac6f-4988-8981-5ccc1136386&title=" alt="1.png"></p><p>其实除了以<code>SELECT</code>开头的查询语句，其余的<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>以及<code>UPDATE</code>语句前边都可以加上<code>EXPLAIN</code>这个词儿，用来查看这些语句的执行计划，不过我们这里对<code>SELECT</code>语句更感兴趣，所以后边只会以<code>SELECT</code>语句为例来描述<code>EXPLAIN</code>语句的用法。我们先把<code>EXPLAIN</code>语句输出的各个列的作用先大致罗列一下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td></tr><tr><td><code>select_type</code></td><td><code>SELECT</code>关键字对应的那个查询的类型</td></tr><tr><td><code>table</code></td><td>表名</td></tr><tr><td><code>partitions</code></td><td>匹配的分区信息</td></tr><tr><td><code>type</code></td><td>针对单表的访问方法</td></tr><tr><td><code>possible_keys</code></td><td>可能用到的索引</td></tr><tr><td><code>key</code></td><td>实际上使用的索引</td></tr><tr><td><code>key_len</code></td><td>实际使用到的索引长度</td></tr><tr><td><code>ref</code></td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td><code>rows</code></td><td>预估的需要读取的记录条数</td></tr><tr><td><code>filtered</code></td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td><code>Extra</code></td><td>一些额外的信息</td></tr></tbody></table><p>我们前面创建过一张<code>single_table</code>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="1-执行计划输出中各列详解"><a href="#1-执行计划输出中各列详解" class="headerlink" title="1.执行计划输出中各列详解"></a>1.执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。所以我们看一条比较简单的查询语句：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280274365-43dda4af-2f66-465c-abfb-647b465bc8b3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u078f92e2&margin=%5Bobject%20Object%5D&name=2.png&originHeight=121&originWidth=950&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4213&status=done&style=none&taskId=ue1f9160c-2764-48a6-9c06-4df370be589&title=" alt="2.png"></p><p>这个查询语句只涉及对<code>s1</code>表的单表查询，所以<code>EXPLAIN</code>输出中只有一条记录，其中的<code>table</code>列的值是<code>s1</code>，表明这条记录是用来说明对<code>s1</code>表的单表访问方法的。</p><p>下边我们看一下一个连接查询的执行计划：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280282078-c817d0b7-eec8-4fac-b9ee-bfcde6afb3ff.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u198071a8&margin=%5Bobject%20Object%5D&name=3.png&originHeight=129&originWidth=1199&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5766&status=done&style=none&taskId=ufd1691fc-bc9e-4bf2-b272-a981164853f&title=" alt="3.png"></p><p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的<code>table</code>列分别是<code>s1</code>和<code>s2</code>，这两条记录用来分别说明对<code>s1</code>表和<code>s2</code>表的访问方法是什么。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>我们知道我们写的查询语句一般都以<code>SELECT</code>关键字开头，比较简单的查询语句里只有一个<code>SELECT</code>关键字，比如下边这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>稍微复杂一点的连接查询中也只有一个<code>SELECT</code>关键字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>但是下边两种情况下在一条查询语句中会出现多个<code>SELECT</code>关键字：</p><ul><li><p> 查询中包含子查询的情况<br>比如下边这个查询语句中就包含2个<code>SELECT</code>关键字：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT key3 FROM s2);</span><br></pre></td></tr></table></figure></li><li><p> 查询中包含<code>UNION</code>语句的情况<br>比如下边这个查询语句中也包含2个<code>SELECT</code>关键字：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1  UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li></ul><p>查询语句中每出现一个<code>SELECT</code>关键字，<code>MySQL</code>就会为它分配一个唯一的<code>id</code>值。这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下边这个查询中只有一个<code>SELECT</code>关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280291489-d6fd669d-dbf3-4054-a672-8352fce214a2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4dfdf582&margin=%5Bobject%20Object%5D&name=4.png&originHeight=122&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9275&status=done&style=none&taskId=u460df76a-a444-4d5b-a7ca-7d7a5c7026b&title=" alt="4.png"></p><p>对于连接查询来说，一个<code>SELECT</code>关键字后边的<code>FROM</code>子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280298828-57ae0bb0-9f11-4fc1-a716-dcd5b9fb003b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue0905b12&margin=%5Bobject%20Object%5D&name=5.png&originHeight=141&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12198&status=done&style=none&taskId=u9124e447-4620-4012-9fbc-82044c4a955&title=" alt="5.png"></p><p>可以看到，上述连接查询中参与连接的<code>s1</code>和<code>s2</code>表分别对应一条记录，但是这两条记录对应的<code>id</code>值都是<code>1</code>。在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，<strong>出现在前边的表表示驱动表，出现在后边的表表示被驱动表</strong>。所以从上边的<code>EXPLAIN</code>输出中我们可以看出，查询优化器准备让<code>s1</code>表作为驱动表，让<code>s2</code>表作为被驱动表来执行查询。</p><p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值，比如这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280305890-e78bef80-48fd-4ace-805c-cb03ea315780.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u515a991c&margin=%5Bobject%20Object%5D&name=6.png&originHeight=137&originWidth=1276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13575&status=done&style=none&taskId=ub9ed2c7d-641b-4e47-ba2e-ed467048a13&title=" alt="6.png"></p><p>从输出结果中我们可以看到，<code>s1</code>表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是<code>1</code>，<code>s2</code>表在子查询中，子查询有一个独立的<code>SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280313651-8d89c1be-d533-4331-bbb7-e2d48b436318.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u776fd7cc&margin=%5Bobject%20Object%5D&name=7.png&originHeight=158&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16676&status=done&style=none&taskId=ub79395b5-7ac6-4798-a418-550eee0aadc&title=" alt="7.png"></p><p>虽然我们的查询语句是一个子查询，但是执行计划中<code>s1</code>和<code>s2</code>表对应的记录的<code>id</code>值全部是<code>1</code>，这就表明了查询优化器将子查询转换为了连接查询。</p><p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280321427-124e6217-466a-41c2-9363-d807856fadb7.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6436d0a7&margin=%5Bobject%20Object%5D&name=8.png&originHeight=176&originWidth=1360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14950&status=done&style=none&taskId=u50a3e117-c91d-420f-a8b4-31af4e2b3c2&title=" alt="8.png"></p><p>这个语句的执行计划的第三条记录是个什么？为什么<code>id</code>值是<code>NULL</code>，而且<code>table</code>名也不大对？<code>UNION</code>子句会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？<code>MySQL</code>使用的是内部的临时表。正如上边的查询计划中所示，<code>UNION</code>子句是为了把<code>id</code>为<code>1</code>的查询和<code>id</code>为<code>2</code>的查询的结果集合并起来并去重，所以在内部创建了一个临时表（就是执行计划第三条记录的<code>table</code>列的名称），<code>id</code>为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p><p>跟<code>UNION</code>对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个<code>id</code>为<code>NULL</code>的记录，如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280329103-1d10728f-1cb6-424c-afc2-a6998f2ba02d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9423ac3e&margin=%5Bobject%20Object%5D&name=9.png&originHeight=146&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10897&status=done&style=none&taskId=u493e7dd0-542c-4a70-9c7b-7298631abd7&title=" alt="9.png"></p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>通过上边的内容我们知道，一条大的查询语句里边可以包含若干个<code>SELECT</code>关键字，每个<code>SELECT</code>关键字代表着一个小的查询语句，而每个<code>SELECT</code>关键字的<code>FROM</code>子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个<code>SELECT</code>关键字中的表来说，它们的<code>id</code>值是相同的。</p><p><code>MySQL</code>为每一个<code>SELECT</code>关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中有什么作用。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td>Simple SELECT (not using UNION or subqueries)</td></tr><tr><td><code>PRIMARY</code></td><td>Outermost SELECT</td></tr><tr><td><code>UNION</code></td><td>Second or later SELECT statement in a UNION</td></tr><tr><td><code>UNION RESULT</code></td><td>Result of a UNION</td></tr><tr><td><code>SUBQUERY</code></td><td>First SELECT in subquery</td></tr><tr><td><code>DEPENDENT SUBQUERY</code></td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td><code>DEPENDENT UNION</code></td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td><code>DERIVED</code></td><td>Derived table</td></tr><tr><td><code>MATERIALIZED</code></td><td>Materialized subquery</td></tr><tr><td><code>UNCACHEABLE SUBQUERY</code></td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td><code>UNCACHEABLE UNION</code></td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><ul><li> <code>SIMPLE</code><br>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询的<code>select_type</code>的值就是<code>SIMPLE</code>：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280337218-078fa344-d1da-4a52-857b-352ecb12cddc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufffa3027&margin=%5Bobject%20Object%5D&name=10.png&originHeight=146&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9907&status=done&style=none&taskId=u2df9f156-ab20-4e89-8136-9585d85cba1&title=" alt="10.png"><br>当然，连接查询也算是<code>SIMPLE</code>类型，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280343184-8c2e7e4c-f85b-4bb0-b45f-4325497a7ebd.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63b97864&margin=%5Bobject%20Object%5D&name=11.png&originHeight=158&originWidth=1512&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14164&status=done&style=none&taskId=ud077b5f1-886a-44b5-abcd-76bdbfe08d7&title=" alt="11.png"> </li><li> <code>PRIMARY</code><br>对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280350857-4dfa730e-2b7c-4e94-825e-742a49f2b9e3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3fe99956&margin=%5Bobject%20Object%5D&name=12.png&originHeight=173&originWidth=1331&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14928&status=done&style=none&taskId=u8c6000b8-3cf9-48d9-9447-09224347660&title=" alt="12.png"><br>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是<code>PRIMARY</code>。 </li><li> <code>UNION</code><br>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>，可以对比上一个例子的效果，这就不多举例子了。 </li><li> <code>UNION RESULT</code><br><code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上边有，就不赘述了。 </li><li> <code>SUBQUERY</code><br>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280358319-9d411906-99c1-4214-a731-b31a6fa6487b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udf5c0430&margin=%5Bobject%20Object%5D&name=13.png&originHeight=154&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14997&status=done&style=none&taskId=u59a4d22d-11c4-4b80-b1d8-042fb9c3db7&title=" alt="13.png"><br>可以看到，外层查询的<code>select_type</code>就是<code>PRIMARY</code>，子查询的<code>select_type</code>就是<code>SUBQUERY</code>。由于select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。 </li><li> <code>DEPENDENT SUBQUERY</code><br>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280367090-997cc1b5-ef45-43b8-a298-68a707d7fcac.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b271730&margin=%5Bobject%20Object%5D&name=14.png&originHeight=154&originWidth=1433&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15238&status=done&style=none&taskId=uc46092db-b61b-4abe-b1e5-fdd03ca496e&title=" alt="14.png"></li></ul><p><strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次。</strong> </p><ul><li><p> <code>DEPENDENT UNION</code><br>在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。说的有些绕哈，比方说下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280375650-6efa28fa-5b07-4b2b-a936-51dc06e0687e.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub4c42a77&margin=%5Bobject%20Object%5D&name=15.png&originHeight=176&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21604&status=done&style=none&taskId=u977e1294-949c-4a21-a61e-32deb74d580&title=" alt="15.png"><br>这个查询比较复杂，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = &#39;a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = &#39;b&#39;</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。 </p></li><li><p> <code>DERIVED</code><br>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280385622-887431a3-4aed-4d36-829d-508ee28a1baa.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua247020c&margin=%5Bobject%20Object%5D&name=16.png&originHeight=163&originWidth=1336&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15817&status=done&style=none&taskId=u8f8c12bc-ad97-4e22-aac9-53a038d858f&title=" alt="16.png"><br>从执行计划中可以看出，<code>id</code>为<code>2</code>的记录就代表子查询的执行方式，它的<code>select_type</code>是<code>DERIVED</code>，说明该子查询是以物化的方式执行的。<code>id</code>为<code>1</code>的记录代表外层查询，它的<code>table</code>列显示的是``，表示该查询是针对将派生表物化之后的表进行查询的。  </p><blockquote><p>如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象。</p></blockquote></li><li><p> <code>MATERIALIZED</code><br>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280393291-f5462583-d221-4f0e-962a-a44c8ce95477.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u38a01fd0&margin=%5Bobject%20Object%5D&name=17.png&originHeight=170&originWidth=1455&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17733&status=done&style=none&taskId=u66eebaeb-7470-4f0c-a238-d04e43892d3&title=" alt="17.png"><br>执行计划的第三条记录的<code>id</code>值为<code>2</code>，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为<code>MATERIALIZED</code>可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的<code>id</code>值都为<code>1</code>，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是``，说明该表其实就是<code>id</code>为<code>2</code>对应的子查询执行之后产生的物化表，然后将<code>s1</code>和该物化表进行连接查询。 </p></li><li><p> <code>UNCACHEABLE SUBQUERY</code><br>不常用 </p></li><li><p> <code>UNCACHEABLE UNION</code><br>不常用 </p></li></ul><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>一般情况下我们的查询语句的执行计划的<code>partitions</code>列的值都是<code>NULL</code>。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>执行计划的一条记录就代表着<code>MySQL</code>对某个表的执行查询时的访问方法，其中的<code>type</code>列就表明了这个访问方法是什么，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280402792-2ed1ee54-de24-42de-8f8d-4ec2f861dcd5.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubaa6a847&margin=%5Bobject%20Object%5D&name=18.png&originHeight=141&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10843&status=done&style=none&taskId=u694e9953-97ca-4705-9136-ec6a7dc3196&title=" alt="18.png"></p><p>可以看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。但是我们之前只分析过对使用<code>InnoDB</code>存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。接下来我们详细看一下：</p><ul><li><p> <code>system</code><br>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：<br>然后我们看一下查询这个表的执行计划：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280410379-02b98490-4259-4af4-bd20-c465d0b6bebd.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u85f77e9b&margin=%5Bobject%20Object%5D&name=19.png&originHeight=130&originWidth=1179&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8957&status=done&style=none&taskId=u998b055a-ccec-41f7-8e2e-097010b188d&title=" alt="19.png"><br>可以看到<code>type</code>列的值就是<code>system</code>了。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>把表改成使用InnoDB存储引擎，执行计划的type列是ALL。</p></blockquote></li><li><p> <code>const</code><br>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280418708-2e9e505a-c985-45fa-8518-44c27fc83979.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7438f4f7&margin=%5Bobject%20Object%5D&name=20.png&originHeight=133&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10419&status=done&style=none&taskId=ubcd36136-b889-4eac-aefb-c68f5da874a&title=" alt="20.png"> </p></li><li><p> <code>eq_ref</code><br>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280456161-049d60a4-d6da-46b2-91fe-9b2661fa1d36.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0c6b2463&margin=%5Bobject%20Object%5D&name=21.png&originHeight=158&originWidth=1264&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13498&status=done&style=none&taskId=ue5cce22c-1ad7-46d1-82c7-559db693de7&title=" alt="21.png"><br>从执行计划的结果中可以看出，<code>MySQL</code>打算将<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表，重点关注<code>s2</code>的访问方法是<code>eq_ref</code>，表明在访问<code>s2</code>表的时候可以通过主键的等值匹配来进行访问。 </p></li><li><p> <code>ref</code><br>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>。 </p></li><li><p> <code>fulltext</code><br>全文索引,意义不大。 </p></li><li><p> <code>ref_or_null</code><br>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280463125-26170cb7-ba4b-4933-a004-8c346961b5da.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufa9a4774&margin=%5Bobject%20Object%5D&name=22.png&originHeight=141&originWidth=1422&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12130&status=done&style=none&taskId=u6b7b7747-acae-4a15-adf5-d446fbbb6c0&title=" alt="22.png"> </p></li><li><p> <code>index_merge</code><br>在某些场景下可以使用<code>Intersection</code>、<code>Union</code>、<code>Sort-Union</code>这三种索引合并的方式来执行查询，我们看一下执行计划中是怎么体现<code>MySQL</code>使用索引合并的方式来对某个表执行查询的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280470378-3882e0be-f91d-44c0-a7b9-a979adc93085.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue18487eb&margin=%5Bobject%20Object%5D&name=23.png&originHeight=130&originWidth=1806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18097&status=done&style=none&taskId=u3aaf69a0-df90-4b3e-a75d-7f161bc37f0&title=" alt="23.png"><br>从执行计划的<code>type</code>列的值是<code>index_merge</code>就可以看出，<code>MySQL</code>打算使用索引合并的方式来执行对<code>s1</code>表的查询。 </p></li><li><p> <code>unique_subquery</code><br>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280477014-ddc7ace3-5261-47a3-956c-3acce84f20dc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0d35569a&margin=%5Bobject%20Object%5D&name=24.png&originHeight=138&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15149&status=done&style=none&taskId=ub0da4c73-db17-427c-b87b-e059de96b1b&title=" alt="24.png"><br>可以看到执行计划的第二条记录的<code>type</code>值就是<code>unique_subquery</code>，说明在执行子查询时会使用到<code>id</code>列的索引。 </p></li><li><p> <code>index_subquery</code><br><code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280483868-ff7a1815-8c05-4a2f-94e7-79b880cea954.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue020d52f&margin=%5Bobject%20Object%5D&name=25.png&originHeight=148&originWidth=1457&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16363&status=done&style=none&taskId=u2782b719-e96b-4afa-bb75-8eb977622af&title=" alt="25.png"> </p></li><li><p> <code>range</code><br>如果使用索引获取某些<code>范围区间</code>的记录，那么就可能使用到<code>range</code>访问方法，比如下边的这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280490568-7cef7a7c-7acf-4be1-9c08-5b6da950acfc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08f05ea8&margin=%5Bobject%20Object%5D&name=26.png&originHeight=143&originWidth=1371&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11837&status=done&style=none&taskId=u99904bc8-68ad-4658-a5fc-b5851815429&title=" alt="26.png"><br>或者：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280496929-e1318302-934b-4bda-b7a4-8a858c278403.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u14fae300&margin=%5Bobject%20Object%5D&name=27.png&originHeight=117&originWidth=1355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10119&status=done&style=none&taskId=u13e335fa-04ea-4d0e-861b-045a44df8c6&title=" alt="27.png"> </p></li><li><p> <code>index</code><br>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280502811-c5c73a14-cb70-410e-9997-eb5296fe7ead.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9d0bfa53&margin=%5Bobject%20Object%5D&name=28.png&originHeight=129&originWidth=1445&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11338&status=done&style=none&taskId=u8ea5271b-21e8-4dfe-b21f-f9b7cce2e5a&title=" alt="28.png"><br>上述查询中的搜索列表中只有<code>key_part2</code>一个列，而且搜索条件中也只有<code>key_part3</code>一个列，这两个列又恰好包含在<code>idx_key_part</code>这个索引中，可是搜索条件<code>key_part3</code>不能直接使用该索引进行<code>ref</code>或者<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。  </p><blockquote><p>对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></blockquote></li><li><p> <code>ALL</code><br>最熟悉的全表扫描直接看例子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280509611-e1909546-52e6-44eb-a2ad-bc9422cf1521.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8e1ce447&margin=%5Bobject%20Object%5D&name=29.png&originHeight=136&originWidth=1172&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9873&status=done&style=none&taskId=ucadc9702-0049-4b37-bcc0-a6e180d38b3&title=" alt="29.png"> </p></li></ul><p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引。</p><h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p>在<code>EXPLAIN</code>语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280516466-778cee1a-3912-45ce-b8b0-961fde6131b2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8c4c0e4c&margin=%5Bobject%20Object%5D&name=30.png&originHeight=135&originWidth=1311&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11553&status=done&style=none&taskId=u20dfc39d-6030-42fa-8480-2d27b8ab68a&title=" alt="30.png"></p><p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1,idx_key3</code>，表示该查询可能使用到<code>idx_key1,idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code>来执行查询比较划算。</p><p>不过有一点比较特别，就是在使用<code>index</code>访问方法来查询某个表时，<code>possible_keys</code>列是空的，而<code>key</code>列展示的是实际使用到的索引，比如这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280523465-50db2fcf-3aab-459d-bd56-9fe94cfef62d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u709cacbf&margin=%5Bobject%20Object%5D&name=31.png&originHeight=133&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11806&status=done&style=none&taskId=u7d4f3316-a2df-450a-82f1-e9dc395c5d1&title=" alt="31.png"></p><p>另外需要注意的一点是，possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p><ol><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</li><li>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ol><p>比如下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280530011-7d5e65ca-3e73-4ce5-9cd7-30e30fca150d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u37395cf6&margin=%5Bobject%20Object%5D&name=32.png&originHeight=126&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10064&status=done&style=none&taskId=u620f6e76-7540-4994-b49b-8ecb5d6c62a&title=" alt="32.png"></p><p>由于<code>id</code>列的类型是<code>INT</code>，并且不可以存储<code>NULL</code>值，所以在使用该列的索引时<code>key_len</code>大小就是<code>4</code>。当索引列可以存储<code>NULL</code>值时，比如：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280536833-34a98995-bbb1-4f5b-9c65-cd883418fbd2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u91c8ee45&margin=%5Bobject%20Object%5D&name=33.png&originHeight=132&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10328&status=done&style=none&taskId=uf7c83065-c654-47e4-886d-3e1fc98b6e8&title=" alt="33.png"></p><p>可以看到<code>key_len</code>列就变成了<code>5</code>，比使用<code>id</code>列的索引时多了<code>1</code>。</p><p>对于可变长度的索引列来说，比如下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280547140-fea8d226-3465-4e13-b93d-0e74882cf422.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc8b9f40b&margin=%5Bobject%20Object%5D&name=34.png&originHeight=137&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10837&status=done&style=none&taskId=ubc579fb7-242e-4242-844b-50635088a6d&title=" alt="34.png"></p><p>由于<code>key1</code>列的类型是<code>VARCHAR(100)</code>，所以该列实际最多占用的存储空间就是<code>300</code>字节，又因为该列允许存储<code>NULL</code>值，所以<code>key_len</code>需要加<code>1</code>，又因为该列是可变长度列，所以<code>key_len</code>需要加<code>2</code>，所以最后<code>ken_len</code>的值就是<code>303</code>。</p><p>这里需要强调的一点是，执行计划的生成是在<code>MySQL server</code>层中的功能，并不是针对具体某个存储引擎的功能，<code>MySQL</code>在执行计划中输出<code>key_len</code>列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列，而不是为了准确的说明针对某个具体存储引擎存储变长字段的实际长度占用的空间到底是占用1个字节还是2个字节。比方说下边这个使用到联合索引<code>idx_key_part</code>的查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280574627-423abda2-7282-4686-850d-158ee23ceef0.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue80e815d&margin=%5Bobject%20Object%5D&name=35.png&originHeight=135&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11390&status=done&style=none&taskId=ua1103849-bb46-4d1e-bfe7-d43baa19357&title=" alt="35.png"></p><p>我们可以从执行计划的<code>key_len</code>列中看到值是<code>303</code>，这意味着<code>MySQL</code>在执行上述查询中只能用到<code>idx_key_part</code>索引的一个索引列，而下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280584178-4d046ed5-9399-46e8-acf8-c4dba1e88a44.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufe6bdb41&margin=%5Bobject%20Object%5D&name=36.png&originHeight=148&originWidth=1310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11956&status=done&style=none&taskId=u5a6a7a9e-56f9-4f90-b3e3-3ccce6aeeb1&title=" alt="36.png"></p><p>这个查询的执行计划的<code>ken_len</code>列的值是<code>606</code>，说明执行这个查询的时候可以用到联合索引<code>idx_key_part</code>的两个索引列。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280639189-65511db0-6781-43a2-a189-da56d4a39d06.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3e0a564f&margin=%5Bobject%20Object%5D&name=37.png&originHeight=137&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10813&status=done&style=none&taskId=ubf40913d-f7f9-48b6-a1bc-22be2439bce&title=" alt="37.png"></p><p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280647362-c56ac11e-c810-49b1-b6ef-74142632a2f3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2efc95bd&margin=%5Bobject%20Object%5D&name=38.png&originHeight=151&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13438&status=done&style=none&taskId=u78dba58c-d2a6-4a38-8342-d8829ff9213&title=" alt="38.png"></p><p>可以看到对被驱动表<code>s2</code>的访问方法是<code>eq_ref</code>，而对应的<code>ref</code>列的值是<code>yhd.s1.id</code>，这说明在对被驱动表进行访问时会用到<code>PRIMARY</code>索引，也就是聚簇索引与一个列进行等值匹配的条件，于<code>s2</code>表的<code>id</code>作等值匹配的对象就是<code>yhd.s1.id</code>列（注意这里把数据库名也写出来了）。</p><p>有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280654511-c4a8f217-0578-4a32-b78c-1b61a2160364.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u11c13c47&margin=%5Bobject%20Object%5D&name=39.png&originHeight=152&originWidth=1372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14314&status=done&style=none&taskId=u9c0c9cba-8fec-41c7-82d0-9469e60fcc2&title=" alt="39.png"></p><p>我们看执行计划的第二条记录，可以看到对<code>s2</code>表采用<code>ref</code>访问方法执行查询，然后在查询计划的<code>ref</code>列里输出的是<code>func</code>，说明与<code>s2</code>表的<code>key1</code>列进行等值匹配的对象是一个函数。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。比如下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280662371-b8621d39-7404-4335-8b6f-6ac3bf020927.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubdf57c66&margin=%5Bobject%20Object%5D&name=40.png&originHeight=144&originWidth=1362&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11525&status=done&style=none&taskId=u502bf400-c9d0-4d98-a90c-01d6e656856&title=" alt="40.png"></p><p>我们看到执行计划的<code>rows</code>列的值是<code>1</code>，这意味着查询优化器在经过分析使用<code>idx_key1</code>进行查询的成本之后，觉得满足<code>key1 &gt; &#39;z&#39;</code>这个条件的记录只有<code>1</code>条。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>之前在分析连接查询的成本时提出过一个<code>condition filtering</code>的概念，就是<code>MySQL</code>在计算驱动表扇出时采用的一个策略：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p>比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280695851-4f237801-1121-4cce-935d-8d124f691b30.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08ebf4a7&margin=%5Bobject%20Object%5D&name=41.png&originHeight=139&originWidth=1507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12747&status=done&style=none&taskId=uef9d60d8-c348-4d80-a2f2-29ebce41900&title=" alt="41.png"></p><p>从执行计划的<code>key</code>列中可以看出来，该查询使用<code>idx_key1</code>索引来执行查询，从<code>rows</code>列可以看出满足<code>key1 &gt; &#39;z&#39;</code>的记录有<code>1</code>条。执行计划的<code>filtered</code>列就代表查询优化器预测在这<code>1</code>条记录中，有多少条记录满足其余的搜索条件，也就是<code>common_field = &#39;a&#39;</code>这个条件的百分比。此处<code>filtered</code>列的值是<code>10.00</code>，说明查询优化器预测在<code>1</code>条记录中有<code>10.00%</code>的记录满足<code>common_field = &#39;a&#39;</code>这个条件。</p><p>对于单表查询来说，这个<code>filtered</code>列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的<code>filtered</code>值，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280702717-5e6276df-2775-4dd9-9068-168632a6e891.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua075a642&margin=%5Bobject%20Object%5D&name=42.png&originHeight=159&originWidth=1359&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15418&status=done&style=none&taskId=u2ce577e9-11ca-4213-8c24-e76cc816cc0&title=" alt="42.png"></p><p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>当作驱动表，<code>s2</code>当作被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>997219</code>， <code>filtered</code>列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>997219 × 10.00% = 99721.9</code>，这说明还要对被驱动表执行大约<code>99721.9</code>次查询。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解<code>MySQL</code>到底将如何执行给定的查询语句。</p><ul><li><p> <code>No tables used</code><br>当查询语句的没有<code>FROM</code>子句时将会提示该额外信息，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280709963-b0a3875e-f1e9-4112-928c-5a2509c69a1c.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0af38ec6&margin=%5Bobject%20Object%5D&name=43.png&originHeight=137&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8351&status=done&style=none&taskId=ub8c0c8c7-6dd1-436a-a457-2a8f3fd0a43&title=" alt="43.png"> </p></li><li><p> <code>Impossible WHERE</code><br>查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280716070-b375d8db-fab7-411f-b6c3-fdb1cb8a2b68.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u62a56c70&margin=%5Bobject%20Object%5D&name=44.png&originHeight=140&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10429&status=done&style=none&taskId=u3592d4c4-8b55-4c36-ab4c-19bfcb10f2a&title=" alt="44.png"> </p></li><li><p> <code>No matching min/max row</code><br>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚集函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280722423-8f00c35d-e352-4e4f-9ad0-06344f87d7be.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uae911a2d&margin=%5Bobject%20Object%5D&name=45.png&originHeight=133&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10632&status=done&style=none&taskId=uc25dd0ec-cd40-4efa-b32b-289e0c6a293&title=" alt="45.png"> </p></li><li><p> <code>Using index</code><br>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280729248-e8d19929-5057-4e2b-92b5-4f0815d42951.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uca03b967&margin=%5Bobject%20Object%5D&name=46.png&originHeight=137&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10748&status=done&style=none&taskId=u4ef056f1-92c6-4c14-8947-39aa551837d&title=" alt="46.png"> </p></li><li><p><code>Using index condition</code><br>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：<br>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的<code>MySQL</code>中，是按照下边步骤来执行这个查询的： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</li><li>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</li></ul></li></ul><p>但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以<code>MySQL</code>把上边的步骤改进了一下： </p><ul><li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</li><li>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</li><li>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</li></ul><p>我们说回表操作其实是一个随机<code>IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。<code>MySQL</code>把他们的这个改进称之为<code>索引条件下推</code>（英文名：<code>Index Condition Pushdown</code>）。<br>如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在<code>Extra</code>列中将会显示<code>Using index condition</code>，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280739039-b867ce7b-7772-4c60-ad85-de88f84dfc95.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5f7b5a5f&margin=%5Bobject%20Object%5D&name=47.png&originHeight=150&originWidth=1355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12096&status=done&style=none&taskId=u108c9eb7-bb19-4820-a2c3-34bdae80479&title=" alt="47.png"></p><ul><li><p> <code>Using where</code><br>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280745116-15cf2e92-4bc6-4896-a114-a08fd4f149f1.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue69355bd&margin=%5Bobject%20Object%5D&name=48.png&originHeight=142&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11283&status=done&style=none&taskId=u5bca1059-5304-4173-a759-fe3383de92f&title=" alt="48.png"><br>当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在<code>Extra</code>列中也会提示上述额外信息。比如下边这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1 = &#39;a&#39;</code>，还有包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280750980-0af4ffa5-7801-40ed-b434-60cf04e53c39.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6328631b&margin=%5Bobject%20Object%5D&name=49.png&originHeight=139&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11868&status=done&style=none&taskId=u78e29b4d-4d4a-49e1-85b3-0469f52cbfc&title=" alt="49.png"> </p></li><li><p><code>Using join buffer (Block Nested Loop)</code><br>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>，比如下边这个查询语句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280756935-cbffc56a-f033-486c-bc9e-2a4b45faffc3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u66ccbdd4&margin=%5Bobject%20Object%5D&name=50.png&originHeight=197&originWidth=1615&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16002&status=done&style=none&taskId=u33176016-e036-4aa1-a1e2-fb9469510e0&title=" alt="50.png"><br>可以在对<code>s2</code>表的执行计划的<code>Extra</code>列显示了两个提示： </p><ul><li><code>Using join buffer (Block Nested Loop)</code>：这是因为对表<code>s2</code>的访问不能有效利用索引，只好退而求其次，使用<code>join buffer</code>来减少对<code>s2</code>表的访问次数，从而提高性能。</li><li><code>Using where</code>：可以看到查询语句中有一个<code>s1.common_field = s2.common_field</code>条件，因为<code>s1</code>是驱动表，<code>s2</code>是被驱动表，所以在访问<code>s2</code>表时，<code>s1.common_field</code>的值已经确定下来了，所以实际上查询<code>s2</code>表的条件就是<code>s2.common_field = 一个常数</code>，所以提示了<code>Using where</code>额外信息。</li></ul></li><li><p> <code>Not exists</code><br>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的<code>Extra</code>列就会提示<code>Not exists</code>额外信息，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280765248-adc53a64-08e5-4047-9282-dedf49c0ba53.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud66d86bd&margin=%5Bobject%20Object%5D&name=51.png&originHeight=168&originWidth=1735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20626&status=done&style=none&taskId=ue194205d-192b-4293-96ba-cbbb11125a2&title=" alt="51.png"><br>上述查询中<code>s1</code>表是驱动表，<code>s2</code>表是被驱动表，<code>s2.id</code>列是不允许存储<code>NULL</code>值的，而<code>WHERE</code>子句中又包含<code>s2.id IS NULL</code>的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配<code>ON</code>子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合<code>ON</code>子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们没有必要到被驱动表中找到全部符合ON子句条件的记录，这样可以稍微节省一点性能。  </p><blockquote><p>右（外）连接可以被转换为左（外）连接，所以就不提右（外）连接的情况了。</p></blockquote></li><li><p> <code>Using intersect(...)</code>、<code>Using union(...)</code>和<code>Using sort_union(...)</code><br>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。比如这个查询的执行计划：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280772463-3a90c8d1-6545-4018-b8d7-5025f232d7ee.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ueda5799e&margin=%5Bobject%20Object%5D&name=52.png&originHeight=143&originWidth=1303&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11849&status=done&style=none&taskId=u894c398e-c275-41a7-8968-5e3e310bd43&title=" alt="52.png"><br>其中<code>Extra</code>列就显示了<code>Using intersect(idx_key3,idx_key1)</code>，表明<code>MySQL</code>即将使用<code>idx_key3</code>和<code>idx_key1</code>这两个索引进行<code>Intersect</code>索引合并的方式执行查询。 </p></li><li><p> <code>Zero limit</code><br>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示不打算从表中读出任何记录，将会提示该额外信息，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280778887-9254ccb9-15d2-4dca-ae74-454146fcd5bc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u805e1066&margin=%5Bobject%20Object%5D&name=53.png&originHeight=153&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9929&status=done&style=none&taskId=ud78823f5-06ba-40ce-b3b7-d471c6eb90f&title=" alt="53.png"> </p></li><li><p> <code>Using filesort</code><br>有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280785452-754d9c90-0fa1-49ec-889c-dc8cf142399b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u231ab400&margin=%5Bobject%20Object%5D&name=54.png&originHeight=154&originWidth=1214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11063&status=done&style=none&taskId=u9983daa3-8d15-47c4-aeea-15b73d0dcc1&title=" alt="54.png"><br>这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，<code>MySQL</code>把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280791344-a71710e6-a915-4788-bc09-688eec1a399b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7aa08f31&margin=%5Bobject%20Object%5D&name=55.png&originHeight=148&originWidth=1290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11614&status=done&style=none&taskId=u5f2f6bce-bad5-4b54-8664-8d144260c1a&title=" alt="55.png"><br>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用<code>文件排序</code>的执行方式改为使用索引进行排序。 </p></li><li><p> <code>Using temporary</code><br>在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280797689-75d2cb3d-3866-480c-bf4e-8a69e479536f.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u286716ac&margin=%5Bobject%20Object%5D&name=56.png&originHeight=151&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11377&status=done&style=none&taskId=u4ce60cde-24ba-4663-aadd-a4e68b73f0d&title=" alt="56.png"><br>再比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280803837-7d795aa0-fd17-4d87-9ab0-07c295f5e7c9.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue7b2c60b&margin=%5Bobject%20Object%5D&name=57.png&originHeight=149&originWidth=1425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12625&status=done&style=none&taskId=ub9d1b398-3b4f-4f73-a1ee-342d85bf749&title=" alt="57.png"><br>不知道大家注意到没有，上述执行计划的<code>Extra</code>列不仅仅包含<code>Using temporary</code>提示，还包含<code>Using filesort</code>提示，可是我们的查询语句中明明没有写<code>ORDER BY</code>子句呀？这是因为<code>MySQL</code>会在包含<code>GROUP BY</code>子句的查询中默认添加上<code>ORDER BY</code>子句，也就是说上述查询其实和下边这个查询等价：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY common_field;</span><br></pre></td></tr></table></figure></li></ul><p>如果我们并不想为包含GROUP BY子句的查询进行排序，需要我们显式的写上ORDER BY NULL，就像这样：<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280846631-90d86605-c8b9-4548-b10d-b44be5d9335f.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u822663e5&margin=%5Bobject%20Object%5D&name=58.png&originHeight=150&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12514&status=done&style=none&taskId=u61a5fe59-aa4c-4df4-b86a-5d5c7d5c8fe&title=" alt="58.png"><br>​</p><p>这回执行计划中就没有Using filesort的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。<br>​</p><p>另外，执行计划中出现Using temporary并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含GROUP BY子句的查询就不需要使用临时表：<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280856295-6e72f854-6076-48fe-9766-4b8dd70a434c.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uaf5517ea&margin=%5Bobject%20Object%5D&name=59.png&originHeight=136&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11837&status=done&style=none&taskId=ucb545596-9525-4ce1-ab15-e96493d37f6&title=" alt="59.png"><br>​</p><p>从Extra的Using index的提示里我们可以看出，上述查询只需要扫描idx_key1索引就可以搞定了，不再需要临时表了。</p><ul><li> <code>Start temporary, End temporary</code><br>查询优化器会优先尝试将<code>IN</code>子查询转换成<code>semi-join</code>，而<code>semi-join</code>又有好多种执行策略，当执行策略为<code>DuplicateWeedout</code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的<code>Extra</code>列将显示<code>Start temporary</code>提示，被驱动表查询执行计划的<code>Extra</code>列将显示<code>End temporary</code>提示，就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280870260-d8109158-d388-4665-87a3-fbc3393cb1e6.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u40bf656b&margin=%5Bobject%20Object%5D&name=60.png&originHeight=180&originWidth=1443&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18905&status=done&style=none&taskId=u60106558-b64a-4cad-8c4c-7e89266b735&title=" alt="60.png"></li><li> <code>LooseScan</code><br>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>LooseScan</code>执行策略，则在驱动表执行计划的<code>Extra</code>列就是显示<code>LooseScan</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280878656-f9849a88-d738-4e61-92fe-71e8fb4b8097.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud020c3be&margin=%5Bobject%20Object%5D&name=61.png&originHeight=182&originWidth=1553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18884&status=done&style=none&taskId=u48e16db1-823b-481d-93b1-641580ba363&title=" alt="61.png"> </li><li> <code>FirstMatch(tbl_name)</code><br>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>FirstMatch</code>执行策略，则在被驱动表执行计划的<code>Extra</code>列就是显示<code>FirstMatch(tbl_name)</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280886946-4cee061e-db5d-429b-9f77-887af2159190.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue6d1ea12&margin=%5Bobject%20Object%5D&name=62.png&originHeight=171&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17585&status=done&style=none&taskId=ue1333208-0342-496e-bc90-8215638090b&title=" alt="62.png"> </li></ul><h2 id="2-Json格式的执行计划"><a href="#2-Json格式的执行计划" class="headerlink" title="2.Json格式的执行计划"></a>2.Json格式的执行计划</h2><p>我们上边介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行计划好坏的重要属性 —— 成本。不过<code>MySQL</code>贴心的为我们提供了一种查看某个执行计划花费的成本的方式：</p><ul><li>在<code>EXPLAIN</code>单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。</li></ul><p>这样我们就可以得到一个<code>json</code>格式的执行计划，里边儿包含该计划花费的成本，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: 1,     # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;3197.16&quot;   # 整个查询的执行成本预计为3197.16</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [    # 几个表之间采用嵌套循环连接算法执行</span><br><span class="line">    </span><br><span class="line">    # 以下是参与嵌套循环连接算法的各个表的信息</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,   # s1表是驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,     # 访问方法为ALL，意味着使用全表扫描访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 9688,   # 查询一次s1表大致需要扫描9688条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 驱动表s1的扇出是968</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,  # condition filtering代表的百分比</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;1840.84&quot;,     # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;2034.60&quot;,   # 单次查询s1表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          </span><br><span class="line">          # 对s1表访问时针对单表查询的条件</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`xiaohaizi`.`s1`.`common_field` = &#x27;a&#x27;) and (`xiaohaizi`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,   # s2表是被驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ref&quot;,     # 访问方法为ref，意味着使用索引等值匹配的方式访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,    # 实际使用的索引</span><br><span class="line">          &quot;used_key_parts&quot;: [   # 使用到的索引列</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,    # key_len</span><br><span class="line">          &quot;ref&quot;: [      # 与key2列进行等值匹配的对象</span><br><span class="line">            &quot;xiaohaizi.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 1,  # 查询一次s2表大致需要扫描1条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,     # condition filtering代表的百分比</span><br><span class="line">          </span><br><span class="line">          # s2表使用索引进行查询的搜索条件</span><br><span class="line">          &quot;index_condition&quot;: &quot;(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;968.80&quot;,      # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;3197.16&quot;,   # 单次查询s1、多次查询s2表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>&quot;cost_info&quot;</code>里边的成本是怎么计算出来的？先看<code>s1</code>表的<code>&quot;cost_info&quot;</code>部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>read_cost</code>是由下边这两部分组成的： </p><ul><li><code>IO</code>成本</li><li>检测<code>rows × (1 - filter)</code>条记录的<code>CPU</code>成本<blockquote><p>rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</p></blockquote></li></ul></li><li><p> <code>eval_cost</code>是这样计算的：<br>检测 <code>rows × filter</code>条记录的成本。 </p></li><li><p> <code>prefix_cost</code>就是单独查询<code>s1</code>表的成本，也就是：<br><code>read_cost + eval_cost</code> </p></li><li><p> <code>data_read_per_join</code>表示在此次查询中需要读取的数据量，我们就不多唠叨这个了。 </p></li></ul><blockquote><p>其实没必要关注MySQL为啥使用这么古怪的方式计算出read_cost和eval_cost，关注prefix_cost是查询s1表的成本就好了。</p></blockquote><p>对于<code>s2</code>表的<code>&quot;cost_info&quot;</code>部分是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;968.80&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;3197.16&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>s2</code>表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code>和<code>eval_cost</code>是访问多次<code>s2</code>表后累加起来的值，主要关注里边儿的<code>prefix_cost</code>的值代表的是整个连接查询预计的成本，也就是单次查询<code>s1</code>表和多次查询<code>s2</code>表后的成本的和，也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure><h2 id="3-Extented-EXPLAIN"><a href="#3-Extented-EXPLAIN" class="headerlink" title="3.Extented EXPLAIN"></a>3.Extented EXPLAIN</h2><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280900493-ef323458-9ed7-4213-a1bd-1b1a606384aa.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf7584cec&margin=%5Bobject%20Object%5D&name=63.png&originHeight=308&originWidth=1560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27815&status=done&style=none&taskId=ub7ecd933-32ca-458a-8f52-efe2fb29519&title=" alt="63.png"></p><p>可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level</code>、<code>Code</code>、<code>Message</code>。我们最常见的就是<code>Code</code>为<code>1003</code>的信息，当<code>Code</code>值为<code>1003</code>时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左（外）连接查询，但是有一个<code>s2.common_field IS NOT NULL</code>的条件，着就会导致查询优化器把左（外）连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的<code>LEFT JOIN</code>已经变成了<code>JOIN</code>。</p><p>我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接运行，它只能作为帮助我们理解查<code>MySQL</code>将如何执行查询语句的一个参考依据而已。</p><h1 id="二，optimizer-trace"><a href="#二，optimizer-trace" class="headerlink" title="二，optimizer trace"></a>二，optimizer trace</h1><p>对于<code>MySQL 5.6</code>以及之前的版本来说，查询优化器就像是一个黑盒子一样，只能通过<code>EXPLAIN</code>语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。</p><p>在<code>MySQL 5.6</code>以及之后的版本中，<code>MySQL</code>提出了一个<code>optimizer trace</code>的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量<code>optimizer_trace</code>决定，我们看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;optimizer_trace&#x27;;</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name   | Value                    |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled=off,one_line=off |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>可以看到<code>enabled</code>值为<code>off</code>，表明这个功能默认是关闭的。</p><blockquote><p>one_line的值是控制输出格式的，如果为on那么所有输出都将在一行中展示，不适合人阅读，所以我们就保持其默认值为off吧。</p></blockquote><p>如果想打开这个功能，必须首先把<code>enabled</code>的值改为<code>on</code>，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。这个<code>OPTIMIZER_TRACE</code>表有4个列，分别是：</p><ul><li><code>QUERY</code>：表示我们的查询语句。</li><li><code>TRACE</code>：表示优化过程的JSON格式文本。</li><li><code>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</code>：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li><code>INSUFFICIENT_PRIVILEGES</code>：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是<code>1</code>，我们暂时不关心这个字段的值。</li></ul><p>完整的使用<code>optimizer trace</code>功能的步骤总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1. 打开optimizer trace功能 (默认情况下它是关闭的):</span><br><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line"># 2. 这里输入查询语句</span><br><span class="line">SELECT ...; </span><br><span class="line"></span><br><span class="line"># 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程</span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span><br><span class="line"></span><br><span class="line"># 4. 可能还要观察其他语句执行的优化过程，重复上边的第2、3步</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 5. 当停止查看语句的优化过程时，把optimizer trace功能关闭</span><br><span class="line">SET optimizer_trace=&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure><p>现在我们有一个搜索条件比较多的查询语句，它的执行计划如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280913355-faf51846-5a6c-457f-8c09-ef9a61f1e7f0.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua3d01893&margin=%5Bobject%20Object%5D&name=64.png&originHeight=133&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13872&status=done&style=none&taskId=u3f87397a-3e3c-45de-8b02-c7efbc04957&title=" alt="64.png"></p><p>可以看到该查询可能使用到的索引有3个，那么为什么优化器最终选择了<code>idx_key2</code>而不选择其他的索引或者直接全表扫描呢？这时候就可以通过<code>otpimzer trace</code>功能来查看优化器的具体工作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND </span><br><span class="line">    key2 &lt; 1000000 AND </span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    common_field = &#x27;abc&#x27;;</span><br><span class="line">    </span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure><p>直接看一下通过查询<code>OPTIMIZER_TRACE</code>表得到的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line"># 分析的查询语句是什么</span><br><span class="line">QUERY: SELECT * FROM s1 WHERE</span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND</span><br><span class="line">    key2 &lt; 1000000 AND</span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">    common_field = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line"># 优化的具体过程</span><br><span class="line">TRACE: &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123;     # prepare阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;IN_uses_bisection&quot;: true</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `s1`.`id` AS `id`,`s1`.`key1` AS `key1`,`s1`.`key2` AS `key2`,`s1`.`key3` AS `key3`,`s1`.`key_part1` AS `key_part1`,`s1`.`key_part2` AS `key_part2`,`s1`.`key_part3` AS `key_part3`,`s1`.`common_field` AS `common_field` from `s1` where ((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_preparation */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;    # optimize阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;   # 处理搜索条件</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              # 原始搜索条件</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  # 等值传递转换</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 常量传递转换    </span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 去除没用的条件</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* steps */</span><br><span class="line">            &#125; /* condition_processing */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 替换虚拟生成列</span><br><span class="line">            &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">            &#125; /* substitute_generated_columns */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 表的依赖信息</span><br><span class="line">            &quot;table_dependencies&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                &quot;map_bit&quot;: 0,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ] /* depends_on_map_bits */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* table_dependencies */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">            ] /* ref_optimizer_key_uses */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">          </span><br><span class="line">            # 预估不同单表访问方法的访问成本</span><br><span class="line">            &quot;rows_estimation&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                  &quot;table_scan&quot;: &#123;   # 全表扫描的行数以及成本</span><br><span class="line">                    &quot;rows&quot;: 9688,</span><br><span class="line">                    &quot;cost&quot;: 2036.7</span><br><span class="line">                  &#125; /* table_scan */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析可能使用的索引</span><br><span class="line">                  &quot;potential_range_indexes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,   # 主键不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,  # idx_key2可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key2&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key1&quot;,  # idx_key1可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key1&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key3&quot;,  # idx_key3可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key3&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key_part&quot;,  # idx_keypart不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* potential_range_indexes */,</span><br><span class="line">                  &quot;setup_range_conditions&quot;: [</span><br><span class="line">                  ] /* setup_range_conditions */,</span><br><span class="line">                  &quot;group_index_range&quot;: &#123;</span><br><span class="line">                    &quot;chosen&quot;: false,</span><br><span class="line">                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                  &#125; /* group_index_range */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析各种可能使用的索引的成本</span><br><span class="line">                  &quot;analyzing_range_alternatives&quot;: &#123;</span><br><span class="line">                    &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key2的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                        # 使用idx_key2的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 是否使用index dive</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,     # 使用该索引获取的记录是否按照主键排序</span><br><span class="line">                        &quot;using_mrr&quot;: false,     # 是否使用mrr</span><br><span class="line">                        &quot;index_only&quot;: false,    # 是否是索引覆盖访问</span><br><span class="line">                        &quot;rows&quot;: 12,     # 使用该索引获取的记录条数</span><br><span class="line">                        &quot;cost&quot;: 15.41,  # 使用该索引的成本</span><br><span class="line">                        &quot;chosen&quot;: true  # 是否选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key1的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key1&quot;,</span><br><span class="line">                        # 使用idx_key1的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;z &lt; key1&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 266,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 320.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 因为成本太大所以不选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key3的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key3&quot;,</span><br><span class="line">                        # 使用idx_key3的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;a &lt;= key3 &lt;= a&quot;,</span><br><span class="line">                          &quot;b &lt;= key3 &lt;= b&quot;,</span><br><span class="line">                          &quot;c &lt;= key3 &lt;= c&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 21,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 28.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 同上</span><br><span class="line">                      &#125;</span><br><span class="line">                    ] /* range_scan_alternatives */,</span><br><span class="line">                    </span><br><span class="line">                    # 分析使用索引合并的成本</span><br><span class="line">                    &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                    &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                  &#125; /* analyzing_range_alternatives */,</span><br><span class="line">                  </span><br><span class="line">                  # 对于上述单表查询s1最优的访问方法</span><br><span class="line">                  &quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">                    &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                      &quot;rows&quot;: 12,</span><br><span class="line">                      &quot;ranges&quot;: [</span><br><span class="line">                        &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                      ] /* ranges */</span><br><span class="line">                    &#125; /* range_access_plan */,</span><br><span class="line">                    &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                    &quot;cost_for_plan&quot;: 15.41,</span><br><span class="line">                    &quot;chosen&quot;: true</span><br><span class="line">                  &#125; /* chosen_range_access_summary */</span><br><span class="line">                &#125; /* range_analysis */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* rows_estimation */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            </span><br><span class="line">            # 分析各种可能的执行计划</span><br><span class="line">            #（对多表查询这可能有很多种不同的方案，单表查询的方案上边已经分析过了，直接选取idx_key2就好）</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ] /* plan_prefix */,</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: 12,</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;range_details&quot;: &#123;</span><br><span class="line">                        &quot;used_index&quot;: &quot;idx_key2&quot;</span><br><span class="line">                      &#125; /* range_details */,</span><br><span class="line">                      &quot;resulting_rows&quot;: 12,</span><br><span class="line">                      &quot;cost&quot;: 17.81,</span><br><span class="line">                      &quot;chosen&quot;: true</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* considered_access_paths */</span><br><span class="line">                &#125; /* best_access_path */,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                &quot;cost_for_plan&quot;: 17.81,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* considered_execution_plans */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 尝试给查询添加一些其他的查询条件</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ] /* attached_conditions_computation */,</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* attached_conditions_summary */</span><br><span class="line">            &#125; /* attaching_conditions_to_tables */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 再稍稍的改进一下执行计划</span><br><span class="line">            &quot;refine_plan&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;pushed_index_condition&quot;: &quot;(`s1`.`key2` &lt; 1000000)&quot;,</span><br><span class="line">                &quot;table_condition_attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* refine_plan */</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_optimization */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123;    # execute阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_execution */</span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 因优化过程文本太多而丢弃的文本字节大小，值为0时表示并没有丢弃</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0</span><br><span class="line"></span><br><span class="line"># 权限字段</span><br><span class="line">INSUFFICIENT_PRIVILEGES: 0</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这只是优化器执行过程中的一小部分，<code>MySQL</code>可能会在之后的版本中添加更多的优化过程信息。不过杂乱之中其实还是蛮有规律的，优化过程大致分为了三个阶段：</p><ul><li><code>prepare</code>阶段</li><li><code>optimize</code>阶段</li><li><code>execute</code>阶段</li></ul><p>我们所说的基于成本的优化主要集中在<code>optimize</code>阶段，对于单表查询来说，我们主要关注<code>optimize</code>阶段的<code>&quot;rows_estimation&quot;</code>这个过程，这个过程深入分析了对单表查询的各种执行方案的成本；对于多表连接查询来说，我们更多需要关注<code>&quot;considered_execution_plans&quot;</code>这个过程，这个过程里会写明各种不同的连接方式所对应的成本。反正优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用<code>EXPLAIN</code>语句所展现出的那种方案。</p><p>如果对使用<code>EXPLAIN</code>语句展示出的对某个查询的执行计划很不理解，可以尝试使用<code>optimizer trace</code>功能来详细了解每一种执行方案对应的成本。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[九]基于规则的优化&amp;子查询优化</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><code>MySQL</code>依据一些规则，把语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<code>查询重写</code>。</p><h1 id="1-条件化简"><a href="#1-条件化简" class="headerlink" title="1.条件化简"></a>1.条件化简</h1><p>我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行，<code>MySQL</code>的查询优化器会为我们简化这些表达式。</p><h2 id="1-1移除不必要的括号"><a href="#1-1移除不必要的括号" class="headerlink" title="1.1移除不必要的括号"></a>1.1移除不必要的括号</h2><p>有时候表达式里有许多无用的括号，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a = 5 AND b = c) OR ((a &gt; c) AND (c &lt; 5)))</span><br></pre></td></tr></table></figure><p>优化器会把那些用不到的括号给干掉，就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a = 5 and b = c) OR (a &gt; c AND c &lt; 5)</span><br></pre></td></tr></table></figure><h2 id="1-2常量传递"><a href="#1-2常量传递" class="headerlink" title="1.2常量传递"></a>1.2常量传递</h2><p>有时候某个表达式是某个列和某个常量做等值匹配，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br></pre></td></tr></table></figure><p>当这个表达式和其他涉及列<code>a</code>的表达式使用<code>AND</code>连接起来时，可以将其他表达式中的<code>a</code>的值替换为<code>5</code>，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 AND b &gt; a</span><br></pre></td></tr></table></figure><p>就可以被转换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 AND b &gt; 5</span><br></pre></td></tr></table></figure><blockquote><p>用OR的表达式不能进行能量传递是因为OR两边的条件是取并集的，或者说互不相关。</p></blockquote><h2 id="1-3-等值传递"><a href="#1-3-等值传递" class="headerlink" title="1.3 等值传递"></a>1.3 等值传递</h2><p>有时候多个列之间存在等值匹配的关系，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b and b = c and c = 5</span><br></pre></td></tr></table></figure><p>这个表达式可以被简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 and b = 5 and c = 5</span><br></pre></td></tr></table></figure><h2 id="1-4移除没用的条件"><a href="#1-4移除没用的条件" class="headerlink" title="1.4移除没用的条件"></a>1.4移除没用的条件</h2><p>对于一些明显永远为<code>TRUE</code>或者<code>FALSE</code>的表达式，优化器会移除掉它们，比如这个表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; 1 and b = b) OR (a = 6 OR 5 != 5)</span><br></pre></td></tr></table></figure><p>很明显，<code>b = b</code>这个表达式永远为<code>TRUE</code>，<code>5 != 5</code>这个表达式永远为<code>FALSE</code>，所以简化后的表达式就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; 1 and TRUE) OR (a = 6 OR FALSE)</span><br></pre></td></tr></table></figure><p>可以继续被简化为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt; 1 OR a = 6</span><br></pre></td></tr></table></figure><h2 id="1-5表达式计算"><a href="#1-5表达式计算" class="headerlink" title="1.5表达式计算"></a>1.5表达式计算</h2><p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 + 1</span><br></pre></td></tr></table></figure><p>因为<code>5 + 1</code>这个表达式只包含常量，所以就会被化简成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 6</span><br></pre></td></tr></table></figure><p>但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABS(a) &gt; 5</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a &lt; -8</span><br></pre></td></tr></table></figure><p>优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。</p><h2 id="1-6HAVING-amp-WHERE子句的合并"><a href="#1-6HAVING-amp-WHERE子句的合并" class="headerlink" title="1.6HAVING&amp;WHERE子句的合并"></a>1.6HAVING&amp;WHERE子句的合并</h2><p>如果查询语句中没有出现诸如<code>SUM</code>、<code>MAX</code>等等的聚集函数以及<code>GROUP BY</code>子句，优化器就把<code>HAVING</code>子句和<code>WHERE</code>子句合并起来。</p><h2 id="1-7常量表检测"><a href="#1-7常量表检测" class="headerlink" title="1.7常量表检测"></a>1.7常量表检测</h2><p><code>MySQL</code>觉得下边这两种查询运行的特别快：</p><ol><li>查询的表中一条记录没有，或者只有一条记录。</li><li>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</li></ol><p>MySQL觉得这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为<code>常量表</code>（英文名：<code>constant tables</code>）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本，比方说这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table1 INNER JOIN table2</span><br><span class="line">    ON table1.column1 = table2.column2 </span><br><span class="line">    WHERE table1.primary_key = 1;</span><br></pre></td></tr></table></figure><p>很明显，这个查询可以使用主键和常量值的等值匹配来查询<code>table1</code>表，也就是在这个查询中<code>table1</code>表相当于<code>常量表</code>，在分析对<code>table2</code>表的查询成本之前，就会执行对<code>table1</code>表的查询，并把查询中涉及<code>table1</code>表的条件都替换掉，也就是上边的语句会被转换成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2 </span><br><span class="line">    ON table1表column1列的常量值 = table2.column2;</span><br></pre></td></tr></table></figure><h1 id="2-外连接消除"><a href="#2-外连接消除" class="headerlink" title="2.外连接消除"></a>2.外连接消除</h1><p><code>内连接</code>的驱动表和被驱动表的位置可以相互转换，而<code>左（外）连接</code>和<code>右（外）连接</code>的驱动表和被驱动表是固定的。这就导致<code>内连接</code>可能通过优化表的连接顺序来降低整体的查询成本，而<code>外连接</code>却无法优化表的连接顺序。我在之前的文章创建了两个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line">    m1 int, </span><br><span class="line">    n1 char(1)</span><br><span class="line">) Engine=InnoDB, CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE t2 (</span><br><span class="line">    m2 int, </span><br><span class="line">    n2 char(1)</span><br><span class="line">) Engine=InnoDB, CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>再看一下表的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2   | n2   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。查询效果就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">|    1 | a    | NULL | NULL |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于上边例子中的（左）外连接来说，由于驱动表<code>t1</code>中<code>m1=1, n1=&#39;a&#39;</code>的记录无法在被驱动表<code>t2</code>中找到符合<code>ON</code>子句条件<code>t1.m1 = t2.m2</code>的记录，所以就直接把这条记录加入到结果集，对应的<code>t2</code>表的<code>m2</code>和<code>n2</code>列的值都设置为<code>NULL</code>。</p><blockquote><p>右（外）连接和左（外）连接其实只在驱动表的选取方式上是不同的，其余方面都是一样的，所以优化器会首先把右（外）连接查询转换成左（外）连接查询。</p></blockquote><p>凡是不符合WHERE子句中条件的记录都不会参与连接。只要我们在搜索条件中指定关于被驱动表相关列的值不为<code>NULL</code>，那么外连接中在被驱动表中找不到符合<code>ON</code>子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>由于指定了被驱动表<code>t2</code>的<code>n2</code>列不允许为<code>NULL</code>，所以上边的<code>t1</code>和<code>t2</code>表的左（外）连接查询和内连接查询是一样一样的。当然，我们也可以不用显式的指定被驱动表的某个列<code>IS NOT NULL</code>，只要隐含的有这个意思就行了，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在<code>WHERE</code>子句中指定了被驱动表<code>t2</code>的<code>m2</code>列等于<code>2</code>，也就相当于间接的指定了<code>m2</code>列不为<code>NULL</code>值，所以上边的这个左（外）连接查询其实和下边这个内连接查询是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们把这种在外连接查询中，指定的<code>WHERE</code>子句中包含被驱动表中的列不为<code>NULL</code>值的条件称之为<code>空值拒绝</code>（英文名：<code>reject-NULL</code>）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p><h1 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3.子查询优化"></a>3.子查询优化</h1><h2 id="3-1子查询语法"><a href="#3-1子查询语法" class="headerlink" title="3.1子查询语法"></a>3.1子查询语法</h2><h3 id="3-1-1按返回的结果集区分子查询"><a href="#3-1-1按返回的结果集区分子查询" class="headerlink" title="3.1.1按返回的结果集区分子查询"></a>3.1.1按返回的结果集区分子查询</h3><p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型：</p><ol><li><p> 标量子查询<br>那些只返回一个单一值的子查询称之为<code>标量子查询</code>，比如这样：<br>或者这样：<br>这两个查询语句中的子查询都返回一个单一的值，也就是一个<code>标量</code>。这些标量子查询可以作为一个单一值或者表达式的一部分出现在查询语句的各个地方。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (SELECT m1 FROM t1 LIMIT 1);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);</span><br></pre></td></tr></table></figure></li><li><p> 行子查询<br>顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：<br>其中的<code>(SELECT m2, n2 FROM t2 LIMIT 1)</code>就是一个行子查询，整条语句的含义就是要从<code>t1</code>表中找一些记录，这些记录的<code>m1</code>和<code>n1</code>列分别等于子查询结果中的<code>m2</code>和<code>n2</code>列。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);</span><br></pre></td></tr></table></figure></li><li><p> 列子查询<br>列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：<br>其中的<code>(SELECT m2 FROM t2)</code>就是一个列子查询，表明查询出<code>t2</code>表的<code>m2</code>列的值作为外层查询<code>IN</code>语句的参数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</span><br></pre></td></tr></table></figure></li><li><p> 表子查询<br>顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：<br>其中的<code>(SELECT m2, n2 FROM t2)</code>就是一个表子查询，这里需要和行子查询对比一下，行子查询中我们用了<code>LIMIT 1</code>来保证子查询的结果只有一条记录，表子查询中不需要这个限制。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-1-2按与外层查询关系来区分子查询"><a href="#3-1-2按与外层查询关系来区分子查询" class="headerlink" title="3.1.2按与外层查询关系来区分子查询"></a>3.1.2按与外层查询关系来区分子查询</h3><ol><li> 不相关子查询<br>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为<code>不相关子查询</code>。我们前边介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了哈。 </li><li> 相关子查询<br>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为<code>相关子查询</code>。比如：<br>例子中的子查询是<code>(SELECT m2 FROM t2 WHERE n1 = n2)</code>，可是这个查询中有一个搜索条件是<code>n1 = n2</code>，别忘了<code>n1</code>是表<code>t1</code>的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个<code>相关子查询</code>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-1-3-子查询语法注意事项"><a href="#3-1-3-子查询语法注意事项" class="headerlink" title="3.1.3 子查询语法注意事项"></a>3.1.3 子查询语法注意事项</h3><ol><li><p> 子查询必须用小括号扩起来。 </p></li><li><p> 在<code>SELECT</code>子句中的子查询必须是标量子查询。 </p></li><li><p> 在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用<code>LIMIT 1</code>语句来限制记录数量。 </p></li><li><p> 对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。<br>比如这样是非法的：<br>因为<code>[NOT] IN/ANY/SOME/ALL</code>子查询不支持<code>LIMIT</code>语句，所以子查询中的这些语句也就是多余的了： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 WHERE m1 IN (SELECT * FROM t2 LIMIT 2);</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code>子句：子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要。</p></li><li><p><code>DISTINCT</code>语句：集合里的值去不去重也没啥意义。</p></li><li><p>没有聚集函数以及<code>HAVING</code>子句的<code>GROUP BY</code>子句。</p></li></ol><p>对于这些冗余的语句，查询优化器在一开始就把它们给干掉了。 </p><ol start="5"><li> 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM t1 WHERE m1 &lt; (SELECT MAX(m1) FROM t1);</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-子查询的执行"><a href="#3-2-子查询的执行" class="headerlink" title="3.2 子查询的执行"></a>3.2 子查询的执行</h2><p>还是复用前面的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>我们假设有两个表<code>s1</code>、<code>s2</code>与这个<code>single_table</code>表的构造是相同的，而且这两个表里边儿有10000条记录。</p><h3 id="3-2-1-标量-行子查询的执行方式"><a href="#3-2-1-标量-行子查询的执行方式" class="headerlink" title="3.2.1 标量/行子查询的执行方式"></a>3.2.1 标量/行子查询的执行方式</h3><p>我们经常在下边两个场景中使用到标量子查询或者行子查询：</p><ul><li><code>SELECT</code>子句中，我们前边说过的在查询列表中的子查询必须是标量子查询。</li><li>子查询使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li></ul><p>对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下边这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27; LIMIT 1);</span><br></pre></td></tr></table></figure><ol><li>先单独执行<code>(SELECT common_field FROM s2 WHERE key3 = &#39;a&#39; LIMIT 1)</code>这个子查询。</li><li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 = ...</code>。</li></ol><p>也就是说，<strong>对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</strong></p><p>对于相关的标量子查询或者行子查询来说，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12610368/1641804199349-63a75016-de79-4c41-897b-b2add30ea245.jpeg#clientId=u08f6cf82-f067-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42a271a5&margin=%5Bobject%20Object%5D&name=%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg&originHeight=975&originWidth=3093&originalType=binary&ratio=1&rotation=0&showTitle=false&size=259239&status=done&style=none&taskId=u108f4af2-efce-47d1-bcce-7a62b84dd35&title=" alt="相关子查询执行流程.jpg"></p><h3 id="3-2-2-IN子查询优化"><a href="#3-2-2-IN子查询优化" class="headerlink" title="3.2.2 IN子查询优化"></a>3.2.2 IN子查询优化</h3><h4 id="①-物化表的提出"><a href="#①-物化表的提出" class="headerlink" title="① 物化表的提出"></a>① 物化表的提出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>对于不相关的<code>IN</code>子查询来说，如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还行，但是如果单独执行子查询后的结果集太多的话，就会导致这些问题：</p><ul><li>结果集太多，可能内存中都放不下。</li><li>对于外层查询来说，如果子查询的结果集太多，那就意味着<code>IN</code>子句中的参数特别多，这就导致： <ul><li>无法有效的使用索引，只能对外层查询进行全表扫描。</li><li>在对外层查询执行全表扫描时，由于<code>IN</code>子句中的参数太多，这会导致检测一条记录是否符合和<code>IN</code>子句中的参数匹配花费的时间太长。</li></ul></li></ul><p>所以MySQL并不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。</p><ol><li><p> 该临时表的列就是子查询结果集中的列。 </p></li><li><p> 写入临时表的记录会被去重。<br>我们说<code>IN</code>语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个<code>IN</code>语句的结果并没有影响，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小。  </p><blockquote><p>临时表如何对记录进行去重？只要为表中记录的所有列建立主键或者唯一索引就好了嘛～</p></blockquote></li><li><p> 一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用<code>Memory</code>存储引擎的临时表，而且会为该表建立哈希索引。<br>如果子查询的结果集非常大，超过了系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为<code>B+</code>树索引。 </p><blockquote><p>IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。</p></blockquote></li></ol><p><code>MySQL</code>把这个将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行<code>IN</code>语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p><h4 id="②-物化表转连接"><a href="#②-物化表转连接" class="headerlink" title="② 物化表转连接"></a>② 物化表转连接</h4><p>再看一下最开始的那个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>当我们把子查询进行物化之后，假设子查询物化表的名称为<code>materialized_table</code>，该物化表存储的子查询结果集的列为<code>m_val</code>，那么这个查询其实可以从下边两种角度来看待：</p><ul><li> 从表<code>s1</code>的角度来看待，整个查询的意思其实是：对于<code>s1</code>表中的每条记录来说，如果该记录的<code>key1</code>列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640267701713-1a419399-7381-4338-a04e-0af34b0555d8.png#clientId=u7473b4e3-8a45-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u981c0b64&margin=%5Bobject%20Object%5D&name=1.png&originHeight=519&originWidth=728&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126733&status=done&style=none&taskId=ube4d8262-3244-4e4c-9f1a-846f3f773dd&title=" alt="1.png"></li><li> 从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在<code>s1</code>表中找到对应的<code>key1</code>列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640267710960-6fc5e0b3-555b-4690-be6f-cef6913cb7e8.png#clientId=u7473b4e3-8a45-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1611c8f0&margin=%5Bobject%20Object%5D&name=2.png&originHeight=457&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103779&status=done&style=none&taskId=u1a52d8a1-26f9-4226-9340-d7cd29f77ac&title=" alt="2.png"></li></ul><p>也就是说其实上边的查询就相当于表<code>s1</code>和子查询物化表<code>materialized_table</code>进行内连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;</span><br></pre></td></tr></table></figure><p>转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表<code>s1</code>和物化表<code>materialized_table</code>进行内连接的成本都是由哪几部分组成的：</p><ul><li>如果使用<code>s1</code>表作为驱动表的话，总查询成本由下边几个部分组成： <ol><li>物化子查询时需要的成本</li><li>扫描<code>s1</code>表时的成本</li><li>s1表中的记录数量 × 通过<code>m_val = xxx</code>对<code>materialized_table</code>表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li></ol></li><li>如果使用<code>materialized_table</code>表作为驱动表的话，总查询成本由下边几个部分组成： <ol><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表中的记录数量 × 通过<code>key1 = xxx</code>对<code>s1</code>表进行单表访问的成本（非常庆幸<code>key1</code>列上建立了索引，所以这个步骤是非常快的）。</li></ol></li></ul><p><code>MySQL</code>查询优化器会通过运算来选择上述成本更低的方案来执行查询。</p><h4 id="③-将子查询转换为semi-join"><a href="#③-将子查询转换为semi-join" class="headerlink" title="③ 将子查询转换为semi-join"></a>③ 将子查询转换为semi-join</h4><p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用，能不能不进行物化操作直接把子查询转换为连接呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>我们可以把这个查询理解成：对于<code>s1</code>表中的某条记录，如果我们能在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中找到一条或多条记录，这些记录的<code>common_field</code>的值等于<code>s1</code>表记录的<code>key1</code>列的值，那么该条<code>s1</code>表的记录就会被加入到最终的结果集。这个过程其实和把<code>s1</code>和<code>s2</code>两个表连接起来的效果很像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s2.key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>只不过我们不能保证对于<code>s1</code>表的某条记录来说，在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中有多少条记录满足<code>s1.key1 = s2.common_field</code>这个条件，不过我们可以分三种情况讨论：</p><ul><li>情况一：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中没有任何记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录自然也不会加入到最后的结果集。</li><li>情况二：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中有且只有1条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被加入最终的结果集。</li><li>情况三：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中至少有2条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被多次加入最终的结果集。</li></ul><p>对于<code>s1</code>表的某条记录来说，由于我们只关心<code>s2</code>表中是否存在记录满足<code>s1.key1 = s2.common_field</code>这个条件，而不关心具体有多少条记录与之匹配，又因为有<code>情况三</code>的存在，我们上边所说的<code>IN</code>子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以<code>MySQL</code>在这里提出了一个新概念 — <code>半连接</code>。将<code>s1</code>表和<code>s2</code>表进行半连接的意思就是：对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录。我们假设MySQL内部是这么改写上边的子查询的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 SEMI JOIN s2</span><br><span class="line">    ON s1.key1 = s2.common_field</span><br><span class="line">    WHERE key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>semi-join只是在MySQL内部采用的一种执行子查询的方式，MySQL并没有提供面向用户的semi-join语法，所以我们不需要，也不能尝试把上边这个语句放到mysql客户端执行。</p></blockquote><p>怎么实现这种所谓的<code>半连接</code>呢？</p><ul><li><p> Table pullout （子查询中的表上拉）<br>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表<code>上拉</code>到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个<br>由于<code>key2</code>列是<code>s2</code>表的唯一二级索引列，所以我们可以直接把<code>s2</code>表上拉到外层查询的<code>FROM</code>子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：<br>为什么当子查询的查询列表处只有主键或者唯一索引列时，就可以直接将子查询转换为连接查询呢？主键或者唯一索引列中的数据本身就是不重复的，所以对于同一条<code>s1</code>表中的记录，不可能找到两条以上的符合<code>s1.key2 = s2.key2</code>的记录。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key2 = s2.key2 </span><br><span class="line">    WHERE s2.key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> DuplicateWeedout execution strategy （重复值消除）<br>对于这个查询来说：<br>转换为半连接查询后，<code>s1</code>表中的某条记录可能在<code>s2</code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：<br>这样在执行连接查询的过程中，每当某条<code>s1</code>表中的记录要加入结果集时，就首先把这条记录的<code>id</code>值加入到这个临时表里，如果添加成功，说明之前这条<code>s1</code>表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明之前这条<code>s1</code>表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code>。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp (</span><br><span class="line">    id PRIMARY KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p> LooseScan execution strategy （松散扫描）<br>大家看这个查询：<br>在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640267724986-725be8df-4e22-4b31-ad11-f1f3f52b05ba.png#clientId=u7473b4e3-8a45-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4f2fb7fe&margin=%5Bobject%20Object%5D&name=3.png&originHeight=335&originWidth=810&originalType=binary&ratio=1&rotation=0&showTitle=false&size=127580&status=done&style=none&taskId=u525e014a-627f-4977-a72b-fd728749105&title=" alt="3.png"><br>如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>&#39;aa&#39;</code>的二级索引记录一共有3条，那么只需要取第一条的值到<code>s1</code>表中查找<code>s1.key3 = &#39;aa&#39;</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到<code>s1</code>表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<code>松散扫描</code>。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;);</span><br></pre></td></tr></table></figure></li><li><p> Semi-join Materialization execution strategy<br>我们之前介绍的先把外层查询的<code>IN</code>子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种<code>semi-join</code>，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。 </p></li><li><p> FirstMatch execution strategy （首次匹配）<br><code>FirstMatch</code>是一种最原始的半连接执行方式，先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。 </p></li></ul><p>对于某些使用<code>IN</code>语句的相关子查询，比方这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3);</span><br></pre></td></tr></table></figure><p>它也可以很方便的转为半连接，转换后的语句类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 SEMI JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.common_field AND s1.key3 = s2.key3;</span><br></pre></td></tr></table></figure><p>然后就可以使用我们上边介绍过的<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>FirstMatch</code>等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用<code>table pullout</code>的策略来执行查询，但是，由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询。</p><h4 id="④-semi-join的适用条件"><a href="#④-semi-join的适用条件" class="headerlink" title="④ semi-join的适用条件"></a>④ semi-join的适用条件</h4><p>当然，并不是所有包含<code>IN</code>子查询的查询语句都可以转换为<code>semi-join</code>，只有形如这样的查询才可以被转换为<code>semi-join</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM outer_tables </span><br><span class="line">    WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...</span><br></pre></td></tr></table></figure><p>或者这样的形式也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM outer_tables </span><br><span class="line">    WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...</span><br></pre></td></tr></table></figure><p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为<code>semi-join</code>：</p><ul><li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li><li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li><li>… 还有一些条件比较少见….</li></ul><h4 id="⑤-不适用于semi-join的情况"><a href="#⑤-不适用于semi-join的情况" class="headerlink" title="⑤ 不适用于semi-join的情况"></a>⑤ 不适用于semi-join的情况</h4><p>对于一些不能将子查询转位<code>semi-join</code>的情况，典型的比如下边这几种：</p><ul><li><p> 外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br><span class="line">        OR key2 &gt; 100;</span><br></pre></td></tr></table></figure></li><li><p> 使用<code>NOT IN</code>而不是<code>IN</code>的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br></pre></td></tr></table></figure></li><li><p> 在<code>SELECT</code>子句中的IN子查询的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;) FROM s1 ;</span><br></pre></td></tr></table></figure></li><li><p> 子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);</span><br></pre></td></tr></table></figure></li><li><p> 子查询中包含<code>UNION</code>的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IN (</span><br><span class="line">    SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27; </span><br><span class="line">    UNION</span><br><span class="line">    SELECT common_field FROM s2 WHERE key3 = &#x27;b&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p><code>MySQL</code>仍然会尝试优化不能转为<code>semi-join</code>查询的子查询，那就是：</p><ul><li><p> 对于不相关子查询来说，可以尝试把它们物化之后再参与查询<br>比如我们上边提到的这个查询：<br>先将子查询物化，然后再判断<code>key1</code>是否在物化表的结果集中可以加快查询执行的速度。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br></pre></td></tr></table></figure><blockquote><p>这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。</p></blockquote></li><li><p> 不管子查询是相关的还是不相关的，都可以把<code>IN</code>子查询尝试转为<code>EXISTS</code>子查询<br>其实对于任意一个IN子查询来说，都可以被转为<code>EXISTS</code>子查询，通用的例子如下：<br>可以被转换为：<br>当然这个过程中有一些特殊情况，比如在<code>outer_expr</code>或者<code>inner_expr</code>值为<code>NULL</code>的情况下就比较特殊。因为有<code>NULL</code>值作为操作数的表达式结果往往是<code>NULL</code>，比方说：<br>而<code>EXISTS</code>子查询的结果肯定是<code>TRUE</code>或者<code>FASLE</code>：<br>但是，我们大部分使用<code>IN</code>子查询的场景是把它放在<code>WHERE</code>或者<code>ON</code>子句中，而<code>WHERE</code>或者<code>ON</code>子句是不区分<code>NULL</code>和<code>FALSE</code>的，比方说：<br>所以只要我们的<code>IN</code>子查询是放在<code>WHERE</code>或者<code>ON</code>子句中的，那么<code>IN -&gt; EXISTS</code>的转换就是没问题的。说了这么多，为啥要转换呢？这是因为不转换的话可能用不到索引，比方说下边这个查询：<br>这个查询中的子查询是一个相关子查询，而且子查询执行的时候不能使用到索引，但是将它转为<code>EXISTS</code>子查询后却可以使用到索引：<br>转为<code>EXISTS</code>子查询时便可以使用到<code>s2</code>表的<code>idx_key3</code>索引了。<br>需要注意的是，如果<code>IN</code>子查询不满足转换为<code>semi-join</code>的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为<code>EXISTS</code>查询。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr=inner_expr)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IN (1, 2, 3);</span><br><span class="line">+-------------------+</span><br><span class="line">| NULL IN (1, 2, 3) |</span><br><span class="line">+-------------------+</span><br><span class="line">|              NULL |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 IN (1, 2, 3);</span><br><span class="line">+----------------+</span><br><span class="line">| 1 IN (1, 2, 3) |</span><br><span class="line">+----------------+</span><br><span class="line">|              1 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL IN (NULL);</span><br><span class="line">+----------------+</span><br><span class="line">| NULL IN (NULL) |</span><br><span class="line">+----------------+</span><br><span class="line">|           NULL |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = 1);</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE NULL = 1) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                                        0 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL);</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                                        0 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL);</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL) |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">|                                           0 |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 FROM s1 WHERE NULL;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 FROM s1 WHERE FALSE;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">    WHERE key1 IN (SELECT key3 FROM s2 where s1.common_field = s2.common_field) </span><br><span class="line">        OR key2 &gt; 1000;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 where s1.common_field = s2.common_field AND s2.key3 = s1.key1) </span><br><span class="line">        OR key2 &gt; 1000;</span><br></pre></td></tr></table></figure><blockquote><p>在MySQL5.5以及之前的版本没有引进semi-join和物化的方式优化子查询时，优化器都会把IN子查询转换为EXISTS子查询。</p></blockquote></li></ul><h4 id="⑥-阶段梳理"><a href="#⑥-阶段梳理" class="headerlink" title="⑥ 阶段梳理"></a>⑥ 阶段梳理</h4><ul><li>如果<code>IN</code>子查询符合转换为<code>semi-join</code>的条件，查询优化器会优先把该子查询转换为<code>semi-join</code>，然后再考虑下边5种执行半连接的策略中哪个成本最低： <ul><li>Table pullout</li><li>DuplicateWeedout</li><li>LooseScan</li><li>Materialization</li><li>FirstMatch</li></ul></li></ul><p>选择成本最低的那种执行策略来执行子查询。 </p><ul><li>如果<code>IN</code>子查询不符合转换为<code>semi-join</code>的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询： <ul><li>先将子查询物化之后再执行查询</li><li>执行<code>IN to EXISTS</code>转换。</li></ul></li></ul><h3 id="3-2-3-ANY-ALL子查询优化"><a href="#3-2-3-ANY-ALL子查询优化" class="headerlink" title="3.2.3 ANY/ALL子查询优化"></a>3.2.3 ANY/ALL子查询优化</h3><p>如果ANY/ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行，比方说：</p><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr …)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr …)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h3 id="3-2-4-NOT-EXISTS子查询的执行"><a href="#3-2-4-NOT-EXISTS子查询的执行" class="headerlink" title="3.2.4 [NOT] EXISTS子查询的执行"></a>3.2.4 [NOT] EXISTS子查询的执行</h3><p>如果<code>[NOT] EXISTS</code>子查询是不相关子查询，可以先执行子查询，得出该<code>[NOT] EXISTS</code>子查询的结果是<code>TRUE</code>还是<code>FALSE</code>，并重写原先的查询语句，比如对这个查询来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE key1 = &#x27;a&#x27;) </span><br><span class="line">        OR key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>因为这个语句里的子查询是不相关子查询，所以优化器会首先执行该子查询，假设该EXISTS子查询的结果为<code>TRUE</code>，那么接着优化器会重写查询为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE TRUE OR key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>进一步简化后就变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE TRUE;</span><br></pre></td></tr></table></figure><p>对于相关的<code>[NOT] EXISTS</code>子查询来说，比如这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.common_field);</span><br></pre></td></tr></table></figure><p>这个查询只能按照普通的那种执行相关子查询的方式来执行。不过如果<code>[NOT] EXISTS</code>子查询中如果可以使用索引的话，那查询速度也会加快不少，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.key1);</span><br></pre></td></tr></table></figure><p>上边这个<code>EXISTS</code>子查询中可以使用<code>idx_key1</code>来加快查询速度。</p><h3 id="3-2-5-对于派生表的优化"><a href="#3-2-5-对于派生表的优化" class="headerlink" title="3.2.5 对于派生表的优化"></a>3.2.5 对于派生表的优化</h3><p>我们前边说过把子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code>，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM  (</span><br><span class="line">        SELECT id AS d_id,  key3 AS d_key3 FROM s2 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 WHERE d_key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>子查询<code>( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = &#39;a&#39;)</code>的结果就相当于一个派生表，这个表的名称是<code>derived_s1</code>，该表有两个列，分别是<code>d_id</code>和<code>d_key3</code>。</p><p>对于含有<code>派生表</code>的查询，<code>MySQL</code>提供了两种执行策略：</p><ul><li><p> 把派生表物化<br>我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当然，在对派生表进行物化时，<code>MySQL</code>使用了一种称为<code>延迟物化</code>的策略，也就是在查询中真正使用到派生表时才会去尝试物化派生表，而不是还没开始执行查询就把派生表物化掉。比方说对于下边这个含有派生表的查询来说：<br>如果采用物化派生表的方式来执行这个查询的话，那么执行时首先会到<code>s2</code>表中找出满足<code>s2.key2 = 1</code>的记录，如果找不到，说明参与连接的<code>s2</code>表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">        SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 INNER JOIN s2</span><br><span class="line">    ON derived_s1.key1 = s2.key1</span><br><span class="line">    WHERE s2.key2 = 1;</span><br></pre></td></tr></table></figure></li><li><p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式<br>我们来看这个包含派生表的查询：<br>这个查询本质上就是想查看<code>s1</code>表中满足<code>key1 = &#39;a&#39;</code>条件的的全部记录，所以和下边这个语句是等价的：<br>对于一些稍微复杂的包含派生表的语句，比如我们上边提到的那个：<br>我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：<br>这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;) AS derived_s1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">        SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 INNER JOIN s2</span><br><span class="line">    ON derived_s1.key1 = s2.key1</span><br><span class="line">    WHERE s2.key2 = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.key1 = &#x27;a&#x27; AND s2.key2 = 1;</span><br></pre></td></tr></table></figure><ul><li>聚集函数，比如MAX()、MIN()、SUM()…</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的<code>SELECT</code>子句中含有另一个子查询</li><li>… 还有些不常用的情况…</li></ul></li></ul><p>所以<code>MySQL</code>在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>MySQL会对用户编写的SQL语句进行重写操作，比如：</p><ol><li>移除不必要的括号</li><li>常量传递</li><li>移除没用的条件</li><li>表达式计算</li><li>HAVING&amp;WHERE子句的合并</li><li>常量表检测</li></ol><p>在被驱动表的WHERE子句符合空值拒绝条件的时候，外连接&amp;内连接可以相互转换。</p><p>子查询可以按照不同维度进行不同分类，比如按照子查询返回的结果集分类：</p><ol><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ol><p>按照与外层查询的关系来分类：</p><ol><li>不相关子查询</li><li>相关子查询</li></ol><p>MySQL对in查询进行了很多优化。如果in子查询符合转换为半连接的条件，查询优化器会优先把该子查询转换为半连接，然后再考虑下面五种执行半连接查询的策略中哪个成本最低，最后选择成本最低的执行策略来执行子查询。</p><ol><li>table pullout</li><li>duplicate weedout</li><li>looseScan</li><li>Semj-join Materialization</li><li>FirstMatch</li></ol><p>如果IN子查询不符合转换为半连接的条件，查询优化器会从下面的两种策略里面找出一种成本更低的方式去执行子查询：</p><ol><li>先将子查询物化，在执行子查询</li><li>执行in到exists的转换</li></ol><p>MySQL在处理带有派生表的语句的时候，优先尝试把派生表和外层查询进行合并；如果不行，再把派生表物化掉，然后执行查询。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[八]InnoDB统计数据收集原理</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇我们来分析下<code>InnoDB</code>存储引擎的统计数据收集策略。</p></blockquote><h1 id="1-统计数据的存储方式"><a href="#1-统计数据的存储方式" class="headerlink" title="1.统计数据的存储方式"></a>1.统计数据的存储方式</h1><p><code>InnoDB</code>提供了两种存储统计数据的方式：</p><ol><li> 永久性的统计数据<br>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。 </li><li> 非永久性的统计数据<br>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。 </li></ol><p><code>MySQL</code>提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在<code>MySQL 5.6.6</code>之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说<code>InnoDB</code>的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p><p>不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。</p><p>我们可以在创建和修改表的时候通过指定<code>STATS_PERSISTENT</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br></pre></td></tr></table></figure><p>当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上，当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值。</p><h1 id="2-永久性统计数据"><a href="#2-永久性统计数据" class="headerlink" title="2.永久性统计数据"></a>2.永久性统计数据</h1><p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;innodb%&#x27;;</span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql (innodb%) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| innodb_index_stats        |</span><br><span class="line">| innodb_table_stats        |</span><br><span class="line">+---------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>可以看到，这两个表都位于<code>mysql</code>系统数据库下边，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><p>看一下这两个表里边都有什么以及表里的数据是如何生成的。</p><h2 id="2-1-innodb-table-stats"><a href="#2-1-innodb-table-stats" class="headerlink" title="2.1 innodb_table_stats"></a>2.1 innodb_table_stats</h2><p>直接看一下这个<code>innodb_table_stats</code>表中的各个列都是干嘛的：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>database_name</code></td><td>数据库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>last_update</code></td><td>本条记录最后更新时间</td></tr><tr><td><code>n_rows</code></td><td>表中记录的条数</td></tr><tr><td><code>clustered_index_size</code></td><td>表的聚簇索引占用的页面数量</td></tr><tr><td><code>sum_of_other_index_sizes</code></td><td>表的其他索引占用的页面数量</td></tr></tbody></table><p>注意这个表的主键是<code>(database_name,table_name)</code>，也就是innodb_table_stats表的每条记录代表着一个表的统计信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_table_stats;</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">| database_name | table_name    | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">| mysql         | gtid_executed | 2021-12-14 00:00:08 |      0 |                    1 |                        0 |</span><br><span class="line">| sys           | sys_config    | 2021-12-14 00:00:09 |      6 |                    1 |                        0 |</span><br><span class="line">| yhd           | person_info   | 2021-12-19 00:27:39 |      0 |                    1 |                        1 |</span><br><span class="line">| yhd           | single_table  | 2021-12-19 02:13:19 | 910545 |                 3109 |                     5836 |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到<code>single_table</code>表的统计信息就对应着<code>mysql.innodb_table_stats</code>的第三条记录。几个重要统计信息项的值如下：</p><ul><li><code>n_rows</code>的值是<code>9693</code>，表明<code>single_table</code>表中大约有<code>9693</code>条记录，注意这个数据是估计值。</li><li><code>clustered_index_size</code>的值是<code>97</code>，表明<code>single_table</code>表的聚簇索引占用97个页面，这个值是也是一个估计值。</li><li><code>sum_of_other_index_sizes</code>的值是<code>175</code>，表明<code>single_table</code>表的其他索引一共占用175个页面，这个值是也是一个估计值。</li></ul><h3 id="2-1-1-n-rows统计项的收集"><a href="#2-1-1-n-rows统计项的收集" class="headerlink" title="2.1.1 n_rows统计项的收集"></a>2.1.1 n_rows统计项的收集</h3><p>为啥<code>n_rows</code>这个统计项的值是估计值呢？InnoDB`统计一个表中有多少行记录的套路是这样的：</p><ul><li> 按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的<code>n_rows</code>值。  <blockquote><p>真实的计算过程比这个稍微复杂一些，不过大致上就是这样。</p></blockquote></li></ul><p>可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，<code>MySQL</code>为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。</p><p>我们前边说过，不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br></pre></td></tr></table></figure><p>如果我们在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。</p><h3 id="2-1-2-clustered-index-size和sum-of-other-index-sizes统计项的收集"><a href="#2-1-2-clustered-index-size和sum-of-other-index-sizes统计项的收集" class="headerlink" title="2.1.2 clustered_index_size和sum_of_other_index_sizes统计项的收集"></a>2.1.2 clustered_index_size和sum_of_other_index_sizes统计项的收集</h3><p>这两个统计项的收集过程如下：</p><ul><li> 从数据字典里找到表的各个索引对应的根页面位置。<br>系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。 </li><li>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。<br>在每个索引的根页面的<code>Page Header</code>部分都有两个字段： <ul><li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li><li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li></ul></li><li> 从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。<br>这个是<code>Segment Header</code>结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640188725245-45998fe0-ca45-4a90-9fbb-85d0fa39744d.png#clientId=ucf54091a-1d82-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u664e06a0&margin=%5Bobject%20Object%5D&name=1.png&originHeight=261&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87783&status=done&style=none&taskId=u43c2aedd-8d61-4203-85ad-6f9875928e5&title=" alt="1.png"></li><li> 从对应的<code>INODE Entry</code>结构中可以找到该段对应所有零散的页面地址以及<code>FREE</code>、<code>NOT_FULL</code>、<code>FULL</code>链表的基节点。<br>这个是<code>INODE Entry</code>结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640188857945-2f6e0703-1c75-4280-a7dd-5d30eabec059.png#clientId=ucf54091a-1d82-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=509&id=ue79edf9e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&size=187896&status=done&style=none&taskId=ub5bc9cbc-5d67-457c-ae3a-58017a6198d&title=&width=848" alt="image.png"></li><li> 直接统计零散的页面有多少个，然后从那三个链表的<code>List Length</code>字段中读出该段占用的区的大小，每个区占用<code>64</code>个页，所以就可以统计出整个段占用的页面。<br>这个是链表基节点的示意图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640188756249-938d7c13-7332-46d4-aeea-cebd520a8faf.png#clientId=ucf54091a-1d82-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=388&id=uf62cb732&margin=%5Bobject%20Object%5D&name=image.png&originHeight=388&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134904&status=done&style=none&taskId=u8941ec55-2b91-454b-a3ff-4ad64206a27&title=&width=750" alt="image.png"></li><li> 分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是<code>clustered_index_size</code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是<code>sum_of_other_index_sizes</code>的值。 </li></ul><p>注意，我们说一个段的数据在非常多时（超过32个页面），会以<code>区</code>为单位来申请空间，这里头的问题是以区为单位申请空间中有一些页可能并没有使用，但是在统计<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code>时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p><h2 id="2-2-innodb-index-stats"><a href="#2-2-innodb-index-stats" class="headerlink" title="2.2 innodb_index_stats"></a>2.2 innodb_index_stats</h2><p>直接看一下这个<code>innodb_index_stats</code>表中的各个列：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>database_name</code></td><td>数据库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>index_name</code></td><td>索引名</td></tr><tr><td><code>last_update</code></td><td>本条记录最后更新时间</td></tr><tr><td><code>stat_name</code></td><td>统计项的名称</td></tr><tr><td><code>stat_value</code></td><td>对应的统计项的值</td></tr><tr><td><code>sample_size</code></td><td>为生成统计数据而采样的页面数量</td></tr><tr><td><code>stat_description</code></td><td>对应的统计项的描述</td></tr></tbody></table><p>注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。我们直接看一下关于<code>single_table</code>表的索引统计数据都有些什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_index_stats WHERE table_name = &#x27;single_table&#x27;;</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">| database_name | table_name   | index_name   | last_update         | stat_name    | stat_value | sample_size | stat_description                  |</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">| yhd           | single_table | PRIMARY      | 2021-12-19 02:13:19 | n_diff_pfx01 |     910518 |          20 | id                                |</span><br><span class="line">| yhd           | single_table | PRIMARY      | 2021-12-19 02:13:19 | n_leaf_pages |       3097 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | PRIMARY      | 2021-12-19 02:13:19 | size         |       3109 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | n_diff_pfx01 |          8 |          10 | key1                              |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | n_diff_pfx02 |     882192 |          20 | key1,id                           |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | n_leaf_pages |        828 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | size         |        993 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | n_diff_pfx01 |          8 |          10 | key3                              |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | n_diff_pfx02 |     910072 |          20 | key3,id                           |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | n_leaf_pages |        827 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | size         |        993 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx01 |          8 |          10 | key_part1                         |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx02 |         82 |          20 | key_part1,key_part2               |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx03 |        730 |          20 | key_part1,key_part2,key_part3     |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx04 |    1028534 |          20 | key_part1,key_part2,key_part3,id  |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_leaf_pages |       2556 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | size         |       2985 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | uk_key2      | 2021-12-19 02:13:19 | n_diff_pfx01 |     913104 |          20 | key2                              |</span><br><span class="line">| yhd           | single_table | uk_key2      | 2021-12-19 02:13:19 | n_leaf_pages |        816 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | uk_key2      | 2021-12-19 02:13:19 | size         |        865 |        NULL | Number of pages in the index      |</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">20 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这个结果有点儿多，正确查看这个结果的方式是这样的：</p><ol><li><p> 先查看<code>index_name</code>列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来，<code>PRIMARY</code>索引（也就是主键）占了3条记录，<code>idx_key_part</code>索引占了6条记录。 </p></li><li><p> 针对<code>index_name</code>列相同的记录，<code>stat_name</code>表示针对该索引的统计项名称，<code>stat_value</code>展示的是该索引在该统计项上的值，<code>stat_description</code>指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项： </p></li><li><p> <code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。 </p></li><li><p> <code>size</code>：表示该索引共占用多少页面。 </p></li><li><p> <code>n_diff_pfx**NN**</code>：表示对应的索引列不重复的值有多少。<br>其实<code>NN</code>可以被替换为<code>01</code>、<code>02</code>、<code>03</code>… 这样的数字。比如对于<code>idx_key_part</code>来说：       1. <code>n_diff_pfx01</code>表示的是统计<code>key_part1</code>这单单一个列不重复的值有多少。      1. <code>n_diff_pfx02</code>表示的是统计<code>key_part1、key_part2</code>这两个列组合起来不重复的值有多少。      1. <code>n_diff_pfx03</code>表示的是统计<code>key_part1、key_part2、key_part3</code>这三个列组合起来不重复的值有多少。      1. <code>n_diff_pfx04</code>表示的是统计<code>key_part1、key_part2、key_part3、id</code>这四个列组合起来不重复的值有多少。</p><blockquote><p>注意：对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_key1来说，key1列就可能有很多值重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少。比如上边的idx_key1有n_diff_pfx01、n_diff_pfx02两个统计项，而idx_key2却只有n_diff_pfx01一个统计项。</p></blockquote></li><li><p> 在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，<code>sample_size</code>列就表明了采样的页面数量是多少。  </p><blockquote><p>注意：对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sample_pages × 索引列的个数。当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以在查询结果中看到不同索引对应的size列的值可能是不同的。</p></blockquote></li></ol><h2 id="2-3定期更新统计数据"><a href="#2-3定期更新统计数据" class="headerlink" title="2.3定期更新统计数据"></a>2.3定期更新统计数据</h2><p>随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是要变的，不变的话<code>MySQL</code>查询优化器计算的成本就会有问题。<code>MySQL</code>提供了如下两种更新统计数据的方式：</p><ul><li><p> 开启<code>innodb_stats_auto_recalc</code>。<br>系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。<br><code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：<br>当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_AUTO_RECALC=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0);</span><br></pre></td></tr></table></figure></li><li><p> 手动调用<code>ANALYZE TABLE</code>语句来更新统计信息<br>如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：<br>需要注意的是，<strong>ANALYZE TABLE</strong>语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE single_table;</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| Table                  | Op      | Msg_type | Msg_text |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| yhd.single_table | analyze | status   | OK       |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4手动更新统计数据"><a href="#2-4手动更新统计数据" class="headerlink" title="2.4手动更新统计数据"></a>2.4手动更新统计数据</h2><p>其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以手动更新某个表或者索引的统计数据。比如说我们想把<code>single_table</code>表关于行数的统计数据更改一下可以这么做：</p><ol><li><p> 步骤一：更新<code>innodb_table_stats</code>表。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE innodb_table_stats </span><br><span class="line">    SET n_rows = 1</span><br><span class="line">    WHERE table_name = &#x27;single_table&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 步骤二：让<code>MySQL</code>查询优化器重新加载我们更改过的数据。<br>更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下边的命令就可以了：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLE single_table;</span><br></pre></td></tr></table></figure></li></ol><p>之后我们使用<code>SHOW TABLE STATUS</code>语句查看表的统计数据时就看到<code>Rows</code>行变为了<code>1</code>。</p><h1 id="3-非永久性统计数据"><a href="#3-非永久性统计数据" class="headerlink" title="3.非永久性统计数据"></a>3.非永久性统计数据</h1><p>当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p><p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><p>另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成经常变化的执行计划。</p><h1 id="4-innodb-stats-method"><a href="#4-innodb-stats-method" class="headerlink" title="4.innodb_stats_method"></a>4.innodb_stats_method</h1><p><code>索引列不重复的值的数量</code>这个统计数据对于<code>MySQL</code>查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p><ul><li><p> 单表查询中单点区间太多，比方说这样：<br>当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key IN (&#x27;xx1&#x27;, &#x27;xx2&#x27;, ..., &#x27;xxn&#x27;);</span><br></pre></td></tr></table></figure></li><li><p> 连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询，比方说这样：<br>在真正执行对<code>t2</code>表的查询前，<code>t1.comumn</code>的值是不确定的，所以我们也不能通过<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 JOIN t2 ON t1.column = t2.key WHERE ...;</span><br></pre></td></tr></table></figure></li></ul><p>在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现<code>NULL</code>值怎么办，比方说某个索引列的内容是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| col  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">| NULL |</span><br><span class="line">| NULL |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><p>此时计算这个<code>col</code>列中不重复的值的数量就有下边的分歧：</p><ul><li><p> 有的人认为<code>NULL</code>值代表一个未确定的值，所以<code>MySQL</code>认为任何和<code>NULL</code>值做比较的表达式的值都为<code>NULL</code>，就是这样：<br>所以每一个<code>NULL</code>值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把<code>NULL</code>值当作一个独立的值，所以<code>col</code>列的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个值）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = NULL;</span><br><span class="line">+----------+</span><br><span class="line">| 1 = NULL |</span><br><span class="line">+----------+</span><br><span class="line">|     NULL |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 != NULL;</span><br><span class="line">+-----------+</span><br><span class="line">| 1 != NULL |</span><br><span class="line">+-----------+</span><br><span class="line">|      NULL |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL = NULL;</span><br><span class="line">+-------------+</span><br><span class="line">| NULL = NULL |</span><br><span class="line">+-------------+</span><br><span class="line">|        NULL |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL != NULL;</span><br><span class="line">+--------------+</span><br><span class="line">| NULL != NULL |</span><br><span class="line">+--------------+</span><br><span class="line">|         NULL |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p> 有的人认为其实<code>NULL</code>值在业务上就是代表没有，所有的<code>NULL</code>值代表的意义是一样的，所以<code>col</code>列不重复的值的数量就是：<code>3</code>（分别是1、2、NULL这三个值）。 </p></li><li><p> 有的人认为这<code>NULL</code>完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以<code>col</code>列不重复的值的数量就是：<code>2</code>（分别是1、2这两个值）。 </p></li></ul><p><code>MySQL</code>提供了一个名为<code>innodb_stats_method</code>的系统变量，我们可以自己来设置，这个系统变量有三个候选值：</p><ol><li> <code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。这个值也是<code>innodb_stats_method</code>的默认值。<br>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。 </li><li> <code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。<br>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。 </li><li> <code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。 </li></ol><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><ol><li><code>InnoDB</code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li><li><code>innodb_stats_persistent</code>控制着使用永久性统计数据还是非永久性统计数据；<code>innodb_stats_persistent_sample_pages</code>控制着永久性统计数据的采样页面数量；<code>innodb_stats_transient_sample_pages</code>控制着非永久性统计数据的采样页面数量；<code>innodb_stats_auto_recalc</code>控制着是否自动重新计算统计数据。</li><li>我们可以针对某个具体的表，在创建和修改表时通过指定<code>STATS_PERSISTENT</code>、<code>STATS_AUTO_RECALC</code>、<code>STATS_SAMPLE_PAGES</code>的值来控制相关统计数据属性。</li><li><code>innodb_stats_method</code>决定着在统计某个索引列不重复值的数量时如何对待<code>NULL</code>值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[七]基于成本的优化</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是成本？"><a href="#1-什么是成本？" class="headerlink" title="1.什么是成本？"></a>1.什么是成本？</h1><p>在<code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p><ul><li> <code>I/O</code>成本<br>我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。 </li><li> <code>CPU</code>成本<br>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。 </li></ul><p>对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，<code>MySQL</code>规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>。</p><blockquote><p>不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p></blockquote><h1 id="2-单表查询的成本"><a href="#2-单表查询的成本" class="headerlink" title="2.单表查询的成本"></a>2.单表查询的成本</h1><h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><p>把之前用到的<code>single_table</code>表搬来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="2-2-基于成本的优化步骤"><a href="#2-2-基于成本的优化步骤" class="headerlink" title="2.2 基于成本的优化步骤"></a>2.2 基于成本的优化步骤</h2><p>在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE </span><br><span class="line">    key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    key2 &gt; 10 AND key2 &lt; 1000 AND </span><br><span class="line">    key3 &gt; key2 AND </span><br><span class="line">    key_part1 LIKE &#x27;%hello%&#x27; AND</span><br><span class="line">    common_field = &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-根据搜索条件，找出所有可能使用的索引"><a href="#2-2-1-根据搜索条件，找出所有可能使用的索引" class="headerlink" title="2.2.1 根据搜索条件，找出所有可能使用的索引"></a>2.2.1 根据搜索条件，找出所有可能使用的索引</h3><p>对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，<code>MySQL</code>把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p><p>我们分析一下上边查询中涉及到的几个搜索条件：</p><ul><li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li><li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li><li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li><li><code>key_part1 LIKE &#39;%hello%&#39;</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li><li><code>common_field = &#39;123&#39;</code>，由于该列上压根儿没有索引，所以不会用到索引。</li></ul><p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p><h3 id="2-2-2-计算全表扫描的代价"><a href="#2-2-2-计算全表扫描的代价" class="headerlink" title="2.2.2 计算全表扫描的代价"></a>2.2.2 计算全表扫描的代价</h3><p>对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>这两个信息从哪来呢？<code>MySQL</code>为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的后面再谈，现在看看怎么查看这些统计信息。<code>MySQL</code>给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE &#x27;single_table&#x27;</span><br></pre></td></tr></table></figure><p>虽然出现了很多统计选项，但我们目前只关心两个：</p><ul><li> <code>Rows</code><br>本选项表示表中的记录条数。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。 </li><li> <code>Data_length</code><br>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：<br>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data_length = 聚簇索引的页面数量 x 每个页面的大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</span><br></pre></td></tr></table></figure></li></ul><p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是<code>MySQL</code>在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，这些微调的值十分的小，并不影响我们分析。现在可以看一下全表扫描成本的计算过程：</p><ul><li><p> <code>I/O</code>成本<br><code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 x 1.0 + 1.1 = 98.1</span><br></pre></td></tr></table></figure></li><li><p> <code>CPU</code>成本：<br><code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 x 0.2 + 1.0 = 1939.6</span><br></pre></td></tr></table></figure></li><li><p> 总成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">98.1 + 1939.6 = 2037.7</span><br></pre></td></tr></table></figure></li></ul><p>综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p><blockquote><p>表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是MySQL在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I/O成本的依据，是不区分内节点和叶子节点的。</p></blockquote><h3 id="2-2-3-计算使用不同索引执行查询的代价"><a href="#2-2-3-计算使用不同索引执行查询的代价" class="headerlink" title="2.2.3 计算使用不同索引执行查询的代价"></a>2.2.3 计算使用不同索引执行查询的代价</h3><p>从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p><h4 id="①使用idx-key2执行查询的成本分析"><a href="#①使用idx-key2执行查询的成本分析" class="headerlink" title="①使用idx_key2执行查询的成本分析"></a>①使用idx_key2执行查询的成本分析</h4><p><code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176350999-33e75909-f6cf-4f47-8a62-a2d8212eb876.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u71764c3f&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1170&originWidth=1622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=575463&status=done&style=none&taskId=u1e906447-5f38-4b93-8674-a23e7572a47&title=" alt="1.png"></p><p>对于使用<code>二级索引 + 回表</code>方式的查询，<code>MySQL</code>计算这种查询的成本依赖两个方面的数据：</p><ul><li><p> 范围区间数量<br>不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 x 1.0 = 1.0</span><br></pre></td></tr></table></figure></li><li><p>需要回表的记录数<br>优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算<code>idx_key2</code>在<code>(10, 1000)</code>这个范围区间中包含多少二级索引记录，计算过程是这样的： </p><ul><li> 步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。 </li><li> 步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。 </li><li> 步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176366166-30415d07-4c40-4385-bf7e-e6f27ecd0b98.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9da06e48&margin=%5Bobject%20Object%5D&name=2.png&originHeight=972&originWidth=1890&originalType=binary&ratio=1&rotation=0&showTitle=false&size=419948&status=done&style=none&taskId=ue5d8028d-6b8b-462c-8ee2-a9ab5e558aa&title=" alt="2.png"></li></ul></li></ul><p>如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就贼小了。<br>如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中，继续递归，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。<br>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 = 19.01</span><br></pre></td></tr></table></figure><p>其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。<br>在通过二级索引获取到记录之后，还需要干两件事儿： </p><ul><li><p> 根据这些记录里的主键值到聚簇索引中做回表操作<br><code>MySQL</code>认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上边统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：<br>其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 1.0 = 95.0</span><br></pre></td></tr></table></figure></li><li><p> 回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立<br>回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：<br><code>MySQL</code>只计算这个查找过程所需的<code>I/O</code>成本，也就是我们上一步骤中得到的<code>95.0</code>，在内存中的定位完整用户记录的过程的成本是忽略不计的。在定位到这些完整的用户记录后，需要检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立，这个比较过程花费的<code>CPU</code>成本就是：<br>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 = 19.0</span><br></pre></td></tr></table></figure></li></ul><p>所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p><ul><li><p> <code>I/O</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0 + 95 x 1.0 = 96.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li><li><p> <code>CPU</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 + 95 x 0.2 = 38.01 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li></ul><p>综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96.0 + 38.01 = 134.01</span><br></pre></td></tr></table></figure><h4 id="②使用idx-key1执行查询的成本分析"><a href="#②使用idx-key1执行查询的成本分析" class="headerlink" title="②使用idx_key1执行查询的成本分析"></a>②使用idx_key1执行查询的成本分析</h4><p><code>idx_key1</code>对应的搜索条件是：<code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，也就是说相当于3个单点区间：</p><ul><li><code>[&#39;a&#39;, &#39;a&#39;]</code></li><li><code>[&#39;b&#39;, &#39;b&#39;]</code></li><li><code>[&#39;c&#39;, &#39;c&#39;]</code></li></ul><p>使用<code>idx_key1</code>搜索的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176380041-9a9e19f0-8469-426c-a064-ec10b855b743.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u920d7136&margin=%5Bobject%20Object%5D&name=3.png&originHeight=1144&originWidth=1524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=621869&status=done&style=none&taskId=u47f178fc-4c5c-47b1-ae74-fcb0d934c72&title=" alt="3.png"></p><p>与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p><ul><li><p> 范围区间数量<br>使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 x 1.0 = 3.0</span><br></pre></td></tr></table></figure></li><li><p>需要回表的记录数<br>由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数： </p><ul><li> 查找单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数<br>计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，最后计算得到单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数是：<code>35</code>。 </li><li> 查找单点区间<code>[&#39;b&#39;, &#39;b&#39;]</code>对应的二级索引记录数<br>与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。 </li><li> 查找单点区间<code>[&#39;c&#39;, &#39;c&#39;]</code>对应的二级索引记录数<br>与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。 </li></ul></li></ul><p>所以，这三个单点区间总共需要回表的记录数就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 + 44 + 39 = 118</span><br></pre></td></tr></table></figure><p>读取这些二级索引记录的<code>CPU</code>成本就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 = 23.61</span><br></pre></td></tr></table></figure><p>得到总共需要回表的记录数之后，就要考虑： </p><ul><li><p> 根据这些记录里的主键值到聚簇索引中做回表操作<br>所需的<code>I/O</code>成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 1.0 = 118.0</span><br></pre></td></tr></table></figure></li><li><p> 回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立<br>此步骤对应的<code>CPU</code>成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 = 23.6</span><br></pre></td></tr></table></figure></li></ul><p>所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p><ul><li><p> <code>I/O</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0 + 118 x 1.0 = 121.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li><li><p> <code>CPU</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 + 118 x 0.2 = 47.21 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li></ul><p>综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.0 + 47.21 = 168.21</span><br></pre></td></tr></table></figure><h4 id="③是否有可能使用索引合并（Index-Merge）"><a href="#③是否有可能使用索引合并（Index-Merge）" class="headerlink" title="③是否有可能使用索引合并（Index Merge）"></a>③是否有可能使用索引合并（Index Merge）</h4><p>本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p><h3 id="2-2-4-对比各种执行方案的代价，找出成本最低的那一个"><a href="#2-2-4-对比各种执行方案的代价，找出成本最低的那一个" class="headerlink" title="2.2.4 对比各种执行方案的代价，找出成本最低的那一个"></a>2.2.4 对比各种执行方案的代价，找出成本最低的那一个</h3><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p><ul><li>全表扫描的成本：<code>2037.7</code></li><li>使用<code>idx_key2</code>的成本：<code>134.01</code></li><li>使用<code>idx_key1</code>的成本：<code>168.21</code></li></ul><p>很显然，使用<code>idx_key2</code>的成本最低，所以选择<code>idx_key2</code>来执行查询。</p><h2 id="2-3-基于索引统计数据的成本计算"><a href="#2-3-基于索引统计数据的成本计算" class="headerlink" title="2.3 基于索引统计数据的成本计算"></a>2.3 基于索引统计数据的成本计算</h2><p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下边这个查询（下边查询语句中的<code>...</code>表示还有很多参数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure><p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。<code>MySQL</code>把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p><blockquote><p>index dive就是直接利用索引对应的B+树来计算某个范围区间对应的记录条数。</p></blockquote><p>有几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是如果很多的话，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。<code>MySQL</code>提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%dive%&#x27;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| eq_range_index_dive_limit | 200   |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。</p><p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM single_table;</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table        | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| single_table |          0 | PRIMARY      |            1 | id          | A         |       9693  |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| single_table |          0 | idx_key2     |            1 | key2        | A         |       9693  |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key1     |            1 | key1        | A         |        968 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key3     |            1 | key3        | A         |        799 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            1 | key_part1   | A         |        9673 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            2 | key_part2   | A         |        9999 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            3 | key_part3   | A         |       10000 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>Table</code></td><td>索引所属表的名称。</td></tr><tr><td><code>Non_unique</code></td><td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code></td></tr><tr><td>，普通二级索引该列值为<code>1</code></td><td></td></tr><tr><td>。</td><td></td></tr><tr><td><code>Key_name</code></td><td>索引的名称。</td></tr><tr><td><code>Seq_in_index</code></td><td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code></td></tr><tr><td>，来说，<code>key_part1</code></td><td></td></tr><tr><td>、<code>key_part2</code></td><td></td></tr><tr><td>和<code>key_part3</code></td><td></td></tr><tr><td>对应的位置分别是1、2、3。</td><td></td></tr><tr><td><code>Column_name</code></td><td>索引列的名称。</td></tr><tr><td><code>Collation</code></td><td>索引列中的值是按照何种排序方式存放的，值为<code>A</code></td></tr><tr><td>时代表升序存放，为<code>NULL</code></td><td></td></tr><tr><td>时代表降序存放。</td><td></td></tr><tr><td><code>Cardinality</code></td><td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td></tr><tr><td><code>Sub_part</code></td><td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code></td></tr><tr><td>个字符或字节建立索引，这个属性表示的就是那个<code>n</code></td><td></td></tr><tr><td>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code></td><td></td></tr><tr><td>。</td><td></td></tr><tr><td><code>Packed</code></td><td>索引列如何被压缩，<code>NULL</code></td></tr><tr><td>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td><td></td></tr><tr><td><code>Null</code></td><td>该索引列是否允许存储<code>NULL</code></td></tr><tr><td>值。</td><td></td></tr><tr><td><code>Index_type</code></td><td>使用索引的类型，我们最常见的就是<code>BTREE</code></td></tr><tr><td>，其实也就是<code>B+</code></td><td></td></tr><tr><td>树索引。</td><td></td></tr><tr><td><code>Comment</code></td><td>索引列注释信息。</td></tr><tr><td><code>Index_comment</code></td><td>索引注释信息。</td></tr></tbody></table><p>上述属性其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。</p><p>前边说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p><ul><li> 使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。 </li><li> 使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。<br>结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个值的重复次数 ≈ Rows ÷ Cardinality</span><br></pre></td></tr></table></figure></li></ul><p>以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 ÷ 968 ≈ 10（条）</span><br></pre></td></tr></table></figure><p>此时再看上边那条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure><p>假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20000 x 10 = 200000</span><br></pre></td></tr></table></figure><p>使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是不精确！。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p><blockquote><p>在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</p></blockquote><h1 id="3-连接查询的成本"><a href="#3-连接查询的成本" class="headerlink" title="3. 连接查询的成本"></a>3. 连接查询的成本</h1><p>我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p><h2 id="3-1-条件过滤"><a href="#3-1-条件过滤" class="headerlink" title="3.1 条件过滤"></a>3.1 条件过滤</h2><p>我们前边说过，<code>MySQL</code>中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：</p><ul><li><p> 查询一：<br>假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2;</span><br></pre></td></tr></table></figure></li><li><p> 查询二：<br>仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前边计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">WHERE s1.key2 &gt;10 AND s1.key2 &lt; 1000;</span><br></pre></td></tr></table></figure></li></ul><p>有的时候扇出值的计算就变得很棘手，比方说下边几个查询：</p><ul><li><p> 查询三：<br>本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; &#39;xyz&#39;</code>条件。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 查询四：<br>本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; &#39;xyz&#39;</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; &#39;xyz&#39;</code>条件。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>查询五：<br>本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure><ul><li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></li><li><code>common_field &gt; &#39;xyz&#39;</code></li></ul></li></ul><p>也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。 </p><p>说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p><code>MySQL</code>把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是<code>MySQL</code>单纯的瞎猜。</p><blockquote><p>在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。在MySQL 5.7中，MySQL引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。 MySQL称之为启发式规则（heuristic）。</p></blockquote><h2 id="3-2-两表连接成本分析"><a href="#3-2-两表连接成本分析" class="headerlink" title="3.2 两表连接成本分析"></a>3.2 两表连接成本分析</h2><p>连接查询的成本计算公式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure><p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p><ul><li>分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p><ul><li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li><li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。</p><blockquote><p>左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询。</p></blockquote><p>比如对于下边这个查询来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND </span><br><span class="line">          s2.key2 &gt; 1000 AND s2.key2 &lt; 2000;</span><br></pre></td></tr></table></figure><p>可以选择的连接顺序有两种：</p><ul><li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li><li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li></ul><p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p><ul><li>使用<code>s1</code>作为驱动表的情况 <ul><li>分析对于驱动表的成本最低的执行方案<br>首先看一下涉及<code>s1</code>表单表的搜索条件有哪些： <ul><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li></ul></li></ul></li></ul><p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，很显然使用<code>idx_key2</code>执行查询的成本更低些。 </p><ul><li>然后分析对于被驱动表的成本最低的执行方案<br>此时涉及被驱动表<code>s2</code>的搜索条件就是： <ul><li><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</li><li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li></ul></li></ul><p>很显然，第一个条件由于<code>common_field</code>没有用到索引，此时访问<code>s2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，假设使用<code>idx_key2</code>的成本更小。<br>所以此时使用<code>s1</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</span><br></pre></td></tr></table></figure><ul><li>使用<code>s2</code>作为驱动表的情况 <ul><li>分析对于驱动表的成本最低的执行方案<br>首先看一下涉及<code>s2</code>表单表的搜索条件有哪些： <ul><li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li></ul></li></ul></li></ul><p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，假设使用<code>idx_key2</code>执行查询的成本更低些。 </p><ul><li>然后分析对于被驱动表的成本最低的执行方案<br>此时涉及被驱动表<code>s1</code>的搜索条件就是： <ul><li><code>s1.key1 = 常数</code></li><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 2000</code></li></ul></li></ul><p>这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这时优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上边已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们并不知道，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本更低，这里假设使用<code>idx_key1</code>进行对<code>s1</code>的访问。<br>所以此时使用<code>s2</code>作为驱动表时的总成本就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</span><br></pre></td></tr></table></figure><p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下边这两个部分：</p><ul><li> 尽量减少驱动表的扇出 </li><li> 对被驱动表的访问成本尽量低<br>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。 </li></ul><h2 id="3-3-多表连接的成本分析"><a href="#3-3-多表连接的成本分析" class="headerlink" title="3.3 多表连接的成本分析"></a>3.3 多表连接的成本分析</h2><p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p><ul><li> 对于两表连接，比如表A和表B连接<br>只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。 </li><li> 对于三表连接，比如表A、表B、表C进行连接<br>有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。 </li><li> 对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。 </li><li> 对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。 </li></ul><p>有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍，不过<code>MySQL</code>想了很多办法减少计算非常多种连接顺序的成本的方法：</p><ul><li> 提前结束某种顺序的成本评估<br><code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。 </li><li> 系统变量<code>optimizer_search_depth</code><br>为了防止无穷无尽的分析各种连接顺序的成本，<code>MySQL</code>提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。 </li><li> 根据某些规则压根儿就不考虑某些连接顺序<br>即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以<code>MySQL</code>干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。 </li></ul><h1 id="4-调节成本常数"><a href="#4-调节成本常数" class="headerlink" title="4. 调节成本常数"></a>4. 调节成本常数</h1><p>我们前边已经介绍了两个<code>成本常数</code>：</p><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>其实除了这两个成本常数，<code>MySQL</code>还支持好多，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库）的两个表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;</span><br><span class="line">+--------------------------+</span><br><span class="line">| Tables_in_mysql (%cost%) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| engine_cost              |</span><br><span class="line">| server_cost              |</span><br><span class="line">+--------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>一条语句的执行其实是分为两层的：</p><ul><li><code>server</code>层</li><li>存储引擎层</li></ul><p>在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p><h2 id="4-1mysql-server-cost表"><a href="#4-1mysql-server-cost表" class="headerlink" title="4.1mysql.server_cost表"></a>4.1mysql.server_cost表</h2><p><code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.server_cost;</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| cost_name                    | cost_value | last_update         | comment |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| disk_temptable_create_cost   |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| disk_temptable_row_cost      |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| key_compare_cost             |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_create_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_row_cost    |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| row_evaluate_cost            |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">6 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>我们先看一下<code>server_cost</code>各个列都分别是什么意思：</p><ul><li> <code>cost_name</code><br>表示成本常数的名称。 </li><li> <code>cost_value</code><br>表示成本常数对应的值。如果该列的值为<code>NULL</code>的话，意味着对应的成本常数会采用默认值。 </li><li> <code>last_update</code><br>表示最后更新记录的时间。 </li><li> <code>comment</code><br>注释。 </li></ul><p>从<code>server_cost</code>中的内容可以看出来，目前在<code>server</code>层的一些操作对应的<code>成本常数</code>有以下几种：</p><table><thead><tr><th>成本常数名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>disk_temptable_create_cost</code></td><td><code>40.0</code></td><td>创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td><code>disk_temptable_row_cost</code></td><td><code>1.0</code></td><td>向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td><code>key_compare_cost</code></td><td><code>0.1</code></td><td>两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code></td></tr><tr><td>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code></td><td></td><td></td></tr><tr><td>。</td><td></td><td></td></tr><tr><td><code>memory_temptable_create_cost</code></td><td><code>2.0</code></td><td>创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td><code>memory_temptable_row_cost</code></td><td><code>0.2</code></td><td>向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td><code>row_evaluate_cost</code></td><td><code>0.2</code></td><td>这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td></tr></tbody></table><blockquote><p>MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。<strong>创建临时表和对这个临时表进行写入和读取的操作代价还是很高的。</strong></p></blockquote><p>这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p><ul><li><p> 对我们感兴趣的成本常数做更新操作<br>比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.server_cost </span><br><span class="line">    SET cost_value = 0.4</span><br><span class="line">    WHERE cost_name = &#x27;row_evaluate_cost&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 让系统重新加载这个表的值。<br>使用下边语句即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li></ul><p>当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p><h2 id="4-2mysql-engine-cost表"><a href="#4-2mysql-engine-cost表" class="headerlink" title="4.2mysql.engine_cost表"></a>4.2mysql.engine_cost表</h2><p><code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.engine_cost;</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| engine_name | device_type | cost_name              | cost_value | last_update         | comment |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| default     |           0 | io_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| default     |           0 | memory_block_read_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p><ul><li> <code>engine_name</code>列<br>指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。 </li><li> <code>device_type</code>列<br>指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。 </li></ul><p>我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p><table><thead><tr><th>成本常数名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>io_block_read_cost</code></td><td><code>1.0</code></td><td>从磁盘上读取一个块对应的成本。请注意我使用的是<code>块</code></td></tr><tr><td>，而不是<code>页</code></td><td></td><td></td></tr><tr><td>这个词儿。对于<code>InnoDB</code></td><td></td><td></td></tr><tr><td>存储引擎来说，一个<code>页</code></td><td></td><td></td></tr><tr><td>就是一个块，不过对于<code>MyISAM</code></td><td></td><td></td></tr><tr><td>存储引擎来说，默认是以<code>4096</code></td><td></td><td></td></tr><tr><td>字节作为一个块的。增大这个值会加重<code>I/O</code></td><td></td><td></td></tr><tr><td>成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td><td></td><td></td></tr><tr><td><code>memory_block_read_cost</code></td><td><code>1.0</code></td><td>与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td></tr></tbody></table><p>怎么从内存中和从磁盘上读取一个块的默认成本是一样的？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以<code>MySQL</code>认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改。</p><p>与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p><ul><li><p> 插入针对某个存储引擎的成本常数<br>比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mysql.engine_cost</span><br><span class="line">    VALUES (&#x27;InnoDB&#x27;, 0, &#x27;io_block_read_cost&#x27;, 2.0,</span><br><span class="line">    CURRENT_TIMESTAMP, &#x27;increase Innodb I/O cost&#x27;);</span><br></pre></td></tr></table></figure></li><li><p> 让系统重新加载这个表的值。<br>使用下边语句即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>在MySQL中，一个查询的执行成本是由IO成本和CPU成本组成的。对于InnoDB存储引擎来说，读取一个页面的默认IO成本是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。</p><p>在单表查询中，优化器生成执行计划的步骤如下：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那个方案</li></ol><p>在优化器生成执行计划过程中，需要依赖一些数据。这些数据可能是使用下面两种方式得到的：</p><ol><li>index dive：通过直接访问索引对应的B+树来获取数据</li><li>索引统计数据：直接依赖对表或者索引的统计数据</li></ol><p>为了更准确的计算连接查询的成本，MySQL提出了条件过滤的概念，也就是采用了某些规则来预测驱动表的扇出值。</p><p>对于内连接来说，为了生成成本最低的执行计划，需要考虑两方面的事情：</p><ol><li>选择最优的表连接顺序</li><li>为驱动表和被驱动表选择成本最低的访问方法</li></ol><p>我们可以通过手动修改MySQL数据库下engine_cost &amp; server_cost表中的某些成本常数，更精确的控制在生成执行计划时的成本计算过程。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[六]单表查询&amp;连接查询原理</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一，单表查询"><a href="#一，单表查询" class="headerlink" title="一，单表查询"></a><strong>一</strong>，单表查询</h1><p>不会走之前不要跑，在学SQL优化之前，我们先来分析下SQL是怎么执行的。</p><p>前面说过，<code>MySQL Server</code>有一个称为<code>查询优化器</code>的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的<code>执行计划</code>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p><p>如果觉得我这篇博客讲的看不懂，回头看看我前面的几篇，MySQL是一个很复杂的东西，尽量不要跳着学，要静下心系统的来学习，之前我都是四处看帖子看博客，一直觉得自己MySQL迷迷糊糊，甚至成了痛点，所以决心写个MySQL专栏，系统的学习下。</p><p>我们前面创建过一张表，现在拿来复用下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>我们为这个<code>single_table</code>表建立了1个聚簇索引和4个二级索引，分别是：</p><ul><li>为<code>id</code>列建立的聚簇索引。</li><li>为<code>key1</code>列建立的<code>idx_key1</code>二级索引。</li><li>为<code>key2</code>列建立的<code>idx_key2</code>二级索引，而且该索引是唯一二级索引。</li><li>为<code>key3</code>列建立的<code>idx_key3</code>二级索引。</li><li>为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>列建立的<code>idx_key_part</code>二级索引，这也是一个联合索引。</li></ul><p>这张表我插入了一百万数据，用来做实验。</p><h2 id="1-访问方法"><a href="#1-访问方法" class="headerlink" title="1.访问方法"></a>1.访问方法</h2><p>对于单个表的查询来说，MySQL把查询的执行方式大致分为下边两种：</p><ul><li> 使用全表扫描进行查询<br>这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。 </li><li>使用索引进行查询<br>因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类： <ul><li>针对主键或唯一二级索引的等值查询</li><li>针对普通二级索引的等值查询</li><li>针对索引列的范围查询</li><li>直接扫描整个索引</li></ul></li></ul><p><code>MySQL</code>把<code>MySQL</code>执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能相差很多。</p><h2 id="2-const"><a href="#2-const" class="headerlink" title="2.const"></a>2.const</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id = 1438;</span><br></pre></td></tr></table></figure><p><code>MySQL</code>会直接利用主键值在聚簇索引中定位对应的用户记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103085231-5c954328-c25e-401a-81eb-4339b0fcb577.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7458340a&margin=%5Bobject%20Object%5D&name=1.png&originHeight=440&originWidth=573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50562&status=done&style=none&taskId=u7102ad8d-f063-4069-aa27-905850afdc8&title=" alt="1.png"></p><p><code>**B+**</code><strong>树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的</strong><code>**B+**</code><strong>树叶子节点中的记录就是按照</strong><code>**id**</code><strong>列排序的。</strong>所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 = 3841;</span><br></pre></td></tr></table></figure><p>这个查询的执行过程的示意图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103092812-dc9c5731-27e4-47df-983d-759d09654719.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1166289d&margin=%5Bobject%20Object%5D&name=2.png&originHeight=596&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=159765&status=done&style=none&taskId=u57c775c3-45a1-43e1-a318-25b1b176f70&title=" alt="2.png"></p><p>这个查询的执行分两步：</p><ol><li>先从<code>idx_key2</code>对应的<code>B+</code>树索引中根据<code>key2</code>列与常数的等值比较条件定位到一条二级索引记录</li><li>再根据该记录的<code>id</code>值到聚簇索引中获取到完整的用户记录</li></ol><p><code>MySQL</code>认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录非常快，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：<code>const</code>，意思是常数级别的，代价是可以忽略不计的。不过这种<code>const</code>访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个<code>const</code>访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。</p><p>对于唯一二级索引来说，查询该列为<code>NULL</code>值的情况比较特殊，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IS NULL;</span><br></pre></td></tr></table></figure><p>因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用<code>const</code>访问方法来执行。</p><h2 id="3-ref"><a href="#3-ref" class="headerlink" title="3.ref"></a>3.ref</h2><p>有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的<code>id</code>值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以<code>MySQL</code>可能选择使用索引而不是全表扫描的方式来执行查询。MySQL把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：<code>ref</code>。我们看一下采用<code>ref</code>访问方法执行查询的图示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103103047-d3232525-adc5-43e0-920c-a21da1bcf02f.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7fd346ba&margin=%5Bobject%20Object%5D&name=3.png&originHeight=571&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157444&status=done&style=none&taskId=ub0bb4412-15a5-46c2-9696-9e0cf98d47b&title=" alt="3.png"></p><p>对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种<code>ref</code>访问方法比<code>const</code>差了那么一点，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了）。</p><p>有两种特殊情况：</p><ul><li> 二级索引列值为<code>NULL</code>的情况<br>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含<code>NULL</code>值的数量并不限制，所以我们采用<code>key IS NULL</code>这种形式的搜索条件最多只能使用<code>ref</code>的访问方法，而不是<code>const</code>的访问方法。 </li><li> 对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用<code>ref</code>的访问方法，比方说下边这几个查询： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 = &#x27;legendary&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 = &#x27;legendary&#x27; AND key_part3 = &#x27;penta kill&#x27;;</span><br></pre></td></tr></table></figure><p>但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为<code>ref</code>了，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 &gt; &#x27;legendary&#x27;;</span><br></pre></td></tr></table></figure><h2 id="4-ref-or-null"><a href="#4-ref-or-null" class="headerlink" title="4.ref_or_null"></a>4.ref_or_null</h2><p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为<code>NULL</code>的记录也找出来，就像下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure><p>当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为<code>ref_or_null</code>，这个<code>ref_or_null</code>访问方法的执行过程如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103112647-02b81ae3-23ba-4eac-adcd-1699c6b384de.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua961cb22&margin=%5Bobject%20Object%5D&name=4.png&originHeight=581&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175770&status=done&style=none&taskId=uc5f31edd-d5d3-435c-baa7-c24c0d5d7d2&title=" alt="4.png"></p><p>上边的查询相当于先分别从<code>idx_key1</code>索引对应的<code>B+</code>树中找出<code>key1 IS NULL</code>和<code>key1 = &#39;abc&#39;</code>的两个连续的记录范围，然后根据这些二级索引记录中的<code>id</code>值再回表查找完整的用户记录。</p><h2 id="5-range"><a href="#5-range" class="headerlink" title="5.range"></a>5.range</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);</span><br></pre></td></tr></table></figure><p>如果采用<code>二级索引 + 回表</code>的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中<code>key2</code>列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：</p><ul><li><code>key2</code>的值是<code>1438</code></li><li><code>key2</code>的值是<code>6328</code></li><li><code>key2</code>的值在<code>38</code>和<code>79</code>之间。</li></ul><p><code>MySQL</code>把这种利用索引进行范围匹配的访问方法称之为：<code>range</code>。</p><blockquote><p>此处所说的使用索引进行范围匹配中的 <code>索引</code> 可以是聚簇索引，也可以是二级索引。</p></blockquote><p>我们可以把那种索引列等值匹配的情况称之为<code>单点区间</code>，上边所说的<code>范围1</code>和<code>范围2</code>都可以被称为单点区间，像<code>范围3</code>这种的我们可以称为连续范围区间。</p><h2 id="6-index"><a href="#6-index" class="headerlink" title="6.index"></a>6.index</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>由于<code>key_part2</code>并不是联合索引<code>idx_key_part</code>最左索引列，所以我们无法使用<code>ref</code>或者<code>range</code>访问方法来执行这个语句。但是这个查询符合下边这两个条件：</p><ul><li>它的查询列表只有3个列：<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>，而索引<code>idx_key_part</code>又包含这三个列。</li><li>搜索条件中只有<code>key_part2</code>列。这个列也包含在索引<code>idx_key_part</code>中。</li></ul><p>也就是说我们可以直接通过遍历<code>idx_key_part</code>索引的叶子节点的记录来比较<code>key_part2 = &#39;abc&#39;</code>这个条件是否成立，把匹配成功的二级索引记录的<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，<code>MySQL</code>就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p><h2 id="7-all"><a href="#7-all" class="headerlink" title="7.all"></a>7.all</h2><p>全表扫描</p><h2 id="8-注意"><a href="#8-注意" class="headerlink" title="8.注意"></a>8.注意</h2><h3 id="8-1-二级索引-回表"><a href="#8-1-二级索引-回表" class="headerlink" title="8.1  二级索引 + 回表"></a>8.1  二级索引 + 回表</h3><p>一般情况下只能利用单个二级索引执行查询，比方说下边的这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27; AND key2 &gt; 1000;</span><br></pre></td></tr></table></figure><p>查询优化器会识别到这个查询中的两个搜索条件：</p><ul><li><code>key1 = &#39;abc&#39;</code></li><li><code>key2 &gt; 1000</code></li></ul><p>优化器一般会根据<code>single_table</code>表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的<code>WHERE</code>条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是<code>ref</code>的访问方法一般比<code>range</code>好，但这也不总是一定的，也可能采用<code>ref</code>访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用<code>idx_key1</code>索引进行查询，那么整个查询过程可以分为两个步骤：</p><ol><li>使用二级索引定位记录的阶段，也就是根据条件<code>key1 = &#39;abc&#39;</code>从<code>idx_key1</code>索引代表的<code>B+</code>树中找到对应的二级索引记录。</li><li>回表阶段，也就是根据上一步骤中找到的记录的主键值进行<code>回表</code>操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件<code>key2 &gt; 1000</code>到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。</li></ol><p>注意，因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用<code>idx_key1</code>索引进行查询时只会用到与<code>key1</code>列有关的搜索条件，其余条件，比如<code>key2 &gt; 1000</code>这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤。</p><blockquote><p>一般情况下执行一个查询只会用到单个二级索引，不过还是有特殊情况的。</p></blockquote><p>从上文可以看出，每次从二级索引中读取到一条记录后，就会根据该记录的主键值执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机I/O带来的性能开销比较大。于是MySQL提出了一个名为Disk-S weep Multi-Range Read(MRR，多范围读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执行回表操作。相对于每读取一条二级索引记录 就立即执行回表操作，这样会节省一些I/0开销。当然使用这个MRR优化措施的条件比较苛刻，我们之前的讨论中没有涉及MRR 之后的讨论中也将忽略这项优化措施，直接认为每读取一条二级索引记录就立即执行回表操作。</p><h3 id="8-2-range访问方法使用的范围区间"><a href="#8-2-range访问方法使用的范围区间" class="headerlink" title="8.2 range访问方法使用的范围区间"></a>8.2 range访问方法使用的范围区间</h3><p>其实对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>区间</code>。</p><blockquote><p>LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引。 IN操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328);</span><br><span class="line">    </span><br><span class="line">SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328;</span><br></pre></td></tr></table></figure><p>在日常的工作中，一个查询的<code>WHERE</code>子句可能有很多个小的搜索条件，这些搜索条件需要使用<code>AND</code>或者<code>OR</code>操作符连接起来。当我们想使用<code>range</code>访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。</p><h2 id="9-索引合并"><a href="#9-索引合并" class="headerlink" title="9.索引合并"></a>9.索引合并</h2><p><code>MySQL</code>在一般情况下执行一个查询时最多只会用到单个二级索引，但是还有特殊情况，在这些特殊情况下也可能在一个查询中使用到多个二级索引，<code>MySQL</code>把这种使用到多个索引来完成一次查询的执行方法称之为：<code>index merge</code>，具体的索引合并算法有下边三种。</p><h3 id="9-1-Intersection合并"><a href="#9-1-Intersection合并" class="headerlink" title="9.1 Intersection合并"></a>9.1 Intersection合并</h3><p><code>Intersection</code>翻译过来的意思是<code>交集</code>。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>假设这个查询使用<code>Intersection</code>合并的方式执行的话，那这个过程就是这样的：</p><ul><li>从<code>idx_key1</code>二级索引对应的<code>B+</code>树中取出<code>key1 = &#39;a&#39;</code>的相关记录。</li><li>从<code>idx_key3</code>二级索引对应的<code>B+</code>树中取出<code>key3 = &#39;b&#39;</code>的相关记录。</li><li>二级索引的记录都是由<code>索引列 + 主键</code>构成的，所以我们可以计算出这两个结果集中<code>id</code>值的交集。</li><li>按照上一步生成的<code>id</code>值列表进行回表操作，也就是从聚簇索引中把指定<code>id</code>值的完整用户记录取出来，返回给用户。</li></ul><p>为啥不直接使用<code>idx_key1</code>或者<code>idx_key3</code>只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。</p><ol><li>只读取一个二级索引的成本：</li></ol><ul><li>按照某个搜索条件读取一个二级索引</li><li>根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</li></ul><ol start="2"><li>读取多个二级索引之后取交集成本：</li></ol><ul><li>按照不同的搜索条件分别读取不同的二级索引</li><li>将从多个二级索引得到的主键值取交集，然后进行回表操作</li></ul><p>虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是<code>顺序I/O</code>，而回表操作是<code>随机I/O</code>，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为<code>回表</code>而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p><p><code>MySQL</code>在某些特定的情况下才可能会使用到<code>Intersection</code>索引合并：</p><ul><li> 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。<br>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Intersection</code>索引合并的操作： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>而下边这两个查询就不能进行<code>Intersection</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#x27;a&#x27; AND key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Intersection</code>索引合并。</p><ul><li> 情况二：主键列可以是范围匹配<br>比方说下边这个查询可能用到主键和<code>idx_key1</code>进行<code>Intersection</code>索引合并的操作： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id &gt; 100 AND key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>对于<code>InnoDB</code>的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由<code>索引列 + 主键</code>构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照<code>主键</code>的值进行排序的。所以在二级索引列都是等值匹配的情况下才可能使用<code>Intersection</code>索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</p><p><strong>根据二级索引查询出的结果集是按照主键值排序的对使用</strong><code>**Intersection**</code><strong>索引合并的好处？</strong><code>Intersection</code>索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很简单。假设某个查询使用<code>Intersection</code>索引合并的方式从<code>idx_key1</code>和<code>idx_key2</code>这两个二级索引中获取到的主键值分别是：</p><ul><li>从<code>idx_key1</code>中获取到已经排好序的主键值：1、3、5</li><li>从<code>idx_key2</code>中获取到已经排好序的主键值：2、3、4</li></ul><p>那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了：</p><ul><li>先取出这两个结果集中较小的主键值做比较，因为<code>1 &lt; 2</code>，所以把<code>idx_key1</code>的结果集的主键值<code>1</code>丢弃，取出后边的<code>3</code>来比较。</li><li>因为<code>3 &gt; 2</code>，所以把<code>idx_key2</code>的结果集的主键值<code>2</code>丢弃，取出后边的<code>3</code>来比较。</li><li>因为<code>3 = 3</code>，所以把<code>3</code>加入到最后的交集结果中，继续两个结果集后边的主键值来比较。</li><li>后边的主键值也不相等，所以最后的交集结果中只包含主键值<code>3</code>。</li></ul><p>这个过程其实很快，时间复杂度是<code>O(n)</code>，但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。</p><blockquote><p>按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR。</p></blockquote><p>另外，不仅是多个二级索引之间可以采用<code>Intersection</code>索引合并，索引合并也可以有聚簇索引参加，也就是我们上边写的<code>情况二</code>：在搜索条件中有主键的范围匹配的情况下也可以使用<code>Intersection</code>索引合并索引合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND id &gt; 100;</span><br></pre></td></tr></table></figure><p>假设这个查询可以采用<code>Intersection</code>索引合并，我们理所当然的以为这个查询会分别按照<code>id &gt; 100</code>这个条件从聚簇索引中获取一些记录，在通过<code>key1 = &#39;a&#39;</code>这个条件从<code>idx_key1</code>二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。二级索引的记录中都带有主键值的，所以可以在从<code>idx_key1</code>中获取到的主键值上直接运用条件<code>id &gt; 100</code>过滤就行了。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。</p><p>当然，上边说的<code>情况一</code>和<code>情况二</code>只是发生<code>Intersection</code>索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生<code>Intersection</code>索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过<code>Intersection</code>索引合并后需要回表的记录数大大减少时才会使用<code>Intersection</code>索引合并。</p><h3 id="9-2-Union合并"><a href="#9-2-Union合并" class="headerlink" title="9.2 Union合并"></a>9.2 Union合并</h3><p>有时候<code>OR</code>关系的不同搜索条件会使用到不同的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p><code>Intersection</code>是交集的意思，这适用于使用不同索引的搜索条件之间使用<code>AND</code>连接起来的情况；<code>Union</code>是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。与<code>Intersection</code>索引合并类似，<code>MySQL</code>在某些特定的情况下才可能会使用到<code>Union</code>索引合并：</p><ul><li> 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。<br>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Union</code>索引合并的操作： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR ( key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;);</span><br></pre></td></tr></table></figure><p>而下边这两个查询就不能进行<code>Union</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#x27;a&#x27; OR (key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Union</code>索引合并。</p><ul><li>情况二：主键列可以是范围匹配</li><li>情况三：使用<code>Intersection</code>索引合并的搜索条件</li></ul><p>这种情况其实就是搜索条件的某些部分使用<code>Intersection</code>索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27; OR (key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>优化器可能采用这样的方式来执行这个查询：</p><ul><li>先按照搜索条件<code>key1 = &#39;a&#39; AND key3 = &#39;b&#39;</code>从索引<code>idx_key1</code>和<code>idx_key3</code>中使用<code>Intersection</code>索引合并的方式得到一个主键集合。</li><li>再按照搜索条件<code>key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39; AND key_part3 = &#39;c&#39;</code>从联合索引<code>idx_key_part</code>中得到另一个主键集合。</li><li>采用<code>Union</code>索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li></ul><p>当然，查询条件符合了这些情况也不一定就会采用<code>Union</code>索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p><h3 id="9-3-Sort-Union合并"><a href="#9-3-Sort-Union合并" class="headerlink" title="9.3 Sort-Union合并"></a>9.3 Sort-Union合并</h3><p><code>Union</code>索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到<code>Union</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &lt; &#x27;a&#x27; OR key3 &gt; &#x27;z&#x27;</span><br></pre></td></tr></table></figure><p>这是因为根据<code>key1 &lt; &#39;a&#39;</code>从<code>idx_key1</code>索引中获取的二级索引记录的主键值不是排好序的，根据<code>key3 &gt; &#39;z&#39;</code>从<code>idx_key3</code>索引中获取的二级索引记录的主键值也不是排好序的，但是<code>key1 &lt; &#39;a&#39;</code>和<code>key3 &gt; &#39;z&#39;</code>这两个条件又特别让我们动心，所以我们可以这样：</p><ul><li>先根据<code>key1 &lt; &#39;a&#39;</code>条件从<code>idx_key1</code>二级索引中获取记录，并按照记录的主键值进行排序</li><li>再根据<code>key3 &gt; &#39;z&#39;</code>条件从<code>idx_key3</code>二级索引中获取记录，并按照记录的主键值进行排序</li><li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了。</li></ul><p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p><blockquote><p>为啥有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说， Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高 而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection。</p></blockquote><h3 id="9-4-索引合并注意事项"><a href="#9-4-索引合并注意事项" class="headerlink" title="9.4 索引合并注意事项"></a>9.4 索引合并注意事项</h3><h4 id="联合索引替代Intersection索引合并"><a href="#联合索引替代Intersection索引合并" class="headerlink" title="联合索引替代Intersection索引合并"></a>联合索引替代Intersection索引合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>这个查询之所以可能使用<code>Intersection</code>索引合并的方式执行，还不是因为<code>idx_key1</code>和<code>idx_key3</code>是两个单独的<code>B+</code>树索引，要是把这两个列搞一个联合索引，那直接使用这个联合索引就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE single_table drop index idx_key1, idx_key3, add index idx_key1_key3(key1, key3);</span><br></pre></td></tr></table></figure><p>这样我们把没用的<code>idx_key1</code>、<code>idx_key3</code>都干掉，再添加一个联合索引<code>idx_key1_key3</code>，使用这个联合索引进行查询效果更好，既不用多读一棵<code>B+</code>树，也不用合并结果。</p><blockquote><p>不过如果有单独对key3列进行查询的业务场景，这样子不得不再把key3列的单独索引给加上。具体还得以业务为准。</p></blockquote><h1 id="二，连接查询原理"><a href="#二，连接查询原理" class="headerlink" title="二，连接查询原理"></a>二，连接查询原理</h1><h2 id="1-连接简介"><a href="#1-连接简介" class="headerlink" title="1. 连接简介"></a>1. 连接简介</h2><h3 id="1-1-连接的本质"><a href="#1-1-连接的本质" class="headerlink" title="1.1 连接的本质"></a>1.1 连接的本质</h3><p>我们先建立两个简单的表并给它们填充一点数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (m1 int, n1 char(1));</span><br><span class="line"></span><br><span class="line">CREATE TABLE t2 (m2 int, n2 char(1));</span><br><span class="line"></span><br><span class="line">INSERT INTO t1 VALUES(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO t2 VALUES(2, &#x27;b&#x27;), (3, &#x27;c&#x27;), (4, &#x27;d&#x27;);</span><br></pre></td></tr></table></figure><p>我们成功建立了<code>t1</code>、<code>t2</code>两个表，这两个表都有两个列，一个是<code>INT</code>类型的，一个是<code>CHAR(1)</code>类型的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2   | n2   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把<code>t1</code>和<code>t2</code>两个表连接起来的过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103128021-169724be-ad76-430d-88d4-27b8c7ef3b05.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud419858f&margin=%5Bobject%20Object%5D&name=5.png&originHeight=386&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132855&status=done&style=none&taskId=u39b88778-304b-4c35-b4f3-2f176449c1b&title=" alt="5.png"></p><p>这个过程看起来就是把<code>t1</code>表的记录和<code>t2</code>的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为<code>笛卡尔积</code>。因为表<code>t1</code>中有3条记录，表<code>t2</code>中也有3条记录，所以这两个表连接之后的笛卡尔积就有<code>3×3=9</code>行记录。在<code>MySQL</code>中，连接查询的语法很简单，只要在<code>FROM</code>语句后边跟多个表名就好了，比如我们把<code>t1</code>表和<code>t2</code>表连接起来的查询语句可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2;</span><br></pre></td></tr></table></figure><h3 id="1-2-连接过程简介"><a href="#1-2-连接过程简介" class="headerlink" title="1.2 连接过程简介"></a>1.2 连接过程简介</h3><p>在连接查询中的过滤条件可以分成两种：</p><ul><li> 涉及单表的条件<br>这种只涉及单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为<code>搜索条件</code>，比如<code>t1.m1 &gt; 1</code>是只针对<code>t1</code>表的过滤条件，<code>t2.n2 &lt; &#39;d&#39;</code>是只针对<code>t2</code>表的过滤条件。 </li><li> 涉及两表的条件<br>这种过滤条件我们之前没见过，比如<code>t1.m1 = t2.m2</code>、<code>t1.n1 &gt; t2.n2</code>等，这些条件中涉及到了两个表。 </li></ul><p>我们看一下携带过滤条件的连接查询的大致执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure><p>在这个查询中我们指明了这三个过滤条件：</p><ul><li><code>t1.m1 &gt; 1</code></li><li><code>t1.m1 = t2.m2</code></li><li><code>t2.n2 &lt; &#39;d&#39;</code></li></ul><p>这个连接查询的大致执行过程如下：</p><ol><li> 首先确定第一个需要查询的表，这个表称之为<code>驱动表</code>。此处假设使用<code>t1</code>作为驱动表，那么就需要到<code>t1</code>表中找满足<code>t1.m1 &gt; 1</code>的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询<code>t1</code>表的访问方法就设定为<code>all</code>吧，也就是采用全表扫描的方式执行单表查询，所以查询过程就如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103137241-5f6ca008-f17b-44e8-b9a2-848e217eb287.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubff6b2a5&margin=%5Bobject%20Object%5D&name=6.png&originHeight=228&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45158&status=done&style=none&taskId=u2ab46c4d-01ec-4c86-a78b-46fd6bb81f6&title=" alt="6.png"><br>我们可以看到，<code>t1</code>表中符合<code>t1.m1 &gt; 1</code>的记录有两条。 </li><li> 针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到<code>t2</code>表中查找匹配的记录，所谓<code>匹配的记录</code>，指的是符合过滤条件的记录。因为是根据<code>t1</code>表中的记录去找<code>t2</code>表中的记录，所以<code>t2</code>表也可以被称之为<code>被驱动表</code>。上一步骤从驱动表中得到了2条记录，所以需要查询2次<code>t2</code>表。此时涉及两个表的列的过滤条件<code>t1.m1 = t2.m2</code>就派上用场了： </li></ol><ul><li>当<code>t1.m1 = 2</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 2</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 2</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li><li>当<code>t1.m1 = 3</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 3</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 3</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li></ul><p>所以整个连接查询的执行过程就如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103145039-c650a6a9-c051-481b-937c-b1e332d6bf9e.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc1ba2202&margin=%5Bobject%20Object%5D&name=7.png&originHeight=386&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92768&status=done&style=none&taskId=u98e6d49c-aa2e-4c67-a098-9ea24815ff5&title=" alt="7.png"></p><p>也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br></pre></td></tr></table></figure><p>这个两表连接查询共需要查询1次<code>t1</code>表，2次<code>t2</code>表。当然这是在特定的过滤条件下的结果，如果我们把<code>t1.m1 &gt; 1</code>这个条件去掉，那么从<code>t1</code>表中查出的记录就有3条，就需要查询3次<code>t2</code>表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p><h3 id="1-3-内连接和外连接"><a href="#1-3-内连接和外连接" class="headerlink" title="1.3 内连接和外连接"></a>1.3 内连接和外连接</h3><p>我们先创建两个有现实意义的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    number INT NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">    name VARCHAR(5) COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    major VARCHAR(30) COMMENT &#x27;专业&#x27;,</span><br><span class="line">    PRIMARY KEY (number)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    number INT COMMENT &#x27;学号&#x27;,</span><br><span class="line">    subject VARCHAR(30) COMMENT &#x27;科目&#x27;,</span><br><span class="line">    score TINYINT COMMENT &#x27;成绩&#x27;,</span><br><span class="line">    PRIMARY KEY (number, subject)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生成绩表&#x27;;</span><br></pre></td></tr></table></figure><p>我们新建了一个学生信息表，一个学生成绩表，然后我们向上述两个表中插入一些数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student;</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">| number   | name      | major                    |</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">| 20180101 | 杜子腾    | 软件学院                 |</span><br><span class="line">| 20180102 | 范统      | 计算机科学与工程         |</span><br><span class="line">| 20180103 | 史珍香    | 计算机科学与工程         |</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM score;</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">| number   | subject                     | score |</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">| 20180101 | 母猪的产后护理              |    78 |</span><br><span class="line">| 20180101 | 论萨达姆的战争准备          |    88 |</span><br><span class="line">| 20180102 | 论萨达姆的战争准备          |    98 |</span><br><span class="line">| 20180102 | 母猪的产后护理              |   100 |</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了（因为<code>score</code>中没有姓名信息，所以不能单纯只查询<code>score</code>表）。连接过程就是从<code>student</code>表中取出记录，在<code>score</code>表中查找<code>number</code>相同的成绩记录，所以过滤条件就是<code>student.number = socre.number</code>，整个查询语句就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student, score WHERE student.number = score.number;</span><br></pre></td></tr></table></figure><p>从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，<code>史珍香</code>同学，也就是学号为<code>20180103</code>的同学因为某些原因没有参加考试，所以在<code>score</code>表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的<code>连接查询</code>是无法完成这样的需求的。</p><p>这个需求的本质是：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了<code>内连接</code>和<code>外连接</code>的概念。</p><ul><li> 对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的<code>内连接</code>。 </li><li>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。<br>在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种： <ul><li>左外连接：选取左侧的表为驱动表。</li><li>右外连接：选取右侧的表为驱动表。</li></ul></li></ul><p>对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。把过滤条件分为两种就可以了，所以放在不同地方的过滤条件是有不同语义的：</p><ul><li> <code>WHERE</code>子句中的过滤条件<br><code>WHERE</code>子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合<code>WHERE</code>子句中的过滤条件的记录都不会被加入最后的结果集。 </li><li> <code>ON</code>子句中的过滤条件<br>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用<code>NULL</code>值填充。 </li></ul><p>需要注意的是，这个<code>ON</code>子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把<code>ON</code>子句放到内连接中，<code>MySQL</code>会把它和<code>WHERE</code>子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。</p><p>一般情况下，我们都把只涉及单表的过滤条件放到<code>WHERE</code>子句中，把涉及两表的过滤条件都放到<code>ON</code>子句中，我们也一般把放到<code>ON</code>子句中的过滤条件也称之为<code>连接条件</code>。</p><h4 id="1-3-1-左（外）连接的语法"><a href="#1-3-1-左（外）连接的语法" class="headerlink" title="1.3.1 左（外）连接的语法"></a>1.3.1 左（外）连接的语法</h4><p>比如我们要把<code>t1</code>表和<code>t2</code>表进行左外连接查询可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>其中中括号里的<code>OUTER</code>单词是可以省略的。对于<code>LEFT JOIN</code>类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。所以上述例子中<code>t1</code>就是外表或者驱动表，<code>t2</code>就是内表或者被驱动表。需要注意的是，对于左（外）连接和右（外）连接来说，必须使用<code>ON</code>子句来指出连接条件。</p><p>回到我们上边那个现实问题中来，看看怎样写查询语句才能把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;</span><br></pre></td></tr></table></figure><p>从结果集中可以看出来，虽然<code>史珍香</code>并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把她放到了结果集中，只不过在对应的成绩记录的各列使用<code>NULL</code>值填充而已。</p><h4 id="1-3-2-右（外）连接的语法"><a href="#1-3-2-右（外）连接的语法" class="headerlink" title="1.3.2 右（外）连接的语法"></a>1.3.2 右（外）连接的语法</h4><p>右（外）连接和左（外）连接的原理是一样一样的，语法也只是把<code>LEFT</code>换成<code>RIGHT</code>而已：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>只不过驱动表是右边的表，被驱动表是左边的表。</p><h4 id="1-3-3-内连接的语法"><a href="#1-3-3-内连接的语法" class="headerlink" title="1.3.3 内连接的语法"></a>1.3.3 内连接的语法</h4><p>内连接和外连接的根本区别就是在驱动表中的记录不符合<code>ON</code>子句中的连接条件时不会把该记录加入到最后的结果集。</p><p>一种最简单的内连接语法，就是直接把需要连接的多个表都放到<code>FROM</code>子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以<code>t1</code>和<code>t2</code>表为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>也就是说在<code>MySQL</code>中，下边这几种内连接的写法都是等价的：</p><ul><li>SELECT * FROM t1 JOIN t2;</li><li>SELECT * FROM t1 INNER JOIN t2;</li><li>SELECT * FROM t1 CROSS JOIN t2;</li></ul><p>上边的这些写法和直接把需要连接的表名放到<code>FROM</code>语句之后，用逗号<code>,</code>分隔开的写法是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2;</span><br></pre></td></tr></table></figure><p>在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。</p><p>前边说过，连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。而对于内连接来说，由于凡是不符合<code>ON</code>子句或<code>WHERE</code>子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合ON子句条件的记录时也要将其加入到结果集，所以此时驱动表和被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换。</p><h2 id="2-连接的原理"><a href="#2-连接的原理" class="headerlink" title="2.连接的原理"></a>2.连接的原理</h2><p>接下来看一下MySQL采用了什么样的算法来进行表与表之间的连接。</p><h3 id="2-1-嵌套循环连接"><a href="#2-1-嵌套循环连接" class="headerlink" title="2.1 嵌套循环连接"></a>2.1 嵌套循环连接</h3><p>对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。</p><p>再来看一下<code>t1</code>表和<code>t2</code>表执行内连接查询的大致过程：</p><ul><li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li><li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li></ul><p>通用的两表连接过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103159882-9771a923-7a5e-4d93-9d96-8ba02b9c732a.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udb034861&margin=%5Bobject%20Object%5D&name=8.png&originHeight=397&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93464&status=done&style=none&taskId=u1de44252-9bc7-44ee-bc05-48a7d9b564b&title=" alt="8.png"></p><p>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是<code>步骤2</code>中得到的结果集中的每一条记录都需要到<code>t3</code>表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 &#123;   #此处表示遍历满足对t1单表查询结果集中的每一条记录</span><br><span class="line">    </span><br><span class="line">    for each row in t2 &#123;   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录</span><br><span class="line">    </span><br><span class="line">        for each row in t3 &#123;   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询</span><br><span class="line">            if row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<code>嵌套循环连接</code>（<code>Nested-Loop Join</code>），这是最简单，也是最笨拙的一种连接查询算法。</p><h3 id="2-2-使用索引加快连接速度"><a href="#2-2-使用索引加快连接速度" class="headerlink" title="2.2 使用索引加快连接速度"></a>2.2 使用索引加快连接速度</h3><p>在<code>嵌套循环连接</code>的<code>步骤2</code>中可能需要访问多次被驱动表，如果访问被驱动表的方式都是全表扫描的话，要查很多次。但是查询<code>t2</code>表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度。回到最开始的<code>t1</code>表和<code>t2</code>表进行内连接的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640103172521-d5df075b-57e4-47f9-87cf-0c120e1f5486.jpeg#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf6ae63ce&margin=%5Bobject%20Object%5D&name=%E9%80%9A%E7%94%A8%E4%B8%A4%E5%BC%A0%E8%A1%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg&originHeight=1214&originWidth=2550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=268198&status=done&style=shadow&taskId=u37a2eaa4-6f87-44ac-8fb2-05dd6470b20&title=" alt="通用两张表连接过程.jpg"></p><p>查询驱动表<code>t1</code>后的结果集中有两条记录，<code>嵌套循环连接</code>算法需要对被驱动表查询2次：</p><ul><li><p> 当<code>t1.m1 = 2</code>时，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，原来的<code>t1.m1 = t2.m2</code>这个涉及两个表的过滤条件在针对<code>t2</code>表做查询时关于<code>t1</code>表的条件就已经确定了，所以我们只需要单单优化对<code>t2</code>表的查询了，上述两个对<code>t2</code>表的查询语句中利用到的列是<code>m2</code>和<code>n2</code>列，我们可以：</p><ul><li> 在<code>m2</code>列上建立索引，因为对<code>m2</code>列的条件是等值查找，比如<code>t2.m2 = 2</code>、<code>t2.m2 = 3</code>等，所以可能使用到<code>ref</code>的访问方法，假设使用<code>ref</code>的访问方法去执行对<code>t2</code>表的查询的话，需要回表之后再判断<code>t2.n2 &lt; d</code>这个条件是否成立。<br>这里有一个比较特殊的情况，就是假设<code>m2</code>列是<code>t2</code>表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从<code>t2</code>表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而<code>MySQL</code>把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。 </li><li> 在<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; &#39;d&#39;</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。 </li></ul><p>假设<code>m2</code>和<code>n2</code>列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对<code>t2</code>表的查询。当然，建立了索引不一定使用索引，只有在<code>二级索引 + 回表</code>的代价比全表扫描的代价更低时才会使用索引。</p><p>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用<code>*</code>作为查询列表，最好把真实用到的列作为查询列表。</p><h3 id="2-3-基于块的嵌套循环连接"><a href="#2-3-基于块的嵌套循环连接" class="headerlink" title="2.3 基于块的嵌套循环连接"></a>2.3 基于块的嵌套循环连接</h3><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中的表可不像<code>t1</code>、<code>t2</code>这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：尽量减少访问被驱动表的次数。</p><p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。</p><p><strong>如果在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价。</strong></p><p><code>MySQL</code>提出了一个<code>join buffer</code>的概念，<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640103192756-bf8742e1-011a-4c59-8287-1526091cc67d.jpeg#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udffc465f&margin=%5Bobject%20Object%5D&name=%E9%80%9A%E7%94%A8%E4%B8%A4%E5%BC%A0%E8%A1%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%26JOIN%20BUFFER.jpg&originHeight=1214&originWidth=3664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=353466&status=done&style=shadow&taskId=u48cf259d-db08-4290-ab9b-43a4c2f5c9a&title=" alt="通用两张表连接过程&amp;JOIN BUFFER.jpg"></p><p>最好的情况是<code>join buffer</code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。<code>MySQL</code>把这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><p>这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[五]InnoDb表空间</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%BA%94%5DInnoDb%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%BA%94%5DInnoDb%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前面的两篇文章已经对InnoDB索引的结构，页存储结构，行格式做了十分细致的分析，也详细阐述了为什么你的SQL会慢，索引命中的原理，接下来我要继续深入学习MySQL。在此之前还要先来补充一下MySQL的一些基础知识。</p></blockquote><h1 id="一，MySQL的数据目录"><a href="#一，MySQL的数据目录" class="headerlink" title="一，MySQL的数据目录"></a>一，MySQL的数据目录</h1><h2 id="1-数据库和文件系统的关系"><a href="#1-数据库和文件系统的关系" class="headerlink" title="1. 数据库和文件系统的关系"></a>1. 数据库和文件系统的关系</h2><p>InnoDB,MyISAM这样的存储引擎都是把表存储在磁盘上，而操作系统是使用文件系统来管理磁盘的。【像InnoDB,MyISAM这样的存储引擎都是把数据存储在文件系统上的。】当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎又会把数据写回到文件系统。</p><p>本小节主要就是分析下InnoDB,MyISAM两个存储引擎的数据是如何在文件系统中存储的。</p><blockquote><p>我的MySQL版本是5.7.28，所以接下来的操作和分析都是基于这个小版本的。其他版本可能会有细微的差异。</p></blockquote><h2 id="2-MySQL数据目录"><a href="#2-MySQL数据目录" class="headerlink" title="2.MySQL数据目录"></a>2.MySQL数据目录</h2><p>MySQL服务器程序在启动时，会到文件系统的某个目录下加载一些数据，之后再运行过程中产生的数据也会存储到这个目录下的某些文件中。这个目录就是数据目录。</p><h3 id="2-1-数据目录和安装目录的区别"><a href="#2-1-数据目录和安装目录的区别" class="headerlink" title="2.1 数据目录和安装目录的区别"></a>2.1 数据目录和安装目录的区别</h3><p>MySQL的安装目录是在安装MySQL的时候指定的安装位置，下面有个很重要的bin目录，里面存储着控制客户端程序与服务器程序的命令。</p><p>MySQL的数据目录是用来存储MySQL在运行过程中产生的数据。</p><h3 id="2-2-MySQL的数据目录在哪里"><a href="#2-2-MySQL的数据目录在哪里" class="headerlink" title="2.2 MySQL的数据目录在哪里"></a>2.2 MySQL的数据目录在哪里</h3><p>数据目录对应着一个系统变量<code>datadir</code>，在使用客户端与服务器建立连接以后，查看这个系统变量的值就知道了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;datadir&#x27;;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;datadir&#x27;;</span><br><span class="line">+---------------+--------------------+</span><br><span class="line">| Variable_name | Value              |</span><br><span class="line">+---------------+--------------------+</span><br><span class="line">| datadir       | C:\yhd\mysql\Data\ |</span><br><span class="line">+---------------+--------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="3-数据目录的结构"><a href="#3-数据目录的结构" class="headerlink" title="3.数据目录的结构"></a>3.数据目录的结构</h2><h3 id="3-1-数据库在文件系统中的表示"><a href="#3-1-数据库在文件系统中的表示" class="headerlink" title="3.1 数据库在文件系统中的表示"></a>3.1 数据库在文件系统中的表示</h3><p>每个数据库都对应着数据目录下的一个子目录，或者说对应着一个文件夹。当我们创建一个新的数据库的时候，MySQL会帮助我们做两件事：</p><ol><li>在数据目录下创建一个与数据库同名的文件目录</li><li>在该子目录下创建一个<strong>db.opt</strong>文件。这个文件中包含了数据库的一些属性，比如该数据库的字符集和比较规则。</li></ol><p>下面来看一下我的MySQL中的数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| yhd                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>再从数据目录里看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C:\yhd\mysql\Data&gt;dir</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 CA5F-90F5</span><br><span class="line"></span><br><span class="line"> C:\yhd\mysql\Data 的目录</span><br><span class="line"></span><br><span class="line">2021/12/19  00:27    &lt;DIR&gt;          .</span><br><span class="line">2021/12/19  00:27    &lt;DIR&gt;          ..</span><br><span class="line">2021/12/14  00:00                56 auto.cnf</span><br><span class="line">2021/12/14  00:00             1,703 ca-key.pem</span><br><span class="line">2021/12/14  00:00             1,131 ca.pem</span><br><span class="line">2021/12/14  00:00             1,131 client-cert.pem</span><br><span class="line">2021/12/14  00:00             1,707 client-key.pem</span><br><span class="line">2021/12/14  00:12               696 DESKTOP-NJIMTJP-slow.log</span><br><span class="line">2021/12/18  01:15            25,345 DESKTOP-NJIMTJP.err</span><br><span class="line">2021/12/18  01:15                 5 DESKTOP-NJIMTJP.pid</span><br><span class="line">2021/12/19  02:18        79,691,776 ibdata1</span><br><span class="line">2021/12/18  01:15        12,582,912 ibtmp1</span><br><span class="line">2021/12/18  01:15               356 ib_buffer_pool</span><br><span class="line">2021/12/19  02:18        50,331,648 ib_logfile0</span><br><span class="line">2021/12/19  02:18        50,331,648 ib_logfile1</span><br><span class="line">2021/12/14  00:00    &lt;DIR&gt;          mysql</span><br><span class="line">2021/12/14  00:00    &lt;DIR&gt;          performance_schema</span><br><span class="line">2021/12/14  00:00             1,707 private_key.pem</span><br><span class="line">2021/12/14  00:00               461 public_key.pem</span><br><span class="line">2021/12/14  00:00             1,131 server-cert.pem</span><br><span class="line">2021/12/14  00:00             1,707 server-key.pem</span><br><span class="line">2021/12/14  00:00    &lt;DIR&gt;          sys</span><br><span class="line">2021/12/19  00:56    &lt;DIR&gt;          yhd</span><br><span class="line">              17 个文件    192,975,120 字节</span><br><span class="line">               6 个目录 189,156,126,720 可用字节</span><br><span class="line"></span><br><span class="line">C:\yhd\mysql\Data&gt;</span><br></pre></td></tr></table></figure><p>仔细看会发现，除了<strong>information_schema</strong>这个数据库以外，其他的数据库都对应一个文件目录，这个数据库有点特殊，后面在具体分析。</p><h3 id="3-2-表在文件系统中的表示"><a href="#3-2-表在文件系统中的表示" class="headerlink" title="3.2 表在文件系统中的表示"></a>3.2 表在文件系统中的表示</h3><p>我们的数据其实是以记录的形式插入到表中的。每个表的信息其实可以分为两种。</p><ol><li>表结构信息</li><li>表数据信息</li></ol><p>为了保存表结构信息，InnoDB,MyISAM这两种存储引擎都会在数据目录下对应的数据库子目录中创建一个专门用于描述表结构的文件，文件名是<strong>表名.frm</strong>。这个文件是二进制格式的，直接打开会乱码。</p><p>我们知道不同的存储引擎对于表中的数据存储是不一样的，接下来我们分别来看一下InnoDB,MyISAM是如何存储表中的数据的。</p><h4 id="InnoDb是如何存储数据的"><a href="#InnoDb是如何存储数据的" class="headerlink" title="InnoDb是如何存储数据的"></a>InnoDb是如何存储数据的</h4><p>我们再来回顾下上一篇的知识：</p><ol><li>innoDB其实是使用页来作为基本单位管理存储空间的，默认大小16KB。</li><li>对于InnoDB存储引擎来说，每个索引都对应一颗B+树，该B+树的每个结点都是一个数据页。数据页之间没有必要是物理连续的，因为数据页之间有双向链表来维护这些页的顺序。</li><li>InnoDB的聚簇索引的叶子结点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。</li></ol><p>为了更好的管理这些页，InnoDB提出了表空间或者文件空间的概念。这个表空间是一个抽象的概念，他可以对应文件系统上一个或者多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间可以被划分为很多个页，表数据被存放在某个表空间下的某些页中。InnoDB将表空间划分几种不同的类型，我们一个个分析一下子。</p><ol><li>系统表空间</li></ol><p>这个系统表空间可以对应文件系统上一个或者多个实际的文件。在默认情况下，InnoDB会在数据目录下创建一个名为<strong>ibdata1</strong>，大小为12MB的文件，这个文件就是对应的系统表空间在文件系统上的表示。怎么才12MB？这是因为这个文件是自扩展文件，也就是当不够用的时候会自己增加文件大小。</p><p>当然，如果想让系统表空间对应文件系统上的多个实际文件，或者仅仅觉得原来的<strong>ibdata1</strong>这个文件名难听，那么可以在MySQL服务启动的时候，配置对应的文件路径以及他们的大小。比如像下面这样修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure><p>这样，在MySQL启动之后会创建data1和data2这两个各自512MB大小的文件作为系统表空间。其中的autoextend表明，如果这两个文件不够用，则会自动扩展data2文件的大小。</p><p>我们也可以把<code>系统表空间</code>对应的文件路径不配置到<code>数据目录</code>下，甚至可以配置到单独的磁盘分区上，涉及到的启动参数就是<code>innodb_data_file_path</code>和<code>innodb_data_home_dir</code>。</p><p>需要注意的一点是，在一个MySQL服务器中，系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 **<em>系统表空间</em>**。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011685295-19dfeb6a-b276-4482-9655-817ed9fb066c.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2751d2c7&margin=%5Bobject%20Object%5D&name=ibdata1.png&originHeight=581&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71436&status=done&style=none&taskId=u6729a863-9b30-44f3-b559-08d55e8b5d8&title=" alt="ibdata1.png"></p><ol start="2"><li>独立表空间</li></ol><p>在MySQL5.6.6以及以后的版本中，InnoDB不在默认把各个表的数据存储到系统表空间，而是为每一个表建立一个独立的表空间，也就是说，创建多少张表就会对应多少个表空间。在使用独立表空间来存储表数据的时候，会在该表所属的数据库对应的子目录下创建一个表示该独立表空间的文件，其文件名和表名相同，只不过添加了一个.ibd扩展名。所以完整的文件名称：<strong>表名.ibd</strong>。</p><p>假如我们使用独立表空间来存储yhd数据库下的person_info表，那么在该数据库所对应的yhd文件目录下会为person_info表创建下面两个文件：<strong>person_info.frm</strong>,<strong>person_info.ibd</strong>。</p><p>其中ibd文件用来存储表中的数据。当然也可以自己指定是使用系统表空间还是独立表空间来存储数据。</p><ol start="3"><li>其他类型表空间</li></ol><p>除了上述两种表空间之外，还有一些不同类型的表空间，比如通用表空间，undo表空间，临时表空间。</p><h4 id="MyISAM是如何存储数据的"><a href="#MyISAM是如何存储数据的" class="headerlink" title="MyISAM是如何存储数据的"></a>MyISAM是如何存储数据的</h4><p>索引和数据在InnoDB是一回事，但是MyISAM中的索引相当于全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，而且与InnoDB不同的是，MyISAM并没有什么表空间一说，表的数据和索引都存放到对应的数据库子目录下。</p><p>假设我们person_info表使用的是MyISAM存储引擎，那么在它所在数据库对应的yhd文件目录下会为person_info创建三个文件：<strong>person_info.frm</strong>,<strong>person_info.MYD</strong>,<strong>person_info.MYI</strong>。</p><p>其中<strong>person_info.MYD</strong>表示表的数据文件，也就是插入的用户记录，<strong>person_info.MYI</strong>表示表的索引文件，我们为该表创建的索引都会放到这个文件中。</p><h3 id="3-3-其他的文件"><a href="#3-3-其他的文件" class="headerlink" title="3.3 其他的文件"></a>3.3 其他的文件</h3><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li> 服务器进程文件。<br>我们知道每运行一个<code>MySQL</code>服务器程序，都意味着启动一个进程。<code>MySQL</code>服务器会把自己的进程ID写入到一个文件中。 </li><li> 服务器日志文件。<br>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等各种日志，这些日志各有各的用途，现在先了解一下就可以了。 </li><li> 默认/自动生成的SSL和RSA证书和密钥文件。<br>主要是为了客户端和服务器安全通信而创建的一些文件 </li></ul><h2 id="4-文件系统对数据库的影响"><a href="#4-文件系统对数据库的影响" class="headerlink" title="4.文件系统对数据库的影响"></a>4.文件系统对数据库的影响</h2><p>因为<code>MySQL</code>的数据都是存在文件系统中的，就不得不受到文件系统的一些制约，这在数据库和表的命名、表的大小和性能方面体现的比较明显，比如下边这些方面：</p><ul><li> 数据库名称和表名称不得超过文件系统所允许的最大长度。<br>每个数据库都对应<code>数据目录</code>的一个子目录，数据库名称就是这个子目录的名称；每个表都会在数据库子目录下产生一个和表名同名的<code>.frm</code>文件，如果是<code>InnoDB</code>的独立表空间或者使用<code>MyISAM</code>引擎还会有别的文件的名称与表名一致。这些目录或文件名的长度都受限于文件系统所允许的长度～ </li><li> 特殊字符的问题<br>为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，<code>MySQL</code>会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 <code>@+编码值</code>的形式作为文件名。比方说我们创建的表的名称为<code>&#39;test?&#39;</code>，由于<code>?</code>不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应的<code>.frm</code>文件的名称就变成了<code>test@003f.frm</code>。 </li><li> 文件长度受文件系统最大长度限制<br>对于<code>InnoDB</code>的独立表空间来说，每个表的数据都会被存储到一个与表名同名的<code>.ibd</code>文件中；对于<code>MyISAM</code>存储引擎来说，数据和索引会分别存放到与表同名的<code>.MYD</code>和<code>.MYI</code>文件中。这些文件会随着表中记录的增加而增大，它们的大小受限于文件系统支持的最大文件大小。 </li></ul><h2 id="5-MySQL系统数据库简介"><a href="#5-MySQL系统数据库简介" class="headerlink" title="5.MySQL系统数据库简介"></a>5.MySQL系统数据库简介</h2><p>我们前边提到了MySQL的几个系统数据库，这几个数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息，我们现在稍微了解一下。</p><ul><li> <code>mysql</code><br>这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。 </li><li> <code>information_schema</code><br>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等等。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。 </li><li> <code>performance_schema</code><br>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。 </li><li> <code>sys</code><br>这个数据库主要是通过视图的形式把<code>information_schema</code>和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。 </li></ul><hr><h1 id="二，回顾前面"><a href="#二，回顾前面" class="headerlink" title="二，回顾前面"></a>二，回顾前面</h1><p>数据页（也就是Index类型的页）由7部分组成，其中有两个部分是所有类型的页面都通用的。</p><p>所有类型的页都会包含下面两个部分。</p><ol><li>File Header：记录页面的一些通用信息</li><li>File Trailer: 校验页是否完整，保证页面在从内存刷新到磁盘后内容是相同的</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011719008-1353f404-8f8c-4d81-9a6f-76f122d746e4.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua635e316&margin=%5Bobject%20Object%5D&name=%E9%80%9A%E7%94%A8%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=475&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14614&status=done&style=none&taskId=u82ecfbd8-f77e-45b2-8d2d-d644c13df24&title=" alt="通用页结构示意图.png"></p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li>表空间中的每一个页都对应着一个页号，也就是<code>FIL_PAGE_OFFSET</code>，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3…依此类推</li><li>某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了<code>INDEX</code>类型的页，也就是我们之前一直说的数据页建立<code>B+</code>树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。</li><li>每个页的类型由<code>FIL_PAGE_TYPE</code>表示，比如像数据页的该字段的值就是<code>0x45BF</code>，不同类型的页在该字段上的值是不同的。</li></ul><blockquote><p>InnoDB支持许多种类型的表空间，我们暂时重点关注系统表空间和独立表空间的结构。他们结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先分析独立表空间，再说系统表空间。</p></blockquote><h1 id="三，独立表空间"><a href="#三，独立表空间" class="headerlink" title="三，独立表空间"></a>三，独立表空间</h1><h2 id="1-区的概念"><a href="#1-区的概念" class="headerlink" title="1.区的概念"></a>1.区的概念</h2><p>为了更好的管理表中的页，InnoDB提出了区的概念。对于16KB的页来说，<strong>连续的64个页就是一个区</strong>。也就是说一个区默认占用1M空间。不论是系统表空间还是独立表空间，都可以看成是由若干区组成的，<strong>每256个区划分为一个组</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011740953-f94184f0-9793-4ade-9c74-159b23ced818.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf93a16d1&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.png&originHeight=637&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9806&status=done&style=none&taskId=u05c54b28-435d-4e5e-ab48-bee5b80fcf1&title=" alt="表空间结构.png"></p><p>为什么要有区的概念？</p><p>从理论上来讲，不引入区的概念只使用页的概念对存储引擎的运行并没有任何影响，但是我们来分析下：</p><p>我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的<code>B+</code>树的节点中插入数据。而<code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页</code>为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。</p><p>B+树的范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O</code>是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>所以才引入了<code>区</code>（<code>extent</code>）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区</code>为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机<code>I/O</code>。</p><h2 id="2-段的概念"><a href="#2-段的概念" class="headerlink" title="2.段的概念"></a>2.段的概念</h2><p>范围查询，其实是对<code>B+</code>树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。InnoDB对B+树的叶子节点和非叶子节点进行了区别对待：叶子节点有自己独有的<code>区</code>，非叶子节点也有自己独有的<code>区</code>。存放叶子节点的区的集合就算是一个<code>段</code>（<code>segment</code>），存放非叶子节点的区的集合也算是一个<code>段</code>。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>默认情况下一个使用<code>InnoDB</code>存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？</p><p>为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了碎片区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p><ol><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的</li><li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间</li></ol><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，<code>InnoDB</code>中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。</p><blockquote><p>有的时候处于不同的阶段，对于某个概念的定义或者理解是不同的，随着知识水平的提升后续再来逐渐完善，就像小学的时候老师会告诉你最小的数是0，中学又告诉你最小的数是负无穷一样。</p></blockquote><h2 id="3-区的分类"><a href="#3-区的分类" class="headerlink" title="3.区的分类"></a>3.区的分类</h2><p>每个区都对应一个XDES Entry结构，这个结构中存储了一些与这个区有关的属性。这些区可以被分为下面四种类型。</p><ol><li>空闲的区：现在还没有用到这个区中的任何页面，这些区会被加入到FREE链表。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面，这些区会被加入到FREE_FRAG链表。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面；这些区会被加入到FULL_FRAG链表。</li><li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位；每个段所属的区又会被组织成下面几种链表。 <ol><li>FREE链表：在同一个段中，所有页面都是空闲页面的区对应的XDES Entry结构会被加入到这个链表。</li><li>NOT_FULL链表：在同一个段中，仍有空闲页面的区对应的XDES Entry结构会被加入到这个链表。</li><li>FULL链表：在同一个段中，已经没有空闲页面的区对应的XDES Entry结构会被加入到这个链表。</li></ol></li></ol><p>这四种类型的区也被叫做区的四种状态。</p><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>FREE</td><td>空闲的区</td></tr><tr><td>FREE_FRAG</td><td>有剩余空间的碎片区</td></tr><tr><td>FULL_FRAG</td><td>没有剩余空间的碎片区</td></tr><tr><td>FSEG</td><td>附属于某个段的区</td></tr></tbody></table><p><strong>处于</strong><code>**FREE**</code><strong>、</strong><code>**FREE_FRAG**</code><strong>以及</strong><code>**FULL_FRAG**</code><strong>这三种状态的区都是独立的，算是直属于表空间；而处于</strong><code>**FSEG**</code><strong>状态的区是附属于某个段的。</strong></p><p>每个段都会对应一个<code>INODE Entry</code>结构，该结构中存储了一些与这个段有关的属性。</p><p>表空间中第一个页面的类型为<code>FSP_HDR</code>，它存储了表空间的一些整体属性以及第一个组内256个区对应的XDES Entry结构。</p><p>除了表空间的第一个组以外，其余组的第一个页面的类型为XDES，这种页面的结构和FSP_HDR类型的页面对比，除了少了File Space header（记录表空间整体属性的部分）部分之外，其余部分是一样的。</p><p>每个组的第二个页面类型为IBUF_BITMAP，存储了一些关于Change Buffer的信息。</p><p>表空间中第一个组的第三个页面的类型是INODE，他是为了存储INODE Entry结构而设计的，这种类型的页面会组织成下面两个链表。</p><ol><li>SEG_INODES_FULL链表：在该链表中，INODE类型的页面中已经没有空闲空间来存储额外的INODE Entry结构。</li><li>SEG_INODES_FREE链表：在该链表中，INODE类型的页面中还有空闲空间来存储额外的INODE Entry结构。</li></ol><h2 id="4-Segment-Header"><a href="#4-Segment-Header" class="headerlink" title="4. Segment Header"></a>4. Segment Header</h2><p>一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个<code>INODE Entry</code>结构，那我们怎么知道<strong>某个段对应哪个</strong><code>**INODE Entry**</code><strong>结构</strong>呢？所以得找个地方记下来这个对应关系。<code>INDEX</code>类型的页时有一个<code>Page Header</code>部分，其中的<code>PAGE_BTR_SEG_LEAF</code>和<code>PAGE_BTR_SEG_TOP</code>都占用10个字节，它们其实对应一个叫<code>Segment Header</code>的结构，该结构图示如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011755576-3ecd1252-2638-464f-889a-90c84eca4f86.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u31b4510f&margin=%5Bobject%20Object%5D&name=SegmentHeader%E7%BB%93%E6%9E%84.png&originHeight=265&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101386&status=done&style=none&taskId=u2dd24fe8-19ea-4269-a879-36246a5de4c&title=" alt="SegmentHeader结构.png"></p><p>各个部分的具体释义如下：</p><table><thead><tr><th>名称</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td>Space ID of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的表空间ID</td></tr><tr><td>Page Number of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的页面页号</td></tr><tr><td>Byte Offset of the INODE Ent</td><td>2</td><td>INODE Entry结构在该页面中的偏移量</td></tr></tbody></table><p><code>PAGE_BTR_SEG_LEAF</code>记录着叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量，<code>PAGE_BTR_SEG_TOP</code>记录着非叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可。</p><blockquote><p>其实Segment Header的作用就是记录哪个段对应哪个<code>INODE Entry</code>结构的。</p></blockquote><h2 id="5-真实表空间对应的文件大小"><a href="#5-真实表空间对应的文件大小" class="headerlink" title="5. 真实表空间对应的文件大小"></a>5. 真实表空间对应的文件大小</h2><p>一个新建的表对应的.ibd文件只占用了96KB，才6个页的大小。刚开始的时候，表空间占用空间自然很小，因为表里面没有数据。不过，ibd文件是自扩展文件，随着数据的增多文件也在逐渐增大。</p><h1 id="四，系统表空间"><a href="#四，系统表空间" class="headerlink" title="四，系统表空间"></a>四，系统表空间</h1><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间相当于是表空间之首，所以它的<code>表空间 ID</code>（Space ID）是<code>0</code>。</p><h2 id="1-系统表空间的整体结构"><a href="#1-系统表空间的整体结构" class="headerlink" title="1.系统表空间的整体结构"></a>1.系统表空间的整体结构</h2><p>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011778567-ae1cca61-ce14-451b-a49c-c3ee3f4ab70a.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub1395531&margin=%5Bobject%20Object%5D&name=%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.png&originHeight=703&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=253316&status=done&style=shadow&taskId=udc4507a5-9091-44cd-9517-bf96623000b&title=" alt="系统表空间结构.png"></p><p>可以看到，系统表空间和独立表空间的前三个页面（页号分别为<code>0</code>、<code>1</code>、<code>2</code>，类型分别是<code>FSP_HDR</code>、<code>IBUF_BITMAP</code>、<code>INODE</code>）的类型是一致的，只是页号为<code>3</code>～<code>7</code>的页面是系统表空间特有的，我们来看一下这些多出来的页面都是干啥使的：</p><table><thead><tr><th>页号</th><th>页面类型</th><th>英文描述</th><th>描述</th></tr></thead><tbody><tr><td>3</td><td>SYS</td><td>Insert Buffer Header</td><td>存储Insert Buffer的头部信息</td></tr><tr><td>4</td><td>INDEX</td><td>Insert Buffer Root</td><td>存储Insert Buffer的根页面</td></tr><tr><td>5</td><td>TRX_SYS</td><td>Transaction System</td><td>事务系统的相关信息</td></tr><tr><td>6</td><td>SYS</td><td>First Rollback Segment</td><td>第一个回滚段的页面</td></tr><tr><td>7</td><td>SYS</td><td>Data Dictionary Header</td><td>数据字典头部信息</td></tr></tbody></table><p>除了这几个记录系统属性的页面之外，系统表空间的<code>extent 1</code>和<code>extent 2</code>这两个区，也就是页号从<code>64</code>~`191<code>这128个页面被称为</code>Doublewrite buffer`，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题，现在我们只分析有关InnoDB数据字典的知识，其余的概念在后边再看。</p><h3 id="1-1-InnoDB数据字典"><a href="#1-1-InnoDB数据字典" class="headerlink" title="1.1 InnoDB数据字典"></a>1.1 InnoDB数据字典</h3><p>每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的<code>B+</code>树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p><ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li></ul><p>上述这些数据并不是我们使用<code>INSERT</code>语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为<code>元数据</code>。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIRTUAL</td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr></tbody></table><p>这些系统表也被称为<code>数据字典</code>，它们都是以<code>B+</code>树的形式保存在系统表空间的某些页面中，其中<code>SYS_TABLES</code>、<code>SYS_COLUMNS</code>、<code>SYS_INDEXES</code>、<code>SYS_FIELDS</code>这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这4个表的结构：</p><h3 id="1-2-SYS-TABLES表"><a href="#1-2-SYS-TABLES表" class="headerlink" title="1.2 SYS_TABLES表"></a>1.2 SYS_TABLES表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>表的名称</td></tr><tr><td>id</td><td>InnoDB存储引擎每一张表都有一个唯一的ID</td></tr><tr><td>n_cols</td><td>该表拥有的列的个数</td></tr><tr><td>type</td><td>表的类型，记录了一些文件格式，行格式，压缩等信息</td></tr><tr><td>Mix_id</td><td>已经过时，忽略</td></tr><tr><td>Mix_len</td><td>表的一些额外属性</td></tr><tr><td>Cluster_id</td><td>未使用，忽略</td></tr><tr><td>Space</td><td>该表所属空间的ID</td></tr></tbody></table><p>这个<code>SYS_TABLES</code>表有两个索引：</p><ul><li>以<code>NAME</code>列为主键的聚簇索引</li><li>以<code>ID</code>列建立的二级索引</li></ul><h3 id="1-3-SYS-COLUMNS表"><a href="#1-3-SYS-COLUMNS表" class="headerlink" title="1.3 SYS_COLUMNS表"></a>1.3 SYS_COLUMNS表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该列所属表对应的ID</td></tr><tr><td>POS</td><td>该列在表中是第几列</td></tr><tr><td>NAME</td><td>该列的名称</td></tr><tr><td>MTYPE</td><td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE等</td></tr><tr><td>PRTYPE</td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td></tr><tr><td>LEN</td><td>该列最多占用存储空间的字节数</td></tr><tr><td>PREC</td><td>该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><p>这个<code>SYS_COLUMNS</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, POS)</code>列为主键的聚簇索引</li></ul><h3 id="1-4-SYS-INDEXES表"><a href="#1-4-SYS-INDEXES表" class="headerlink" title="1.4 SYS_INDEXES表"></a>1.4 SYS_INDEXES表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该索引所属表对应的ID</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td>NAME</td><td>该索引的名称</td></tr><tr><td>N_FIELDS</td><td>该索引包含列的个数</td></tr><tr><td>TYPE</td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td>SPACE</td><td>该索引根页面所在的表空间ID</td></tr><tr><td>PAGE_NO</td><td>该索引根页面所在的页面号</td></tr><tr><td>MERGE_THRESHOLD</td><td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><p>这个<code>SYS_INDEXES</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, ID)</code>列为主键的聚簇索引</li></ul><h3 id="1-5-SYS-FIELDS表"><a href="#1-5-SYS-FIELDS表" class="headerlink" title="1.5 SYS_FIELDS表"></a>1.5 SYS_FIELDS表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>INDEX_ID</td><td>该索引列所属的索引的ID</td></tr><tr><td>POS</td><td>该索引列在某个索引中是第几列</td></tr><tr><td>COL_NAME</td><td>该索引列的名称</td></tr></tbody></table><p>这个<code>SYS_FIELDS</code>表只有一个聚集索引：</p><ul><li>以<code>(INDEX_ID, POS)</code>列为主键的聚簇索引</li></ul><h3 id="1-6-Data-Dictionary-Header页面"><a href="#1-6-Data-Dictionary-Header页面" class="headerlink" title="1.6 Data Dictionary Header页面"></a>1.6 Data Dictionary Header页面</h3><p>只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看<code>SYS_TABLESPACES</code>这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：</p><ul><li>到<code>SYS_TABLES</code>表中根据表名定位到具体的记录，就可以获取到<code>SYS_TABLESPACES</code>表的<code>TABLE_ID</code></li><li>使用这个<code>TABLE_ID</code>到<code>SYS_COLUMNS</code>表中就可以获取到属于该表的所有列的信息。</li><li>使用这个<code>TABLE_ID</code>还可以到<code>SYS_INDEXES</code>表中获取所有的索引的信息，索引的信息中包括对应的<code>INDEX_ID</code>，还记录着该索引对应的<code>B+</code>数根页面是哪个表空间的哪个页面。</li><li>使用<code>INDEX_ID</code>就可以到<code>SYS_FIELDS</code>表中获取所有索引列的信息。</li></ul><p>这4个表的元数据去哪里获取呢？这4个表的元数据，就是它们有哪些列、哪些索引等信息是硬编码到代码中的，InnoDB用一个固定的页面来记录这4个表的聚簇索引和二级索引对应的<code>B+树</code>位置，这个页面就是页号为<code>7</code>的页面，类型为<code>SYS</code>，记录了<code>Data Dictionary Header</code>，也就是数据字典的头部信息。除了这4个表的5个索引的根页面信息外，这个页号为<code>7</code>的页面还记录了整个InnoDB存储引擎的一些全局属性。</p><p>这个页面由下边几个部分组成：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Data Dictionary Header</td><td>数据字典头部信息</td><td>56</td><td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td>Segment Header</td><td>段头部信息</td><td>10</td><td>记录本页面所在段对应的INODE Entry位置信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>16272</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><p>这个页面里有<code>Segment Header</code>部分，意味着InnoDB把这些有关数据字典的信息当成一个段来分配存储空间，我们称之为<code>数据字典段</code>。由于目前我们需要记录的数据字典信息非常少（可以看到<code>Data Dictionary Header</code>部分仅占用了56字节），所以该段只有一个碎片页，也就是页号为<code>7</code>的这个页。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011825618-aa10d2ad-6eec-4c77-b50b-2fe1973e2182.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uca647b94&margin=%5Bobject%20Object%5D&name=%E9%A1%B5%E5%8F%B7%E4%B8%BA7%E7%9A%84%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=944&originWidth=1846&originalType=binary&ratio=1&rotation=0&showTitle=false&size=558893&status=done&style=shadow&taskId=u10130667-5bfc-434f-a8de-39540039538&title=" alt="页号为7的页结构示意图.png"></p><p>接下来我们需要看一下<code>Data Dictionary Header</code>部分的各个字段：</p><ul><li><code>Max Row ID</code>：如果我们不显式的为表定义主键，而且表中也没有<code>UNIQUE</code>索引，那么<code>InnoDB</code>存储引擎会默认为我们生成一个名为<code>row_id</code>的列作为主键。因为它是主键，所以每条记录的<code>row_id</code>列的值不能重复。原则上只要一个表中的<code>row_id</code>列不重复就可以了，也就是说表a和表b拥有一样的<code>row_id</code>列也没啥关系，不过InnoDB只提供了这个<code>Max Row ID</code>字段，不论哪个拥有<code>row_id</code>列的表插入一条记录时，该记录的<code>row_id</code>列的值就是<code>Max Row ID</code>对应的值，然后再把<code>Max Row ID</code>对应的值加1，也就是说这个<code>Max Row ID</code>是全局共享的。</li><li><code>Max Table ID</code>：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</li><li><code>Max Index ID</code>：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</li><li><code>Max Space ID</code>：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</li><li><code>Mix ID Low(Unused)</code>：这个字段没啥用，跳过。</li><li><code>Root of SYS_TABLES clust index</code>：本字段代表<code>SYS_TABLES</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_TABLE_IDS sec index</code>：本字段代表<code>SYS_TABLES</code>表为<code>ID</code>列建立的二级索引的根页面的页号。</li><li><code>Root of SYS_COLUMNS clust index</code>：本字段代表<code>SYS_COLUMNS</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_INDEXES clust index</code>本字段代表<code>SYS_INDEXES</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_FIELDS clust index</code>：本字段代表<code>SYS_FIELDS</code>表聚簇索引的根页面的页号。</li><li><code>Unused</code>：这4个字节没用，跳过。</li></ul><p>以上就是页号为<code>7</code>的页面的全部内容。</p><h3 id="1-7-information-schema系统数据库"><a href="#1-7-information-schema系统数据库" class="headerlink" title="1.7 information_schema系统数据库"></a>1.7 information_schema系统数据库</h3><p>用户是不能直接访问<code>InnoDB</code>的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过InnoDB考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库<code>information_schema</code>中提供了一些以<code>innodb_sys</code>开头的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE information_schema;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| Tables_in_information_schema (innodb_sys%) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| INNODB_SYS_DATAFILES                       |</span><br><span class="line">| INNODB_SYS_VIRTUAL                         |</span><br><span class="line">| INNODB_SYS_INDEXES                         |</span><br><span class="line">| INNODB_SYS_TABLES                          |</span><br><span class="line">| INNODB_SYS_FIELDS                          |</span><br><span class="line">| INNODB_SYS_TABLESPACES                     |</span><br><span class="line">| INNODB_SYS_FOREIGN_COLS                    |</span><br><span class="line">| INNODB_SYS_COLUMNS                         |</span><br><span class="line">| INNODB_SYS_FOREIGN                         |</span><br><span class="line">| INNODB_SYS_TABLESTATS                      |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表，而是在存储引擎启动时读取这些以<code>SYS</code>开头的系统表，然后填充到这些以<code>INNODB_SYS</code>开头的表中。以<code>INNODB_SYS</code>开头的表和以<code>SYS</code>开头的表中的字段并不完全一样。<br>​</p><blockquote><p>补充一张表空间完整结构图</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640011944905-2540c89c-22e0-4215-8e21-c15a2da2b621.jpeg#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u54935513&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84%E5%9B%BE.jpg&originHeight=3476&originWidth=6102&originalType=binary&ratio=1&rotation=0&showTitle=false&size=396886&status=done&style=shadow&taskId=u9cd36e06-bfc7-476f-96f8-800de759742&title=" alt="表空间完整结构图.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[四]索引命中原理</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%9B%9B%5D%E7%B4%A2%E5%BC%95%E5%91%BD%E4%B8%AD%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%9B%9B%5D%E7%B4%A2%E5%BC%95%E5%91%BD%E4%B8%AD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇分析了InnoDB存储引擎的B+树索引，现在来进行一个简单的回顾。</p><ol><li>每个索引都对应一颗B+树，B+树分为好多层，最下边一层是叶子结点，其余的是内结点。所有的用户记录都存储在B+树的叶子结点，所有目录项记录都存储在内节点。</li><li>InnoDB存储引擎会自动为主键建立聚簇索引，聚簇索引的叶子结点包含完整的用户记录。</li><li>我们可以为指定的列建立二级索引，二级索引的叶子结点包含的用户记录由索引列+主键组成，所以如果项通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+树中每层结点都是按照索引列值从大到小的顺序排序而组成了双向链表，而且每个页内的记录(不论是用户记录还是目录项记录)都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，在按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+树的根节点开始，一层一层乡下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中查找非常快。</li></ol></blockquote><h1 id="一，做一些前置的准备"><a href="#一，做一些前置的准备" class="headerlink" title="一，做一些前置的准备"></a>一，做一些前置的准备</h1><p>为了这篇文章的演示，需要先建立一张简单的表，用来演示索引执行过程中出现的一些情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> single_table</span><br><span class="line">(</span><br><span class="line">    # 主键索引</span><br><span class="line">    id           <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    key1         <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key2         <span class="type">int</span>,</span><br><span class="line">    key3         <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1    <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2    <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3    <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    # 索引列key1</span><br><span class="line">    key idx_key1 (key1),</span><br><span class="line">    # 唯一索引：索引列key2</span><br><span class="line">    <span class="keyword">unique</span> key uk_key2 (key2),</span><br><span class="line">    # 索引列key3</span><br><span class="line">    key idx_key3 (key3),</span><br><span class="line">    # 联合索引：索引列：key_part1, key_part2, key_part3</span><br><span class="line">    key idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) engine <span class="operator">=</span> innodb</span><br><span class="line">  charset <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><p>再往表中插入100w条数据，具体的插入过程不在演示。</p><h1 id="二，索引的代价"><a href="#二，索引的代价" class="headerlink" title="二，索引的代价"></a>二，索引的代价</h1><p>凡事都是有利有弊的，索引可以加快查询的速度，但是同样的，他也有相应的缺点。</p><ol><li>空间上</li></ol><blockquote><p>一个索引对应一个B+树，每一个B+树的每一个节点都是一个数据页。一个数据页大小默认是16kb，所以一张表的索引越多，占用的空间其实越大，特别是在数据量大的时候，所以一般我们建立索引，默认每张表不要超过5个。</p></blockquote><ol start="2"><li>时间上</li></ol><blockquote><p>在对表进行增删改操作的时候，要对所有索引对应的B+树进行修改。而且上一篇分析过，B+树的每一层节点都按照索引列的值从小到大的顺序排序组成了双向链表。页中的记录都按照索引列的值从小到大的顺序形成了一个单向链表。而增删改操作可能会对结点和记录的排序造成破坏，所以存储引擎需要额外的时间进行页面分裂，页回收等操作，好维护结点和记录的排序。索引越多，维护的时间成本越高。</p><p>还有一点就是执行查询语句之前，会先生成执行计划。一般情况下一条语句再一次执行过程中只会使用一个二级索引(有特殊的，后面会分析)，在生成执行计划的时候需要计算使用不同索引执行查询时所需成本，最后选取成本最低的索引执行查询。如果索引太多，分析成本就会很高，耗时严重，从而影响查询语句的执行性能。</p></blockquote><p>为了合理的建立索引，一方面加快我们的查询速度，一方面又不会过分的占用我们的时间和空间，我们需要了解索引在查询执行期间到底是如何发挥作用的。</p><h1 id="三，使用B-树索引"><a href="#三，使用B-树索引" class="headerlink" title="三，使用B+树索引"></a>三，使用B+树索引</h1><h2 id="1-扫描区间和边界条件"><a href="#1-扫描区间和边界条件" class="headerlink" title="1.扫描区间和边界条件"></a>1.扫描区间和边界条件</h2><p>先说什么是全表扫描？就是从头到尾依次遍历所有结点，再依次遍历结点中的所有记录。全表扫描虽然效率很低，但是却是一种万能的解决方案，所有查询都可以使用这种方案兜底。</p><p>我们可以利用B+树查找索引列值等于某个值的记录，这样可以明显减少需要扫描的记录数量。由于B+树叶子节点中的记录是按照索引列值从小到大的顺序排序的，所以只扫描某个区间或某些区间中的记录也是很快的，比如下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from single_table where id&gt;=2 and id&lt;=100;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861046004-8c35f559-5650-44b9-b0a9-47b2334d60ad.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1c70cd2c&margin=%5Bobject%20Object%5D&name=1.png&originHeight=59&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12854&status=done&style=none&taskId=ucca74516-26f6-41af-88cb-3f76bafac9c&title=" alt="1.png"></p><p>这个时候其实是走了主键索引，这个语句其实是想查找id值在区间【2，100】内的所有聚簇索引记录，我们可以通过主键索引先定位到id=2的记录，然后顺着这条记录的单向链表往后找就行了。</p><p>与全表扫描的100w数据相比，扫描这个区间的成本简直太小了，所以提升了查询效率。我们把这个案例中待扫描的id值所在区间称为扫描区间，把形成这个扫描区间的搜索条件称为形成这个扫描区间的边界条件。</p><blockquote><p>其实对于全表扫描来讲，就是在【-∞，+∞】的区间进行扫描而已。</p></blockquote><p>再来看一条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 in (1438, 6328)</span><br><span class="line">   or (key2 &gt;= 38 and key2 &lt;= 79);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861062027-fb46777d-8f4a-4f15-a4cc-883c41c8ab95.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubca1ca12&margin=%5Bobject%20Object%5D&name=2.png&originHeight=65&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12570&status=done&style=none&taskId=u37ac3391-1f3f-4801-9b06-5935cfb6508&title=" alt="2.png"></p><p>这个查询的搜索条件涉及到key2列，我们正好在key2列上建立了唯一索引。如果使用唯一索引执行这个查询，实际上相当于从三个区间获取二级索引的记录。</p><ol><li>【1438，1438】</li><li>【6328，6328】</li><li>【38，79】</li></ol><p>类似前面两个区间这种，只有一个值的区间，我们称为单点扫描区间，把类似第三个区间这样存在多个值的叫做范围扫描区间，另外，由于我们的查询列是*，导致从上述的区间每次获取到一条二级索引记录，就需要根据二级索引记录的id列的值取回表一次。</p><p>当然，并不是所有的条件都可以称为边界条件，比如下面的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key1 &gt; &#x27;aaa&#x27;</span><br><span class="line">  and key3 &lt; &#x27;zzz&#x27;</span><br><span class="line">  and common_field = &#x27;aaa&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861071980-6cffcbf1-a768-4767-86ec-0ae8355ba6ac.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud3dc6494&margin=%5Bobject%20Object%5D&name=3.png&originHeight=68&originWidth=1510&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13331&status=done&style=none&taskId=u3c8e91ca-b9ac-41fa-9588-9fead969b05&title=" alt="3.png"></p><ol><li>如果使用idx_key1执行查询，那么相应的扫描区间就变成了【’aaa’,+∞】，后面的条件就是普通搜索条件，这些普通的搜索条件需要在获取到idx_key1的二级索引记录后，在执行回表操作，在获取到完整的用户记录后才能去判断他们是否成立。</li><li>如果使用idx_key3执行查询，那么扫描区间就是【-∞,’zzz’】,其余的条件就是普通搜索条件，这些普通的搜索条件需要在获取到idx_key3的二级索引记录后，在执行回表操作，在获取到完整的用户记录后才能去判断他们是否成立。</li></ol><p>在使用某个索引执行查询的时候，关键的问题就是通过搜索条件找出合适的区间，然后再去对应的B+树中扫描索引列值在这些扫描区间的记录，对于每一个区间来说，只需要定位到第一条，就可以沿着单链表一直往后扫符合条件的记录。</p><p>其实对于B+树索引来说： <code>=     &lt;=&gt;    in    not in    is null    is not null    &gt;    &lt;    &gt;=    &lt;=    between    !=    like</code>    都会进行区间扫描，只不过区间扫描大小不同导致效率不同。</p><p>不过也有一些需要注意的点：</p><ol><li>in和多个 = 用or连接起来的效果其实是一样的，都会产生多个单点扫描区间</li><li>不等于 产生的区间比较操蛋：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="operator">!=</span> <span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure><p>这个时候idx_key1 执行查询的时候对应的扫描区间就是【-∞,’aaa’】和【’aaa’,+∞】。</p><ol start="3"><li>like操作比较特殊，只有在匹配完整的字符串或者匹配字符串前缀的时候才会产生合适的扫描区间</li></ol><blockquote><p>比较字符串的大小其实就是逐个比较每个字符的大小。字符串的比较过程如下：</p><ol><li>先比较字符串的第一个字符，第一个字符串小的字符就比较小</li><li>如果第一个字符一样的话就按照上面的规则比较第二个，以此类推。</li></ol></blockquote><p>对于某个索引列来说，字符串前缀相同的记录在由记录组成的单向链表中肯定是相邻的。比如我们有一个搜索条件是<code>key1 like &#39;a%&#39;</code>，对于二级索引idx_key1来说，所有字符串前缀为a的二级索引记录肯定是相邻的。这也就意味着我们只要定位到key1值得字符串前缀为a的第一条记录，就可以依次往后扫描，直到某条二级索引记录的字符串不是a为止。</p><p>很显然，<code>key1 like &#39;a%&#39;</code>形成的扫描区间相当于【’a’,’b’】。</p><p><strong>在执行一个查询语句的时候，首先需要找出所有可用的索引以及使用他们时对应的扫描区间。</strong>接下来我们分析下怎么从包含若干个and或者or的复杂搜索条件中提取出正确的扫描区间。</p><h3 id="1-1-所有搜索条件都可以生成合适的扫描区间的情况"><a href="#1-1-所有搜索条件都可以生成合适的扫描区间的情况" class="headerlink" title="1.1 所有搜索条件都可以生成合适的扫描区间的情况"></a>1.1 所有搜索条件都可以生成合适的扫描区间的情况</h3><p>在使用某个索引执行查询的时候，有时每个小的搜索条件都可以生成一个合适的扫描区间来减少需要扫描的记录数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  and key2 &gt; 200;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861084810-5b627d4c-74d1-4e3a-a9d5-d13604354033.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9bca9182&margin=%5Bobject%20Object%5D&name=4.png&originHeight=62&originWidth=1622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12578&status=done&style=none&taskId=u65c5ba29-1492-4691-bed1-6a04678fe0c&title=" alt="4.png"></p><p>在使用唯一索引进行查询的时候，这两个条件都可以形成一个扫描区间【100，+∞】，【200，+∞】。因为这两个条件是用and连接的，所以最终就是两个区间取交集【200，+∞】。</p><p>我们把sql改一改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  or key2 &gt; 200;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861091476-035c46dc-56b7-4098-9ed1-01d81c30a134.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6338bb93&margin=%5Bobject%20Object%5D&name=5.png&originHeight=72&originWidth=1617&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12711&status=done&style=none&taskId=u635f5d16-7043-4177-8af3-8966d0f2426&title=" alt="5.png"></p><p>这个时候因为是使用or进行两个条件的连接，所以两个条件的区间应该取并集：【100，+∞】。</p><h3 id="1-2-有的搜索条件不能生成合适的扫描区间的情况"><a href="#1-2-有的搜索条件不能生成合适的扫描区间的情况" class="headerlink" title="1.2 有的搜索条件不能生成合适的扫描区间的情况"></a>1.2 有的搜索条件不能生成合适的扫描区间的情况</h3><p>在使用某个索引进行查询的时候，有些小的搜索条件并不能生成合适的扫描区间来减少需要扫描的行数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  and common_field =&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>在使用唯一索引进行查询的时候，第一个条件会定位出区间【100，+∞】，但是第二个条件是一个普通条件，相当于【-∞，+∞】，因为两个条件使用and连接的，所以最终取交集之后的区间就是【100，+∞】。</p><p>其实在使用唯一索引进行查询的时候，在寻找对应的扫描区间的过程中，搜索条件<code>common_field =&#39;abc&#39;</code>没有起到任何作用，我们可以直接把这个条件进行一个等价替换【TRUE】(true对应的扫描区间也是【-∞，+∞】)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  and true;</span><br></pre></td></tr></table></figure><p>在进行化简之后就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br></pre></td></tr></table></figure><p>也就是说上面的查询语句在使用唯一索引进行查询的时候对应的扫描区间就是【100，+∞】。</p><p>再来看一下使用OR的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  or common_field =&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>同样进行化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  or true;</span><br></pre></td></tr></table></figure><p>继续化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where true</span><br></pre></td></tr></table></figure><p>可见如果此时强制使用唯一索引进行查询，对应的扫描区间就是【-∞，+∞】，再加上这是二级索引，每次匹配到一条都要进行回表，所以这个查询的代价甚至比全表扫描还大，这个时候再使用唯一索引就没意义了。</p><h3 id="1-3从复杂的搜索条件中找出扫描区间"><a href="#1-3从复杂的搜索条件中找出扫描区间" class="headerlink" title="1.3从复杂的搜索条件中找出扫描区间"></a>1.3从复杂的搜索条件中找出扫描区间</h3><p>来一个复杂点的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> single_table</span><br><span class="line"><span class="keyword">where</span> (key1 <span class="operator">&gt;</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">and</span> key2 <span class="operator">&gt;</span> <span class="number">748</span>)</span><br><span class="line">   <span class="keyword">or</span> (key1 <span class="operator">&lt;</span> <span class="string">&#x27;eee&#x27;</span> <span class="keyword">and</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">   <span class="keyword">or</span> (key1 <span class="keyword">like</span> <span class="string">&#x27;%f&#x27;</span> <span class="keyword">and</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">and</span> (key2 <span class="operator">&lt;</span> <span class="number">8000</span> <span class="keyword">or</span> common_field <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span>));</span><br></pre></td></tr></table></figure><p>这无语的SQL怎么搞？</p><ol><li>先看where子句里面都涉及到了哪些列，以及我们为哪些列建立了索引</li><li>对于可以用到的索引，我们来分析索引的扫描区间</li></ol><h4 id="1-3-1-使用idx-key1查询"><a href="#1-3-1-使用idx-key1查询" class="headerlink" title="1.3.1 使用idx_key1查询"></a>1.3.1 使用idx_key1查询</h4><p>先把不能形成合适扫描区间的搜索条件干掉，怎么干掉？直接把他们替换成TRUE。</p><p>替换之后的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where (key1 &gt; &#x27;aaa&#x27; and TRUE)</span><br><span class="line">   or (key1 &lt; &#x27;eee&#x27; and key1 &gt; &#x27;ccc&#x27;)</span><br><span class="line">   or (TRUE and key1 &gt; &#x27;aaa&#x27; and (TRUE or TRUE));</span><br></pre></td></tr></table></figure><p>化简之后的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where (key1 &gt; &#x27;aaa&#x27; ) -- 【aaa,+∞】</span><br><span class="line">   or (key1 &lt; &#x27;eee&#x27; and key1 &gt; &#x27;ccc&#x27;) -- 【&#x27;ccc&#x27;,&#x27;eee&#x27;】</span><br></pre></td></tr></table></figure><p>因为这两个条件之间是用OR连接起来的，所以我们应该取并集，最终：【aaa,+∞】。</p><p>也就是需要把所有key1在这个区间内的所有二级索引记录都取出来，针对获取到的每一条二级索引记录进行一次回表，在得到完整的用户记录之后在使用其他的搜索条件进行过滤。</p><h4 id="1-3-2-使用唯一二级索引查询"><a href="#1-3-2-使用唯一二级索引查询" class="headerlink" title="1.3.2 使用唯一二级索引查询"></a>1.3.2 使用唯一二级索引查询</h4><p>我们还是进行化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where (TRUE and key2 = 748)</span><br><span class="line">   or (TRUE and TRUE)</span><br><span class="line">   or (TRUE and TRUE and (key2 &lt; 8000 or common_field = &#x27;aaa&#x27;));</span><br></pre></td></tr></table></figure><p>再继续化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where  key2 = 748</span><br><span class="line">   or TRUE</span><br></pre></td></tr></table></figure><p>因为两个条件使用OR连接的，所以最终的结果就是【-∞，+∞】。</p><p>也就是需要把所有key2所有二级索引记录都取出来，针对获取到的每一条二级索引记录进行一次回表，在得到完整的用户记录之后在使用其他的搜索条件进行过滤，比全表扫描还耗时，所以这个时候我们是不会走唯一二级索引的。</p><blockquote><p>在使用idx_key1执行上述查询的时候，搜索条件 <code>key1 like &#39;%f&#39;</code> 比较特殊。虽然他不能作为形成扫描区间的边界条件，但是idx_key1的二级索引记录是包含key1列的。因此我们可以先判断获取到的二级索引记录是否符合这个条件。如果符合在执行回表操作，如果不符合就不用回表了。这样就可以较少因为回表带来的性能损耗，这就是<strong>索引下推</strong>。</p></blockquote><h3 id="1-4使用联合索引执行查询时对应的扫描区间"><a href="#1-4使用联合索引执行查询时对应的扫描区间" class="headerlink" title="1.4使用联合索引执行查询时对应的扫描区间"></a>1.4使用联合索引执行查询时对应的扫描区间</h3><p>联合索引的索引列包含多个列，B+树中的每一层页面以及每一个页中的记录采用的排序规则比较复杂。以上面的表为例，<code>idx_key_part (key_part1, key_part2, key_part3)</code> 采用的排序规则如下：</p><ol><li>先按照key_part1进行排序</li><li>key_part1相同按照key_part2进行排序，以此类推</li></ol><h4 id="1-4-1全值匹配原理"><a href="#1-4-1全值匹配原理" class="headerlink" title="1.4.1全值匹配原理"></a>1.4.1全值匹配原理</h4><p>对于下面这条查询语句来讲：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 =&#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>因为二级索引记录先按照key_part1进行值排序的，所以符合条件的所有记录肯定是相邻的。我们可以先定位到符合条件的第一条记录，沿着链表顺序往下扫描知道不符合条件为止（当然，对于获取到的每一条二级索引记录都需要进行回表）。此时的扫描区间【’a’,’a’】。</p><p>在看一条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 = &#x27;a&#x27;</span><br><span class="line">  and key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>按照联合索引的排序规则，最终的扫描区间其实就是【(‘a’,’b’),(‘a’,’b’)】。</p><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 &lt;&#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>因为二级索引记录先按照key_part1进行值排序的，所以符合条件的所有记录肯定是相邻的。我们可以先定位到符合条件的第一条记录，然后顺着单向链表继续往后扫描，直到遇到不符合规则的记录就停止。【-∞,’a’】</p><h4 id="1-4-2最佳左前缀匹配原理"><a href="#1-4-2最佳左前缀匹配原理" class="headerlink" title="1.4.2最佳左前缀匹配原理"></a>1.4.2最佳左前缀匹配原理</h4><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part2 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>由于二级索引记录不是直接按照key_part2列的值进行排序的，所以符合条件的二级索引记录可能并不相邻，也就意味着我们不能通过搜索条件来减少需要扫描的行数，这种情况下，我们是不会使用这个索引的。</p><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 = &#x27;a&#x27;</span><br><span class="line">  and key_part3 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>这个时候，其实是可以按照key_part1进行过滤的，但是因为接下来是按照key_part2进行排序的，所以满足搜索条件 <code>key_part3 = &#39;c&#39;</code>的二级索引值记录可能并不相邻，这个时候扫描区间其实就是【’a’,’a’】。因为第二个条件走不了索引。</p><blockquote><p>针对获取到的每一条二级索引记录，如果没有开启索引条件下推的特性，则必须先回表获取完整的记录在来判断 <code>key_part3 = &#39;c&#39;</code>条件是否成立，如果开启了索引下推特性，可以判断完 <code>key_part3 = &#39;c&#39;</code>是否成立后在进行回表操作，索引下推是在MySQL5.6引入的，默认开启。</p></blockquote><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 &lt; &#x27;a&#x27;</span><br><span class="line">  and key_part2 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>因为二级索引记录先按照key_part1进行值排序的，所以符合条件的所有记录肯定是相邻的。但是对于<code>key_part1 &lt; &#39;a&#39;</code>条件的二级索引记录来说，并不是直接按照key_part2进行排序的，也就是说我们不能根据<code>key_part2 = &#39;c&#39;</code>来进一步减少扫描的行数。那么，如果使用当前索引执行查询，可以定位到符合<code>key_part1 &lt; &#39;a&#39;</code>的第一条记录，然后沿着单链表往后扫描，一直到不符合<code>key_part1 &lt; &#39;a&#39;</code>为止。</p><p>所以在使用当前索引执行SQL的时候，对应的扫描区间其实就是【-∞,’a’】。</p><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 &lt;= &#x27;a&#x27;</span><br><span class="line">  and key_part2 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>这条SQL和上一条SQL很像，唯一的区别就是从小于变成了小于等于。很显然符合<code>key_part1 &lt;= &#39;a&#39;</code>的索引值记录是连续的，但是对于符合<code>key_part1 &lt;= &#39;a&#39;</code>条件的二级索引记录来说，并不是直接按照key_part2列排序的。<strong>但是</strong>，对于符合<code>key_part1 = &#39;a&#39;</code>的二级索引记录来说，是按照key_part2的值进行排序的。那么再确定需要扫描的二级索引记录的范围时，当二级索引记录的<code>key_part1 = &#39;a&#39;</code>时，也可以通过<code>key_part2 = &#39;c&#39;</code>来减少扫描行数，也就是说，当扫描到不符合<code>key_part1 &lt;= &#39;a&#39; and key_part2 = &#39;c&#39;</code>的第一条记录的时候，就可以结束扫描，而不需要将所有的<code>key_part1 = &#39;a&#39;</code>的记录全部扫描完。</p><h2 id="2-索引用于排序"><a href="#2-索引用于排序" class="headerlink" title="2. 索引用于排序"></a>2. 索引用于排序</h2><p>我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2, key_part3 LIMIT 10;</span><br></pre></td></tr></table></figure><p>这个查询的结果集需要先按照<code>key_part1</code>值排序，如果记录的<code>key_part1</code>值相同，则需要按照<code>key_part2</code>来排序，如果<code>key_part2</code>的值相同，则需要按照<code>key_part3</code>排序。因为这个<code>B+</code>树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行<code>回表</code>操作取出该索引中不包含的列就好了。</p><h3 id="2-1使用联合索引进行排序注意事项"><a href="#2-1使用联合索引进行排序注意事项" class="headerlink" title="2.1使用联合索引进行排序注意事项"></a>2.1使用联合索引进行排序注意事项</h3><p>对于<code>联合索引</code>有个问题需要注意，<code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出<code>ORDER BY key_part1, key_part3, key_part2</code>的顺序，那也是用不了<code>B+</code>树索引，这种颠倒顺序就不能使用索引的原因我们上边详细说过了，这就不赘述了。</p><p>同理，<code>ORDER BY key_part1</code>、<code>ORDER BY key_part1, key_part2</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;A&#x27; ORDER BY key_part2, key_part3 LIMIT 10;</span><br></pre></td></tr></table></figure><p>这个查询能使用联合索引进行排序是因为<code>key_part1</code>列的值相同的记录是按照<code>key_part2</code>, <code>key_part3</code>排序的。</p><h3 id="2-2不可以使用索引进行排序的几种情况"><a href="#2-2不可以使用索引进行排序的几种情况" class="headerlink" title="2.2不可以使用索引进行排序的几种情况"></a>2.2不可以使用索引进行排序的几种情况</h3><h4 id="2-2-1ASC、DESC混用"><a href="#2-2-1ASC、DESC混用" class="headerlink" title="2.2.1ASC、DESC混用"></a>2.2.1ASC、DESC混用</h4><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序。</p><blockquote><p>ORDER BY子句后的列如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。</p></blockquote><p>为啥会有这种规定呢？这个还得回头想想这个<code>idx_key_part</code>联合索引中记录的结构：</p><ul><li>先按照记录的<code>key_part1</code>列的值进行升序排列。</li><li>如果记录的<code>key_part1</code>列的值相同，再按照<code>key_part2</code>列的值进行升序排列。</li><li>如果记录的<code>key_part2</code>列的值相同，再按照<code>key_part3</code>列的值进行升序排列。</li></ul><p>如果查询中的各个排序列的排序顺序是一致的，比方说下边这两种情况：</p><ul><li> <code>ORDER BY key_part1, key_part2 LIMIT 10</code><br>这种情况直接从索引的最左边开始往右读10行记录就可以了。 </li><li> <code>ORDER BY key_part1 DESC, key_part2 DESC LIMIT 10</code>，<br>这种情况直接从索引的最右边开始往左读10行记录就可以了。 </li></ul><p>但是如果我们查询的需求是先按照<code>key_part1</code>列进行升序排列，再按照<code>key_part2</code>列进行降序排列的话，比如说这样的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2 DESC LIMIT 10;</span><br></pre></td></tr></table></figure><p>这样如果使用索引排序的话过程就是这样的：</p><ul><li>先从索引的最左边确定<code>key_part1</code>列最小的值，然后找到<code>key_part1</code>列等于该值的所有记录，然后从<code>name</code>列等于该值的最右边的那条记录开始往左找10条记录。</li><li>如果<code>key_part1</code>列等于最小的值的记录不足10条，再继续往右找<code>key_part1</code>值第二小的记录，重复上边那个过程，直到找到10条记录为止。</li></ul><p>这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据，所以就规定<strong>使用联合索引的各个排序列的排序顺序必须是一致的</strong>。</p><h4 id="2-2-2排序列包含非同一个索引的列"><a href="#2-2-2排序列包含非同一个索引的列" class="headerlink" title="2.2.2排序列包含非同一个索引的列"></a>2.2.2排序列包含非同一个索引的列</h4><p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, common_field LIMIT 10;</span><br></pre></td></tr></table></figure><p><code>key_part1</code>和<code>common_field</code>并不属于一个联合索引中的列，所以无法使用索引进行排序。</p><h4 id="2-2-3排序列使用了复杂的表达式"><a href="#2-2-3排序列使用了复杂的表达式" class="headerlink" title="2.2.3排序列使用了复杂的表达式"></a>2.2.3排序列使用了复杂的表达式</h4><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY UPPER(key_part1) LIMIT 10;</span><br></pre></td></tr></table></figure><p>使用了<code>UPPER</code>函数修饰过的列就不是单独的列了，这样就无法使用索引进行排序了。</p><h2 id="3-索引用于分组"><a href="#3-索引用于分组" class="headerlink" title="3. 索引用于分组"></a>3. 索引用于分组</h2><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3, COUNT(*) FROM single_table GROUP BY key_part1, key_part2, key_part3</span><br></pre></td></tr></table></figure><p>这个查询语句相当于做了3次分组操作：</p><ol><li>先把记录按照<code>key_part1</code>值进行分组，所有<code>key_part1</code>值相同的记录划分为一组。</li><li>将每个<code>key_part1</code>值相同的分组里的记录再按照<code>key_part2</code>的值进行分组，将<code>key_part3</code>值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li><li>再将上一步中产生的小分组按照<code>key_part3</code>的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把<code>大分组</code>分成若干个<code>小分组</code>，然后把若干个<code>小分组</code>再细分成更多的<code>小小分组</code>。</li></ol><p>然后针对那些<code>小小分组</code>进行统计，比如在我们这个查询语句中就是统计每个<code>小小分组</code>包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的<code>B+</code>树中的索引列的顺序是一致的，而我们的<code>B+</code>树索引又是按照索引列排好序的，这不正好么，所以可以直接使用<code>B+</code>树索引进行分组。</p><p>和使用<code>B+</code>树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p><h1 id="四，回表的代价"><a href="#四，回表的代价" class="headerlink" title="四，回表的代价"></a>四，回表的代价</h1><p>看下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 &gt; &#x27;aaa&#x27; AND key_part1 &lt; &#x27;zzz&#x27;;</span><br></pre></td></tr></table></figure><p>在使用<code>idx_key_part</code>索引进行查询时大致可以分为这两个步骤：</p><ol><li>从索引<code>idx_key_part</code>对应的<code>B+</code>树中取出<code>key_part1</code>值在<code>aaa</code>～<code>zzz</code>之间的用户记录。</li><li>由于索引idx_key_part对应的<code>B+</code>树用户记录中只包含<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>、<code>id</code>这4个字段，而查询列表是<code>*</code>，意味着要查询表中所有字段，也就是还要包括其他字段。这时需要把从上一步中获取到的每一条记录的<code>id</code>字段都到聚簇索引对应的<code>B+</code>树中找到完整的用户记录，也就是我们通常所说的<code>回表</code>，然后把完整的用户记录返回给查询用户。</li></ol><p>由于索引<code>idx_key_part</code>对应的<code>B+</code>树中的记录首先会按照<code>key_part1</code>列的值进行排序，所以值在<code>aaa～zzz</code>之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为<code>顺序I/O</code>。根据第1步中获取到的记录的<code>id</code>字段的值可能并不相连，而在聚簇索引中记录是根据<code>id</code>（也就是主键）的顺序排列的，所以根据这些并不连续的<code>id</code>值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为<code>随机I/O</code>。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引<code>idx_key_part</code>的查询有这么两个特点：</p><ol><li> 会使用到两个<code>B+</code>树索引，一个二级索引，一个聚簇索引。 </li><li> 访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code>。 </li></ol><p>需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用<code>二级索引</code>。比方说<code>key_part1</code>值在<code>aaa</code>～<code>zzz</code>之间的用户记录数量占全部记录数量90%以上，那么如果使用<code>idx_key_part</code>索引的话，有90%多的<code>id</code>值需要回表，还不如直接去扫描聚簇索引（也就是全表扫描）。</p><p>那什么时候采用全表扫描的方式，什么时候使用采用<code>二级索引 + 回表</code>的方式去执行查询呢？这个就是查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用<code>二级索引 + 回表</code>的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用<code>二级索引 + 回表</code>的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 &gt; &#x27;aaa&#x27; AND key_part1 &lt; &#x27;zzz&#x27; LIMIT 10;</span><br></pre></td></tr></table></figure><p>添加了<code>LIMIT 10</code>的查询更容易让优化器采用<code>二级索引 + 回表</code>的方式进行查询。</p><p>对于有排序需求的查询，上边讨论的采用<code>全表扫描</code>还是<code>二级索引 + 回表</code>的方式进行查询的条件也是成立的，比方说下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2, key_part3;</span><br></pre></td></tr></table></figure><p>由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。如果我们加了<code>LIMIT</code>子句，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2, key_part3 LIMIT 10;</span><br></pre></td></tr></table></figure><p>这样需要回表的记录特别少，优化器就会倾向于使用<code>二级索引 + 回表</code>的方式执行查询。</p><h1 id="五，更好的创建和使用索引"><a href="#五，更好的创建和使用索引" class="headerlink" title="五，更好的创建和使用索引"></a>五，更好的创建和使用索引</h1><h2 id="1-只为了用于搜索，排序-amp-分组的列创建索引"><a href="#1-只为了用于搜索，排序-amp-分组的列创建索引" class="headerlink" title="1. 只为了用于搜索，排序&amp;分组的列创建索引"></a>1. 只为了用于搜索，排序&amp;分组的列创建索引</h2><p>也就是说，只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2 FROM single_table WHERE key_part3 = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>像查询列表中的key_part1、key_part2这两个列就不需要建立索引，我们只需要为出现在<code>WHERE</code>子句中的<code>key_part3</code>列创建索引就可以了。</p><h2 id="2-考虑列的基数"><a href="#2-考虑列的基数" class="headerlink" title="2. 考虑列的基数"></a>2. 考虑列的基数</h2><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个<code>列的基数</code>指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为<code>1</code>，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：<strong>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</strong></p><h2 id="3-索引列的类型尽量小"><a href="#3-索引列的类型尽量小" class="headerlink" title="3. 索引列的类型尽量小"></a>3. 索引列的类型尽量小</h2><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>这么几种，它们占用的存储空间依次递增，我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>～ 这是因为：</p><ol><li>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东西）</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ol><p>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的<code>I/O</code>。</p><h2 id="4-为列前缀建立索引"><a href="#4-为列前缀建立索引" class="headerlink" title="4. 为列前缀建立索引"></a>4. 为列前缀建立索引</h2><p>一个字符串其实是由若干个字符组成，如果我们在<code>MySQL</code>中使用<code>utf8</code>字符集去存储字符串的话，编码一个字符需要占用<code>1~3</code>个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的<code>B+</code>树中有这么两个问题：</p><ol><li> <code>B+</code>树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。 </li><li> 如果<code>B+</code>树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。 </li></ol><p>索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在<code>B+</code>树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题。</p><h2 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h2><p>为了彻底告别<code>回表</code>操作带来的性能损耗，建议：最好在查询列表里只包含索引列，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2 FROM single_table WHERE key_part3 = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>因为我们只查询<code>key_part1</code>, <code>key_part2</code>, 这2个索引列的值，所以在通过<code>idx_key_part</code>索引得到结果后就不必到<code>聚簇索引</code>中再查找记录的剩余列，这样就省去了<code>回表</code>操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为<code>索引覆盖</code>。排序操作也优先使用<code>覆盖索引</code>的方式进行查询，比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  key_part1, key_part2, key_part3  FROM person_info ORDER BYkey_part1, key_part2, key_part3;</span><br></pre></td></tr></table></figure><p>虽然这个查询中没有<code>LIMIT</code>子句，但是采用了<code>覆盖索引</code>，所以查询优化器就会直接使用<code>idx_key_part</code>索引进行排序而不需要回表操作了。</p><p>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是尽量不要用用<code>*</code>号作为查询列表，最好把需要查询的列依次标明。</p><h2 id="6-不要乱动列名"><a href="#6-不要乱动列名" class="headerlink" title="6.不要乱动列名"></a>6.不要乱动列名</h2><p>假设表中有一个整数列<code>my_col</code>，我们为这个列建立了索引。下边的两个<code>WHERE</code>子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li><code>WHERE my_col * 2 &lt; 4</code></li><li><code>WHERE my_col &lt; 4/2</code></li></ol><p>第1个<code>WHERE</code>子句中<code>my_col</code>列并不是以单独列的形式出现的，而是以<code>my_col * 2</code>这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于<code>4</code>，所以这种情况下是使用不到为<code>my_col</code>列建立的<code>B+</code>树索引的。而第2个<code>WHERE</code>子句中<code>my_col</code>列并是以单独列的形式出现的，这样的情况可以直接使用<code>B+</code>树索引。</p><p>所以结论就是<strong>：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的</strong>。</p><h2 id="7-尽量维持有序插入"><a href="#7-尽量维持有序插入" class="headerlink" title="7. 尽量维持有序插入"></a>7. 尽量维持有序插入</h2><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在<code>1~100</code>之间：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861103166-845b6b09-0294-4027-ad5d-b5815df00793.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub7061039&margin=%5Bobject%20Object%5D&name=6.png&originHeight=248&originWidth=1118&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5278&status=done&style=none&taskId=u7c51a7b9-7e57-4ac1-9546-eb1849caa4f&title=" alt="6.png"></p><p>如果此时再插入一条主键值为<code>9</code>的记录，那它插入的位置就如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861109717-cb54b239-fa3d-463d-b7bf-d5a71ab2d1ca.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0dbeca73&margin=%5Bobject%20Object%5D&name=7.png&originHeight=407&originWidth=1101&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8706&status=done&style=none&taskId=udac3d09f-d048-4f8a-a7bc-6dfdca9f91e&title=" alt="7.png"></p><p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：<strong>让主键具有</strong><code>**AUTO_INCREMENT**</code><strong>，让存储引擎自己为表生成主键，而不是我们手动插入</strong> 。</p><h2 id="8-冗余和重复索引"><a href="#8-冗余和重复索引" class="headerlink" title="8.冗余和重复索引"></a>8.冗余和重复索引</h2><p>我们知道，通过<code>idx_key_part</code>索引就可以对<code>key_part1</code>列进行快速搜索，再创建一个专门针对<code>key_part1</code>列的索引就算是一个<code>冗余</code>索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><blockquote><p>至此，索引命中的原理和我们在建立索引的时候应该注意什么就分析完了，好家伙，又是一个通宵。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[三]InnoDB索引结构</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>索引其实就是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】。<br>​</p><blockquote><p>为什么有页的概念？<br>​</p></blockquote><blockquote><p>查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p></blockquote><p>​</p><p>数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。<br>​</p><blockquote><p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796442070-30497473-d6d6-4848-9622-3ef7c4be8eab.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5dd411f3&margin=%5Bobject%20Object%5D&name=%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.jpg&originHeight=816&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24988&status=done&style=shadow&taskId=u7ea9c417-2241-4f50-b784-ce1b7ae3a67&title=" alt="索引的层级关系.jpg"></p><p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p><h1 id="一，行格式"><a href="#一，行格式" class="headerlink" title="一，行格式"></a>一，行格式</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p><h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><p>比如我们创建一张表来指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="keyword">VALUES</span>(<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="string">&#x27;eeee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>首先我们来看Compact行格式。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796457336-bb5e4bf7-0f44-4c11-9580-32077f221ac3.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u510eb047&margin=%5Bobject%20Object%5D&name=Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=513&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108011&status=done&style=shadow&taskId=u3c55f797-d70f-44c7-bc54-b58728aaeaf&title=" alt="Compact行格式示意图.png"></p><p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p><h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>额外的信息实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p><h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】。</p><blockquote><p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p></blockquote><p>在Compact行格式中，会把所有的变长字段占用的真实长度全部<strong>逆序</strong>存储在记录的开头位置，形成一个变长字段长度列表。</p><p>比如我们刚才创建的那张表，我们来分析一下：</p><p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p><table><thead><tr><th>列名</th><th>储存内容</th><th>内容长度(十进制表示)</th><th>内容长度(十六进制表示)</th></tr></thead><tbody><tr><td>C1</td><td>‘aaaa’</td><td>4</td><td>0x04</td></tr><tr><td>C2</td><td>‘bbb’</td><td>3</td><td>0x03</td></tr><tr><td>C4</td><td>‘d’</td><td>1</td><td>0x01</td></tr></tbody></table><p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796496893-933ea1aa-d845-4f94-9328-beff8d57dbc4.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8653fe78&margin=%5Bobject%20Object%5D&name=%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=471&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96980&status=done&style=shadow&taskId=u7e13eb1a-bbe3-4c44-8f4e-7237f99dd6f&title=" alt="第一条记录的存储格式.png"></p><p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p><p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p><p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p><p>【L】：真实占用的字节数</p><ol><li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li></ol><blockquote><p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p></blockquote><ol start="2"><li>如果M*W&gt;=255,这个时候再次分为两种情况： <ol><li>如果L&lt;=127，那就用1个字节表示</li><li>否则就用2个字节表示</li></ol></li></ol><blockquote><p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p><p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p><p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p></blockquote><p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p><p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p><h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p><p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p><p>看一下处理过程：</p><ol><li>首先统计出表中允许存储NULL的字段</li><li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li><li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li></ol><p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p><p>这个时候再来看我们上面创建的表中的记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796522793-2b2f0b54-2e1b-4534-97fc-ad5d2ae29267.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua59c3787&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=578&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116004&status=done&style=shadow&taskId=u474c254b-e5cb-420c-939e-50e0762c364&title=" alt="表中记录的存储格式.png"></p><h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651393775-13c8a071-3007-4743-98e6-6bfadf766833.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=nEsCg&originHeight=238&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>接下来来看记录的真实数据。</p><h3 id="2-2-真实数据"><a href="#2-2-真实数据" class="headerlink" title="2.2 真实数据"></a>2.2 真实数据</h3><p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p><p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p><p>在完善下我们开头创建的那张表的记录形象。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651419885-ccc53e84-579f-4e2b-aaa3-c2da800dcf5b.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=EzoHh&originHeight=480&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p><h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p><p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p><blockquote><p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p></blockquote><h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p><h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p><p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p><ol><li>真实数据</li><li>真实数据占用的字节长度</li><li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li></ol><p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p><p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p><blockquote><p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p></blockquote><h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651449173-c7c3df4a-7697-4e98-8461-0f4d8fa25acf.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=YE1nR&originHeight=698&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651459938-08f5b09b-16a1-4981-b0db-58ce8c2776fd.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=yQ6dC&originHeight=427&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p><h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p><p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p><p>分析一下页空间是如何利用的</p><ol><li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li><li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：<table><thead><tr><th>内容</th><th>大小(字节)</th></tr></thead><tbody><tr><td>真实数据的长度</td><td>2</td></tr><tr><td>列是否是NULL值</td><td>1</td></tr><tr><td>头信息</td><td>5</td></tr><tr><td>row_id</td><td>6</td></tr><tr><td>transaction_id</td><td>6</td></tr><tr><td>roll_pointer</td><td>7</td></tr></tbody></table></li></ol><p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p><h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651470552-ca5845c2-4a02-4778-8072-12e7cfc5e936.png#crop=0&crop=0&crop=1&crop=1&id=DwYBu&originHeight=456&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p><blockquote><p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p></blockquote><h1 id="二，页的存储结构"><a href="#二，页的存储结构" class="headerlink" title="二，页的存储结构"></a>二，页的存储结构</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p><p>本节分析存放表中记录的页，官方成为索引页，为了分析方便，我们暂且叫做数据页。</p><blockquote><p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p></blockquote><p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796599016-6db7f08f-012c-4991-beb7-f86a02b783e9.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u24a51a9d&margin=%5Bobject%20Object%5D&name=%E8%A1%8C%E6%A0%BC%E5%BC%8F%26%E9%A1%B5%E7%BB%93%E6%9E%84.png&originHeight=1924&originWidth=2164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=761701&status=done&style=shadow&taskId=ua68b2010-2f09-4933-82b5-8624ccfa018&title=" alt="行格式&amp;页结构.png"></p><p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页专有的一些信息</td></tr><tr><td>Infifmum + Supremum</td><td>最小记录和最大记录</td><td>26</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658751624-f2ae040c-521a-4279-a33a-3d049076dbbb.png#crop=0&crop=0&crop=1&crop=1&id=rhsyy&originHeight=443&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>再次回顾下记录头中5个字节表示的数据。</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>针对当前这个表的行格式简化图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658929002-26d8d2aa-f31f-4424-9364-53bb1e935f02.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=JuPWk&originHeight=328&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>接下来我们往表中插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639659360000-9ea955da-a191-4149-a654-02130cd27262.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=IQRli&originHeight=511&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>分析一下头信息中的每个属性是什么意思。</p><h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p><p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p><blockquote><p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p></blockquote><h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p><h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p><p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p><p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p><p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660568126-eca45a45-699f-4c18-a914-9b0082e4409e.png#crop=0&crop=0&crop=1&crop=1&id=Qa0fp&originHeight=341&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660690280-f21f9cde-a88c-43b7-bed2-e61cdf99821c.png#crop=0&crop=0&crop=1&crop=1&id=yv4uT&originHeight=417&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p><h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p><p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p><h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661137395-fec2e2b7-c0d0-4ecd-8cf0-ff73e86cd98b.png#crop=0&crop=0&crop=1&crop=1&id=GEIoi&originHeight=509&originWidth=1025&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>删除第二条记录以后：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661263287-6bf68c5d-2b08-49f7-9b64-91ff84f8c25f.png#crop=0&crop=0&crop=1&crop=1&id=ehUJN&originHeight=472&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>发生的变化：</p><ul><li>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</li><li>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</li><li>第一条记录的next record指向了第三条记录</li><li>最大记录的 n_owned 值从5 变成了4</li></ul><p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p><p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p><p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p><p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661938956-dbc09fae-e330-4b44-a97c-ad28500fb0c0.png#crop=0&crop=0&crop=1&crop=1&id=N59w2&originHeight=516&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p><h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol><li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li><li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li><li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li></ol><p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663655164-28caa8e4-aceb-4b4e-aaaf-75ab188453c9.png#crop=0&crop=0&crop=1&crop=1&id=xFmTO&originHeight=481&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p><p>注意最大和最小记录的头信息的n_owned属性：</p><ol><li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li><li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li></ol><p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663745413-7924a9ec-b680-4231-8686-eb99c41946df.png#crop=0&crop=0&crop=1&crop=1&id=k3iqz&originHeight=541&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。所以分组是按照下边的步骤进行的：</p><ul><li> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </li><li> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li><li> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663920121-ec3b0a9f-f512-432d-a584-fb3187b0a0bf.png#crop=0&crop=0&crop=1&crop=1&id=caRNN&originHeight=632&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ol><h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p><p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p><h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p><p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p><ol><li>前四个字节代表校验和</li><li>后四个字节代表页面被最后修改时对应的日志序列位置</li></ol><p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p><blockquote><p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p></blockquote><h1 id="三，索引"><a href="#三，索引" class="headerlink" title="三，索引"></a>三，索引</h1><h2 id="1-假如没有索引"><a href="#1-假如没有索引" class="headerlink" title="1.假如没有索引"></a>1.假如没有索引</h2><p>我们先来看看没有索引的情况下，我们进行数据的查找(毕竟没有对比就没有伤害)。</p><h3 id="1-1-在一个页中查找"><a href="#1-1-在一个页中查找" class="headerlink" title="1.1 在一个页中查找"></a>1.1 在一个页中查找</h3><p>假设表中的记录很少，所有的记录仅仅用一个页就存放下了，这个时候按照不同的搜索条件其实可以分为两种情况讨论：</p><p>【以主键为搜索的条件】：可以再页目录中根据二分查找快速定位到槽，在根据槽定位到该组的最小索引记录，然后进行遍历匹配查找。</p><p>【以其他列作为搜索条件】：在数据页中并没有为非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。在这种情况下，只能从最小记录开始依次往后遍历单链表中的每条记录，然后对比每条记录是否符合搜索条件，显然，效率很低。</p><h3 id="1-2-在很多页中查找"><a href="#1-2-在很多页中查找" class="headerlink" title="1.2 在很多页中查找"></a>1.2 在很多页中查找</h3><p>很多时候，表的记录一个页都是存储不下的，这个时候的查找其实分为两个步骤：</p><p>【定位到记录所在的页】</p><p>【从所在的页内查找相应的记录】</p><p>因为我们不能快速的定位到所在的页，所以只能从第一页开始沿着双链表往后遍历定位页，定位到页以后在根据在一个页中的查找方式进行匹配查找，显而易见，这个时候效率低的可怕。</p><blockquote><p>有了痛点，就会有大牛去思考整个生命周期，完善逻辑和资源倾斜，形成一套自己的方法论，想办法为快速查找赋能。</p></blockquote><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>我们先创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><h3 id="2-1-一个简单的索引方案"><a href="#2-1-一个简单的索引方案" class="headerlink" title="2.1 一个简单的索引方案"></a>2.1 一个简单的索引方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？</p><p>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <strong><em>不得不</em></strong> 依次遍历所有的数据页。</p><p>如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？</p><p>对比根据主键值快速定位一条记录从而在页中的位置建立页目录，我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录。</p><p>【<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。】</p><p>假设我们现在每一页只能放三条记录，现在已经放了主键为1,3,5的三条记录。这个时候我们再添加一条主键为4的记录，我们不得不为他分配一个新的页。</p><blockquote><p>注意：新分配的数据页编号可能和原来并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。他们只是通过维护着上一页和下一页的编号而建立了链表关系。</p></blockquote><p>原来页中主键最大的值为5，现在我们新插入一条记录，如果直接放在新页里面，那就会有问题，这不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值得要求，所以在插入主键值为4 的记录的时候需要伴随一次记录的移动，也就是把主键值为5 的记录移动到新分配的页中，然后把主键值为4 的记录插入到原来的页中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796706858-85d2f635-d8a4-40cf-96ad-d575a4929471.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua72ea1d2&margin=%5Bobject%20Object%5D&name=%E9%A1%B5%E5%88%86%E8%A3%82.png&originHeight=689&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27916&status=done&style=shadow&taskId=u163f5ce3-dbab-47a0-bad4-ed0af4cae2f&title=" alt="页分裂.png"></p><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为<code>页分裂</code>。</p><p>【<strong>给所有的页建立一个目录项。</strong>】</p><p>由于数据页的编号可能并不是连续的，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796721543-59286c6b-be1f-4bf0-89c0-3c9d783caf2c.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7a2de81e&margin=%5Bobject%20Object%5D&name=%E6%8F%92%E5%85%A5%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E6%83%85%E6%99%AF.png&originHeight=206&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17346&status=done&style=shadow&taskId=ue4ddf3bb-d1ea-41aa-a3e4-48daab58dfa&title=" alt="插入多条记录后的情景.png"></p><p>因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p><ol><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li><li>页号，我们用<code>page_no</code>表示。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796747935-7d4d34c8-1163-4cae-8461-f44007b8fc07.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uafd00c0b&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BB%BA%E7%AB%8B%E7%9B%AE%E5%BD%95.png&originHeight=537&originWidth=1081&originalType=binary&ratio=1&rotation=0&showTitle=false&size=211150&status=done&style=none&taskId=u664861d2-e96c-4b27-9d3e-0df0e0538f5&title=" alt="推理索引-建立目录.png"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</li><li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录其实就是【索引】。</p><h3 id="2-2-InnoDB中的索引方案"><a href="#2-2-InnoDB中的索引方案" class="headerlink" title="2.2 InnoDB中的索引方案"></a>2.2 InnoDB中的索引方案</h3><p>上面的方案存在什么样的问题？</p><ul><li><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下。</li></ul><p>InnoDB复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。</p><p>那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？通过记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>**1**</code><strong>：目录项记录</strong></li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796769647-30add870-277e-46a6-b85f-eb81c9fffd78.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udd4ebea4&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BC%95%E5%87%BA%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=477&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245132&status=done&style=shadow&taskId=u5c27ff4c-5fe6-43bc-8fc3-5bbf4ebce0e&title=" alt="推理索引-引出目录项记录.png"></p><p>从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</li><li><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>头信息里面有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p>除此之外，两者就没有区别了，页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li><li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li></ol><blockquote><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p><p><strong>当然是再多整一个存储</strong><code>**目录项记录**</code><strong>的页。</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796794024-3c603a8c-379a-4741-b43f-0d09f823f3db.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u74247d36&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=423&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206755&status=done&style=shadow&taskId=uf9035595-4bd9-4c46-8e69-5fa3ae1bf3e&title=" alt="推理索引-多目录项记录.png"></p><p>从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前边假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li>确定<code>目录项记录</code>页</li></ol><blockquote><p>我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></blockquote><ol start="2"><li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？</p><p>为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796830733-a6cde000-9332-4f5a-8a83-0f7e8303a427.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5af42117&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95.png&originHeight=565&originWidth=888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246476&status=done&style=shadow&taskId=ub41ee0ab-63de-4476-9f1f-a9ecedd9f1f&title=" alt="推理索引-多级目录.png"></p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796848198-e8ce79c1-5f89-473a-97bf-03b44b900c28.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b765b2b&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png&originHeight=483&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27024&status=done&style=shadow&taskId=u8446b051-6d0e-476f-acb2-2a089be6d78&title=" alt="多路平衡二叉树.png"></p><p>其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上边的那个节点也称为<code>根节点</code>。</p><p>从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，<code>InnoDB</code>规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的分析我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p><ul><li>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</li><li>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</li><li>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。</li></ul><p>一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录。</p><h3 id="2-3-聚簇索引"><a href="#2-3-聚簇索引" class="headerlink" title="2.3 聚簇索引"></a>2.3 聚簇索引</h3><p>上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li> 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </li></ol><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul><ol start="2"><li> <code>B+</code>树的叶子节点存储的是完整的用户记录。<br>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </li></ol><p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建，<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的<strong>索引即数据，数据即索引</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796876199-b11195b7-5f43-49e4-95b4-9f16f805b7c2.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc673077f&margin=%5Bobject%20Object%5D&name=B%2B%E6%A0%91%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.jpg&originHeight=1878&originWidth=2947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=414971&status=done&style=shadow&taskId=ue286f0f6-c6f0-48b5-a853-ab5a88d3867&title=" alt="B+树主键索引.jpg"></p><h3 id="2-4-二级索引"><a href="#2-4-二级索引" class="headerlink" title="2.4 二级索引"></a>2.4 二级索引</h3><p><code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p><p>我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797313347-a44afddd-2c1b-4011-acc5-577ff4416285.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u807c5795&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png&originHeight=580&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=250264&status=done&style=shadow&taskId=uffdaff61-f70c-4ca9-b584-bb4c6ec8250&title=" alt="二级索引.png"></p><p>这个<code>B+</code>树与上边介绍的聚簇索引有几处不同：</p><ol><li> 使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义： </li><li>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li> <code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。 </li><li> 目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。 </li></ol><p>所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li>确定<code>目录项记录</code>页</li></ol><blockquote><p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p></blockquote><ol start="2"><li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li></ol><blockquote><p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p></blockquote><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录.</li></ol><blockquote><p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p></blockquote><ol start="4"><li>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li></ol><p><strong>我们根据这个以</strong><code>**c2**</code><strong>列大小排序的</strong><code>**B+**</code><strong>树只能确定我们要查找记录的主键值，所以如果我们想根据</strong><code>**c2**</code><strong>列的值查找到完整的用户记录的话，仍然需要到</strong><code>**聚簇索引**</code><strong>中再查一遍，这个过程也被称为</strong><code>**回表**</code><strong>。</strong>也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p><p>为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？</p><p>如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为为c2列建立的索引。</p><p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p><p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p><h3 id="2-5-联合索引"><a href="#2-5-联合索引" class="headerlink" title="2.5 联合索引"></a>2.5 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li></ul><p>为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797330214-15ee3ffb-1ebd-41aa-a48a-6c81ea92814d.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42fac64f&margin=%5Bobject%20Object%5D&name=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png&originHeight=599&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264505&status=done&style=shadow&taskId=uaa1c9645-b635-4e8f-a3d7-7942580366d&title=" alt="联合索引.png"></p><h2 id="3-InnoDB的B-树索引的注意事项"><a href="#3-InnoDB的B-树索引的注意事项" class="headerlink" title="3. InnoDB的B+树索引的注意事项"></a>3. InnoDB的B+树索引的注意事项</h2><h3 id="3-1-跟页面永远固定不动"><a href="#3-1-跟页面永远固定不动" class="headerlink" title="3.1 跟页面永远固定不动"></a>3.1 跟页面永远固定不动</h3><p>前边介绍<code>B+</code>树索引的时候，为了理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p><ul><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程需要特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p><h3 id="3-2-内节点中目录项记录的唯一性"><a href="#3-2-内节点中目录项记录的唯一性" class="headerlink" title="3.2 内节点中目录项记录的唯一性"></a>3.2 内节点中目录项记录的唯一性</h3><p>我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。假设表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797360116-ea5f9dc7-74cc-4191-ae4d-dd56cd80b6f5.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u817bb64e&margin=%5Bobject%20Object%5D&name=%E4%B8%BAc2%E5%BB%BA%E7%AB%8B%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%90%8E%E7%9A%84%E6%A0%91.png&originHeight=434&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77378&status=done&style=shadow&taskId=uc338898e-4933-47a8-9023-5f624b43729&title=" alt="为c2建立二级索引后的树.png"></p><p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中?</p><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的。</p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><h3 id="3-3-一个页面最少存储2条记录"><a href="#3-3-一个页面最少存储2条记录" class="headerlink" title="3.3 一个页面最少存储2条记录"></a>3.3 一个页面最少存储2条记录</h3><p>B+树只需要很少的层级就可以轻松存储数亿条记录，这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录会怎么样？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录，会导致效率很低。</p><blockquote><p>其实让B+数的叶子结点值存储一条记录，让内节点存储多条记录，也还是可以发挥B+数的作用的。但是InnoDB为了避免数的层级过高，要求所有的数据页都至少可以容纳两条记录。</p></blockquote><h2 id="4-MyISAM中的索引方案简单介绍"><a href="#4-MyISAM中的索引方案简单介绍" class="headerlink" title="4. MyISAM中的索引方案简单介绍"></a>4. MyISAM中的索引方案简单介绍</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><ul><li> 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。 </li><li> 使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！<br>这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code>！ </li><li> 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。 </li></ul><blockquote><p>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在MyIsaM数据上使用二分法进行查找。</p></blockquote><h2 id="5-创建和删除索引的语句"><a href="#5-创建和删除索引的语句" class="headerlink" title="5. 创建和删除索引的语句"></a>5. 创建和删除索引的语句</h2><p><code>InnoDB</code>和<code>MyISAM</code>会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。</p><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY<span class="operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们也可以在修改表结构的时候添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure><p>也可以在修改表结构的时候删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</span><br></pre></td></tr></table></figure><blockquote><p>至此，整个索引相关的结构我们就都分析完了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[一]入门</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一，MYSQL入门"><a href="#一，MYSQL入门" class="headerlink" title="一，MYSQL入门"></a>一，MYSQL入门</h3><h4 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1.数据库相关概念"></a>1.数据库相关概念</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DB：数据库：存储数据的仓库，保存了一系列有组织的数据。</span></span><br><span class="line"><span class="attr">DBMS：数据库管理系统：数据库是通过DBMS创建和操作的容器。</span></span><br><span class="line"><span class="attr">SQL：结构化查询语言：专门用来与数据库通信的语言。</span></span><br></pre></td></tr></table></figure><h4 id="2-数据库的好处"><a href="#2-数据库的好处" class="headerlink" title="2.数据库的好处"></a>2.数据库的好处</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.可以持久化数据到本地</span></span><br><span class="line"><span class="attr">2.可以实现结构化查询，方便管理</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库存储数据特点"><a href="#3-数据库存储数据特点" class="headerlink" title="3.数据库存储数据特点"></a>3.数据库存储数据特点</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.将数据放到表中，表放到库中。</span></span><br><span class="line"><span class="attr">2.一个数据库有多张表，每个表都有一个名字，用来标识自己。</span></span><br><span class="line"><span class="attr">表名具有唯一性。</span></span><br><span class="line"><span class="attr">3.表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中类的设计。</span></span><br><span class="line"><span class="attr">4.表有列组成，我们也称为字段。所有表都是由一个列或多个列组成的，</span></span><br><span class="line"><span class="attr">每一列类似Java中的属性。</span></span><br><span class="line"><span class="attr">5.表中的数据按照行来存储，每一行类似于Java中的对象。</span></span><br></pre></td></tr></table></figure><h4 id="4-mysql的安装与使用"><a href="#4-mysql的安装与使用" class="headerlink" title="4.mysql的安装与使用"></a>4.mysql的安装与使用</h4><p><strong>参照mysql安装文档</strong></p><h4 id="5-Mysql常用命令"><a href="#5-Mysql常用命令" class="headerlink" title="5.Mysql常用命令"></a>5.Mysql常用命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">显示数据库-----&gt;show</span> <span class="string">Databases;</span></span><br><span class="line"><span class="meta">使用数据库-----&gt;use</span> <span class="string">数据库名；</span></span><br><span class="line"><span class="meta">显示表----&gt;show</span> <span class="string">tables;</span></span><br><span class="line"><span class="meta">显式指定数据库的表----&gt;show</span> <span class="string">tables from 数据库名；</span></span><br><span class="line"><span class="meta">查看位于那个数据库----&gt;select</span> <span class="string">database();</span></span><br><span class="line"><span class="meta">显示表结构---&gt;desc</span> <span class="string">表名；</span></span><br><span class="line"><span class="meta">查看数据库版本：---&gt;select</span> <span class="string">version();</span></span><br><span class="line"><span class="meta">查看数据库版本2</span>:<span class="string">-----&gt;Dos:mysql --version;</span></span><br><span class="line"><span class="meta">查看数据库信息-----&gt;show</span> <span class="string">CREATE DATABASE mydb1;</span></span><br><span class="line"><span class="meta">查看服务器中的数据库，并把mydb1的字符集修改为utf-8-----&gt;ALTER</span> <span class="string">DATABASE mydb1character set utf8;</span></span><br><span class="line"><span class="meta">删除数据库-----&gt;drop</span> <span class="string">database mydb1;</span></span><br><span class="line"><span class="meta">表中增加一栏信息-----&gt;alter</span> <span class="string">table student add image blob;</span></span><br><span class="line"><span class="meta">删除表-----&gt;drop</span> <span class="string">table student;</span></span><br><span class="line"><span class="meta">修改地址-----&gt;alter</span> <span class="string">table student modify address varchar(100);</span></span><br><span class="line"><span class="meta">删除一个属性-----&gt;</span> <span class="string">alter table student drop image;</span></span><br><span class="line"><span class="meta">修改表名-----&gt;rename</span> <span class="string">table student to students;</span></span><br><span class="line"><span class="meta">查看表的创建细节-----&gt;show</span> <span class="string">create table students;</span></span><br><span class="line"><span class="meta">修改表的字符集为</span> <span class="string">gbk-----&gt;alter table students character set gbk;</span></span><br><span class="line"><span class="meta">列名name修改为studentname-----&gt;alter</span> <span class="string">table students change name studentname varchar(100);</span></span><br></pre></td></tr></table></figure><h4 id="6-mysql语法规范"><a href="#6-mysql语法规范" class="headerlink" title="6.mysql语法规范"></a>6.mysql语法规范</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.不区分大小写，建议关键字大写，表名列名小写。</span></span><br><span class="line"><span class="attr">2.每条命令最好用分号结尾。</span></span><br><span class="line"><span class="attr">3.每条语句可以缩进，换行。</span></span><br><span class="line"><span class="attr">4.注释</span></span><br><span class="line"><span class="attr">单行注释：#注释文字</span></span><br><span class="line">          <span class="meta">--</span> <span class="string">注释文字</span></span><br><span class="line"><span class="meta">多行注释：/*</span> <span class="string">*/</span></span><br></pre></td></tr></table></figure><h3 id="二，DQL查询语言"><a href="#二，DQL查询语言" class="headerlink" title="二，DQL查询语言"></a>二，DQL查询语言</h3><h4 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">**语法：</span> <span class="string">select 查询列表 from 表名**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询列表：表中的字段，常量，表达式，函数**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询的结果是张虚拟的表格**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.查询表中的单个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.查询表中的多个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name,salary,email from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.查询表中的所有字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.查询常量值</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">&#x27;john&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.查询表达式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100*98;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">6.查询函数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">version();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">7.起别名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name as name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">8.去重</span></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工表中涉及到的所有的部门编号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">distinct department_id from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">9.+的作用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#运算符：两个操作数都为数值型，则做加法运算；</span></span><br><span class="line"><span class="comment">#其中一方为字符型，试图将字符型数值转换成数值型，</span></span><br><span class="line"><span class="comment">#如果转换成功，继续做加法运算；否则，将字符型数值</span></span><br><span class="line"><span class="comment">#转换为0；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">10.使用concat实现连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名和性连接成一个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CONCAT(username,PASSWORD) FROM USER;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#任何数与null做运算结果都为null</span></span><br></pre></td></tr></table></figure><h4 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h4><p><strong>语法：</strong></p><p><strong>select 查询列表 from 表名 where 筛选条件</strong></p><p><strong>分类：</strong></p><h5 id="①按照条件表达式筛选"><a href="#①按照条件表达式筛选" class="headerlink" title="①按照条件表达式筛选"></a>①按照条件表达式筛选</h5><p>条件运算符：&gt;,&lt;,=,!=,&gt;=,&lt;=</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工工资&gt;1w2的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee where salary &gt;12000;</span></span><br><span class="line"><span class="meta">查询部门编号！</span>=<span class="string">90号的员工名和部门编号</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name, dep_id from employee where  dep_id 1=90；</span></span><br></pre></td></tr></table></figure><h5 id="②按照逻辑表达式筛选"><a href="#②按照逻辑表达式筛选" class="headerlink" title="②按照逻辑表达式筛选"></a>②按照逻辑表达式筛选</h5><p>逻辑运算符：&amp;&amp;,||,!,AND,OR,NOT</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询工资在一万到两万之见的员工名，工资以及奖金。</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name,salary ,jiangjin where salary between 10000 and 20000;</span></span><br><span class="line"><span class="attr">查询部门编号不在90-110之间，或者工资高于15000的员工信息。</span></span><br><span class="line"><span class="attr">select</span>  <span class="string">* from employee where department&lt;90||department&gt;110 ||salary &gt;15000;</span></span><br></pre></td></tr></table></figure><h5 id="③模糊查询"><a href="#③模糊查询" class="headerlink" title="③模糊查询"></a>③模糊查询</h5><p>like：一般和通配符搭配使用<br>通配符：<br>%任意多个字符，包含0个字符<br>_任意单个字符<br>BETWEEN AND:包含临界值<br>IN:判断某个字段的值是否属于in列表中的某一项<br>IS NULL,IS NOT NULL:=或者！=不能用来判断null<br>安全等于&lt;=&gt;可以判断null</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工名中包含a的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where name like %a%;</span></span><br><span class="line"><span class="attr">查询员工名中第三个字符为e第五个字符为a的员工名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp where name like %__e_a%;</span></span><br><span class="line"><span class="attr">员工名中第二个字符为_的员工名</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name from emp where name like %_\_%;</span></span><br><span class="line"><span class="attr">查询员工编号在100到120之间的所有员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where id between 100 and 120;</span></span><br><span class="line"><span class="attr">查询员工的工种编号是IT_PRIG,AD_PRES,AD_VP中的一个员</span></span><br><span class="line"><span class="attr">工名和工种编号；</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name , id from emp where id in(IT_PRIG,AD_PRES,AD_VP);</span></span><br><span class="line"><span class="attr">查询没有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary , jjl from emp where salary is Null;</span></span><br><span class="line"><span class="attr">查询有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary ,jjl from emp where salary is not null;</span></span><br></pre></td></tr></table></figure><h5 id="④IF-null的使用："><a href="#④IF-null的使用：" class="headerlink" title="④IF null的使用："></a>④IF null的使用：</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工号为176的员工的姓名和部门号和年薪</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name ,department_id , salary*(1+IFNULL(commission_pct,0))*12 &#x27;年薪&#x27;</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees WHERE employee_id =176;</span></span><br></pre></td></tr></table></figure><h4 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h4><p><strong>语法：</strong></p><p><strong>select   查询列表</strong></p><p><strong>from 表</strong></p><p><strong>where 筛选条件</strong></p><p><strong>order by 排序列表 asc 或desc （升序或者降序，默认为升序）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工信息，要求工资从高到低排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by salary desc;</span></span><br><span class="line"><span class="attr">查询部门编号大于等于90的员工信息，按照入职时间先后排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where dep_id &gt;=90 order by createtime asc;</span></span><br><span class="line"><span class="attr">按照员工年薪的高低显示员工的信息和年薪</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* ,年薪 from emp  order by salary*(1+if null(jjl,0))*12 as 年薪 desc;</span></span><br><span class="line"><span class="attr">按姓名长度显示员工的姓名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp order by length(name) asc;</span></span><br><span class="line"><span class="attr">查询员工信息，先按照工资排序，再按照员工编号排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp  order by salary asc,id asc;</span></span><br></pre></td></tr></table></figure><h4 id="4-常见函数"><a href="#4-常见函数" class="headerlink" title="4.常见函数"></a>4.常见函数</h4><p><strong>功能：类似Java中的方法</strong><br><strong>分类：单行函数</strong><br><strong>分组函数</strong></p><h5 id="1-单行函数"><a href="#1-单行函数" class="headerlink" title="1.单行函数"></a>1.单行函数</h5><h6 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1.字符函数"></a>1.字符函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.length</span> <span class="string">获取参数值的字节个数</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by length(name);</span></span><br><span class="line"><span class="meta">2.concat</span> <span class="string">拼接字符串</span></span><br><span class="line"><span class="attr">select</span> <span class="string">concat(last_name,first_name) as 姓名 from emp;</span></span><br><span class="line"><span class="meta">3.upper，lower</span> <span class="string">大小写转换函数</span></span><br><span class="line"><span class="attr">案例：将姓变大写，名字变小写，然后拼接</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">CONCAT(UPPER(last_name),LOWER(first_name))</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.substr,SUBSTRING</span> <span class="string">截取字符串</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2,3);</span></span><br><span class="line"><span class="attr">案例：姓名中首字符大写，其他的小写然后用_拼接显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">CONCAT(</span></span><br><span class="line">    <span class="meta">UPPER(SUBSTR(last_name,</span> <span class="string">1, 1)),</span></span><br><span class="line">    <span class="attr">&#x27;_&#x27;,</span></span><br><span class="line">    <span class="meta">LOWER(SUBSTR(last_name,</span> <span class="string">2))</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">output </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">5.instr</span>:<span class="string">返回字串第一次出现的索引，如果找不到返回0</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">INSTR(&#x27;风急天高猿啸哀&#x27;,&#x27;天&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.trim</span> :<span class="string">去掉前后空格或前后指定字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LENGTH(TRIM(&#x27;   张三丰   &#x27;)) AS out_put;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRIM(&#x27;a&#x27; FROM &#x27;aaaa1aa2aaa3aaa&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">7.lpad</span> :<span class="string">用指定字符填满指定长度（左填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">8.rpad</span>:<span class="string">用指定字符填满指定长度（右填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">RPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">9.replace</span> <span class="string">替换</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">REPLACE(&#x27;千锋培训机构&#x27;,&#x27;千锋&#x27;,&#x27;尚硅谷&#x27;);</span></span><br></pre></td></tr></table></figure><h6 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2.数学函数"></a>2.数学函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.round</span>:<span class="string">四舍五入</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.666);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.567,2);</span></span><br><span class="line"><span class="meta">2.ceil</span> <span class="string">向上取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CEIL(1.52);</span></span><br><span class="line"><span class="meta">3.floor</span> <span class="string">向下取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">FLOOR(1.52);</span></span><br><span class="line"><span class="meta">4.truncate</span>:<span class="string">截断（小数点后保留几位）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRUNCATE(1.65,2);</span></span><br><span class="line"><span class="meta">5.mod</span>:<span class="string">取余</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MOD(10,3);</span></span><br></pre></td></tr></table></figure><h6 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.now</span>:<span class="string">返回当前系统日期时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">NOW();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.curdate</span>:<span class="string">返回当前系统日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURDATE();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.curtime</span>:<span class="string">返回当前时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURTIME();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.获取指定部分的年月日时分秒</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(hiredate) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.str_to_date将字符通过指定的格式转化成日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">STR_TO_DATE(&#x27;1998-3-2&#x27;,&#x27;%Y-%c-%d&#x27;) AS out_put;</span></span><br><span class="line"><span class="attr">案例：查询入职时间为1992-4-3的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">hiredate=STR_TO_DATE(&#x27;2016-3-3&#x27;,&#x27;%Y-%c-%d&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.date_format</span> <span class="string">将日期转换成字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATE_FORMAT(NOW(),&#x27;%y年%m月%d日&#x27;) AS 日期;</span></span><br><span class="line"><span class="meta">案例：查询有奖金的员工名和入职日期（xx月/xx日</span> <span class="string">xx年）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="meta">DATE_FORMAT(hiredate,</span> <span class="string">&#x27;%c月/%d日 %y&#x27;) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL ;</span></span><br></pre></td></tr></table></figure><h6 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SELECT</span> <span class="string">VERSION();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATABASE();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">USER();</span></span><br></pre></td></tr></table></figure><h6 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.if</span>:<span class="string">IF else效果</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">IF(10&gt;5,&#x27;true&#x27;,&#x27;false&#x27;);</span></span><br><span class="line"><span class="attr">案例：查询如果有奖金就备注有，没有就备注没有。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">commission_pct,</span></span><br><span class="line">  <span class="attr">IF(</span></span><br><span class="line">    <span class="attr">commission_pct</span> <span class="string">IS NULL,</span></span><br><span class="line">    <span class="attr">&#x27;没奖金&#x27;,</span></span><br><span class="line">    <span class="attr">&#x27;有奖金&#x27;</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">AS 备注 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.case函数</span></span><br><span class="line"><span class="attr">1)switch-CASE</span></span><br><span class="line"><span class="meta">语法</span>:<span class="string"></span></span><br><span class="line"><span class="attr">CASE</span> <span class="string">要判断的字段或者表达式</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量1 THEN 要显示的值1或者语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量2 THEN 要显示的值2或者语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或者语句n；</span></span><br><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"><span class="meta">2)CASE</span> <span class="string">使用2：</span></span><br><span class="line"><span class="attr">语法：</span></span><br><span class="line"><span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件1 THEN 要显示的值1或语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件2 THEN 要显示的值2或语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或语句n</span></span><br><span class="line"><span class="attr">END</span></span><br><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees ;</span></span><br></pre></td></tr></table></figure><h5 id="2-分组函数"><a href="#2-分组函数" class="headerlink" title="2.分组函数"></a>2.分组函数</h5><p><strong>功能：用作统计使用</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.sum</span> :<span class="string">求和</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.avg：平均值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.max：最大值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MAX(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.min：最小值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.count：计算个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">总结</span></span><br><span class="line"><span class="attr">①.sum,avg一般用于处理数值类型</span></span><br><span class="line"><span class="attr">②.max，min，count用来处理任何类型</span></span><br><span class="line"><span class="attr">③.以上分组函数都忽略null值</span></span><br><span class="line"><span class="attr">④.可以和distinct搭配</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(DISTINCT salary) 纯净,SUM(salary) FROM employees;</span></span><br><span class="line"><span class="attr">6.count的详细介绍</span></span><br><span class="line"><span class="meta">①select</span> <span class="string">COUNT(*) FROM employees;</span></span><br><span class="line"><span class="meta">②select</span> <span class="string">COUNT(1) FROM employees;</span></span><br><span class="line"><span class="meta">③和分组函数一同查询的字段要求是group</span> <span class="string">by后的字段。</span></span><br></pre></td></tr></table></figure><h4 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h4><p><strong>GROUP BY 和分组函数对应</strong><br><strong>分组查询中分组条件分为两类</strong></p><table><thead><tr><th></th><th><strong>数据源</strong></th><th><strong>位置</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td><strong>分组前筛选</strong></td><td>原始表</td><td>GROUP BY 子句的前面</td><td>WHERE</td></tr><tr><td><strong>分组后筛选</strong></td><td>分组后的结果集</td><td>GROUP BY 子句的后面</td><td>HAVING</td></tr></tbody></table><p><strong>分组函数做条件肯定是放在having子句中。</strong><br><strong>group BY 子句支持单个字段分组，多个字段分组</strong><br><strong>（多个字段之间用逗号隔开没有顺序要求），表达式或函数。</strong><br><strong>也可以添加排序，放在整个分组查询的最后。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询每个工种的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY MAX(salary) ASC ;</span></span><br><span class="line"><span class="attr">案例：查询邮箱中包含a字符的，每个部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AVG(salary),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">email LIKE &#x27;%a%&#x27; </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id ;</span></span><br><span class="line"><span class="comment">#select Avg(salary),dep_id from employee where email like %a% group by dep_id ;</span></span><br><span class="line"><span class="attr">案例：查询有奖金的每个领导手下员工的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">manager_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id ;</span></span><br><span class="line"><span class="comment">#select max(salary) ,manage_id from employees where commission_pct is not null group by manager_id;</span></span><br><span class="line"><span class="attr">案例：哪个部门的员工个数大于二？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 2 ;</span></span><br><span class="line"><span class="comment">#select dep_id from emp group by dep_id having count(*)&gt;2;</span></span><br><span class="line"><span class="attr">案例：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MAX(salary) &gt; 12000 ;</span></span><br><span class="line"><span class="comment">#select job_id ,max(salary) from emp where commission_pct IS NOT NULL group by job_id having max(salary)&gt;12000;</span></span><br><span class="line"><span class="attr">案例：查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id ,MIN(salary)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">manager_id&gt;102</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#select manager_id from emp where manager_id&gt;102 group by manager_id having min(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#按照员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(*) AS c</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY LENGTH(last_name) </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">c&gt;5;</span></span><br><span class="line"><span class="comment"># select count(*) from emp group by length(name) having count(*)&gt;5;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资并且按照平均工资的高低显示</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY AVG(salary) ASC;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id order by avg(salary) asc;</span></span><br></pre></td></tr></table></figure><h4 id="6-连接查询"><a href="#6-连接查询" class="headerlink" title="6.连接查询"></a>6.连接查询</h4><p><strong>又称为多表查询，当查询的字段来自多个表时，就会用到连接查询。</strong><br>**笛卡尔乘积现象：表1有m行，表2有n行，结果：m_n行_<br><strong>发生原因：没有有效的连接条件</strong></p><p><strong>分类</strong></p><p>①按年代分类<br>sql92:仅仅支持内连接<br>sql99：不支持全外连接</p><p>②按功能分类</p><table><thead><tr><th>内连接</th><th>外连接</th><th>交叉连接</th></tr></thead><tbody><tr><td>等值连接</td><td>左外连接</td><td></td></tr><tr><td>非等值连接</td><td>右外连接</td><td></td></tr><tr><td>自连接</td><td>全外连接</td><td></td></tr></tbody></table><h5 id="1-等值连接"><a href="#1-等值连接" class="headerlink" title="1.等值连接"></a>1.等值连接</h5><p>①多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序，分组，筛选</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例一：查询女优名对应的男优名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">NAME,</span></span><br><span class="line">  <span class="attr">boyName</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">beauty,</span></span><br><span class="line">  <span class="attr">boys</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">beauty.boyfriend_id = boys.`id` ;</span></span><br><span class="line"><span class="comment">#select name, boyname from girl ,boy where girl.boyfriend_id=boy.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名和对应的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employees.`department_id` = departments.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e,dep d where e.dep.id= d.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名，工种号，工种名。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">emp.`job_id`,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">job </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">emp.`job_id` = job.`job_id` ;</span></span><br><span class="line"><span class="comment">#select name , e.job_id,job_title from emp e,job j where e.job_id=j.id;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的员工名和部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">dep </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL &amp;&amp; emp.`department_id` = dep.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e ,dep d where e.dep_id =d.id &amp;&amp;e.salary_pct is not null;</span></span><br><span class="line"><span class="comment">#案例：查询城市名第二个字符为o的部门</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">l.`city` LIKE &#x27;_o%&#x27; ;</span></span><br><span class="line"><span class="comment">#select dep_name from location l , dep d where l.city like %_o% &amp;&amp; l.id =d.location_id;</span></span><br><span class="line"><span class="comment">#案例：查询每个城市的部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY l.`city` ;</span></span><br><span class="line"><span class="comment">#select count(*),city from loca l,dep d where l.loc_id=d.loc_id group by count(*) asc;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.`department_name`,</span></span><br><span class="line">  <span class="attr">d.manager_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">e.`commission_pct` IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY d.`department_id`,</span></span><br><span class="line">  <span class="meta">d.`department_name`</span> <span class="string">;</span></span><br><span class="line"><span class="comment">#select dep_name ,d.manager_id ,min(salary) from emp e ,dep d where e.`department_id` = d.`department_id` AND e.`commission_pct` IS NOT NULL GROUP BY d.`department_id`,d.`department_name` ;</span></span><br><span class="line"><span class="comment">#案例：查询每个工种的工种名和员工的个数，并且按照员工个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">j.job_title,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">j,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">j.`job_id` = e.`job_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.`job_id`,</span></span><br><span class="line">  <span class="meta">j.`job_title`</span> <span class="string"></span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名，部门名和所在城市</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d,</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">d.`location_id` = l.`location_id` ;</span></span><br></pre></td></tr></table></figure><h5 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2.非等值连接"></a>2.非等值连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工的工资和工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DISTINCT </span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.salary &gt;= j.lowest_sal &amp;&amp; e.salary &lt;= j.highest_sal </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary ASC ;</span></span><br></pre></td></tr></table></figure><h5 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3.自连接"></a>3.自连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工名和上级的名称</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">e.last_name,</span></span><br><span class="line">  <span class="meta">m.last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">m </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.manager_id = m.employee_id ;</span></span><br></pre></td></tr></table></figure><h5 id="4-内连接"><a href="#4-内连接" class="headerlink" title="4.内连接"></a>4.内连接</h5><p><strong>INNER 可以省略</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询员工名，部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.department_id = d.department_id ;</span></span><br><span class="line"><span class="comment">#查询名字中包含e的员工名和工种名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.job_id = j.job_id </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">last_name LIKE &#x27;%e%&#x27; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询部门个数&gt;3的城市名和部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">city,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN locations l </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">d.`location_id` = l.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY city</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按照个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询员工名，部门名，工种名，并按照部门名降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`job_id` = j.`job_id` </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY department_name DESC ;</span></span><br><span class="line"><span class="comment">#查询员工工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level,</span></span><br><span class="line">  <span class="attr">salary</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN employees e </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` ;</span></span><br><span class="line"><span class="comment">#查询每个工资级别的个数，并且降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">grade_level,COUNT(*)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN  job_grades j</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY grade_level</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC;</span></span><br><span class="line"><span class="comment">#查询员工的名字和上级的名字</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">e1.last_name, e2.last_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e1</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN employees e2</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e1.`employee_id`=e2.`manager_id`;</span></span><br></pre></td></tr></table></figure><h5 id="5-左外连接"><a href="#5-左外连接" class="headerlink" title="5.左外连接"></a>5.左外连接</h5><p><strong>语法：</strong><br>SELECT 查询列表<br>FROM 表1 【连接类型】<br>JOIN 表2<br>ON 连接条件<br>WHERE 筛选条件<br>GROUP BY 分组<br>HAVING 筛选条件<br>ORDER BY 排序条件<br><strong>连接类型：</strong><br>内连接：inner<br>左外连接：left<br>右外连接：right<br>全外连接：full<br>交叉连接：cross<br><strong>外连接</strong><br>用于查询一个表中有，另一个表中没有的数据<br>左外连接，left左边是主表<br>右外连接，right右边是主表<br><em>Mysql不支持全外连接</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有男朋友的女生</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">g.`name`,b.`boyName`</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.`id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName` IS NULL;</span></span><br></pre></td></tr></table></figure><h5 id="6-交叉连接"><a href="#6-交叉连接" class="headerlink" title="6.交叉连接"></a>6.交叉连接</h5><p><strong>笛卡尔乘积</strong></p><h4 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h4><p><strong>出现在其它语句中的select语句，称为子查询或内查询</strong><br><strong>外部的查询语句，称为主查询或外查询</strong><br><strong>分类：</strong></p><p>①按照子查询出现的位置：</p><table><thead><tr><th>select后面</th><th>from后面</th><th>where或having后面</th><th>exists后面</th></tr></thead><tbody><tr><td>仅仅支持标量子查询</td><td>支持表子查询</td><td>标量子查询，列子查询</td><td>表子查询</td></tr></tbody></table><p>②按照结果集的行列数不同：</p><table><thead><tr><th>标量子查询</th><th>列子查询</th><th>行子查询</th><th>表子查询</th></tr></thead><tbody><tr><td>结果只有一行一列</td><td>结果一列多行</td><td>一行多列</td><td>多行多列</td></tr></tbody></table><h5 id="1）where或having后面"><a href="#1）where或having后面" class="headerlink" title="1）where或having后面"></a>1）where或having后面</h5><p><strong>特点：</strong><br>子查询一般放在小括号内<br>子查询一般放在条件的右边<br>标量子查询，一般搭配着单行操作符<br>列子查询：一般搭配多行操作符使用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.标量子查询</span></span><br><span class="line"><span class="comment">#谁的工资比Abel高</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">last_name = &#x27;Abel&#x27;) ;</span></span><br><span class="line"><span class="comment">#返回job_id于141号员工相同，salary比143号员工多的员工 姓名，job_id和工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">job_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 141) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 143)</span></span><br><span class="line"><span class="comment">#返回公司工资工资最少的员工的姓名，job_id,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees);</span></span><br><span class="line"><span class="comment">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary) &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">department_id = 50) ;</span></span><br><span class="line"><span class="attr">2.列子查询</span></span><br><span class="line"><span class="attr">多行操作符：</span></span><br><span class="line"><span class="attr">IN</span> <span class="string">/ NOT in：等于列表中的任意一个</span></span><br><span class="line"><span class="attr">ANY</span> <span class="string">/ SOME ：和子查询返回的某一个值比较</span></span><br><span class="line"><span class="attr">ALL</span> <span class="string">：和子查询返回的所有值比较</span></span><br><span class="line"><span class="comment">#返回location_id是1400或者1700的部门中的所有员工姓名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id IN</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string">DISTINCT</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">departments</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">location_id IN (1400, 1700)) ;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门任意工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门所有工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="attr">*********************************</span></span><br><span class="line"><span class="attr">3.行子查询</span></span><br><span class="line"><span class="comment">#查询员工编号最小并且工资最高的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="meta">*</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(employee_id)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="meta">employees)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees)</span></span><br></pre></td></tr></table></figure><h5 id="2）SELECT-后面"><a href="#2）SELECT-后面" class="headerlink" title="2）SELECT 后面"></a>2）SELECT 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询每个部门的员工个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.*,</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">e.department_id = d.department_id) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d ;</span></span><br><span class="line"><span class="comment">#查询员工号等于102的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 102) ;</span></span><br></pre></td></tr></table></figure><h5 id="3）FROM-后面"><a href="#3）FROM-后面" class="headerlink" title="3）FROM 后面"></a>3）FROM 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询每个部门平均工资的工资等级</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string">,aa.department_id</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">AVG(salary)</span> <span class="string">ag,</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">GROUP</span> <span class="string">BY department_id) aa </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN job_grades j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">aa.ag BETWEEN lowest_sal </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">highest_sal ;</span></span><br></pre></td></tr></table></figure><h5 id="4）exists后面（相关子查询）"><a href="#4）exists后面（相关子查询）" class="headerlink" title="4）exists后面（相关子查询）"></a>4）exists后面（相关子查询）</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询有员工的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_name FROM departments d</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">EXISTS(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees  e WHERE d.department_id=e.department_id</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="comment">#查询没有女朋友的男生信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">bo.* FROM boys bo WHERE</span></span><br><span class="line"><span class="meta">bo.`id`</span> <span class="string">NOT IN(SELECT boyfriend_id FROM beauty);</span></span><br></pre></td></tr></table></figure><h5 id="5）子查询经典案例祥讲"><a href="#5）子查询经典案例祥讲" class="headerlink" title="5）子查询经典案例祥讲"></a>5）子查询经典案例祥讲</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.查询工资最低的员工信息：last_name,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,salary FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">salary=(SELECT MIN(salary) FROM employees);</span></span><br><span class="line"><span class="attr">2.查询平均工资最低的部门信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM departments WHERE department_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">3.查询平均工资最低的部门信息和该部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">d.*,a1.ag FROM departments  d JOIN </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">AVG(salary) ag,department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1) a1</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">d.department_id=a1.department_id</span></span><br><span class="line"><span class="attr">4.查询平均工资最高的job信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">j.* FROM jobs j WHERE j.job_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">job_id FROM employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id ORDER BY AVG(salary) DESC LIMIT 1)</span></span><br><span class="line"><span class="attr">5.查询平均工资高于公司平均工资的部门有哪些</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id ,AVG(salary) AS avg1 FROM employees GROUP BY  department_id) e1</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e1.avg1&gt;(SELECT AVG(salary)  AS avg2 FROM employees) </span></span><br><span class="line"><span class="attr">6.查询出公司中所有manager的详细信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id IN(SELECT DISTINCT manager_id FROM employees);</span></span><br><span class="line"><span class="attr">7.各个部门中，最高工资中最低的那个部门的最低工资是多少</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees GROUP BY department_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY MAX(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">8.查询平均工资最高的部门的manager的详细信息：last_name,department_id,email,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,department_id,email,salary FROM employees WHERE employee_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id FROM departments WHERE department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">LIMIT 1))</span></span><br></pre></td></tr></table></figure><h4 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8.分页查询"></a>8.分页查询</h4><p>**语法：limit(currentPage-1)<em>size,size</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询前五条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 0,5;</span></span><br><span class="line"><span class="comment">#查询第11-25条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 10,15;</span></span><br><span class="line"><span class="comment">#查询有奖金的员工，并且工资最高的前十名显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary DESC </span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">0 ,10;</span></span><br></pre></td></tr></table></figure><h4 id="9-联合查询"><a href="#9-联合查询" class="headerlink" title="9.联合查询"></a>9.联合查询</h4><p><strong>要查询的结果来自于多个表，且多个表没有直接的连接关系，单查询的信息一致时</strong><br><strong>特点：</strong><br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以不去除重复项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工部门编号大于90或邮箱包含a的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE department_id&gt;90</span></span><br><span class="line"><span class="attr">UNION</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE email LIKE &#x27;%a%&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="三，DML数据操作语言"><a href="#三，DML数据操作语言" class="headerlink" title="三，DML数据操作语言"></a>三，DML数据操作语言</h3><p><strong>插入insert</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一：插入语句</span></span><br><span class="line"><span class="comment">#插入beauty一行数据</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;波多野吉依&#x27;,&#x27;女&#x27;,&#x27;1998-11-11&#x27;,&#x27;13342969497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,10)</span></span><br><span class="line"><span class="comment">#可以为null的列如何不插入值</span></span><br><span class="line"><span class="attr">直接写null，或列名少写一列</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;小泽玛利亚&#x27;,&#x27;女&#x27;,&#x27;1999-11-11&#x27;,&#x27;13342456497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,11)</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty VALUES(15,&#x27;马蓉&#x27;,&#x27;女&#x27;,&#x27;1989-11-11&#x27;,&#x27;13342456123&#x27;,</span></span><br><span class="line"><span class="attr">NULL,12);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty SET id=16,NAME=&#x27;刘亦菲&#x27;, sex=&#x27;女&#x27;,borndate=&#x27;1989-10-01&#x27;,</span></span><br><span class="line"><span class="attr">phone</span>=<span class="string">&#x27;15945231056&#x27;,boyfriend_id=16;</span></span><br><span class="line"><span class="comment">#insert 嵌套子查询，将一个表的数据插入另一张表</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty (NAME,sex,borndate,phone,boyfriend_id)</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">&#x27;妲己&#x27;,&#x27;女&#x27;,&#x27;1111-11-11&#x27;,&#x27;13146587954&#x27;,0;</span></span><br></pre></td></tr></table></figure><p><strong>修改update</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">二，修改</span></span><br><span class="line"> <span class="attr">UPDATE</span> <span class="string">beauty SET phone=&#x27;110&#x27; WHERE id=16;</span></span><br><span class="line"><span class="attr">多表修改：sql99</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">表1 别名</span></span><br><span class="line"><span class="meta">INNER|LEFT|RIGHT</span> <span class="string">JOIN 表2 别名</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">连接条件</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">列=值</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">筛选条件</span></span><br><span class="line"><span class="comment">#修改张无忌的女朋友手机号为114</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.phone=&#x27;114&#x27;</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.boyName=&#x27;张无忌&#x27;;</span></span><br><span class="line"><span class="comment">#修改没有男朋友的女生的男朋友编号都为4号</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN  boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.`boyfriend_id`=4</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=NULL;</span></span><br></pre></td></tr></table></figure><p><strong>删除delete</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">三，删除</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">和 TRUNCATE 的区别：</span></span><br><span class="line"><span class="attr">1.delete可以加where条件，truncate不行</span></span><br><span class="line"><span class="attr">2.truncate删除效率高</span></span><br><span class="line"><span class="attr">3.加入要删除的表中有自增列，</span></span><br><span class="line"><span class="attr">用delete删除整个表后在插入数据，从断点处开始插入</span></span><br><span class="line"><span class="attr">用truncate删除后在插入数据，从1开始。</span></span><br><span class="line"><span class="attr">4.truncate删除没有返回值，delete有返回值</span></span><br><span class="line"><span class="attr">5.truncate删除不能回滚，delete删除可以回滚</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM beauty WHERE id=17;</span></span><br><span class="line"><span class="meta">语法：truncate</span> <span class="string">TABLE 表名;</span></span><br><span class="line"><span class="comment">#删除张无忌的女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=1;</span></span><br><span class="line"><span class="comment">#删除黄晓明以及他女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">b,g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">b.`id`=g.`boyfriend_id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName`=&#x27;黄晓明&#x27;;</span></span><br><span class="line"><span class="meta">多表删除</span> :<span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">TRUNCATE</span> <span class="string">TABLE boys</span></span><br></pre></td></tr></table></figure><h3 id="四，DDL数据定义语言"><a href="#四，DDL数据定义语言" class="headerlink" title="四，DDL数据定义语言"></a>四，DDL数据定义语言</h3><h4 id="1-库和表的管理"><a href="#1-库和表的管理" class="headerlink" title="1.库和表的管理"></a>1.库和表的管理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一，库的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">DATABASE IF NOT EXISTS mydb1 ;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.更改字符集</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">DATABASE mydb1 CHARACTER SET utf8;</span></span><br><span class="line"><span class="meta">删除</span> <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">DATABASE IF EXISTS school;</span></span><br><span class="line"><span class="attr">二，表的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE book(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">b_name</span> <span class="string">VARCHAR(30),</span></span><br><span class="line"><span class="attr">price</span> <span class="string">DOUBLE,</span></span><br><span class="line"><span class="attr">author_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">publishDate</span> <span class="string">DATE</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">book ;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE author(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">au_name</span> <span class="string">VARCHAR(20),</span></span><br><span class="line"><span class="attr">nation</span> <span class="string">VARCHAR(10)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">author;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.修改列名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book CHANGE COLUMN publishDate pub_date DATETIME;</span></span><br><span class="line"><span class="attr">2.修改列的类型或约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book MODIFY COLUMN pub_date DATE;</span></span><br><span class="line"><span class="attr">3.添加新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author ADD COLUMN annual DOUBLE;</span></span><br><span class="line"><span class="attr">4.删除新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author DROP COLUMN annual;</span></span><br><span class="line"><span class="attr">5.修改表名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author RENAME TO book_author;</span></span><br><span class="line"><span class="meta">删除</span>  <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE IF EXISTS my_employee;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">TABLES;</span></span><br><span class="line"><span class="attr">复制</span></span><br><span class="line"><span class="attr">1.仅仅复制表的结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy LIKE book_author;</span></span><br><span class="line"><span class="attr">2.复制表的结构加数据</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy2</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM book_author;</span></span><br><span class="line"><span class="attr">3.复制部分结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy3 </span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">id,au_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">book_author</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">id=0;</span></span><br></pre></td></tr></table></figure><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p><strong>数值型</strong><br><strong>1.整型</strong></p><table><thead><tr><th>TINYINT</th><th>SMALLINT</th><th>MEDIUMINT</th><th>INT/INTEGER</th><th>BIGINT</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>8</td></tr></tbody></table><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如何设置无符号和有符号(默认有符号)</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_int;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_int(t1 INT,t2 INT UNSIGNED);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_int(t1,t2) VALUES(-1,1);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_int;</span></span><br></pre></td></tr></table></figure><p>1）如果插入的数值超出了整形的范围，会报out of range异常，并且插入<br>临界值。<br>2）如果不设置长度，会有默认的长度。<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配<br>zerofill使用。<br><strong>2.小数</strong><br>①定点数<br>dec（M,D）<br>②浮点数<br>float（4） ，double（8）<br>M，D的意思：M指定一共多少位，D指定小数几位，超出会四舍五入。<br>MD都可以省略，<br>如果是dec，则M默认为10，D默认为0<br>如果是浮点数，则会根据插入数值的精度改变精度<br>定点型精度相对较高。<br><strong>3.字符型</strong><br>①较短的文本<br>CHAR(M)默认为1,VARCHAR(M)<br>M:字符数<br>char：固定长度字符，比较耗费空间，但是效率高。<br>varchar：可变长度字符</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ENUM</span> <span class="string">枚举类</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_char(</span></span><br><span class="line">   <span class="attr">t1</span> <span class="string">ENUM(&#x27;a&#x27;,&#x27;c&#x27;,&#x27;b&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">集合</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_set(</span></span><br><span class="line"><span class="attr">s1</span> <span class="string">SET(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_set(s1) VALUES(&#x27;a,b&#x27;);</span></span><br></pre></td></tr></table></figure><p>BINARY:保存较短的二进制。<br>②较长的文本<br>text（文本）,BLOB(较大的二进制)<br><strong>4.日期型</strong><br>DATE:日期<br>DATETIME:日期加时间，8字节<br>timestamp：跟时区有关系，建议使用，4字节<br>time：时间<br>year：年</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_date(</span></span><br><span class="line"><span class="attr">t1</span> <span class="string">DATETIME,</span></span><br><span class="line"><span class="attr">t2</span> <span class="string">TIMESTAMP</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_date(t1,t2)</span></span><br><span class="line"><span class="attr">VALUES(NOW(),NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM tab_date;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">time_zone=&#x27;+9:00&#x27;;</span></span><br><span class="line"><span class="comment">#设置时区为东9区</span></span><br></pre></td></tr></table></figure><h4 id="3-常见约束"><a href="#3-常见约束" class="headerlink" title="3.常见约束"></a>3.常见约束</h4><p><strong>含义：一种限制，用于限制表中的数据，保证数据的一致性。</strong></p><ol><li> NOT NULL </li><li> DEFAULT </li><li> PRIMARY KEY  唯一，且不为空 </li><li> UNIQUE  唯一，可以为空 </li><li> CHECK Mysql不支持 </li><li> FOREIGN KEY 外键约束，用于限制两个表的关系，<br>用于保证该字段的值必须来自于主表的关联列的值。<br>约束的分类：<br>列级约束：除外键约束<br>表级约束：除了非空，默认。<br>CREATE TABLE 表名(<br>字段1 字段类型 列级约束,<br>字段2 字段类型 列级约束,<br>表级约束<br>); </li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建表时添加列级约束</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_test;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_major(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">major_name</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_test;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">INDEX FROM tab_test;</span></span><br><span class="line"><span class="comment">#查看索引信息</span></span><br><span class="line"><span class="comment">#添加表级约束</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id FOREIGN KEY(major_id) REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id 可以省略</span></span><br></pre></td></tr></table></figure><p>面试题：主键约束和唯一约束的区别：<br>都可以保证唯一性，<br>主键不能为空 ，unique 能为空，但是只能有一个null。<br>主键只能有1个，unique可以有多个。<br>都允许两个列组合成一个约束。<br>面试题：外键：<br>要求在从表设置外键关系<br>从表的外键列类型和主表的关联列类型一致，名称无要求<br>要求主表的关联列必须是主键或者唯一键<br>插入数据应该先插入主表再插入从表<br>删除数据应该先删除从表，在删除主表<br>二，修改表时添加约束</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test2(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) ,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR ,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT , </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT  </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN stu_name  VARCHAR(20) NOT NULL ;</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;</span></span><br><span class="line"><span class="comment">#添加外键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 ADD FOREIGN KEY(major_id) REFERENCES tab_major(id);</span></span><br></pre></td></tr></table></figure><h4 id="4-标识列"><a href="#4-标识列" class="headerlink" title="4.标识列"></a>4.标识列</h4><p>自增长列 AUTO_INCREMENT<br>特点：<br>1.表示必须和一个key搭配<br>2.一个表最多一个标识列<br>3.标识列类型只能是数值型<br>4.标识列可以通过set auto_increment_increment=3;设置步长</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">tab_auto(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">NAME</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br></pre></td></tr></table></figure><h3 id="五，TCL语言：事务控制语言"><a href="#五，TCL语言：事务控制语言" class="headerlink" title="五，TCL语言：事务控制语言"></a>五，TCL语言：事务控制语言</h3><p>事务：一个或一组sql语句组成的执行单元，</p><p>要么全部执行,要么都不执行。<br>存储引擎:在MySQL中的数据用各种不同的技术存储在文件中。<br>通过show ENGINES;来查看mysql支持的存储引擎。<br>innodb引擎支持事务。<br>事务的ACID属性：<br>1.原子性:事务是一个不可分割的工作单位，要么都发生，要么都不发生。<br>2.一致性：事务必须使数据库从一个一致性状态变为另一个一致性状态。<br>3.隔离性：一个事务的执行不能被另一个事务干扰。<br>4.持久性：事务一旦被提交，对数据库事务的改变就是永久性的。</p><p>DELETE 和 TRUNCATE 在事务中的区别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">演示delete</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="meta">演示</span> <span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">TRUNCATE</span>  <span class="string">TABLE tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">是直接删除表中数据，truncate是江表删除，创建一张与原来一样的空表。</span></span><br></pre></td></tr></table></figure><h3 id="六，视图"><a href="#六，视图" class="headerlink" title="六，视图"></a>六，视图</h3><p><strong>含义：虚拟表，和普通表格一样使用</strong><br><strong>通过表动态生成的数据</strong></p><h4 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1.创建视图"></a>1.创建视图</h4><p><strong>语法：</strong><br><strong>CREATE VIEW 视图名</strong><br><strong>AS</strong><br><strong>查询语句 ;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询姓名中包含a字符的员工名，部门名和工种信息</span><br><span class="line">create view view1 as</span><br><span class="line">    select e.last_name,d.department_name ,j.job_title from employees e</span><br><span class="line">inner join departments d on e.department_id = d.department_id</span><br><span class="line">    inner join jobs j on e.job_id = j.job_id</span><br><span class="line">where e.last_name like &#x27;%a%&#x27;;</span><br><span class="line">select * from view1;</span><br><span class="line"># 案例：查询各个部门的平均工资级别</span><br><span class="line">create view view2 as</span><br><span class="line">select j.grade_level ,aa.department_id</span><br><span class="line">    from job_grades j</span><br><span class="line">inner join (select avg(salary) avg_s,department_id from employees  group by department_id) aa</span><br><span class="line">    on aa.avg_s between j.lowest_sal and j.highest_sal;</span><br><span class="line">select * from view2;</span><br><span class="line"># 案例：查询平均工资最低的部门信息</span><br><span class="line">create view view3 as</span><br><span class="line">select avg(salary) avg_s ,department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">order by avg_s asc</span><br><span class="line">limit 1;</span><br><span class="line">select * from view3;</span><br></pre></td></tr></table></figure><h4 id="2-视图修改"><a href="#2-视图修改" class="headerlink" title="2.视图修改"></a>2.视图修改</h4><p><strong>①create OR REPLACE VIEW 视图名 AS 查询语句;</strong><br><strong>②alter VIEW 视图名 AS 查询语句;</strong></p><h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h4><p><strong>DROP VIEW v1,v2;</strong></p><h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4.查看视图"></a><strong>4.查看视图</strong></h4><p><strong>DESC v1;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资，邮箱</span><br><span class="line">CREATE VIEW emp_v1 AS</span><br><span class="line">SELECT last_name ,salary,email FROM employees WHERE</span><br><span class="line">phone_number LIKE &#x27;%011&#x27;;</span><br><span class="line">#创建视图emp_v2,要求查询部门的最高工资高于12000的部门信息</span><br><span class="line">CREATE VIEW v4 AS</span><br><span class="line">SELECT department_id FROM employees GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt; 12000;</span><br><span class="line">CREATE VIEW emp_v2 AS</span><br><span class="line">SELECT * FROM departments WHERE department_id IN(SELECT * FROM v4);</span><br></pre></td></tr></table></figure><h4 id="5-视图的更新"><a href="#5-视图的更新" class="headerlink" title="5.视图的更新"></a>5.视图的更新</h4><p><strong>视图的可更新性和视图中查询的定义有关，以下类型的视图是不能更新的。</strong><br><strong>1.包含以下关键字的sql语句：分组函数，distinct，group by，having，union</strong><br><strong>2.常量视图</strong><br><strong>3.select中包含子查询的</strong><br><strong>4.join</strong><br><strong>5.from 一个不能更新的视图</strong><br><strong>6.where子句的子查询引用了from子句的表</strong></p><h4 id="6-视图和表的对比："><a href="#6-视图和表的对比：" class="headerlink" title="6.视图和表的对比："></a>6.视图和表的对比：</h4><table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td><strong>视图</strong></td><td>CREATE VIEW</td><td>只是保存了sql逻辑</td><td>增删改查，一般不能增删改</td></tr><tr><td><strong>表</strong></td><td>CREATE TABLE</td><td>占用</td><td>增删改查</td></tr></tbody></table><h3 id="七，变量"><a href="#七，变量" class="headerlink" title="七，变量"></a>七，变量</h3><p><strong>系统变量</strong>   ：变量由系统提供，不是用户自定义，属于服务器层面。<br>查看系统所有变量：show GLOBAL VARIABLES;<br>查看满足条件的部分系统变量： SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>查看指定的某个系统变量的值： SELECT  @@global.autocommit;<br>为某个系统变量赋值：set @@global.系统变量名=值;<br><strong>全局变量:GLOBAL</strong><br>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话有效，但不能<br>跨重启。<br><strong>会话变量:SESSION</strong><br>作用域：针对当前的会话有效。<br>用户自定义变量<br><strong>用户变量</strong><br>声明： SET/SELECT  @用户变量名 :=值;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @用户变量名 :=值;<br>使用：select @用户变量名;<br>应用在任何地方。<br>作用域：针对当前会话和连接有效。<br><strong>局部变量</strong><br>作用域：作用在定义它的begin END 块中。<br>声明： DECLARE 变量名 类型  （default 值）;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @变量名 :=值;<br>使用：select @变量名;<br>只能放在begin END 中的第一句话</p><h3 id="八，存储过程和函数"><a href="#八，存储过程和函数" class="headerlink" title="八，存储过程和函数"></a>八，存储过程和函数</h3><h4 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h4><p><strong>一组预先定义好的sql语句集合，理解成批处理语句。</strong><br>1.提高代码的重用性<br>2.简化操作<br>3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率。</p><h5 id="1-创建语法："><a href="#1-创建语法：" class="headerlink" title="1.创建语法："></a>1.创建语法：</h5><p>CREATE PROCEDURE 存储过程名（参数列表）<br>BEGIN<br>一组合法的sql语句;<br>END<br>参数列表：参数模式 参数名 参数类型</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>OUT  ：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出</p><p>如果存储过程只有一句话，begin END 可以省略</p><p>存储过程体中的每条sql语句的结尾需要必须加分号，<br>存储过程的结尾可以使用 DELIMITER 重新设置。</p><h5 id="2-调用"><a href="#2-调用" class="headerlink" title="2.调用"></a>2.调用</h5><p>CALL 存储过程名（实参列表）;</p><h5 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插入到admin表中五条记录</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_a()</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;yin&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;aa&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;bb&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;cc&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;dd&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="comment">#创建存储过程实现 根据女生名查询对应的男生信息</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_b(IN beauty_name VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line">      <span class="attr">SELECT</span> <span class="string">bo.*</span></span><br><span class="line">      <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">      <span class="attr">RIGHT</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">      <span class="attr">WHERE</span> <span class="string">b.name=beauty_name;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_b(&#x27;热巴&#x27;);</span></span><br><span class="line"><span class="comment">#根据女生名返回他的男朋友名</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_d(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SELECT</span> <span class="string">bo.boyName INTO boyName</span></span><br><span class="line">        <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">        <span class="attr">INNER</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">        <span class="attr">WHERE</span> <span class="string">b.name=beautyName;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_d(&#x27;小昭&#x27;,@b_name);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@b_name;</span></span><br><span class="line"><span class="comment">#传入两个值a，b，最终翻倍返回a和b</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_e(INOUT a INT ,INOUT b INT )</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">a=a*2;</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">b=b*2;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@m=10;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@n=20;</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_e(@m,@n);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@m,@n;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除存储过程"><a href="#4-删除存储过程" class="headerlink" title="4.删除存储过程"></a>4.删除存储过程</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE 存储过程名</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE my_a;</span></span><br></pre></td></tr></table></figure><h5 id="5-查看存储过程的信息"><a href="#5-查看存储过程的信息" class="headerlink" title="5.查看存储过程的信息"></a>5.查看存储过程的信息</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE PROCEDURE  my_b;</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>存储过程可以有0/n个返回值：适合批量增删改</strong><br><strong>函数有且仅有一个返回值：适合查询</strong></p><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION 函数名(参数列表) RETURNS 返回类型</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span></span><br></pre></td></tr></table></figure><p>注意：<br>参数列表：参数名，参数类型<br>一定会有return语句</p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p><strong>SELECT 函数名(参数列表)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回公司员工个数</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f1() RETURNS INT</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c INT DEFAULT 0 ;</span></span><br><span class="line">    <span class="attr">SELECT</span> <span class="string">COUNT(*) INTO c FROM employees;</span></span><br><span class="line">    <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f1();</span></span><br><span class="line"><span class="comment">#根据员工名返回他的工资</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f2(NAME VARCHAR(20)) RETURNS DOUBLE</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c DOUBLE;</span></span><br><span class="line">     <span class="attr">SELECT</span> <span class="string">salary INTO c FROM employees WHERE last_name=NAME;</span></span><br><span class="line">     <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@a=&#x27;Hunold&#x27;;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f2(@a);</span></span><br></pre></td></tr></table></figure><h5 id="3-查看"><a href="#3-查看" class="headerlink" title="3.查看"></a>3.查看</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h3 id="九，流程控制"><a href="#九，流程控制" class="headerlink" title="九，流程控制"></a>九，流程控制</h3><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h5 id="1-if-（表达式1，表达式2，表达式3）"><a href="#1-if-（表达式1，表达式2，表达式3）" class="headerlink" title="1.if （表达式1，表达式2，表达式3）"></a>1.if （表达式1，表达式2，表达式3）</h5><p>如果表达式1成立，就返回表达式2的值，否则返回表达式3的值。<br>应用在任何地方</p><h5 id="2-case"><a href="#2-case" class="headerlink" title="2.case"></a>2.case</h5><h6 id="1-switch-CASE"><a href="#1-switch-CASE" class="headerlink" title="1)switch-CASE"></a>1)switch-CASE</h6><p><strong>语法:</strong><br><strong>CASE 要判断的字段或者表达式</strong><br><strong>WHEN 常量1 THEN 要显示的值1或者语句1</strong><br><strong>WHEN 常量2 THEN 要显示的值2或者语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或者语句n；</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br></pre></td></tr></table></figure><h6 id="2-CASE-使用2："><a href="#2-CASE-使用2：" class="headerlink" title="2)CASE 使用2："></a>2)CASE 使用2：</h6><p><strong>语法：</strong><br><strong>CASE</strong><br><strong>WHEN 条件1 THEN 要显示的值1或语句1</strong><br><strong>WHEN 条件2 THEN 要显示的值2或语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或语句n</strong><br><strong>END</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees </span></span><br><span class="line"> <span class="attr">可以放在任何地方</span></span><br><span class="line"><span class="comment"> #创建存储过程，根据传入的成绩，显示等级，90A,80B，70C，60D ，F</span></span><br><span class="line"> <span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">PROCEDURE my_1(IN score INT)</span></span><br><span class="line"> <span class="attr">BEGIN</span></span><br><span class="line"> <span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"> <span class="attr">WHEN</span>  <span class="string">score BETWEEN 90 AND 100</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;A&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 80 AND 90</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;B&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 80</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;C&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 60</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;D&#x27;;</span></span><br><span class="line"> <span class="attr">ELSE</span> <span class="string">SELECT &#x27;E&#x27;;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">CASE;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_1(95);</span></span><br></pre></td></tr></table></figure><h5 id="3-if"><a href="#3-if" class="headerlink" title="3.if"></a>3.if</h5><p><strong>语法：</strong><br><strong>IF 条件1 THEN 语句1;</strong><br><strong>ELSEIF 条件2 THEN 语句2;</strong><br><strong>…</strong><br><strong>ELSE 语句n;</strong><br><strong>END IF;</strong><br>只能用在begin end中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建存储过程，根据传入的成绩，返回等级，90A,80B，70C，60D ，F</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">FUNCTION my_2( score INT) RETURNS CHAR</span></span><br><span class="line"> <span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line">   <span class="attr">IF</span> <span class="string">score &gt;=90 THEN RETURN&#x27;A&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=80 THEN RETURN&#x27;B&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=70 THEN RETURN&#x27;C&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=60 THEN RETURN&#x27;D&#x27;;</span></span><br><span class="line">   <span class="attr">ELSE</span> <span class="string">RETURN&#x27;E&#x27;;</span></span><br><span class="line">   <span class="attr">END</span> <span class="string">IF;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">SELECT</span>  <span class="string">my_2(85);</span></span><br></pre></td></tr></table></figure><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>在存储过程或函数里面使用</strong></p><h5 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h5><p><strong>语法：</strong><br><strong>标签:WHILE 循环条件 DO</strong><br><strong>循环体;</strong><br><strong>END WHILE 标签;</strong><br><strong>循环控制和标签搭配使用</strong></p><h5 id="2-loop"><a href="#2-loop" class="headerlink" title="2.loop"></a>2.loop</h5><p><strong>语法：</strong><br><strong>标签： LOOP</strong><br><strong>循环体;</strong><br><strong>END LOOP 标签;</strong></p><h5 id="3-repeat"><a href="#3-repeat" class="headerlink" title="3.repeat"></a>3.repeat</h5><p><strong>语法：</strong><br><strong>标签： REPEAT</strong><br><strong>循环体;</strong><br><strong>UNTIL 结束循环的条件</strong><br><strong>END REPEAT 标签;</strong></p><p>循环控制<br>ITERATE 类似continue<br>LEAVE   类似break</p><hr><p>left join==left outer join</p><p>a left join b 就是取a和b的交集加a剩下的部分</p><p>inner join</p><p>a inner join b就是取交集</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12610368/1641814968278-9ad396b9-3c05-4a17-816c-26b50cd647c2.jpeg" alt="夜拍.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[二]概述</title>
      <link href="/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一，一条SQL的查询流程"><a href="#一，一条SQL的查询流程" class="headerlink" title="一，一条SQL的查询流程"></a>一，一条SQL的查询流程</h1><ol><li><p>去连接池获取连接</p></li><li><p>查询缓存，命中返回，否则继续向下</p></li><li><p>词法解析&amp;预处理</p><blockquote><p>词法解析拆分SQL，语法分析检查SQL的正确性生成一颗解析树，预处理检查表名，列名，生成一颗解析树。</p></blockquote></li><li><p>优化器优化，优化计划，查询计划</p></li><li><p>执行引擎生成执行计划</p></li><li><p>存储引擎查询SQL，加入缓存，返回结果。</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641449666256-21382ea1-bf47-4ce3-b1ea-5cb8e82965f1.png" alt="image.png"></p><h2 id="1-获取连接"><a href="#1-获取连接" class="headerlink" title="1.获取连接"></a>1.获取连接</h2><p>MySQL支持多种通信协议，可以使用同步/异步的方式，支持长连接，短连接。<br>​</p><h3 id="1-1-通信类型"><a href="#1-1-通信类型" class="headerlink" title="1.1 通信类型"></a>1.1 通信类型</h3><p>​</p><p>一般来说，<strong>连接数据库都是同步连接</strong>。<br>​</p><blockquote><ol><li>同步连接：依赖于被调用方，受限制于被调用方的性能；一般只能一对一。</li><li>异步连接：避免阻塞，但不能节省SQL的执行时间，并发情况下，每个SQL的执行都要单独建立连接，占用大量CPU资源；异步连接必须使用连接池减少线程创建销毁的开销。</li></ol></blockquote><h3 id="1-2-连接方式"><a href="#1-2-连接方式" class="headerlink" title="1.2 连接方式"></a>1.2 连接方式</h3><p>MySQL长短连接都支持，一般我们会在连接池中使用长连接。保持长连接会消耗内存，长时间不活动的连接，MySQL服务器会断开。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">-- 非交互式超时时间，如 JDBC 程序</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;interactive_timeout&#x27;</span>; <span class="comment">-- 交互式超时时间，如数据库工具</span></span><br></pre></td></tr></table></figure><blockquote><p>默认长连接断开时间是8小时。</p></blockquote><p>可以使用 <code>show status;</code>查看当前MySQL有多少个连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Threads_cached</th><th>缓存中的线程连接数</th></tr></thead><tbody><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>为处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>每产生一个连接或者会话，服务端就会创建一个线程来处理。杀死会话本质就是kill 线程。<br>​</p><blockquote><p>可以使用<code>SHOW PROCESSLIST; </code>（root 用户）查看 SQL 的执行状态。<br>​</p></blockquote><blockquote><p>+—-+——+———–+——+———+——+———-+<br>| Id | User | Host      | db   | Command | Time | State    | Info             |<br>+—-+——+———–+——+———+——+———-+<br>| 11 | root | localhost | NULL | Query   |    0 | starting | show processlist |<br>+—-+——+———–+——+———+——+———-+</p></blockquote><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Sleep</td><td>线程正在等待客户端，以向它发送一个新语句</td></tr><tr><td>Query</td><td>线程正在执行查询或往客户端发送数据</td></tr><tr><td>Locked</td><td>该查询被其它查询锁定</td></tr><tr><td>Copying to tmp table on disk</td><td>临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器</td></tr><tr><td>Sending data</td><td>线程正在为 SELECT 语句处理行，同时正在向客户端发送数据</td></tr><tr><td>Sorting for group</td><td>线程正在进行分类，以满足 GROUP BY 要求</td></tr><tr><td>Sorting for order</td><td>线程正在进行分类，以满足 ORDER BY 要求</td></tr></tbody></table><p>在5.7版本，MySQL的默认连接数是151个，我们最大可以修改为16384个 （214）。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> [<span class="keyword">global</span> <span class="operator">|</span> session] max_connections <span class="operator">=</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-3-通信协议"><a href="#1-3-通信协议" class="headerlink" title="1.3 通信协议"></a>1.3 通信协议</h3><p>​</p><ol><li>编程语言的连接模块都是用 TCP 协议连接到 MySQL 服务器的，比如mysql-connector-java-x.x.xx.jar。</li><li>类unix系统上，支持 Socket套接字文件进行进程间通信。<code>/tmp/mysql.sock</code></li><li>windows系统上还支持命名管道和共享内存。</li></ol><p>​</p><h3 id="1-4-通信方式"><a href="#1-4-通信方式" class="headerlink" title="1.4 通信方式"></a>1.4 通信方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641431698698-e3b38143-26dc-439d-8a75-feff85dbc973.png" alt="image.png"><br>MySQL使用了半双工通信，所以客户端发送SQL语句给服务端的时候，不管SQL有多大，都是一次发过去的。<br>​</p><blockquote><p>比如我们用MyBatis动态SQL生成了一个批量插入的语句，插入10万条数据，values后面跟了一长串的内容，或者 where 条件 in 里面的值太多，会出现问题。这个时候我们必须要调整 MySQL 服务器配置 max_allowed_packet 参数的值（默认是 4M），把它调大，否则就会报错。</p></blockquote><p>对于服务端来说，也是一次性发送所有的数据，不能因为你已经取到了想要的数据就中断操作，这个时候会对网络和内存产生大量消耗。在程序里面避免不带 limit 的这种操作，比如一次把所有满足条件的数据全部查出来，一定要先 count 一下。如果数据量的话，可以分批查询。</p><hr><h2 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h2><p>MySQL 的缓存默认是关闭的。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL不推荐使用自带的缓存，命中条件过于苛刻。且表里数据发生变化，整张表的缓存全部失效，MySQL8移除掉了缓存。</p><hr><h2 id="3-语法解析-amp-预处理"><a href="#3-语法解析-amp-预处理" class="headerlink" title="3.语法解析&amp;预处理"></a>3.语法解析&amp;预处理</h2><h3 id="3-1-词法解析"><a href="#3-1-词法解析" class="headerlink" title="3.1 词法解析"></a>3.1 词法解析</h3><p>词法分析就是把一个完整的 SQL 语句打碎成一个个的单词。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>它会打碎成 8 个符号，每个符号是什么类型，从哪里开始到哪里结束。<br>​</p><h3 id="3-2-语法解析"><a href="#3-2-语法解析" class="headerlink" title="3.2 语法解析"></a>3.2 语法解析</h3><p>语法分析会对 SQL 做一些语法检查，比如单引号有没有闭合，然后根据 MySQL 定义的语法规则，根据 SQL 语句生成一个数据结构。这个数据结构我们把它叫做解析树（select_lex）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641432113376-2499bc3f-6277-49aa-8a99-eb135ce35507.png" alt="image.png"></p><blockquote><p>任何数据库的中间件，比如 Mycat，Sharding-JDBC（用到了 Druid Parser），都必须要有词法和语法分析功能。</p></blockquote><h3 id="3-3-预处理"><a href="#3-3-预处理" class="headerlink" title="3.3 预处理"></a>3.3 预处理</h3><p>​</p><p>如果写了一个词法和语法都正确的 SQL，但是表名或者字段不存在，会在哪里报错？是在数据库的执行层还是解析器？<br>​</p><p>实际上还是在解析的时候报错，解析 SQL 的环节里面有个预处理器。它会检查生成的解析树，解决解析器无法解析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理之后得到一个新的解析树。<br>​</p><hr><h2 id="4-查询优化-amp-查询执行计划"><a href="#4-查询优化-amp-查询执行计划" class="headerlink" title="4.查询优化&amp;查询执行计划"></a>4.查询优化&amp;查询执行计划</h2><p>一条SQL语句的执行方式有很多种，但是最终返回的结果都是相同的。查询优化器的目的就是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，那种执行计划开销最小，就用哪种。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看查询的开销</span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-优化器的作用"><a href="#4-1-优化器的作用" class="headerlink" title="4.1 优化器的作用"></a>4.1 优化器的作用</h3><ol><li>多表联查，以哪张表为基准表</li><li>用不用索引，用哪个索引</li><li>。。。。</li></ol><p>​</p><h3 id="4-2-优化器是怎么得到执行计划的"><a href="#4-2-优化器是怎么得到执行计划的" class="headerlink" title="4.2 优化器是怎么得到执行计划的"></a>4.2 优化器是怎么得到执行计划的</h3><ol><li>首先我们要启用优化器的追踪（默认是关闭的）。</li></ol><blockquote><p>开启这开关是会消耗性能的，因为它要把优化分析的结果写到表里面，所以不要轻易开启，或者查看完之后关闭它（改成 off）。</p></blockquote><ol start="2"><li>接着执行一个 SQL 语句，优化器会生成执行计划：</li></ol><ol start="3"><li>这个时候优化器分析的过程已经记录到系统表里面了，我们可以查询：</li></ol><blockquote><p>它是一个 JSON 类型的数据，主要分成三部分，准备阶段、优化阶段和执行阶段。</p></blockquote><blockquote><p>expanded_query 是优化后的 SQL 语句。</p></blockquote><blockquote><p>considered_execution_plans 里面列出了所有的执行计划。</p></blockquote><ol start="4"><li>分析完记得关掉它</li></ol><blockquote><p>通过追踪优化器，可以看到优化器对sql的初始优化，表的读取顺序，为什么采用了这种读取顺序。为什么采用了某个索引或者采用了全表查询。</p></blockquote><h3 id="4-3-优化器得到的结果"><a href="#4-3-优化器得到的结果" class="headerlink" title="4.3 优化器得到的结果"></a>4.3 优化器得到的结果</h3><p>​</p><p>优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。</p><p>当然，这个执行计划是不是一定是最优的执行计划呢？不一定，因为 MySQL 也有可能覆盖不到所有的执行计划。<br>​</p><p>MySQL 提供了一个执行计划的工具。我们在 SQL 语句前面加上 EXPLAIN，就可以看到执行计划的信息。<br>​</p><p><strong>Explain 的结果也不一定最终执行的方式。</strong><br><strong>​</strong></p><h3 id="4-4-选错索引"><a href="#4-4-选错索引" class="headerlink" title="4.4 选错索引"></a>4.4 选错索引</h3><p>这里错误决定分两类，第一，彻底错误。第二，基于成本最低，但执行速度不是最快。</p><ol><li><p>由于InnoDB的 MVCC 功能和随机采样方式，默认随机采取几个数据页，当做总体数据。以部分代表整体，本来就有错误的风险。加上数据不断地添加过程中，索引树可能会分裂，结果更加不准确。 </p><blockquote><ol><li>执行 ANALYZE TABLE ,可以重新构建索引，使索引树不过于分裂。</li><li>调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。</li></ol></blockquote></li><li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。 </p><blockquote><ol><li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li><li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。 </li></ol></blockquote></li></ol><hr><h2 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5. 存储引擎"></a>5. 存储引擎</h2><p>得到执行计划以后，SQL 语句是不是终于可以执行了？</p><ol><li>从逻辑的角度来说，我们的数据是放在哪里的，或者说放在一个什么结构里面？</li></ol><ol start="2"><li>执行计划在哪里执行？是谁去执行？</li></ol><p>表在存储数据的同时，还要组织数据的存储结构，这个存储结构就是由存储引擎决定的，所以也可以把存储引擎叫做表类型。</p><p>在 MySQL 里面，支持多种存储引擎，他们是可以替换的，所以叫做插件式的存储引擎。<br>​</p><h3 id="5-1-查看存储引擎"><a href="#5-1-查看存储引擎" class="headerlink" title="5.1 查看存储引擎"></a>5.1 查看存储引擎</h3><p>我们数据库里面已经存在的表，我们怎么查看它们的存储引擎呢？<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> `数据库名`;</span><br></pre></td></tr></table></figure><p>或者通过 DDL 建表语句来查看。<br>​</p><p>在 MySQL 里面，我们创建的每一张表都可以指定它的存储引擎，而不是一个数据库只能使用一个存储引擎。存储引擎的使用是以表为单位的。而且，创建表之后还可以修改存储引擎。<br>​</p><p>一张表使用的存储引擎决定存储数据的结构，那在服务器上它们是怎么存储的呢？先要找到数据库存放数据的路径：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434256832-de450340-7be5-41be-845e-61c79f6b4f82.png" alt="image.png"><br>默认情况下，每个数据库有一个自己文件夹，以 yhd数据库为例。任何一个存储引擎都有一个 frm 文件，这个是表结构定义文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434747584-0e54ae84-325f-48ba-9586-59d5b480aa92.png" alt="image.png"><br>不同的存储引擎存放数据的方式不一样，产生的文件也不一样，innodb 是 1 个，memory 没有，myisam 是两个。</p><h3 id="5-2-存储引擎比较"><a href="#5-2-存储引擎比较" class="headerlink" title="5.2 存储引擎比较"></a>5.2 存储引擎比较</h3><h4 id="①常见存储引擎"><a href="#①常见存储引擎" class="headerlink" title="①常见存储引擎"></a>①常见存储引擎</h4><p>MyISAM 和 InnoDB 是我们用得最多的两个存储引擎，在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，它是 MySQL 自带的。</p><p>5.5 版本之后默认的存储引擎改成了 InnoDB，最主要的原因还是 InnoDB 支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。</p><h4 id="②数据库支持的存储引擎"><a href="#②数据库支持的存储引擎" class="headerlink" title="②数据库支持的存储引擎"></a>②数据库支持的存储引擎</h4><p>可以用这个命令查看数据库对存储引擎的支持情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines ;</span><br></pre></td></tr></table></figure><p>其中有存储引擎的描述和对事务、XA 协议和 Savepoints 的支持。</p><p>XA 协议用来实现分布式事务（分为本地资源管理器，事务管理器）。</p><p>Savepoints 用来实现子事务（嵌套事务）。创建了一个 Savepoints 之后，事务就可以回滚到这个点，不会影响到创建 Savepoints 之前的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641435383199-5ae5e040-4df5-4a35-94ba-e8e13b19fe54.png" alt="image.png"></p><h4 id="③MyISAM（3-个文件）"><a href="#③MyISAM（3-个文件）" class="headerlink" title="③MyISAM（3  个文件）"></a>③MyISAM（3  个文件）</h4><p>应用范围比较小。表级锁定限制了读/写的性能，因此在 Web 和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p><strong>特点</strong></p><ol><li>支持表级别的锁（插入和更新会锁表）。不支持事务。</li></ol><ol start="2"><li>拥有较高的插入（insert）和查询（select）速度。</li></ol><ol start="3"><li>存储了表的行数（count 速度更快）。</li></ol><p>适合：只读之类的数据分析的项目。</p><h4 id="④InnoDB（2个文件）"><a href="#④InnoDB（2个文件）" class="headerlink" title="④InnoDB（2个文件）"></a>④InnoDB（2个文件）</h4><p>mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全（与 ACID 兼容）的 MySQL存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB 行级锁（不升级为更粗粒度的锁）和 Oracle 风格的一致非锁读提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中，以减少基于主键的常见查询的 I/O。为了保持数据完整性，InnoDB 还支持外键引用完整性约束。</p><p><strong>特点</strong></p><ol><li>支持事务，支持外键，因此数据的完整性、一致性更高。</li></ol><ol start="2"><li>支持行级别的锁和表级别的锁。</li></ol><ol start="3"><li>支持读写并发，写不阻塞读（MVCC）。</li></ol><ol start="4"><li>特殊的索引存放方式，可以减少 IO，提升查询效率。</li></ol><p>适合：经常更新的表，存在并发读写或者有事务处理的业务系统。</p><h4 id="⑤Memory-1个文件"><a href="#⑤Memory-1个文件" class="headerlink" title="⑤Memory(1个文件)"></a>⑤Memory(1个文件)</h4><p>基于内存的存储引擎。</p><p>特征：</p><ul><li>基于内存的表，服务器重启后，表结构会被保留，但表中的数据会被清空。</li><li>不需要进行磁盘IO，比 MYISAM 快了一个数量级。</li><li>表级锁，故并发插入性能较低。</li><li>每一行是固定的，VARCHAR 列在 memory 存储引擎中会变成 CHAR，可能导致内存浪费。</li><li>不支持 BLOB 或 TEXT 列，如果sql返回的结果列中包含 BLOB 或 TEXT，就直接采用 MYISAM 存储引擎，在磁盘上建临时表</li><li>支持哈希索引，B+树索引</li></ul><p>MEMORY 存储引擎在很多地方可以发挥很好的作用：</p><ul><li>用于查找或映射表，例如邮编和州名的映射表</li><li>用于缓存周期性聚合数据的结果</li><li>用于保存数据分析中产生的中间结果。即SQL执行过程中用到的临时表</li><li>监控MySQL内存中的执行情况，例如：information_schema 库下的表基本都是 memory 存储引擎，监控InnoDB缓冲池中page(INNODB_BUFFER_PAGE表)，InnoDB缓冲池状态(INNODB_BUFFER_POOL_STATS表)、InnoDB缓存页淘汰记录(INNODB_BUFFER_PAGE_LRU表)、InnoDB锁等待(INNODB_LOCK_WAITS表)、InnoDB锁信息(INNODB_LOCKS表)、InnoDB中正在执行的事务(INNODB_TRX表)等。</li></ul><p><strong>MEMORY 存储引擎默认 hash 索引，故等值查询特别快。同时也支持B+树索引。虽然查询速度特别快，但依旧无法取代传统的磁盘建表。</strong></p><h4 id="⑥CSV-3个文件"><a href="#⑥CSV-3个文件" class="headerlink" title="⑥CSV(3个文件)"></a>⑥CSV(3个文件)</h4><p>它的表实际上是带有逗号分隔值的文本文件。csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据。因为 csv 表没有索引，所以通常在正常操作期间将数据保存在 innodb 表中，并且只在导入或导出阶段使用 csv 表。</p><p><strong>特点</strong></p><p>不允许空行，不支持索引。格式通用，可以直接编辑，适合在不同数据库之间导入导出。<br>​</p><h3 id="5-3-如何选择存储引擎"><a href="#5-3-如何选择存储引擎" class="headerlink" title="5.3 如何选择存储引擎"></a>5.3 如何选择存储引擎</h3><ol><li>如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。</li></ol><ol start="2"><li>如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。</li></ol><ol start="3"><li>如果需要一个用于查询的临时表，可以选择 Memory。</li></ol><p>​</p><hr><h2 id="6-执行引擎"><a href="#6-执行引擎" class="headerlink" title="6.执行引擎"></a>6.执行引擎</h2><p>执行引擎，它利用存储引擎提供的相应的 API 来完成操作。</p><p>为什么我们修改了表的存储引擎，操作方式不需要做任何改变？因为不同功能的存储引擎实现的 API 是相同的。</p><p>最后把数据返回给客户端，即使没有结果也要返回。<br>​</p><hr><h1 id="二，一条SQL的更新流程"><a href="#二，一条SQL的更新流程" class="headerlink" title="二，一条SQL的更新流程"></a>二，一条SQL的更新流程</h1><p>更新和查询很多地方并没有区别，仅仅在于拿到数据之后的操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641458151710-45fe3a24-a127-401d-abec-75f52f953f3d.png" alt="image.png"></p><h2 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1.内存结构"></a>1.内存结构</h2><p>InnnoDB 的数据都是放在磁盘上的，InnoDB 操作数据有一个最小的逻辑单位，叫做页（索引页和数据页）。我们对于数据的操作，不是每次都直接操作磁盘，因为磁盘的速度太慢了。InnoDB 使用了一种缓冲池的技术，也就是把磁盘读到的页放到一块内存区域里面。这个内存区域就叫 Buffer Pool。<br>​</p><p>下一次读取相同的页，先判断是不是在缓冲池里面，如果是，就直接读取，不用再次访问磁盘。</p><p>修改数据的时候，先修改缓冲池里面的页。内存的数据页和磁盘数据不一致的时候，我们把它叫做脏页。InnoDB 里面有专门的后台线程把 Buffer Pool 的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p><p>Buffer Pool 是 InnoDB 里面非常重要的一个结构，主要分为 3 个部分： Buffer Pool、Change Buffer、Adaptive HashIndex，另外还有一个（redo）log buffer。<br>​</p><h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>Buffer Pool 缓存的是页信息，包括数据页、索引页，默认大小是 128M（134217728 字节），可以调整。</p><p>查看服务器状态，里面有很多跟 Buffer Pool 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>查看参数（系统变量）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES like &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>内存的缓冲池写满了怎么办？（Redis 设置的内存满了怎么办？）InnoDB 用 LRU算法来管理缓冲池（链表实现，不是传统的 LRU，分成了 young 和 old），经过淘汰的数据就是热点数据。</p><p>内存缓冲区对于提升读写性能有很大的作用。当需要更新一个数据页时，如果数据页在 Buffer Pool 中存在，那么就直接更新好了。否则的话就需要从磁盘加载到内存，再对内存的数据页进行操作。也就是说，如果没有命中缓冲池，至少要产生一次磁盘 IO。<br>​</p><h3 id="1-2-ChangeBuffer写缓冲"><a href="#1-2-ChangeBuffer写缓冲" class="headerlink" title="1.2 ChangeBuffer写缓冲"></a>1.2 ChangeBuffer写缓冲</h3><p>如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓冲池中，从而提升更新语句（Insert、Delete、Update）的执行速度。</p><p>这一块区域就是 Change Buffer。5.5 之前叫 Insert Buffer 插入缓冲，现在也能支持 delete 和 update。</p><p>最后把 Change Buffer 记录到数据页的操作叫做 merge。什么时候发生 merge？有几种情况：在访问这个数据页的时候，或者通过后台线程、或者数据库 shut down、redo log 写满时触发。</p><p>如果数据库大部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以使用 Change Buffer（写缓冲）。写多读少的业务，调大这个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_change_buffer_max_size&#x27;;</span><br></pre></td></tr></table></figure><p>代表 Change Buffer 占 Buffer Pool 的比例，默认 25%。<br>​</p><h3 id="1-3-Adaptive-Hash-Index"><a href="#1-3-Adaptive-Hash-Index" class="headerlink" title="1.3 Adaptive Hash Index"></a>1.3 Adaptive Hash Index</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？</p><p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p><p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。<br>​</p><h3 id="1-4-（redo）Log-Buffer"><a href="#1-4-（redo）Log-Buffer" class="headerlink" title="1.4 （redo）Log Buffer"></a>1.4 （redo）Log Buffer</h3><p>​</p><p>如果 Buffer Pool 里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据丢失。如果写操作写到一半，甚至可能会破坏数据文件导致数据库不可用。为了避免这个问题，InnoDB 把所有对页面的修改操作专门写入一个日志文件，并且在数据库启动时从这个文件进行恢复操作（实现 crash-safe）——用它来实现事务的持久性。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478367975-c4e017fe-92ed-440a-8fb3-3efc4c310546.png" alt="image.png"><br>这个文件就是磁盘的 redo log（叫做重做日志），对应于/var/lib/mysql/目录下的ib_logfile0 和 ib_logfile1，每个 48M。这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里 的 WAL 技 术（Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log%&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认 48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为 2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir 路径。</td></tr></tbody></table><p><strong>同样是写磁盘，为什么不直接写到 db file 里面去？为什么先写日志再写磁盘？</strong></p><p>磁盘的最小组成单元是扇区，通常是 512 个字节。操作系统和内存打交道，最小的单位是页 Page。操作系统和磁盘打交道，读写磁盘，最小的单位是块 Block。<br>​</p><p>如果我们所需要的数据是随机分散在不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们所需要的一块数据，依次进行此过程直到找完所有数据，这个就是随机 IO，读取数据速度较慢。</p><p>假设我们已经找到了第一块数据，并且其他所需的数据就在这一块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序 IO。</p><p>刷盘是随机 I/O，而记录日志是顺序 I/O，顺序 I/O 效率更高。因此先把修改写入日志，可以延迟刷盘时机，进而提升系统吞吐。</p><p>当然 redo log 也不是每一次都直接写入磁盘，在 Buffer Pool 里面有一块内存区域（Log Buffer）专门用来保存即将要写入日志文件的数据，默认 16M，它一样可以节省磁盘 IO。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478572344-fc83dc25-3a96-42fd-8017-03423f4d9f49.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>redo log 的内容主要是用于崩溃恢复。磁盘的数据文件，数据来自 buffer pool。redo log 写入磁盘，不是写入数据文件。</p></blockquote><p>那么，Log Buffer 什么时候写入 log file？</p><p>在我们写入数据到磁盘的时候，操作系统本身是有缓存的。flush 就是把操作系统缓冲区写入到磁盘。</p><p>log buffer 写入磁盘的时机，由一个参数控制，默认是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_flush_log_at_trx_commit&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>log buffer 将每秒一次地写入 log file 中，并且 log file 的 flush 操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。</td></tr><tr><td>1（默认，实时写，实时刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，并且刷到磁盘中去。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file。但是 flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次 flush 操作。</td></tr></tbody></table><p>redo log，它又分成内存和磁盘两部分。redo log 有什么特点？</p><ol><li>redo log 是 InnoDB 存储引擎实现的，并不是所有存储引擎都有。</li></ol><ol start="2"><li>不是记录数据页更新之后的状态，而是记录这个页做了什么改动，属于物理日志。（redo log 记录的是执行的结果）</li></ol><ol start="3"><li>redo log 的大小是固定的，前面的内容会被覆盖。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478994184-25e740bb-80a0-48fe-9327-bc4bb7da7192.png" alt="image.png"><br>check point 是当前要覆盖的位置。如果 write pos 跟 check point 重叠，说明 redolog 已经写满，这时候需要同步 redo log 到磁盘中。</p><p>这是 MySQL 的内存结构，总结一下，分为：Buffer pool、change buffer、Adaptive Hash Index、 log buffer。</p><blockquote><p>磁盘结构里面主要是各种各样的表空间，叫做 Table space。</p></blockquote><h3 id="1-5-缓存的疑问"><a href="#1-5-缓存的疑问" class="headerlink" title="1.5 缓存的疑问"></a>1.5 缓存的疑问</h3><p><strong>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</strong></p><p>然后，InnoDB架构中，有非常重要的一个部分——<strong>缓冲池</strong>。该缓冲池需要占用服务器内存，且<strong>专用于MySQL的服务器，建议把80%的内存交给MySQL。</strong></p><p>缓冲池有一个缓存的功能。这个缓存，是InnoDB自带的，而且经常会用到。该缓存功能并不是MySQL架构中的缓存组件。这是两者最大的区别。</p><ul><li>MySQL组件中的缓存 <ol><li>所处位置：MySQL架构中的缓存组件</li><li>缓存内容：缓存的是SQL 和 该SQL的查询结果。如果SQL的大小写，格式，注释不一致，则被认为是不同的SQL，重新查询数据库，并缓存一份数据。</li><li>可否关闭：是可以手动关闭，并卸载该组件的。</li></ol></li><li>InnoDB中的缓存 <ol><li>所处位置：InnoDB架构中的缓冲池</li><li>缓存内容：缓存的是所有需要查找的数据，所在的数据页。</li><li>可否关闭：是InnoDB缓冲池自带的功能，<strong>无法关闭，无法卸载</strong>。如果InnoDB的缓冲池被关闭或卸载，则InnoDB直接瘫痪。所以说缓冲池是InnoDB的最重要的一部分。</li></ol></li></ul><p>不建议使用MySQL的缓存是指，不建议使用MySQL架构中的缓存组件，并不是同时否定了InnoDB中的缓存功能。<br>​</p><hr><h2 id="2-磁盘结构"><a href="#2-磁盘结构" class="headerlink" title="2.磁盘结构"></a>2.磁盘结构</h2><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB 的表空间分为 5 大类。<br>​</p><h3 id="2-1-系统表空间"><a href="#2-1-系统表空间" class="headerlink" title="2.1 系统表空间"></a>2.1 系统表空间</h3><p>在默认情况下 InnoDB 存储引擎有一个共享表空间（对应文件/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>InnoDB 系统表空间包含 InnoDB 数据字典和双写缓冲区，（Change Buffer 和 UndoLogs），如果没有指定 file-per-table，也包含用户创建的表和索引数据。</p><ol><li>undo 在后面介绍，因为有独立的表空间。</li></ol><ol start="2"><li>数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）。</li></ol><ol start="3"><li>双写缓冲（InnoDB 的一大特性）</li></ol><p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641479261038-52879c45-835e-4fae-abcd-1ca4ac1f9c66.png" alt="image.png"></p><p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_doublewrite&#x27;;</span><br></pre></td></tr></table></figure><p>如果这个页本身已经损坏了，用它来做崩溃恢复是没有意义的。所以在对于应用 redo log 之前，需要一个页的副本。如果出现了写入失效，就用页的副本来还原这个页，然后再应用 redo log。这个页的副本就是 double write，InnoDB 的双写技术。通过它实现了数据页的可靠性。</p><p>跟 redo log 一样，double write 由两部分组成，一部分是内存的 double write，一个部分是磁盘上的 double write。因为 double write 是顺序写入的，不会带来很大的开销。</p><p>在MySQL5.7之前，所有的表共享一个系统表空间，这个文件会越来越大，而且它的空间不会收缩。<br>​</p><h3 id="2-2-独占表空间"><a href="#2-2-独占表空间" class="headerlink" title="2.2 独占表空间"></a>2.2 独占表空间</h3><p>我们可以让每张表独占一个表空间。这个开关通过 innodb_file_per_table 设置，默认开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure><p>开启后，则每张表会开辟一个表空间，这个文件就是数据目录下的 ibd 文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间内。<br>​</p><h3 id="2-3-通用表空间"><a href="#2-3-通用表空间" class="headerlink" title="2.3 通用表空间"></a>2.3 通用表空间</h3><p>通用表空间也是一种共享的表空间，跟 ibdata1 类似。</p><p>可以创建一个通用的表空间，用来存储不同数据库的表，数据路径和文件可以自定义。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace ts2673 add datafile &#x27;/var/lib/mysql/ts2673.ibd&#x27; file_block_size=16K engine=innodb;</span><br></pre></td></tr></table></figure><p>在创建表的时候可以指定表空间，用 ALTER 修改表空间可以转移表空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2673(id integer) tablespace ts2673;</span><br></pre></td></tr></table></figure><p>不同表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table t2673;</span><br><span class="line">drop tablespace ts2673;</span><br></pre></td></tr></table></figure><h3 id="2-4-临时表空间"><a href="#2-4-临时表空间" class="headerlink" title="2.4 临时表空间"></a>2.4 临时表空间</h3><p>存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的 ibtmp1 文件。当数据服务器正常关闭时，该表空间被删除，下次重新产生。</p><p><strong>memory向template的过渡，还有磁盘上简历临时表用的什么存储引擎？</strong></p><p>8.0之前，内存临时表用Memory引擎创建，但假如字段中有BLOB或TEXT,或结果太大，就会转用MYISM在磁盘上建表，8.0之后内存临时表由MEMORY引擎更改为TempTable引擎，相比于前者，后者支持以变长方式存储VARCHAR，VARBINARY等变长字段。从MySQL 8.0.13开始，TempTable引擎支持BLOB字段。如果超过内存表大小，则用InnoDB建表。</p><h3 id="2-5-redo-log"><a href="#2-5-redo-log" class="headerlink" title="2.5 redo log"></a>2.5 redo log</h3><h3 id="2-6-undo-log-表空间"><a href="#2-6-undo-log-表空间" class="headerlink" title="2.6 undo log 表空间"></a>2.6 undo log 表空间</h3><p>undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态（不包括 select）。</p><p>如果修改数据时出现异常，可以用 undo log 来实现回滚操作（保持原子性）。</p><p>在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，属于逻辑格式的日志(记录操作)。</p><p>redo Log 和 undo Log 与事务密切相关，统称为事务日志。</p><p>undo Log 的数据默认在系统表空间 ibdata1 文件中，因为共享表空间不会自动收缩，也可以单独创建一个 undo 表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%undo%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-7-一条SQL的更新流程"><a href="#2-7-一条SQL的更新流程" class="headerlink" title="2.7 一条SQL的更新流程"></a>2.7 一条SQL的更新流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>事务开始，从内存或者磁盘取到这条数据，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>记录name = 二十 到redo log</li><li>调用存储引擎接口，在buffer pool 中修改 name =二十</li><li>事务提交</li></ol><p>​</p><blockquote><p>内存和磁盘之间，工作着很多后台线程。</p></blockquote><hr><h2 id="3-后台线程"><a href="#3-后台线程" class="headerlink" title="3.后台线程"></a>3.后台线程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641480352645-ff2557dd-b622-49e2-829c-d058bbe6d559.png" alt="image.png"><br>后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master线程，IO 线程，purge 线程，page cleaner 线程。<br>​</p><h3 id="3-1-Master-线程"><a href="#3-1-Master-线程" class="headerlink" title="3.1 Master 线程"></a>3.1 Master 线程</h3><p>Master Thread是InnoDB存储引擎非常核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。<br>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    thread_sleep(<span class="number">1</span>);<span class="comment">// sleep 1秒</span></span><br><span class="line">        <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">        <span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">        <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">          <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct(默认是75时)</span></span><br><span class="line">            <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;<span class="comment">// 刷新100脏页到磁盘</span></span><br><span class="line">        <span class="keyword">if</span>(no user activity)</span><br><span class="line">            <span class="keyword">goto</span> backgroud loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>) <span class="comment">// 如果过去10内磁盘IO次数小于设置的innodb_io_capacity的值（默认是200）</span></span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer; <span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">    <span class="keyword">do</span> full purge;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; <span class="number">70</span>%)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer pool flush <span class="number">10</span> dirty page;</span><br><span class="line"></span><br><span class="line">    backgroud loop：<span class="comment">// 后台循环</span></span><br><span class="line">    <span class="keyword">do</span> full purge<span class="comment">// 删除无用的undo页 （总是）</span></span><br><span class="line">    <span class="keyword">do</span> merge <span class="number">20</span> insert buffer;<span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idle<span class="comment">// 如果不空闲，就跳回主循环，如果空闲就跳入flush loop</span></span><br><span class="line">        <span class="keyword">goto</span> loop:<span class="comment">// 跳到主循环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop</span><br><span class="line"></span><br><span class="line">    flush loop:<span class="comment">// 刷新循环</span></span><br><span class="line">    <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">    <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct的值（默认75%）</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop;<span class="comment">// 跳到刷新循环，不断刷新脏页，直到符合条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> suspend loop;<span class="comment">// 完成刷新脏页的任务后，跳入suspend loop</span></span><br><span class="line"></span><br><span class="line">    suspend loop:</span><br><span class="line">    suspend_thread();<span class="comment">//master线程挂起，等待事件发生</span></span><br><span class="line">    waiting event;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master Thread具有<strong>最高的线程优先级别</strong>。内部由多个循环组成：<strong>主循环（loop）</strong>、<strong>后台循环</strong>（backgroup loop）、<strong>刷新循环</strong>（flush loop）、<strong>暂停循环</strong>（suspend loop）。Master Thread会<strong>根据数据库运行的状态</strong>在loop、backgroup loop、flush loop和suspend loop中<strong>进行切换</strong>。loop是主循环，大多数的操作都在这个循环中，主要有两大部分的操作——每秒钟的操作和每10秒钟的操作。<br>​</p><h4 id="①每秒钟的操作"><a href="#①每秒钟的操作" class="headerlink" title="①每秒钟的操作"></a>①每秒钟的操作</h4><p>​</p><ol><li>​<strong>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）</strong>；<br>即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这也解释了为什么再大的事务提交的时间也是很短的。 </li><li> <strong>合并插入缓冲（可能）</strong>；<br>合并插入缓冲并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB存储引擎认为当前的IO压力很小，可以执行合并插入缓冲的操作； </li><li> <strong>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</strong>； 刷新100个脏页也不是每秒都会发生的，InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_get_modified_ratio_pct)是否超过了配置文件中 innodb_max_dirty_pages_pct这个参数（默认是75，代表75%），如果超过了这个值，InnoDB存储引擎则认为需要做磁盘同步的操作，将100个脏页写入磁盘中。 </li><li> <strong>如果当前没有用户活动，则切换到background loop(可能)。</strong></li></ol><p><strong>​</strong></p><h4 id="②每十秒的操作"><a href="#②每十秒的操作" class="headerlink" title="②每十秒的操作"></a>②每十秒的操作</h4><ol><li> <strong>刷新100个脏页到磁盘（可能）</strong> InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO能力，因此将100个脏页刷新到磁盘。 </li><li> <strong>合并至多5个插入缓冲（总是）</strong> </li><li> <strong>将日志缓冲刷新到磁盘（总是）</strong> </li><li> <strong>删除无用的Undo页（总是）</strong> </li><li> <strong>刷新100个或者10个脏页到磁盘（总是）</strong> InnoDB存储引擎会执行full purge操作，即删除无用的Undo页。对表进行update，delete这类的操作时，原先的行被标记为删除，但是因为一致性读的关系，需要保留这些行版本的信息。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB存储引擎会立即将其删除。从源代码中可以看出，InnoDB存储引擎在执行full purge 操作时，每次最多尝试回收20个undo页。<br>然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf_get_modified_ratio_pct）,如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%,则只需刷新10%的脏页到磁盘。</li></ol><p>​</p><hr><p>如果当前没有用户活动（数据库空闲）或者数据库关系，就会切换到backgroud loop这个循环。 backgroud loop会执行以下操作：</p><ol><li><strong>删除无用的Undo页（总是）</strong></li><li><strong>合并20个插入缓冲（总是）</strong></li><li><strong>跳回到主循环（总是）</strong></li><li><strong>不断刷新100个页直到符合条件（可能，需要跳转到flush loop中完成）</strong></li></ol><p>如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。<br>​</p><p>1.0.x版本中，InnoDB存储引擎最多只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，那么可能会来不及刷新所有的脏页以及合并插入缓冲。后来，InnoDB存储引擎提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。<br>​</p><p>对于刷新到磁盘的页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p><ol><li>在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%;</li><li>在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity;</li></ol><p>如果用户使用的是SSD类的磁盘，可以将innodb_io_capacity的值调高，直到符合磁盘IO的吞吐量为止；</p><p>另一个问题是参数innodb_max_dirty_pages_pct的默认值，在1.0.x版本之前，该值的默认值是90，意味着脏页占缓冲池的90%。InnoDB存储引擎在每秒刷新缓冲池和flush loop时会判断这个值，如果该值大于innodb_max_dirty_pages_pct,才会刷新100个脏页，如果有很大的内存，或者数据库服务器的压力很大，这时刷新脏页的速度反而会降低。 后来将innodb_max_dirty_pages_pct的默认值改为了75。这样既可以加快刷新脏页的频率，又能够保证磁盘IO的负载。<br>​</p><p>还有一个新的参数是innodb_adaptive_flushing(自适应地刷新)，该值影响每秒刷新脏页的数量。原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页；大于innodb_max_dirty_pages_pct时，刷新100个脏页。随着innodb_adaptive_flushing参数的引入，InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新脏页最合适的数量。buf_flush_get_desired_flush_rate函数通过判断产生重做日志的速率来决定最合适的刷新脏页数量。</p><p>之前每次进行full purge 操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size,该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改。<br>​</p><p>1.2.x版本中再次对Master Thread进行了优化，对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。<br><strong>​</strong></p><h3 id="3-2-IO-线程"><a href="#3-2-IO-线程" class="headerlink" title="3.2 IO 线程"></a>3.2 IO 线程</h3><p>InnoDB中大量使用<strong>AIO (Async IO)</strong> 来处理IO请求。IO Thread的作用，是负责这些 IO 请求的回调（call back）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641481073193-6d2bbd4e-ffaa-49b5-9c2e-c591b8690872." alt="image.png"></p><h3 id="3-3-Purge-线程"><a href="#3-3-Purge-线程" class="headerlink" title="3.3 Purge 线程"></a>3.3 Purge 线程</h3><p>事务被提交后，其所使用的undo log可能不在需要。因此，需要purge thread来回收已经使用并分配的undo页。以前Master Thread来完成释放undo log，InnoDB1.1独立出来，分担主线程压力。<br>​</p><h3 id="3-4-Page-Cleaner-线程"><a href="#3-4-Page-Cleaner-线程" class="headerlink" title="3.4 Page Cleaner 线程"></a>3.4 Page Cleaner 线程</h3><p><strong>​</strong></p><p>负责将脏页刷新到磁盘。以前Master Thread来刷新脏页，InnoDB1.2独立出来，分担主线程压力。<br>​</p><blockquote><p>除了 InnoDB 架构中的日志文件，MySQL 的 Server 层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p></blockquote><hr><h2 id="4-binlog"><a href="#4-binlog" class="headerlink" title="4.binlog"></a>4.binlog</h2><p>binlog 以事件的形式记录了所有的DDL 和DML 语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不一样，它的文件内容是可以追加的，没有固定大小限制。在开启了 binlog 功能的情况下，我们可以把 binlog 导出成 SQL 语句，把所有的操作重放一遍，来实现数据的恢复。binlog 的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的 binlog，然后执行一遍。<br>​</p><p>有了这两个日志之后，来看一下一条更新语句是怎么执行的：<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​</p><ol><li>事务开始，从内存或者磁盘取到这条数据所在的数据页，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>在buffer pool 中修改 name =二十，此时该页变成脏页</li><li>记录name = 二十 到redo log buffer，redo log buffer每秒刷盘。</li><li>redo log 进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</li><li>写入binlog</li><li>事务提交，并回写最终状态到redo log里，代表该事务已经提交</li></ol><p>​</p><blockquote><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便不断写入redo log文件中。一般情况下，每次事务commit时，必须调用 fsync 操作，将redo日志缓冲同步写到磁盘。另外，每次事务提交时同步写到磁盘bin log中。</p></blockquote><blockquote><p>那么就有了一个谁先谁后的问题：redo log 先，bin log 后。</p></blockquote><blockquote><p>两阶段提交的内容：**事务提交时，redo log处于 pre状态 -&gt; 写入bin log -&gt; 事务真正提交。 **</p></blockquote><blockquote><p>当发生崩溃恢复时，查看的是bin log是否完整，如果bin log完整，则代表事务已经提交。</p></blockquote><blockquote><p>如果在两阶段提交过程中，bin log写入失败，则事务无法终止提交，崩溃恢复时就不需要重做。如果bin log写完的一瞬间，服务器宕机了，事务都来不及提交，此时bin log并不是完整的，缺少了最终的commit标记。因此也是提交失败。</p></blockquote><blockquote><p>简单说，redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641482848254-19b6e1b2-0fa7-411d-924b-0c6cb48f511f.png" alt="1.png"></p><hr><h1 id="三，MySQL中支持的字符集和排序规则"><a href="#三，MySQL中支持的字符集和排序规则" class="headerlink" title="三，MySQL中支持的字符集和排序规则"></a>三，MySQL中支持的字符集和排序规则</h1><h2 id="1-MySQL中的utf8和utf8mb4"><a href="#1-MySQL中的utf8和utf8mb4" class="headerlink" title="1.MySQL中的utf8和utf8mb4"></a>1.MySQL中的utf8和utf8mb4</h2><p>utf8字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计MySQL的大叔偷偷的定义了两个概念：</p><ul><li>utf8mb3：阉割过的utf8字符集，只使用1～3个字节表示字符。</li><li>utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符。</li></ul><p>在MySQL中utf8是utf8mb3的别名，所以之后在MySQL中提到utf8就意味着使用1~3个字节来表示一个字符，如果有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4。</p><p>查看字符集：<code>SHOW (CHARACTER SET|CHARSET)</code>。</p><h2 id="2-字符集-amp-比较规则的应用"><a href="#2-字符集-amp-比较规则的应用" class="headerlink" title="2.字符集&amp;比较规则的应用"></a>2.字符集&amp;比较规则的应用</h2><h3 id="2-1-各级别的字符集和比较规则"><a href="#2-1-各级别的字符集和比较规则" class="headerlink" title="2.1 各级别的字符集和比较规则"></a>2.1 各级别的字符集和比较规则</h3><p>MySQL有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><p>接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p><h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;</span>;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用SET语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure><p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p><h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>其中的DEFAULT可以省略，并不影响语句的语义。比方说我们新创建一个名叫charset_demo_db的数据库，在创建的时候指定它使用的字符集为gb2312，比较规则为gb2312_chinese_ci：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE charset_demo_db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| character_set_database | gb2312 |</span><br><span class="line">+------------------------+--------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;</span>;</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| Variable_name      | Value             |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| collation_database | gb2312_chinese_ci |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这个charset_demo_db数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 _<strong>collation_database</strong>_ 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p><h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure><p>比方说我们在刚刚创建的charset_demo_db数据库中创建一个名为t的表，并指定这个表的字符集和比较规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">CREATE TABLE <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    -&gt;     col VARCHAR(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.03</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</p><h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>比如我们修改一下表t中列col的字符集和比较规则可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">ALTER TABLE t MODIFY col <span class="title">VARCHAR</span><span class="params">(<span class="number">10</span>)</span> CHARACTER SET gbk COLLATE gbk_chinese_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 0  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。</p><blockquote><p>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。 </p></blockquote><h3 id="2-2-客户端和服务器通信中的字符集"><a href="#2-2-客户端和服务器通信中的字符集" class="headerlink" title="2.2 客户端和服务器通信中的字符集"></a>2.2 客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果"><a href="#编码和解码使用的字符集不一致的后果" class="headerlink" title="编码和解码使用的字符集不一致的后果"></a>编码和解码使用的字符集不一致的后果</h4><p>如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p><h4 id="从发送请求到接收结果过程中发生的字符集转换"><a href="#从发送请求到接收结果过程中发生的字符集转换" class="headerlink" title="从发送请求到接收结果过程中发生的字符集转换"></a>从发送请求到接收结果过程中发生的字符集转换</h4><ul><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用character_set_client代表的字符集进行解码，将解码后的字符串再按照character_set_connection代表的字符集进行编码。</li><li>如果character_set_connection代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639999607440-c7181f59-0354-43bd-b896-d3bd722cadc4.png" alt="image.png"></p><p>在这个过程中各个系统变量的含义如下：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p><p><strong>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"/>
      <url>/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>#1.成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表数组的最大限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发级别：jdk7历史遗留问题，仅仅在初始化的时候使用到，并不是真正的代表并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算扩容时候生成的一个 标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当node节点hash=-1 表示当前节点已经被迁移了  ，fwd节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//node hash=-2 表示当前节点已经树化 且 当前节点为treebin对象  ，代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">//转化成二进制实际上是 31个 1  可以将一个负数通过位移运算得到一个正数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了兼容7版本的chp保存的，核心代码并没有使用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表，长度一定是2次方数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment"> * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment"> * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="comment">/**表示sizeCtl属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="comment">/**表示transferIndex属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">/**表示baseCount属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">/**表示cellsBusy属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">/**表示cellValue属性在CounterCell中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">/**表示数组第一个元素的偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">                TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">                BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">                CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">                <span class="comment">//表示数组单元所占用空间大小,scale 表示Node[]数组中每一个单元所占用空间大小</span></span><br><span class="line">                <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">                <span class="comment">//1 0000 &amp; 0 1111 = 0</span></span><br><span class="line">                <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">                <span class="comment">//numberOfLeadingZeros() 这个方法是返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一块。</span></span><br><span class="line">                <span class="comment">//8 =&gt; 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line">                <span class="comment">//4 =&gt; 100 numberOfLeadingZeros(4) = 29</span></span><br><span class="line">                <span class="comment">//ASHIFT = 31 - 29 = 2 ？？</span></span><br><span class="line">                <span class="comment">//ABASE + （5 &lt;&lt; ASHIFT）</span></span><br><span class="line">                ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>#2.基础方法<br>##2.1 spread<br>高位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.2 tabAt<br>该方法获取对象中offset偏移地址对应的对象field的值。实际上这段代码的含义等价于tab[i],但是为什么不直接使用 tab[i]来计算呢？</p><p>getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happen-before 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见；</p><p>虽然 table 数组本身是增加了 volatile 属性，但是“volatile 的数组只针对数组的引用具有volatile 的语义，而不是它的元素”。 所以如果有其他线程对这个数组的元素进行写操作，那么当前线程来读的时候不一定能读到最新的值。出于性能考虑，Doug Lea 直接通过 Unsafe 类来对 table 进行操作。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/tabAt.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.3 casTabAt<br>cas设置当前节点为桶位的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.4 setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.5 resizeStamp<br>resizeStamp 用来生成一个和扩容有关的扩容戳，具体有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer.numberOfLeadingZeros 这个方法是返回无符号整数 n 最高位非 0 位前面的 0 的个数。</p><p>比如 10 的二进制是 0000 0000 0000 0000 0000 0000 0000 1010，那么这个方法返回的值就是 28。</p><p>根据 resizeStamp 的运算逻辑，我们来推演一下，假如 n=16，那么 resizeStamp(16)=32796转化为二进制是[0000 0000 0000 0000 1000 0000 0001 1100]</p><p>接着再来看,当第一个线程尝试进行扩容的时候，会执行下面这段代码：</p><p><code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code><br>rs 左移 16 位，相当于原本的二进制低位变成了高位 1000 0000 0001 1100 0000 0000 00000000</p><p>然后再+2 =1000 0000 0001 1100 0000 0000 0000 0000+10=1000 0000 0001 1100 0000 00000000 0010</p><p><strong>高 16 位代表扩容的标记、低 16 位代表并行扩容的线程数</strong></p><p>这样来存储有什么好处呢？</p><p>1，首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责</p><p>2，可以保证每次扩容都生成唯一的生成戳，每次新的扩容，都有一个不同的 n，这个生成戳就是根据 n 来计算出来的一个数字，n 不同，这个数字也不同</p><p>第一个线程尝试扩容的时候，为什么是+2</p><p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在低 16 位上加 1。<br>##2.6 tableSizeFor<br>经过多次位移返回大于等于c的最小的二次方数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">     * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">     * 返回&gt;=c的最小的2的次方数</span></span><br><span class="line"><span class="comment">     * c=28</span></span><br><span class="line"><span class="comment">     * n=27 =&gt; 0b 11011</span></span><br><span class="line"><span class="comment">     * 11011 | 01101 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * 11111 | 00111 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * ....</span></span><br><span class="line"><span class="comment">     * =&gt; 11111 + 1 =100000 = 32</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#3. 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果指定的容量超过允许的最大值，设置为最大值</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果初始容量小于并发级别，那就设置初始容量为并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="comment">//16/0.75 +1 = 22</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 22 - &gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#4.put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key已经存在，是否覆盖，默认是false</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#5 putVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 </span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#6 initTable<br>数组初始化方法，这个方法比较简单，就是初始化一个合适大小的数组。</p><p>sizeCtl ：这个标志是在 Node 数组初始化或者扩容的时候的一个控制位标识，负数代表正在进行初始化或者扩容操作。</p><p>-1 代表正在初始化</p><p>-N 代表有 N-1 个线程正在进行扩容操作，这里不是简单的理解成 n 个线程，sizeCtl 就是-N</p><p>0 标识 Node 数组还没有被初始化，正数代表初始化或者下一次扩容的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">     *      * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">     *      * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">     *      * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#7 addCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//as 表示 LongAdder.cells</span></span><br><span class="line">    <span class="comment">//b 表示LongAdder.base</span></span><br><span class="line">    <span class="comment">//s 表示当前map.table中元素的数量</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//条件一：true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">    <span class="comment">//       false-&gt;表示当前线程应该将数据累加到 base</span></span><br><span class="line">    <span class="comment">//条件二：false-&gt;表示写base成功，数据累加到base中了，当前竞争不激烈，不需要创建cells</span></span><br><span class="line">    <span class="comment">//       true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">//有几种情况进入到if块中？</span></span><br><span class="line">        <span class="comment">//1.true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">        <span class="comment">//2.true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a 表示当前线程hash寻址命中的cell</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//v 表示当前线程写cell时的期望值</span></span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//m 表示当前cells数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//true -&gt; 未竞争  false-&gt;发生竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：as == null || (m = as.length - 1) &lt; 0</span></span><br><span class="line">        <span class="comment">//true-&gt; 表示当前线程是通过 写base竞争失败 然后进入的if块，就需要调用fullAddCount方法去扩容 或者 重试.. LongAdder.longAccumulate</span></span><br><span class="line">        <span class="comment">//条件二：a = as[ThreadLocalRandom.getProbe() &amp; m]) == null   前置条件：cells已经初始化了</span></span><br><span class="line">        <span class="comment">//true-&gt;表示当前线程命中的cell表格是个空，需要当前线程进入fullAddCount方法去初始化 cell，放入当前位置.</span></span><br><span class="line">        <span class="comment">//条件三：!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)</span></span><br><span class="line">        <span class="comment">//      false-&gt;取反得到false，表示当前线程使用cas方式更新当前命中的cell成功</span></span><br><span class="line">        <span class="comment">//      true-&gt;取反得到true,表示当前线程使用cas方式更新当前命中的cell失败，需要进入fullAddCount进行重试 或者 扩容 cells。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">           ) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">//考虑到fullAddCount里面的事情比较累，就让当前线程 不参与到 扩容相关的逻辑了，直接返回到调用点。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前散列表元素个数，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一定是一个put操作调用的addCount</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//tab 表示map.table</span></span><br><span class="line">        <span class="comment">//nt 表示map.nextTable</span></span><br><span class="line">        <span class="comment">//n 表示map.table数组的长度</span></span><br><span class="line">        <span class="comment">//sc 表示sizeCtl的临时值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">             * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">             * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">             * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//条件一：s &gt;= (long)(sc = sizeCtl)</span></span><br><span class="line">        <span class="comment">//       true-&gt; 1.当前sizeCtl为一个负数 表示正在扩容中..</span></span><br><span class="line">        <span class="comment">//              2.当前sizeCtl是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//       false-&gt; 表示当前table尚未达到扩容条件</span></span><br><span class="line">        <span class="comment">//条件二：(tab = table) != null</span></span><br><span class="line">        <span class="comment">//       恒成立 true</span></span><br><span class="line">        <span class="comment">//条件三：(n = tab.length) &lt; MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//       true-&gt;当前table长度小于最大值限制，则可以进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩容批次唯一标识戳</span></span><br><span class="line">            <span class="comment">//16 -&gt; 32 扩容 标识为：1000 0000 0001 1011</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：表示当前table正在扩容</span></span><br><span class="line">            <span class="comment">//         当前线程理论上应该协助table完成扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">                <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">                <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">                <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">                <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">                <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">                <span class="comment">//条件四：(nt = nextTable) == null</span></span><br><span class="line">                <span class="comment">//        true-&gt;表示本次扩容结束</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容正在进行中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//前置条件：当前table正在执行扩容中.. 当前线程有机会参与进扩容。</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程成功参与到扩容任务中，并且将sc低16位值加1，表示多了一个线程参与工作</span></span><br><span class="line">                <span class="comment">//条件失败：1.当前有很多线程都在此处尝试修改sizeCtl，有其它一个线程修改成功了，导致你的sc期望值与内存中的值不一致 修改失败</span></span><br><span class="line">                <span class="comment">//        2.transfer 任务内部的线程也修改了sizeCtl。</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容线程，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="comment">//条件成立，说明当前线程是触发扩容的第一个线程，在transfer方法需要做一些扩容准备工作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//触发扩容条件的线程 不持有nextTable</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#8. transfer<br>ConcurrentHashMap 支持并发扩容，实现方式是，把 Node 数组进行拆分，让每个线程处理自己的区域，假设 table 数组总长度是 64，默认情况下，那么每个线程可以分到 16 个 bucket。然后每个线程处理的范围，按照倒序来做迁移。</p><p>通过 for 自循环处理每个槽位中的链表元素，默认 advace 为真，通过 CAS 设置 transferIndex属性值，并初始化 i 和 bound 值，i 指当前处理的槽位序号，bound 指需要处理的槽位边界，先处理槽位 31 的节点； （bound,i） =(16,31) 从 31 的位置往前推动。</p><p>每存在一个线程执行完扩容操作，就通过 cas 执行 sc-1。</p><p>接着判断(sc-2) !=resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT ; 如果相等，表示当前为整个扩容操作的 最后一个线程，那么意味着整个扩容操作就结束了；如果不相等，说明还得继续。</p><p>这么做的目的，一方面是防止不同扩容之间出现相同的 sizeCtl，另外一方面，还可以避免sizeCtl 的 ABA 问题导致的扩容重叠的情况。</p><p><strong>扩容图解</strong><br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E6%89%A9%E5%AE%B9%E5%9B%BE%E8%A7%A3.png" alt="img.png"><br>判断是否需要扩容，也就是当更新后的键值对总数 baseCount &gt;= 阈值 sizeCtl 时，进行rehash，这里面会有两个逻辑。</p><ol><li>如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容。</li><li>如果当前没有在扩容，则直接触发扩容操作。</li></ol><p>扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。</p><p>而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。</p><p>它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现。</p><p>fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p><p>advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识。</p><p>finishing:这个变量用于提示扩容是否结束用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示扩容之前table数组的长度</span></span><br><span class="line">    <span class="comment">//stride 表示分配给线程任务的步长</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//  stride 固定为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件成立：表示当前线程为触发本次扩容的线程，需要做一些扩容准备工作</span></span><br><span class="line">    <span class="comment">//条件不成立：表示当前线程是协助扩容的线程..</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了一个比扩容之前大一倍的table</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对象属性 nextTable ，方便协助扩容线程 拿到新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录迁移数据整体位置的一个标记。index计数是从1开始计算的。</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 节点，当某个桶位数据处理完毕后，将此桶位设置为fwd节点，其它写线程 或读线程看到后，会有不同逻辑。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标记</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//完成标记</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">//bound 表示分配给当前线程任务的下界限制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//f 桶位的头结点</span></span><br><span class="line">        <span class="comment">//fh 头结点的hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.给当前线程分配任务区间</span></span><br><span class="line"><span class="comment">             * 2.维护当前线程任务进度（i 表示当前处理的桶位）</span></span><br><span class="line"><span class="comment">             * 3.维护map对象全局范围内的进度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//分配任务的开始下标</span></span><br><span class="line">            <span class="comment">//分配任务的结束下标</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1:</span></span><br><span class="line">            <span class="comment">//条件一：--i &gt;= bound</span></span><br><span class="line">            <span class="comment">//成立：表示当前线程的任务尚未完成，还有相应的区间的桶位要处理，--i 就让当前线程处理下一个 桶位.</span></span><br><span class="line">            <span class="comment">//不成立：表示当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CASE2:</span></span><br><span class="line">            <span class="comment">//前置条件：当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="comment">//条件成立：表示对象全局范围内的桶位都分配完毕了，没有区间可分配了，设置当前线程的i变量为-1 跳出循环后，执行退出迁移任务相关的程序</span></span><br><span class="line">            <span class="comment">//条件不成立：表示对象全局范围内的桶位尚未分配完毕，还有区间可分配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CASE3:</span></span><br><span class="line">            <span class="comment">//前置条件：1、当前线程需要分配任务区间  2.全局范围内还有桶位尚未迁移</span></span><br><span class="line">            <span class="comment">//条件成立：说明给当前线程分配任务成功</span></span><br><span class="line">            <span class="comment">//条件失败：说明分配给当前线程失败，应该是和其它线程发生了竞争吧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：i &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：表示当前线程未分配到任务</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//保存sizeCtl 的变量</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明设置sizeCtl 低16位  -1 成功，当前线程可以正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程不是最后一个退出transfer任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//正常退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置条件：【CASE2~CASE4】 当前线程任务尚未处理完，正在进行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位未存放数据，只需要将此处设置为fwd节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位已经迁移过了，当前线程不用再处理了，直接再次更新当前线程任务索引，再次处理下一个桶位 或者 其它操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//CASE4:</span></span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据，而且node节点 不是 fwd节点，说明这些数据需要迁移。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//sync 加锁当前桶位的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//防止在你加锁头对象之前，当前桶位的头对象被其它写线程修改过，导致你目前加锁对象错误...</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">//hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lastRun</span></span><br><span class="line">                        <span class="comment">//可以获取出 当前链表 末尾连续高位不变的 node</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立：说明lastRun引用的链表为 低位链表，那么就让 ln 指向 低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则，说明lastRun引用的链表为 高位链表，就让 hn 指向 高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是 红黑树 代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转换头结点为 treeBin引用 t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//低位双向链表 lo 指向低位链表的头  loTail 指向低位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位双向链表 lo 指向高位链表的头  loTail 指向高位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lc 表示低位链表元素数量</span></span><br><span class="line">                        <span class="comment">//hc 表示高位链表元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代TreeBin中的双向链表，从头结点 至 尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// h 表示循环处理当前元素的 hash</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//使用当前节点 构建出来的 新的 TreeNode</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件成立：表示当前循环节点 属于低位链 节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//条件成立：说明当前低位链表 还没有数据</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="comment">//说明 低位链表已经有数据了，此时当前元素 追加到 低位链表的末尾就行了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">//将低位链表尾指针指向 p 节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点 属于 高位链 节点</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表迁移原理</p><p>1）高低位原理分析</p><p>ConcurrentHashMap 在做链表迁移时，会用高低位来实现，这里有两个问题要分析一下</p><p>1，如何实现高低位链表的区分</p><p>假如有这样一个队列<br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E8%BF%81%E7%A7%BB%E9%AB%98%E4%BD%8E%E4%BD%8D%E5%8E%9F%E7%90%861.png" alt="img_1.png"><br>第 14 个槽位插入新节点之后，链表元素个数已经达到了 8，且数组长度为 16，优先通过扩容来缓解链表过长的问题</p><p>假如当前线程正在处理槽位为 14 的节点，它是一个链表结构，在代码中，首先定义两个变量节点 ln 和 hn，实际就是 lowNode 和 HighNode，分别保存 hash 值的第 x 位为 0 和不等于0 的节点</p><p>通过 fn&amp;n 可以把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值的第 x 位为不等于 0（至于为什么要这么区分，稍后分析），并且通过 lastRun 记录最后要处理的节点。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 14+16(扩容增加的长度)=30</p><p>把 14 槽位的链表单独伶出来，用蓝色表示 fn&amp;n=0 的节点，假如链表的分类是这样</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/ffb2efa924944e02b25e97a2b90bf6f5.png" alt="111"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b;</span><br><span class="line">        lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码遍历，会记录 runBit 以及 lastRun，按照上面这个结构，那么 runBit 应该是蓝色节点，lastRun 应该是第 6 个节点接着，再通过这段代码进行遍历，生成 ln 链以及 hn 链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/3914c7b94d2843b985ea10e5c23a04b0.png" alt="111"><br>接着，通过 CAS 操作，把 hn 链放在 i+n 也就是 14+16 的位置，ln 链保持原来的位置不动。并且设置当前节点为 fwd，表示已经被当前线程迁移完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>迁移完成以后的数据分布如下</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/e7e01e24e3e844c7b31c4d73da2fffed.png" alt="111"><br>2）为什么要做高低位的划分</p><p>要想了解这么设计的目的，我们需要从 ConcurrentHashMap 的根据下标获取对象的算法来看，在 putVal 方法中 1018 行：</p><p><code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code></p><p>通过(n-1) &amp; hash 来获得在 table 中的数组下标来获取节点数据，【&amp;运算是二进制运算符，1&amp; 1=1，其他都为 0】。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/db389ed8b874494ca1f5a8723e8a6973.png" alt="111"><br>#9.helpTransfer<br>如果对应的节点存在，判断这个节点的 hash 是不是等于 MOVED(-1)，说明当前节点是ForwardingNode 节点，意味着有其他线程正在进行扩容，那么当前现在直接帮助它进行扩容，因此调用 helpTransfer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    <span class="comment">//nextTab 引用的是 fwd.nextTable == map.nextTable 理论上是这样。</span></span><br><span class="line">    <span class="comment">//sc 保存map.sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：tab != null 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件二：(f instanceof ForwardingNode) 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件三：((ForwardingNode&lt;K,V&gt;)f).nextTable) != null 恒成立 true</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿当前标的长度 获取 扩容标识戳   假设 16 -&gt; 32 扩容：1000 0000 0001 1011</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：nextTab == nextTable</span></span><br><span class="line">        <span class="comment">//成立：表示当前扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：1.nextTable被设置为Null 了，扩容完毕后，会被设为Null</span></span><br><span class="line">        <span class="comment">//       2.再次出发扩容了...咱们拿到的nextTab 也已经过期了...</span></span><br><span class="line">        <span class="comment">//条件二：table == tab</span></span><br><span class="line">        <span class="comment">//成立：说明 扩容正在进行中，还未完成</span></span><br><span class="line">        <span class="comment">//不成立：说明扩容已经结束了，扩容结束之后，最后退出的线程 会设置 nextTable 为 table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件三：(sc = sizeCtl) &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：说明扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：说明sizeCtl当前是一个大于0的数，此时代表下次扩容的阈值，当前扩容已经结束。</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">            <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">            <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">            <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">            <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">            <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">            <span class="comment">//条件四：transferIndex &lt;= 0</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明map对象全局范围内的任务已经分配完了，当前线程进去也没活干..</span></span><br><span class="line">            <span class="comment">//      false-&gt;还有任务可以分配。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#10.get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//e 当前元素</span></span><br><span class="line">    <span class="comment">//p 目标节点</span></span><br><span class="line">    <span class="comment">//n table数组长度</span></span><br><span class="line">    <span class="comment">//eh 当前元素hash</span></span><br><span class="line">    <span class="comment">//ek 当前元素key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//扰动运算后得到 更散列的hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：(tab = table) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;表示已经put过数据，并且map内部的table也已经初始化完毕</span></span><br><span class="line">    <span class="comment">//false-&gt;表示创建完map后，并没有put过数据，map内部的table是延迟初始化的，只有第一次写数据时会触发创建逻辑。</span></span><br><span class="line">    <span class="comment">//条件二：(n = tab.length) &gt; 0 true-&gt;表示table已经初始化</span></span><br><span class="line">    <span class="comment">//条件三：(e = tabAt(tab, (n - 1) &amp; h)) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;当前key寻址的桶位 有值</span></span><br><span class="line">    <span class="comment">//false-&gt;当前key寻址的桶位中是null，是null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比头结点hash与查询key的hash是否一致</span></span><br><span class="line">        <span class="comment">//条件成立：说明头结点与查询Key的hash值 完全一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">//完全比对 查询key 和 头结点的key</span></span><br><span class="line">            <span class="comment">//条件成立：说明头结点就是查询数据</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件成立：</span></span><br><span class="line">        <span class="comment">//1.-1  fwd 说明当前table正在扩容，且当前查询的这个桶位的数据 已经被迁移走了</span></span><br><span class="line">        <span class="comment">//2.-2  TreeBin节点，需要使用TreeBin 提供的find 方法查询。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前桶位已经形成链表的这种情况</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#11.remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#12.replaceNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算key经过扰动运算后的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f表示桶位头结点</span></span><br><span class="line">        <span class="comment">//n表示当前table数组长度</span></span><br><span class="line">        <span class="comment">//i表示hash命中桶位下标</span></span><br><span class="line">        <span class="comment">//fh表示桶位头结点 hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：tab == null  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件二：(n = tab.length) == 0  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件三：(f = tabAt(tab, i = (n - 1) &amp; hash)) == null true -&gt; 表示命中桶位中为null，直接break， 会返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2：</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前table正在扩容中，当前是个写操作，所以当前线程需要协助table完成扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//当前桶位 可能是 &quot;链表&quot; 也可能 是  &quot;红黑树&quot; TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保留替换之前的数据引用</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//校验标记</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁当前桶位 头结点，加锁成功之后会进入 代码块。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断sync加锁是否为当前桶位 头节点，防止其它线程，在当前线程加锁成功之前，修改过 桶位 的头结点。</span></span><br><span class="line">                <span class="comment">//条件成立：当前桶位头结点 仍然为f，其它线程没修改过。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//条件成立：说明桶位 为 链表 或者 单个 node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//e 表示当前循环处理元素</span></span><br><span class="line">                        <span class="comment">//pred 表示当前循环节点的上一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="comment">//当前节点key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash true-&gt;说明当前节点的hash与查找节点hash一致</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//if 条件成立，说明key 与查询的key完全一致。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//当前节点的value</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件一：cv == null true-&gt;替换的值为null 那么就是一个删除操作</span></span><br><span class="line">                                <span class="comment">//条件二：cv == ev || (ev != null &amp;&amp; cv.equals(ev))  那么是一个替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">//删除 或者 替换</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//条件成立：说明当前是一个替换操作</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//直接替换</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">//条件成立：说明当前节点非头结点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//当前节点的上一个节点，指向当前节点的下一个节点。</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//说明当前节点即为 头结点，只需要将 桶位设置为头结点的下一个节点。</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：TreeBin节点。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//转换为实际类型 TreeBin t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//r 表示 红黑树 根节点</span></span><br><span class="line">                        <span class="comment">//p 表示 红黑树中查找到对应key 一致的node</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：(r = t.root) != null 理论上是成立</span></span><br><span class="line">                        <span class="comment">//条件二：TreeNode.findTreeNode 以当前节点为入口，向下查找key（包括本身节点）</span></span><br><span class="line">                        <span class="comment">//      true-&gt;说明查找到相应key 对应的node节点。会赋值给p</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//保存p.val 到pv</span></span><br><span class="line">                            V pv = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：cv == null  成立：不必对value，就做替换或者删除操作</span></span><br><span class="line">                            <span class="comment">//条件二：cv == pv ||(pv != null &amp;&amp; cv.equals(pv)) 成立：说明“对比值”与当前p节点的值 一致</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//替换或者删除操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                oldVal = pv;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件成立：替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">//删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">//这里没做判断，直接搞了...很疑惑</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当其他线程修改过桶位 头结点时，当前线程 sync 头结点 锁错对象时，validated 为false，会进入下次for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换的值 为null，说明当前是一次删除操作，oldVal ！=null 成立，说明删除成功，更新当前元素个数计数器。</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#13.TreeBin<br>##13.1 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树 根节点 </span></span><br><span class="line">TreeNode&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//链表的头节点</span></span><br><span class="line"><span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//等待者线程（当前lockState是读锁状态）</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.写锁状态 写是独占状态，以散列表来看，真正进入到TreeBin中的写线程 同一时刻 只有一个线程。 1</span></span><br><span class="line"><span class="comment">         * 2.读锁状态 读锁是共享，同一时刻可以有多个线程 同时进入到 TreeBin对象中获取数据。 每一个线程 都会给 lockStat + 4</span></span><br><span class="line"><span class="comment">         * 3.等待者状态（写线程在等待），当TreeBin中有读线程目前正在读取数据时，写线程无法修改数据，那么就将lockState的最低2位 设置为 0b 10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values for lockState</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p>##13.2 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="comment">//设置节点hash为-2 表示此节点是TreeBin节点</span></span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//使用first 引用 treeNode链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    <span class="comment">//r 红黑树的根节点引用</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x表示遍历的当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//强制设置当前插入节点的左右子树为null</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//条件成立：说明当前红黑树 是一个空树，那么设置插入元素 为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点的父节点 一定为 null</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//颜色改为黑色</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//让r引用x所指向的对象。</span></span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非第一次循环，都会来带else分支，此时红黑树已经有数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//k 表示 插入节点的key</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//h 表示 插入节点的hash</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//kc 表示 插入节点key的class类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//p 表示 为查找插入节点的父节点的一个临时节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//dir (-1, 1)</span></span><br><span class="line">                <span class="comment">//-1 表示插入节点的hash值大于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//1 表示插入节点的hash值 小于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//ph p表示 为查找插入节点的父节点的一个临时节点的hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//临时节点 key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点的hash值 小于 当前节点</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的左子节点 或者 继续在左子树上查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入节点的hash值 大于 当前节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的右子节点 或者 继续在右子树上查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果执行到 CASE3，说明当前插入节点的hash 与 当前节点的hash一致，会在case3 做出最终排序。最终</span></span><br><span class="line">                <span class="comment">//拿到的dir 一定不是0，（-1， 1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//xp 想要表示的是 插入节点的 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//条件成立：说明当前p节点 即为插入节点的父节点</span></span><br><span class="line">                <span class="comment">//条件不成立：说明p节点 底下还有层次，需要将p指向 p的左子节点 或者 右子节点，表示继续向下搜索。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置插入节点的父节点 为 当前节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//小于P节点，需要插入到P节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//大于P节点，需要插入到P节点的右子节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//插入节点后，红黑树性质 可能会被破坏，所以需要调用 平衡方法</span></span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将r 赋值给 TreeBin对象的 root引用。</span></span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.3 putTreeVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前循环节点xp 即为 x 节点的爸爸</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//x 表示插入节点</span></span><br><span class="line">            <span class="comment">//f 老的头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明链表有数据</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//设置老的头结点的前置引用为 当前的头结点。</span></span><br><span class="line">                f.prev = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示 当前新插入节点后，新插入节点 与 父节点 形成 “红红相连”</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//平衡红黑树，使其再次符合规范。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.4 find</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e 表示循环迭代的当前节点   迭代的是first引用的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//s 保存的是lock临时状态</span></span><br><span class="line">            <span class="comment">//ek 链表当前节点 的key</span></span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(WAITER|WRITER) =&gt; 0010 | 0001 =&gt; 0011</span></span><br><span class="line">            <span class="comment">//lockState &amp; 0011 != 0 条件成立：说明当前TreeBin 有等待者线程 或者 目前有写操作线程正在加锁</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前置条件：当前TreeBin中 等待者线程 或者 写线程 都没有</span></span><br><span class="line">            <span class="comment">//条件成立：说明添加读锁成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//查询操作</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//w 表示等待者线程</span></span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">//U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER)</span></span><br><span class="line">                    <span class="comment">//1.当前线程查询红黑树结束，释放当前线程的读锁 就是让 lockstate 值 - 4</span></span><br><span class="line">                    <span class="comment">//(READER|WAITER) = 0110 =&gt; 表示当前只有一个线程在读，且“有一个线程在等待”</span></span><br><span class="line">                    <span class="comment">//当前读线程为 TreeBin中的最后一个读线程。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.(w = waiter) != null 说明有一个写线程在等待读操作全部结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用unpark 让 写线程 恢复运行状态。</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#总结<br>在java8中，ConcurrentHashMap使用数组+链表+红黑树的组合方式，利用cas和synchronized保证并发写的安全。</p><p>引入红黑树的原因：链表查询的时间复杂度为On，但是红黑树的查询时间复杂度为O(log(n)),所以在节点比较多的情况下，使用红黑树可以大大提升性能。</p><p>链式桶是一个由node节点组成的链表。树状桶是一颗由TreeNode节点组成的红黑树。输的根节点为TreeBin类型。</p><p>当链表长度大于8整个hash表长度大于64的时候，就会转化为TreeBin。TreeBin作为根节点，其实就是红黑树对象。在ConcurrentHashMap的table数组中，存放的就是TreeBin对象，而不是TreeNoe对象。</p><p>数组table是懒加载的，只有第一次添加元素的时候才会初始化，所以initTable()存在线程安全问题。</p><p>重要的属性就是sizeCtl，用来控制table的初始化和扩容操作的过程：</p><p>● -1代表table正在初始化，其他线程直接join等待。</p><p>● -N代表有N-1个线程正在进行扩容操作，严格来说，当其为负数的时候，只用到了低16位，如果低16位为M，此时有M-1个线程进行扩容。</p><p>● 大于0有两种情况：如果table没有初始化，她就表示table初始化的大小，如果table初始化完了，就表示table的容量，默认是table大小的四分之三。</p><p>Transfer()扩容</p><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程所负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的 Bucket会被替换为一个Forwarding节点，标记当前Bucket已经被其他线程迁移完了。</p><p>helpTransfer()帮助扩容</p><p>ConcurrentHashMap并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</p><p>第一次添加元素时，默认初始长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>put()</p><p>JDK1.8在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用通常不会很激烈，所以使用CAS自旋、synchronized不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢?如果为每 个桶都创建一个ReentrantLock实 例，就会带来大量的内存消耗，反过来，使用CAS自旋、synchronized，内存消耗的增加更小。</p><p>get()</p><p>get()通过UnSafe的getObjectVolatile()来读取数组中的元素。为什么要这样做?虽然HashEntry数组的引用是volatile类型，但是数组内元素的 用不是volatile类型，因此多线程对 数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的元素对象。get()方法通过UnSafe的getObjectVolatile方法来保证元素的读取安全，调用getObjectVolatile()去读取数组元素需要先获得元素在数组中的偏移量，在这里，get()方法根据哈希码计算出偏移量为u，然后通过偏移量u来尝试读取数值。</p>]]></content>
      
      
      <categories>
          
          <category> 1.基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
