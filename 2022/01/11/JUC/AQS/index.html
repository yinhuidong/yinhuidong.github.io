<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AQS | 二十</title><meta name="keywords" content="并发编程"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AQS">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/11/JUC/AQS/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="AQS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/juc.png">
<meta property="article:published_time" content="2022-01-11T11:06:49.064Z">
<meta property="article:modified_time" content="2022-01-11T11:24:53.300Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/juc.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/11/JUC/AQS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'AQS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 19:24:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/juc.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AQS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-11T11:06:49.064Z" title="发表于 2022-01-11 19:06:49">2022-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T11:24:53.300Z" title="更新于 2022-01-11 19:24:53">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC/">JUC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="AQS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一，Lock"><a href="#一，Lock" class="headerlink" title="一，Lock"></a>一，Lock</h1><p>Lock在juc中是最核心的组件<br>​</p>
<h2 id="1-Lock的实现"><a href="#1-Lock的实现" class="headerlink" title="1.Lock的实现"></a>1.Lock的实现</h2><p>Lock 本质上是一个接口，它定义了释放锁和获得锁的抽象方法，定义成接口就意味着它定义了锁的一个标准规范，也同时意味着锁的不同实现。实现 Lock 接口的类有很多，以下为几个常见的锁实现。<br>​</p>
<p>ReentrantLock：表示重入锁，它是唯一一个实现了 Lock 接口的类。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是直接关联一次计数器增加重入次数。<br>​</p>
<p>ReentrantReadWriteLock：重入读写锁，它实现了 ReadWriteLock 接口，在这个类中维护了两个锁，一个是 ReadLock，一个是 WriteLock，他们都分别实现了 Lock接口。读写锁是一种适合读多写少的场景下解决线程安全问题的工具，基本原则是： 读和读不互斥、读和写互斥、写和写互斥。也就是说涉及到影响数据变化的操作都会存在互斥。<br>​</p>
<p>StampedLock： stampedLock 是 JDK8 引入的新的锁机制，可以简单认为是读写锁的一个改进版本，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock 是一种乐观的读策略，使得乐观锁完全不会阻塞写线程。<br>​</p>
<h2 id="2-Lock的类关系图"><a href="#2-Lock的类关系图" class="headerlink" title="2.Lock的类关系图"></a>2.Lock的类关系图</h2><p>Lock有很多的实现，但是直观的实现是ReentrantLock重入锁。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630307274914-95b2f9fa-6389-418b-a23c-1eda361a2fcc.jpeg#clientId=u72ca8c9a-5df4-4&from=ui&id=uffbabb90&margin=%5Bobject%20Object%5D&name=Lock%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg&originHeight=472&originWidth=834&originalType=binary&ratio=1&size=53650&status=done&style=none&taskId=ub7f65dc5-8cb3-4624-be41-702c7b5c7fd" alt="Lock类关系图.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="comment">// 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="comment">// 和lock()方法相似, 但阻塞的线程 可 中 断 ， 抛 出java.lang.InterruptedException 异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="comment">// 非阻塞获取锁;尝试获取锁，如果成功返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>  <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit timeUnit)</span> <span class="comment">//带有超时时间的获取锁方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="comment">// 释放锁</span></span></span><br></pre></td></tr></table></figure>
<h1 id="二，ReentrantLock"><a href="#二，ReentrantLock" class="headerlink" title="二，ReentrantLock"></a>二，ReentrantLock</h1><p>重入锁，表示支持重新进入的锁，也就是说，如果当前线程 t1 通过调用 lock 方法获取了锁之后，再次调用 lock，是不会再阻塞去获取锁的，直接增加重试次数就行了。synchronized 和 ReentrantLock 都是可重入锁。<br>​</p>
<h2 id="1-重入锁的设计目的"><a href="#1-重入锁的设计目的" class="headerlink" title="1.重入锁的设计目的"></a>1.重入锁的设计目的</h2><p>比如调用 demo 方法获得了当前的对象锁，然后在这个方法中再去调用demo2，demo2 中的存在同一个实例锁，这个时候当前线程会因为无法获得demo2 的对象锁而阻塞，就会产生死锁。重入锁的设计目的是避免线程的死锁。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin:demo&quot;</span>);</span><br><span class="line">        demo2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin:demo1&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantDemo rd = <span class="keyword">new</span> ReentrantDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(rd::demo).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-ReentrantLock使用"><a href="#2-ReentrantLock使用" class="headerlink" title="2.ReentrantLock使用"></a>2.ReentrantLock使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; AtomicDemo.inc()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-ReentrantReadWriteLock"><a href="#3-ReentrantReadWriteLock" class="headerlink" title="3.ReentrantReadWriteLock"></a>3.ReentrantReadWriteLock</h2><p>​</p>
<p>以前理解的锁，基本都是排他锁，也就是这些锁在同一时刻只允许一个线程进行访问，而读写所在同一时刻可以允许多个线程访问，但是在写线程访问时，所有的读线程和其他写线程都会被阻塞。读写锁维护了一对锁，一个读锁、一个写锁;一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Object&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock read = rwl.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock write = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 开始读取数据&quot;</span>);</span><br><span class="line">        read.lock(); <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheMap.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; 开始写数据&quot;</span>);</span><br><span class="line">        write.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheMap.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            write.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个案例中，通过 hashmap 来模拟了一个内存缓存，然后使用读写锁来保证这个内存缓存的线程安全性。当执行读操作的时候，需要获取读锁，在并发访问的时候，读锁不会被阻塞，因为读操作不会影响执行结果。<br>​</p>
<p>在执行写操作时，线程必须要获取写锁，当已经有线程持有写锁的情况下，当前线程会被阻塞，只有当写锁释放以后，其他读写操作才能继续执行。使用读写锁提升读操作的并发性，也保证每次写操作对所有的读写操作的可见性。<br>​</p>
<p><strong>读锁与读锁可以共享</strong><br>​</p>
<p><strong>读锁与写锁不可以共享（排他）</strong></p>
<p><strong>写锁与写锁不可以共享（排他）</strong><br><strong>​</strong></p>
<h1 id="三，ReentrantLock-的实现原理"><a href="#三，ReentrantLock-的实现原理" class="headerlink" title="三，ReentrantLock 的实现原理"></a>三，ReentrantLock 的实现原理</h1><p>​</p>
<p>锁的基本原理是，基于将多线程并行任务通过某一种机制实现线程的串行执行，从而达到线程安全性的目的。在 ReentrantLock 中，在多线程<br>竞争重入锁时，竞争失败的线程是如何实现阻塞以及被唤醒的呢？<br>​</p>
<h2 id="1-AQS是什么？"><a href="#1-AQS是什么？" class="headerlink" title="1.AQS是什么？"></a>1.AQS是什么？</h2><p>在 Lock 中，用到了一个同步队列 AQS，全称 <code>AbstractQueuedSynchronizer</code>，它是一个同步工具也是 Lock 用来实现线程同步的核心组件。<br>​</p>
<h2 id="2-AQS的两种功能"><a href="#2-AQS的两种功能" class="headerlink" title="2.AQS的两种功能"></a>2.AQS的两种功能</h2><p>使用层面上来说，AQS的功能分为两种:独占和共享。<br>​</p>
<p>独占锁：每次只能有一个线程持有锁。<br>​</p>
<p>共享锁：允许多线程同时获取锁，并发访问共享资源。<br>​</p>
<h2 id="3-AQS的内部实现"><a href="#3-AQS的内部实现" class="headerlink" title="3.AQS的内部实现"></a>3.AQS的内部实现</h2><p>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接的前驱结点。所以双向链表可以从任意一个结点开始很方便的访问前驱和后继。每个Node其实是由线程封装，当线程争抢锁失败后会封装成Node加入到AQS队列中去，当获取锁的线程释放锁之后，会从队列中唤醒一个阻塞的节点（线程）。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630308448002-98b50916-743c-4af8-bbeb-90cb4536a601.png#clientId=u72ca8c9a-5df4-4&from=ui&id=udfed11d2&margin=%5Bobject%20Object%5D&name=FIFO%E9%98%9F%E5%88%97.png&originHeight=401&originWidth=852&originalType=binary&ratio=1&size=21797&status=done&style=none&taskId=ud465aa7b-1a68-4b1c-a675-837383150eb" alt="FIFO队列.png"></p>
<h2 id="4-Node的组成"><a href="#4-Node的组成" class="headerlink" title="4.Node的组成"></a>4.Node的组成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">//前驱结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">//后继节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">//当前线程</span></span><br><span class="line"></span><br><span class="line">    Node nextWaiter; <span class="comment">//存储在condition队列中的后继节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否为共享锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-释放锁以及添加线程对于队列的变化"><a href="#5-释放锁以及添加线程对于队列的变化" class="headerlink" title="5.释放锁以及添加线程对于队列的变化"></a>5.释放锁以及添加线程对于队列的变化</h2><p>当出现锁竞争以及释放锁的时候，AQS 同步队列中的节点会发生变化，首先看一下添加节点的场景。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630309324252-69431828-da05-4412-a233-c1288693f424.png#clientId=u72ca8c9a-5df4-4&from=paste&height=360&id=uc0fe4859&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1922&originalType=binary&ratio=1&size=119009&status=done&style=none&taskId=ucafd6568-0c7b-4b6d-9566-fa7f4b2fdf6&width=961" alt="image.png"></p>
<p>这里会涉及到两个变化：<br>​</p>
<ol>
<li>新的线程封装成Node节点追加到同步队列中，设置prev节点以及修改当前节点的前驱节点的next节点指向自己。</li>
<li>通过CAS的方式将tail重新指向新的尾部节点。</li>
</ol>
<p>​</p>
<p>head节点表示获取锁成功的节点，当头结点在释放同步状态的时候，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头节点，节点的变化过程如下：<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630309676987-69bc8189-4e5e-45dd-b95f-77054653741f.png#clientId=u72ca8c9a-5df4-4&from=paste&height=355&id=uc3779785&margin=%5Bobject%20Object%5D&name=image.png&originHeight=710&originWidth=1910&originalType=binary&ratio=1&size=308399&status=done&style=none&taskId=u38e5dc6c-97de-41e3-b10d-fa97875db9a&width=955" alt="image.png"><br>​</p>
<p>这个过程也是涉及到两个变化：<br>​</p>
<ol>
<li>修改head节点指向下一个获得锁的节点</li>
<li>新的获得锁的节点，将prev的指针指向null</li>
</ol>
<p>​</p>
<p><strong>设置head节点不需要用CAS，原因是设置head节点是由获得锁的线程来完成的，而同步锁只能由一个线程来获得，所以不需要CAS保证，只需要把head节点设置为原首节点的后继节点，并且断开原head节点的next引用即可。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630337089876-18e0555f-fbc0-4738-a540-c6ae0d7d6ec2.png#clientId=u62ec6068-bdef-4&from=ui&id=u5f2ff528&margin=%5Bobject%20Object%5D&name=AQS.png&originHeight=1691&originWidth=2681&originalType=binary&ratio=1&size=443627&status=done&style=none&taskId=u8e96a2d9-7879-47f0-ad2d-8ee1bd4dd6e" alt="AQS.png"></p>
<h1 id="四，ReentrantLock-的源码分析"><a href="#四，ReentrantLock-的源码分析" class="headerlink" title="四，ReentrantLock 的源码分析"></a>四，ReentrantLock 的源码分析</h1><h2 id="1-加锁逻辑"><a href="#1-加锁逻辑" class="headerlink" title="1.加锁逻辑"></a>1.加锁逻辑</h2><h3 id="ReentrantLock-lock"><a href="#ReentrantLock-lock" class="headerlink" title="ReentrantLock.lock"></a>ReentrantLock.lock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>sync 实际上是一个抽象的静态内部类，它继承了 AQS 来实现重入锁的逻辑，前面说过 AQS 是一个同步队列，它能够实现线程的阻塞以及唤醒，但它并不具备业务功能，所以在不同的同步场景中，会继承 AQS 来实现对应场景的功能。<br>​</p>
<p>Sync 有两个具体的实现类，分别是：</p>
<p><strong>NofairSync：表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁。</strong></p>
<p><strong>FailSync: 表示所有线程严格按照 FIFO 来获取锁。</strong><br><strong>​</strong></p>
<h3 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock"></a>NonfairSync.lock</h3><ol>
<li>非公平锁和公平锁最大的区别在于：非公平锁中抢占锁的逻辑是，不管有没有线程排队，先上来cas去抢占一下</li>
<li>cas成功，就表示成功获得了锁</li>
<li>cas失败，调用acquire(1)走锁竞争逻辑</li>
</ol>
<p>​</p>
<blockquote>
<p>state 是 AQS 中的一个属性，它在不同的实现中所表达的含义不一样，对于重入锁的实现来说，表示一个同步状态。它有两个含义的表示：<br>​</p>
</blockquote>
<blockquote>
<ol>
<li>当 state=0 时，表示无锁状态。</li>
</ol>
</blockquote>
<p>​</p>
<blockquote>
<ol start="2">
<li>当 state&gt;0 时，表示已经有线程获得了锁，也就是 state=1，但是因为ReentrantLock 允许重入，所以同一个线程多次获得同步锁的时候，state 会递增，比如重入 5 次，那么 state=5。 而在释放锁的时候，同样需要释放 5 次直到 state=0其他线程才有资格获得锁。</li>
</ol>
</blockquote>
<p>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果cas的方式修改state状态成功，说明获取到了锁，直接设置当前持有锁的线程是当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//cas失败，走抢占锁的逻辑</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h3 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire"></a>AQS.acquire</h3><p>acquire是AQS中的方法，如果cas操作未能成功，说明state已经不为0，此时继续acquire(1)操作。<br>​</p>
<p>这个方法的主要逻辑：<br>​</p>
<ol>
<li>通过 tryAcquire 尝试获取独占锁，如果成功返回 true，失败返回 false.</li>
<li>如果 tryAcquire 失败，则会通过 addWaiter 方法将当前线程封装成 Node 添加到 AQS 队列尾部.</li>
<li>acquireQueued，将 Node 作为参数，通过自旋去尝试获取锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果尝试去抢占锁失败 就讲当前线尾插进入阻塞队列，让当前现成的node自旋的方式去尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//响应中断逻辑，表示如果当前线程在 acquireQueued 中被中断过，则需要产生一个中断请求，</span></span><br><span class="line">        <span class="comment">//原因是线程在调用 acquireQueued 方法的时候是不会响应中断请求的。</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-selfInterrupt"><a href="#AQS-selfInterrupt" class="headerlink" title="AQS.selfInterrupt"></a>AQS.selfInterrupt</h3></li>
</ol>
<p>表示如果当前线程在 acquireQueued 中被中断过，则需要产生一个中断请求，原因是线程在调用 acquireQueued 方法的时候是不会响应中断请求的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行中断逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-tryAcquire"><a href="#AQS-tryAcquire" class="headerlink" title="AQS.tryAcquire"></a>AQS.tryAcquire</h3><p>这里采用模板模式，具体的逻辑交给继承该类的子类实现，直接看非公平锁的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NonfairSync-tryAcquire"><a href="#NonfairSync-tryAcquire" class="headerlink" title="NonfairSync.tryAcquire"></a>NonfairSync.tryAcquire</h3><p>这个方法的作用是尝试获取锁，如果成功返回true，不成功返回false。<br>​</p>
<p>它是重写AQS类中的tryAcquire方法，AQS中的tryAcquire()的定义，并没有实现，而是抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock-nofairTryAcquire"><a href="#ReentrantLock-nofairTryAcquire" class="headerlink" title="ReentrantLock.nofairTryAcquire"></a>ReentrantLock.nofairTryAcquire</h3><ol>
<li>获取当前线程，判断当前的锁的状态</li>
<li>如果state=0 表示当前是无锁状态，通过cas更新state状态的值</li>
<li>当前线程是属于重入，则增加重入次数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前的state值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果此时没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//cas去获取一次锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//走到这里说明cas的方式获取到了锁，直接设置当前锁的线程是当前线程，并返回true</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明 当前锁被其他线程持有 或者  当前cas失败，存在竞争</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//如果持有锁的线程是当前线程自己</span></span><br><span class="line">        <span class="comment">//执行到这里说明是一次重入锁的逻辑，直接在原有状态上+就可以</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//什么情况下会走到这里？</span></span><br><span class="line">    <span class="comment">//cas失败，锁被其他线程持有，  </span></span><br><span class="line">    <span class="comment">//state》0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a>AQS.addWaiter</h3></li>
</ol>
<p>当 tryAcquire 方法获取锁失败以后，则会先调用 addWaiter 将当前线程封装成Node.</p>
<p>入参 mode 表示当前节点的状态，传递的参数是 Node.EXCLUSIVE，表示独占状态。意味着重入锁用到了 AQS 的独占锁功能。<br>​</p>
<ol>
<li>将当前线程封装成 Node</li>
</ol>
<p>​</p>
<ol start="2">
<li>当前链表中的 tail 节点是否为空，如果不为空，则通过 cas 操作把当前线程的node 添加到 AQS 队列</li>
</ol>
<p>​</p>
<ol start="3">
<li>如果为空或者 cas 失败，调用 enq 将节点添加到 AQS 队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建一个新的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//尾结点不为空，说明队列已经初始化过了</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将当前节点的前驱节点指向为尾结点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//cas的方式设置尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//cas成功，让尾结点的后继指针指向node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到这里 说明队列尚未初始化， 或者cas的方式设置尾结点失败，说明有其他线程先一步入队了。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-enq"><a href="#AQS-enq" class="headerlink" title="AQS.enq"></a>AQS.enq</h3></li>
</ol>
<p><strong>enq 就是通过自旋操作把当前节点加入到队列中。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630461121698-d8a8a923-c2c0-4d8e-84cc-40b5090fa52f.png#clientId=ucf010d64-75e2-4&from=ui&id=u0089d142&margin=%5Bobject%20Object%5D&name=AQS-%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F-%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90.png&originHeight=3246&originWidth=1221&originalType=binary&ratio=1&size=190377&status=done&style=none&taskId=u0f72119b-90e4-4f6e-b99e-d440904a247" alt="AQS-独占模式-情景分析.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自旋：</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，说明需要初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">            <span class="comment">//注意，这里初始化完之后并没有直接退出，而是继续往下走，为啥呢？</span></span><br><span class="line">            <span class="comment">//因为当前执行的是初始化操作，那就说明，当前这个抢占锁失败的线程需要给当前持有锁的线程补充一个头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//尾结点不为空</span></span><br><span class="line">            <span class="comment">//让当前节点的前驱指针指向尾结点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//cas的方式设置尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">//让尾结点的后继指针指向当前节点</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630328481351-11bc0030-469b-453f-950c-fc3c036504ad.jpeg#clientId=u72ca8c9a-5df4-4&from=ui&id=u1f06876b&margin=%5Bobject%20Object%5D&name=enq.jpg&originHeight=618&originWidth=1184&originalType=binary&ratio=1&size=96597&status=done&style=none&taskId=ufa07b3d4-4d38-4cf6-8756-49de74bf720" alt="enq.jpg"></p>
<h3 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS .acquireQueued"></a>AQS .acquireQueued</h3><p><strong>通过 addWaiter 方法把线程添加到链表后，会接着把 Node 作为参数传递给acquireQueued 方法，去竞争锁</strong><br>​</p>
<ol>
<li><p>获取当前节点的 prev 节点</p>
</li>
<li><p>如果 prev 节点为 head 节点，那么它就有资格去争抢锁，调用 tryAcquire 抢占锁</p>
</li>
</ol>
<p>​</p>
<ol start="3">
<li>抢占锁成功以后，把获得锁的节点设置为 head，并且移除原来的初始化 head节点</li>
</ol>
<p>​</p>
<ol start="4">
<li><p>如果获得锁失败，则根据 waitStatus 决定是否需要挂起线程</p>
</li>
<li><p>最后，通过 cancelAcquire 取消获得锁的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果当前节点的前驱节点是头节点，说明当前节点拥有了竞争锁的权利，尝试cas的方式去获取一次锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//执行到这里说名cas获取到了锁</span></span><br><span class="line">                <span class="comment">//设置头节点为当前节点，这里为啥不用加锁，因为设置头节点的线程是持有锁的线程，独占模式下，只有一个线程持有锁，所以设置头节点不存在线程安全问题</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//让p的后继指针指向null 帮助垃圾回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">//声明获取锁成功</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//当前线程不需要被中断</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前持有锁的线程可能还没有释放锁，所以当前线程尝试获取锁会失败，这个时候当前线程应该park</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//这里比较友好，仅仅是把中断标识位改成true，如果是响应中断逻辑，直接这里抛异常了，然后走cancelAcquire(node)的逻辑。</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630328497959-a099915c-4270-4bbb-a6cc-cccd64878e67.jpeg#clientId=u72ca8c9a-5df4-4&from=ui&id=u93945a00&margin=%5Bobject%20Object%5D&name=acquireQueue.jpg&originHeight=188&originWidth=1012&originalType=binary&ratio=1&size=27804&status=done&style=none&taskId=u8f51a1d6-4112-4f16-883c-95ddc84dfbd" alt="acquireQueue.jpg"></p>
<h3 id="AQS-shouldParkAfterFailedAcquire"><a href="#AQS-shouldParkAfterFailedAcquire" class="headerlink" title="AQS.shouldParkAfterFailedAcquire"></a>AQS.shouldParkAfterFailedAcquire</h3></li>
</ol>
<p>如果 ThreadA 的锁还没有释放的情况下，ThreadB 和 ThreadC 来争抢锁肯定是会失败，那么失败以后会调用 shouldParkAfterFailedAcquire 方法<br>​</p>
<p>Node 有 5 种状态，分别是：CANCELLED（1），SIGNAL（-1）、CONDITION（-2）、PROPAGATE(-3)、默认状态(0)</p>
<ul>
<li><strong>CANCELLED: 在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该 Node 的结点, 其结点的 waitStatus 为 CANCELLED，即结束状态，进入该状态后的结点将不会再变化</strong></li>
</ul>
<p>​</p>
<ul>
<li><strong>SIGNAL: 只要前置节点释放锁，就会通知标识为 SIGNAL 状态的后续节点的线程</strong></li>
</ul>
<p>​</p>
<ul>
<li><strong>CONDITION： 和 Condition 有关系</strong></li>
</ul>
<p>​</p>
<ul>
<li><strong>PROPAGATE：共享模式下，PROPAGATE 状态的线程处于可运行状态</strong></li>
</ul>
<p>​</p>
<ul>
<li><strong>0:初始状态</strong></li>
</ul>
<p>​</p>
<p>这个方法的主要作用是，通过 Node 的状态来判断，ThreadA 竞争锁失败以后是否应该被挂起。<br>​</p>
<ol>
<li>如果 ThreadA 的 pred 节点状态为 SIGNAL，那就表示可以放心挂起当前线程</li>
</ol>
<p>​</p>
<ol start="2">
<li>通过循环扫描链表把 CANCELLED 状态的节点移除</li>
</ol>
<p>​</p>
<ol start="3">
<li>修改 pred 节点的状态为 SIGNAL,返回 false.</li>
</ol>
<p>​</p>
<p><strong>返回 false 时，也就是不需要挂起，返回 true，则需要调用 parkAndCheckInterrupt挂起当前线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果前置节点为 SIGNAL，意味着只需要等待其他前置节点的线程被释放</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//ws 大于 0，意味着 prev 节点取消了排队，直接移除这个节点就行   </span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;<span class="comment">//相当于: pred=pred.prev; node.prev=pred;</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);<span class="comment">//这里采用循环，从双向列表中移除 CANCELLED 的节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//利用 cas 设置 prev 节点的状态为 SIGNAL(-1)</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-parkAndCheckInterrupt"><a href="#AQS-parkAndCheckInterrupt" class="headerlink" title="AQS.parkAndCheckInterrupt"></a>AQS.parkAndCheckInterrupt</h3><p><strong>​</strong></p>
<p><strong>使用 LockSupport.park 挂起当前线程变成 WATING 状态</strong><br>​</p>
<p>Thread.interrupted，返回当前线程是否被其他线程触发过中断请求，也就是thread.interrupt(); 如果有触发过中断请求，那么这个方法会返回当前的中断标识true，并且对中断标识进行复位标识已经响应过了中断请求。如果返回 true，意味着在 acquire 方法中会执行 selfInterrupt()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-cancelAcquire"><a href="#AQS-cancelAcquire" class="headerlink" title="AQS.cancelAcquire"></a>AQS.cancelAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果节点不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//将当前节点的线程设置为空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="comment">//循环判断：如果前驱节点是一个取消状态，那就继续往前找</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">	<span class="comment">//可能是当前节点，可能是ws&gt;0的节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">	<span class="comment">//设置当前节点的waitStatus是取消状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前取消排队的node所在 队列的位置不同，执行的出队策略是不一样的，一共分为三种情况：</span></span><br><span class="line"><span class="comment">     * 1.当前node是队尾  tail -&gt; node</span></span><br><span class="line"><span class="comment">     * 2.当前node 不是 head.next 节点，也不是 tail</span></span><br><span class="line"><span class="comment">     * 3.当前node 是 head.next节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//尾结点且cas tail成功</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">//pred.next = null node出队</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	node不是head.next node 不是tail </span></span><br><span class="line"><span class="comment">            node的前驱节点是取消状态 或 假设前驱状态是 &lt;= 0 则设置前驱状态为 Signal状态..表示要唤醒后继节点。</span></span><br><span class="line"><span class="comment">            if里面要做的就是让node 的prev 跨过node 直接指向 node.next</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//node是head.next &amp;&amp; node !=tail</span></span><br><span class="line">            <span class="comment">//那就跨过node head.next = node.next node.next.prev=head</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-释放锁的逻辑"><a href="#2-释放锁的逻辑" class="headerlink" title="2.释放锁的逻辑"></a>2.释放锁的逻辑</h2><p>如果这个时候 ThreadA 释放锁了，那么来看锁被释放后会产生什么效果？<br>​</p>
<h3 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行sync的release方法，默认是非公平锁，所以看非公平锁的逻辑</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-release"><a href="#AQS-release" class="headerlink" title="AQS.release"></a>AQS.release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果尝试释放锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">//如果头结点不为空，且头节点状态不等于0</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock-tryRelease"><a href="#ReentrantLock-tryRelease" class="headerlink" title="ReentrantLock.tryRelease"></a>ReentrantLock.tryRelease</h3><p>这个方法可以认为是一个设置锁状态的操作，通过将 state 状态减掉传入的参数值（参数是 1），如果结果状态为 0，就将排它锁的 Owner 设置为 null，以使得其它的线程有机会进行执行。<br>​</p>
<p>在排它锁中，加锁的时候状态会增加 1（当然可以自己修改这个值），在解锁的时候减掉 1，同一个锁，在可以重入后，可能会被叠加为 2、3、4 这些值，只有 unlock()的次数与 lock()的次数对应才会将 Owner 线程设置为空，而且也只有这种情况下才会返回 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前值与传入的值进行相减</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//如果当前线程不是线程拥有者，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//重入锁已经完全释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);<span class="comment">//设置当前线程的拥有者为null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);<span class="comment">//修改state状态</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS-unparkSuccessor"><a href="#AQS-unparkSuccessor" class="headerlink" title="AQS.unparkSuccessor"></a>AQS.unparkSuccessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取头节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//如果头结点的状态小于0</span></span><br><span class="line">        <span class="comment">//修改头节点的状态为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取头节点的下一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    /如果下一个节点为 <span class="keyword">null</span> 或者 status&gt;<span class="number">0</span> 表示 cancelled 状态</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过从尾部节点开始扫描，找到距离 head 最近的一个waitStatus&lt;=0 的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)<span class="comment">//唤醒这个节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过锁的释放，原本的结构就发生了一些变化。head 节点的 waitStatus 变成了 0，ThreadB 被唤醒。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630330114313-fec98f70-7bb8-4b8b-ba47-1c1c5384cd01.jpeg#clientId=u72ca8c9a-5df4-4&from=ui&id=uc8b2dda4&margin=%5Bobject%20Object%5D&name=unparkSuccessor.jpg&originHeight=196&originWidth=1011&originalType=binary&ratio=1&size=27298&status=done&style=none&taskId=u06b9e03b-6174-41a6-a3f5-746baef1467" alt="unparkSuccessor.jpg"></p>
<p><strong>为什么释放锁的时候是从尾结点开始扫描？</strong><br><strong>​</strong></p>
<p>再回到 enq那个方法。看一个新的节点是如何加入到链表中的<br>​</p>
<ol>
<li><p>将新的节点的 prev 指向 tail。</p>
</li>
<li><p>通过 cas 将 tail 设置为新的节点，因为 cas 是原子操作所以能够保证线程安全性。</p>
</li>
</ol>
<p>​</p>
<ol start="3">
<li>t.next=node；设置原 tail 的 next 节点指向新的节点。</li>
</ol>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630330220671-4c16a5e6-b742-4260-a588-a8d198aa8ff1.jpeg#clientId=u72ca8c9a-5df4-4&from=ui&id=ue5e214b3&margin=%5Bobject%20Object%5D&name=%E5%94%A4%E9%86%92.jpg&originHeight=269&originWidth=1108&originalType=binary&ratio=1&size=35666&status=done&style=none&taskId=u6bd5c88b-c784-47e2-9c22-714354602ba" alt="唤醒.jpg"></p>
<p>在 cas 操作之后，t.next=node 操作之前。 存在其他线程调用 unlock 方法从 head开始往后遍历，由于 t.next=node 还没执行意味着链表的关系还没有建立完整。就会导致遍历到 t 节点的时候被中断。所以从后往前遍历，一定不会存在这个问题。<br>​</p>
<p><strong>原本被挂起的线程在被唤醒后继续执行</strong><br><strong>​</strong></p>
<p>通过 ReentrantLock.unlock，原本挂起的线程被唤醒以后继续执行，原来被挂起的线程是在 acquireQueued 方法中，所以被唤醒以后继续从这个方法开始执行。<br>​</p>
<p>由于 ThreadB 的 prev 节点指向的是 head，并且 ThreadA 已经释放了锁。所以这个时候调用 tryAcquire 方法时，可以顺利获取到锁。<br>​</p>
<ol>
<li>把 ThreadB 节点当成 head。</li>
</ol>
<p>​</p>
<ol start="2">
<li>把原 head 节点的 next 节点指向为 null。</li>
</ol>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630330433335-7fd7427c-8796-4b0f-a035-70d58a61f913.jpeg#clientId=u72ca8c9a-5df4-4&from=ui&id=uc4a77241&margin=%5Bobject%20Object%5D&name=tryAcquire.jpg&originHeight=216&originWidth=1098&originalType=binary&ratio=1&size=30188&status=done&style=none&taskId=u7e2257c3-5cae-4157-8d00-0814a38d08b" alt="tryAcquire.jpg"></p>
<h2 id="3-公平锁和非公平锁的区别"><a href="#3-公平锁和非公平锁的区别" class="headerlink" title="3.公平锁和非公平锁的区别"></a>3.公平锁和非公平锁的区别</h2><p>锁的公平性是相对于获取锁的顺序而言的，如果是一个公平锁，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是 FIFO。 在上面分析的例子来说，只要CAS 设置同步状态成功，则表示当前线程获取了锁，而公平锁则不一样，差异点有两个：</p>
<h3 id="FairSync-tryAcquire"><a href="#FairSync-tryAcquire" class="headerlink" title="FairSync.tryAcquire"></a>FairSync.tryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    acquire(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非公平锁在获取锁的时候，会先通过 CAS 进行抢占，而公平锁则不会。</strong><br>​</p>
<h3 id="FairSync-tryAcquire-1"><a href="#FairSync-tryAcquire-1" class="headerlink" title="FairSync .tryAcquire"></a>FairSync .tryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前state状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//状态为0，说明此时没有现成持有锁</span></span><br><span class="line">        <span class="comment">//如果队列里面没有节点 且cas的方式获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//设置持有锁的线程我当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前线程是获取锁的线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//锁重入逻辑</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	返回false的情况：</span></span><br><span class="line"><span class="comment">        1. 当前锁被其他线程持有</span></span><br><span class="line"><span class="comment">        2. 队列里面有节点或cas争抢锁失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个方法与 nonfairTryAcquire(int acquires)比较，不同的地方在于判断条件多了hasQueuedPredecessors()方法，也就是加入了[同步队列中当前节点是否有前驱节点]的判断，如果该方法返回 true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</strong></p>
<h3 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先什么时候返回false？返回false代表当前队列没有线程或者当前队列头节点的下一个线程就是当前线程</span></span><br><span class="line"><span class="comment">//1.队列为空</span></span><br><span class="line"><span class="comment">//2.头节点的下一个节点的线程是当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node t = tail; </span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">//h!=t:头节点不是尾结点，说明队列里面还有其他的节点</span></span><br><span class="line">        <span class="comment">//(头节点的下一个节点为空||头节点的后继节点对应的线程不是当前线程) </span></span><br><span class="line">        <span class="comment">//头节点的下一个节点的线程正在拿到锁 或者 头节点的下一个节点的线程不是当前线程</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="五，Condition-条件队列"><a href="#五，Condition-条件队列" class="headerlink" title="五，Condition 条件队列"></a>五，Condition 条件队列</h1><p>对比<code>synchronized</code>管程模型：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630460827733-7e77b41d-0938-418a-ad0e-357795b36fa7.png#clientId=ucf010d64-75e2-4&from=ui&id=u28b03ef2&margin=%5Bobject%20Object%5D&name=%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%88monitor%EF%BC%89.png&originHeight=642&originWidth=1371&originalType=binary&ratio=1&size=69757&status=done&style=none&taskId=u318f3df8-36b9-4c8e-b5e1-34962cbe6f0" alt="管程模型（monitor）.png"><br><code>Condition</code>原理图：<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630460863915-61df5006-9b0d-4568-9bf7-db0f6be48427.png#clientId=ucf010d64-75e2-4&from=ui&id=u4b54df5f&margin=%5Bobject%20Object%5D&name=AQS-%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png&originHeight=768&originWidth=990&originalType=binary&ratio=1&size=52292&status=done&style=none&taskId=uae79d4c1-6bcf-4675-b7b8-25ee821459e" alt="AQS-条件队列.png"></p>
<h2 id="1-AQS-ConditionObject"><a href="#1-AQS-ConditionObject" class="headerlink" title="1.AQS.ConditionObject"></a>1.AQS.ConditionObject</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">//第一个等待的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">//最后一个等待的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Condition接口"><a href="#2-Condition接口" class="headerlink" title="2.Condition接口"></a>2.Condition接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-newCondition"><a href="#3-newCondition" class="headerlink" title="3.newCondition()"></a>3.newCondition()</h2><p>创建一个等待条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上这里new了一个AQS的ConditionObject。<br>​</p>
<h2 id="4-AQS-await"><a href="#4-AQS-await" class="headerlink" title="4.AQS.await"></a>4.AQS.await</h2><p>这个方法的逻辑就是先进行边界判断，如果当前线程已经被中断，就抛出中断异常。否则将当前线程封装成节点加入到条件队列，并释放全部锁资源。<br>接下来判断是否当前持有锁的线程执行了当前线程的signal方法：</p>
<ul>
<li><p>如果没有执行：当前线程就还是在条件队列，此时应当将当前线程挂起</p>
</li>
<li><p>如果执行了：当前线程就迁移到了阻塞队列，就走竞争锁的逻辑….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前线程已经被挂起，直接抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//将当前线程封装成节点加入到条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放线程的全部锁资源</span></span><br><span class="line">    <span class="comment">//为什么这里要释放掉全部的锁？</span></span><br><span class="line">    <span class="comment">//如果此时线程不释放锁资源，其他线程没办法拿到锁触发当前线程的唤醒机制</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">//中断状态：</span></span><br><span class="line">    <span class="comment">//-1:当前线程在条件队列接收到了中断信号</span></span><br><span class="line">    <span class="comment">//0:当前线程在条件队列没有接收到中断信号</span></span><br><span class="line">    <span class="comment">//1:当前线程在条件队列没有接受到中断信号，但是在阻塞队列接收到了中断信号</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果当前线程不在阻塞队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//挂起当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//判断当前线程在等待期间是否被中断过，无论是否发生中断，最终都会进入到阻塞队列</span></span><br><span class="line">        <span class="comment">//什么时候会被唤醒？都有几种情况？</span></span><br><span class="line">        <span class="comment">//1.常规：外部线程获取到lock之后，调用了signal方法，转移条件队列的头节点到阻塞队列，当这个节点获取到锁之后，会唤醒</span></span><br><span class="line">        <span class="comment">//2.转移至阻塞队列后，发现阻塞队列的前驱节点状态是取消状态，此时会唤醒当前节点</span></span><br><span class="line">        <span class="comment">//3.当前节点挂起期间，被外部线程使用中断唤醒...</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//来到这里说明当前线程已经被其他线程调用了signal方法，加入到了阻塞队列</span></span><br><span class="line">    <span class="comment">//如果当前线程在竞争锁的过程中被中断过 &amp;&amp; 中断标识位不是 throw_ie</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//将当前线程的中断标识位设置为重新中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Condition-addConditionWaiter"><a href="#5-Condition-addConditionWaiter" class="headerlink" title="5.Condition.addConditionWaiter"></a>5.Condition.addConditionWaiter</h2><p>线程进入条件队列挂起逻辑：</p>
</li>
<li><p>如果队列有元素，但是元素的状态不对，做一次全队的清理，将所有取消状态的节点干掉，并重新获取尾结点</p>
</li>
<li><p>将线程封装成node节点，判断当前条件队列是否有元素</p>
</li>
<li><p>如果没有元素，就将当前node设置为头节点</p>
</li>
<li><p>如果有元素，就将当前尾结点的next指针指向node</p>
</li>
<li><p>最终设置当前节点为尾节点，并返回当前线程的node。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取尾结点的引用</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">//条件一：尾结点！=空</span></span><br><span class="line">    <span class="comment">//条件二：尾结点的状态！=-2，说明被中断了</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">//做一次全队列的垃圾节点清理</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">//重新获取尾结点的引用，因为在刚才的清理中，尾结点可能换成新的了</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装成node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">//如果尾结点为空，说明队列为空，当前节点是进入队列的第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="comment">//队列不为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="comment">//返回当前线程封装成的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-AQS-fullyRelease"><a href="#6-AQS-fullyRelease" class="headerlink" title="6.AQS.fullyRelease"></a>6.AQS.fullyRelease</h2><p>释放当前节点线程的全部锁资源</p>
</li>
<li><p>正常情况下是会释放成功的，但是可能存在未持有锁的线程调用await方法，错误写法</p>
</li>
<li><p>这个时候，就会将当前线程对应的node状态修改为取消状态，后继线程在假如队列的时候，就会把取消状态的线程清理出去</p>
</li>
<li><p>如果成功释放了锁，会返回当前线程释放的state值，为什么要返回？</p>
</li>
<li><p>因为当前节点迁移到阻塞队列以后，再次被唤醒，并且当前节点在队列中是头节点的下一个节点而且state状态=0表示无锁，这个时候说明当前节点要去竞争锁，此时要将node的state设置为savedStated</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 完全释放锁是否成功</span></span><br><span class="line"><span class="comment">         * 当failed失败的时候，说明当前线程是未持有锁调用 await 方法的线程... 错误写法</span></span><br><span class="line"><span class="comment">         * 假设失败，在finally代码块中 会将刚刚加入到条件队列的 当前线程对应的node状态 修改为 取消状态</span></span><br><span class="line"><span class="comment">         * 后继线程就会将取消状态的节点给清理出去...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前线程持有的state值总数</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">//绝大部分情况下：release这里会返回true</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">//失败标记设置为false</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 返回当前线程释放的state值</span></span><br><span class="line"><span class="comment">                 * 为什么要返回？</span></span><br><span class="line"><span class="comment">                 * 因为当节点被迁移到阻塞队列以后，再次被唤醒，且当前node在阻塞队列中是head.next 而且</span></span><br><span class="line"><span class="comment">                 * 当前lock状态是state=0 的情况下 当前node 可以获取到锁 此时需要将state 设置为 savedState</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果失败了，就把当前节点状态改成取消</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，同步队列会触发锁的释放和重新竞争。ThreadB 获得了锁。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630862419029-14602688-1f77-44db-b755-2101985b4914.jpeg#clientId=u5cac0854-867c-4&from=ui&id=ud30730e3&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=816&originWidth=1239&originalType=binary&ratio=1&size=88026&status=done&style=none&taskId=u444eb797-a855-4bcd-8cd2-6c3bd476f32" alt="1.jpg"></p>
<h2 id="7-isOnSyncQueue"><a href="#7-isOnSyncQueue" class="headerlink" title="7.isOnSyncQueue"></a>7.isOnSyncQueue</h2><p>判断节点是否在阻塞队列</p>
</li>
<li><p>第一个if判断：</p>
</li>
<li><p>节点状态==-2说明当前节点一定在条件队列</p>
</li>
<li><p>当前节点的前驱节点为空：首先分析前置条件 node 的状态肯定不是 -2 ，可能=0或者1，等于1就说明当前节点是未持有锁的await，最终状态会被设置为取消，等于0就说明当前节点已经被持有锁的线程唤醒，但是唤醒之后是先修改状态在入队，所以前驱节点为空，说明此时是当前节点已经被唤醒，但是还未进入到阻塞队列。</p>
</li>
<li><p>执行到第二个if，当前节点的下一个节点不为空，说明一定在同步队列，为啥那？</p>
</li>
<li><p>执行到这里，可以排除掉取消状态的节点，也就是说node的状态一定不等于1，为啥？取消状态的节点不会被加入到阻塞队列</p>
</li>
<li><p>入队的两个条件：当前节点的前驱节点设置为tail，然后cas设置当前节点为tail节点，两个条件都成功了，才是真正进入到了阻塞队列</p>
</li>
<li><p>所以说，就算前驱节点不等于空，也不是一定就是进入了阻塞队列。可能在过程中。</p>
</li>
<li><p>剩下最后一种情况就是当前这个node节点可能进入到阻塞队列了，但是还不是尾结点，这个时候就需要从后往前便利找到他才行，找到了就返回true，找不到说明当前这个节点正在迁移中，返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断节点是否在阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件1：node.waitStatus==node.condition</span></span><br><span class="line"><span class="comment">         * 条件成立说明当前node一定是在条件队列，因为signal方法迁移节点到阻塞队列前，会将node的状态设置为0</span></span><br><span class="line"><span class="comment">         * 条件2：前置条件：node.waitStatus ！= Node.CONDITION ====&gt;</span></span><br><span class="line"><span class="comment">         * node.waitStatus ==0 : 表示当前节点已经被signal</span></span><br><span class="line"><span class="comment">         * node.waitStatus ==1 : 当前线程是未持有锁调用await  最终这个节点将被取消</span></span><br><span class="line"><span class="comment">         * node.waitStatus ==0 为什么还要判断 node.prev == null ？</span></span><br><span class="line"><span class="comment">         * 因为signal方法是先修改状态在迁移</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到这里，</span></span><br><span class="line"><span class="comment">         * node.waitStatus !=Condition 且 node.prev!=null ====&gt; 可以排除掉 node.waitStatus ==1 取消状态</span></span><br><span class="line"><span class="comment">         * 为什么可以排除掉取消状态？因为signal方法是不会吧取消状态的节点迁移走的</span></span><br><span class="line"><span class="comment">         * 设置prev引用的逻辑是迁移阻塞队列 逻辑的设置的 eng方法</span></span><br><span class="line"><span class="comment">         * 入队的逻辑：1.设置node.prev =tail</span></span><br><span class="line"><span class="comment">         * 2.cas当前node为 阻塞队列的tail节点成功才算是真正的进入到阻塞队列</span></span><br><span class="line"><span class="comment">         * 可以推算出，就算是prev不是null，也不能说明当前node已经成功入队到阻塞队列了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//执行到这里从阻塞队列的尾巴开始向前遍历查找node，找到了就返回true，找不到返回false，</span></span><br><span class="line">    <span class="comment">//当前node有可能正在迁移中，还未完成。</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-signal"><a href="#8-signal" class="headerlink" title="8.signal"></a>8.signal</h2></li>
<li><p>首先当前线程持有的必须是独占锁，否则没有必要进入到阻塞队列，所以如果不是独占锁，会抛出异常。</p>
</li>
<li><p>获取到条件队列的头节点，如果头节点不为空，就说明条件队列里面有节点，去唤醒条件队列的第一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前线程是不是持有的独占锁，如果不是，直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//获取条件队列的首节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="comment">//如果首节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);<span class="comment">//唤醒条件队列的首节点线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-doSignal"><a href="#9-doSignal" class="headerlink" title="9.doSignal"></a>9.doSignal</h2></li>
<li><p>如果头节点的下一个节点为空，说明头节点出队之后，头节点，尾结点都会是空，也就是条件队列没有元素了。</p>
</li>
<li><p>断开当前头节点的next</p>
</li>
<li><p>调用transferForSignal方法去迁移头节点到阻塞队列，如果成功返回true，失败返回false。</p>
</li>
<li><p>循环的条件是：如果当前头节点迁移失败了，那就将头节点设置为当前头节点的下一个节点继续尝试，直到迁移成功或者头节点为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//当前first马上要出队了，所以更新firstWaiter为当前节点的下一个节点</span></span><br><span class="line">        <span class="comment">//如果当前节点的下一个节点是null，说明条件队列只有当前一个节点了...当前出队后，整个队列就空了</span></span><br><span class="line">        <span class="comment">//所以需要更新lastWaiter==null</span></span><br><span class="line">        <span class="keyword">if</span>((firstWaiter=first.nextWaiter)==<span class="keyword">null</span>) lastWaiter=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//当前节点即将出队列，断开和下一个节点的关系</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * transferForSignal(first) 返回true 当前first节点迁移到阻塞队列成功 false 迁移失败</span></span><br><span class="line"><span class="comment">                 * while循环：(first =firstWaiter)!=null 当前first 迁移失败 ，则将first更新为first.next 继续尝试迁移</span></span><br><span class="line"><span class="comment">                 * 直至迁移某个节点成功，或者条件队列为 null 为止。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first)&amp;&amp;(first =firstWaiter)!=<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-transferForSignal"><a href="#10-transferForSignal" class="headerlink" title="10.transferForSignal"></a>10.transferForSignal</h2><p>接收到signal信号以后，把节点转入等待队列</p>
</li>
<li><p>首先上来先cas将node的状态从-2设置为0，设置成功才继续往下，那么什么时候会设置失败呢？</p>
</li>
<li><p>当前节点是取消状态，或者当前节点的线程在挂起期间被其他线程使用中断信号唤醒过，这个时候节点会进入到阻塞队列，这个时候节点的状态也会修改成0</p>
</li>
<li><p>使用enq方法添加当前节点到阻塞队列，并返回当前节点的前驱节点</p>
</li>
<li><p>如果前驱节点的状态大于0就说明前驱结点的状态是取消状态，</p>
</li>
<li><p>第二个条件的前置条件就是前驱节点状态小于0，cas设置前驱节点为signal，</p>
</li>
<li><p>如果条件一或者条件二成立一个，那就唤醒当前节点的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到signal信号后，把节点转入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * cas修改当前节点的状态，修改为0，因为当前节点马上要迁移到阻塞队列了</span></span><br><span class="line"><span class="comment">         * 成功：当前节点在条件队列中状态正常</span></span><br><span class="line"><span class="comment">         * 失败：</span></span><br><span class="line"><span class="comment">         *      1.取消状态 （线程await时，未持有锁，最终线程对应的node将会被设置为取消状态）</span></span><br><span class="line"><span class="comment">         *      2.node对应的线程 挂起期间，被其他线程使用中断信号唤醒过...（就会主动进入到阻塞队列，这时</span></span><br><span class="line"><span class="comment">         *      也会修改状态为0）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//添加节点到等待队列，并返回节点的前继节点(prev)</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">//ws:前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件1：ws&gt;0成立：说明前驱节点的状态在阻塞队列中是取消状态，唤醒当前节点</span></span><br><span class="line"><span class="comment">         * 条件2：前置条件 ws&lt;=0</span></span><br><span class="line"><span class="comment">         * cas 返回true表示设置前驱节点状态为signal状态成功</span></span><br><span class="line"><span class="comment">         * cas返回false，什么时候返回false？</span></span><br><span class="line"><span class="comment">         * 当前驱node对应的线程是lockInterrupt入队的node时，是会响应中断的，外部线程给前驱线程中断信号之后</span></span><br><span class="line"><span class="comment">         * 前驱node会将状态修改为 取消状态，并且执行出队逻辑...</span></span><br><span class="line"><span class="comment">         * 前驱节点状态只要不是0 或者 -1 ，那么就唤醒当前线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">//如果前节点被取消，说明当前为最后一个等待线程，unpark唤醒当前线程</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="comment">//如果 node 的 prev 节点已经是signal 状态，那么被阻塞的 ThreadA 的唤醒工作由 AQS 队列来完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完 doSignal 以后，会把 condition 队列中的节点转移到 aqs 队列上，逻辑结构图如下，这个时候会判断 ThreadA 的 prev 节点也就是 head 节点的 waitStatus，如果大于 0 或者设置 SIGNAL 失败，表示节点被设置成了 CANCELLED 状态。这个时候会唤醒ThreadA 这个线程。否则就基于 AQS 队列的机制来唤醒，也就是等到 ThreadB 释放锁之后来唤醒 ThreadA。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630862618418-958b17ed-a54d-449f-848d-ec27b9b96432.jpeg#clientId=u5cac0854-867c-4&from=ui&id=u8bc6d86f&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=917&originWidth=1241&originalType=binary&ratio=1&size=90741&status=done&style=none&taskId=uc1895115-5d1b-4bfe-ae1a-bebcdb46e51" alt="1.jpg"></p>
</li>
</ul>
<p><strong>再往下就是被阻塞的线程唤醒之后的逻辑。</strong><br><strong>​</strong></p>
<h2 id="11-AQS-await"><a href="#11-AQS-await" class="headerlink" title="11.AQS.await"></a>11.AQS.await</h2><p><strong>​</strong></p>
<p>前面在分析 await 方法时，线程会被阻塞。而通过 signal被唤醒之后又继续回到上次执行的逻辑中。<br>​</p>
<p>checkInterruptWhileWaiting 这个方法是干嘛呢？其实从名字就可以看出来，就是 ThreadA 在 condition 队列被阻塞的过程中，有没有被其他线程触发过中断请求。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//表示 await 允许被中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();<span class="comment">//创建一个新的节点，节点状态为 condition，采用的数据结构仍然是链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放当前的锁，得到锁的状态，并唤醒 AQS 队列中的一个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果当前节点没有在同步队列上，即还没有被 signal，则将当前线程阻塞</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;<span class="comment">//判断这个节点是否在 AQS 队列上，第一次判断的是 false，因为前面已经释放锁了</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);<span class="comment">//通过 park 挂起当前线程</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当这个线程醒来,会尝试拿锁, 当 acquireQueued返回 false 就是拿到锁了.</span></span><br><span class="line">    <span class="comment">// interruptMode != THROW_IE -&gt; 表示这个线程没有成功将 node 入队,但 signal 执行了 enq 方法让其入队了.</span></span><br><span class="line">    <span class="comment">// 将这个变量设置成 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 如果 node 的下一个等待者不是 null, 则进行清理,清理 Condition 队列上的节点.</span></span><br><span class="line">    <span class="comment">// 如果是 null ,就没有什么好清理的了.</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果线程被中断了,需要抛出异常.或者什么都不做</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-checkInterruptWhileWaiting"><a href="#12-checkInterruptWhileWaiting" class="headerlink" title="12.checkInterruptWhileWaiting"></a>12.checkInterruptWhileWaiting</h2><p>​</p>
<p>如果当前线程被中断，则调用transferAfterCancelledWait 方法判断后续的处理应该是抛出 InterruptedException 还是重新中断。<br>​</p>
<p>这里需要注意的地方是，如果第一次 CAS 失败了，则不能判断当前线程是先进行了中断还是先进行了 signal 方法的调用，可能是先执行了 signal 然后中断，也可能是先执行了中断，后执行了 signal，当然，这两个操作肯定是发生在 CAS 之前。这时需要做的就是等待当前线程的 node被添加到 AQS 队列后，也就是 enq 方法返回后，返回false 告诉 checkInterruptWhileWaiting 方法返回REINTERRUPT(1)，后续进行重新中断。<br>​</p>
<p>简单来说，该方法的返回值代表当前线程是否在 park 的时候被中断唤醒，如果为 true 表示中断在 signal 调用之前，signal 还未执行，那么这个时候会根据 await 的语义，在 await 时遇到中断需要抛出interruptedException，返回 true 就是告诉checkInterruptWhileWaiting 返回 THROW_IE(-1)。如果返回 false，否则表示 signal 已经执行过了，只需要重新响应中断即可。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 cas 修改节点状态，如果还能修改成功，说明线程被中断时，signal 还没有被调用。</span></span><br><span class="line"><span class="comment">// 这里有一个知识点，就是线程被唤醒，并不一定是在 java 层面执行了locksupport.unpark，也可能是调用了线程的 interrupt()方法，这个方法会更新一个中断标识，并且会唤醒处于阻塞状态下的线程。</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);<span class="comment">//如果 cas 成功，则把node 添加到 AQS 队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果 cas 失败，则判断当前 node 是否已经在 AQS 队列上，如果不在，则让给其他线程执行</span></span><br><span class="line"><span class="comment">// 当 node 被触发了 signal 方法时， node 就会被加到 aqs 队列上</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))<span class="comment">//循环检测 node 是否已经成功添加到 AQS 队列中。如果没有，则通过 yield</span></span><br><span class="line">        Thread.yield();<span class="comment">//使当前线程由执行状态，变成为就绪状态，让出cpu时间，在下一个线程执行时候，此线程有可能被执行，也有可能没有被执行。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-AQS-acquireQueued"><a href="#12-AQS-acquireQueued" class="headerlink" title="12.AQS.acquireQueued"></a>12.AQS.acquireQueued</h2><p>​</p>
<p>这个方法是当前被唤醒的节点ThreadA 去抢占同步锁。并且要恢复到原本的重入次数状态。调用完这个方法之后，AQS 队列的状态如下：<br>​</p>
<p>将 head 节点的 waitStatus 设置为-1，Signal 状态。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1630862853399-f6232b9c-3eae-49e5-a562-56a45d28cac9.jpeg#clientId=u5cac0854-867c-4&from=ui&id=ua5cd85c7&margin=%5Bobject%20Object%5D&name=1.jpg&originHeight=892&originWidth=1245&originalType=binary&ratio=1&size=92022&status=done&style=none&taskId=u2a83c204-6ac9-4b00-9175-45c5de5beaa" alt="1.jpg"></p>
<h2 id="12-reportInterruptAfterWait"><a href="#12-reportInterruptAfterWait" class="headerlink" title="12.reportInterruptAfterWait"></a>12.reportInterruptAfterWait</h2><p>根据 checkInterruptWhileWaiting 方法返回的中断标识来进行中断上报。</p>
<p>如果是 THROW_IE，则抛出中断异常。<br>​</p>
<p>如果是 REINTERRUPT，则重新响应中断。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-总结与梳理"><a href="#13-总结与梳理" class="headerlink" title="13.总结与梳理"></a>13.总结与梳理</h2><p>线程 awaitThread 先通过 lock.lock()方法获取锁成功后调用了 condition.await 方法进入等待队列，而另一个线程 signalThread 通过 lock.lock()方法获取锁成功后调用了 condition.signal 或者 signalAll 方法，使得线程awaitThread 能够有机会移入到同步队列中，当其他线程释放 lock 后使得线程 awaitThread 能够有机会获取lock，从而使得线程 awaitThread 能够从 await 方法中退出执行后续操作。如果 awaitThread 获取 lock 失败会直接进入到同步队列。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1630863760742-f0125f3f-0b8e-4483-8ed3-46dbd93f3e42.png#clientId=u5cac0854-867c-4&from=paste&height=303&id=u325a5b2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=606&originWidth=1330&originalType=binary&ratio=1&size=261083&status=done&style=none&taskId=ua0ca24f9-2399-4b81-9699-1a371009245&width=665" alt="image.png"><br>​</p>
<p>阻塞：await()方法中，在线程释放锁资源之后，如果节点不在 AQS 等待队列，则阻塞当前线程，如果在等待队列，则自旋等待尝试获取锁。<br>​</p>
<p>释放：signal()后，节点会从 condition 队列移动到 AQS等待队列，则进入正常锁的获取流程。<br>​</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/11/JUC/AQS/">https://yinhuidong.github.io/2022/01/11/JUC/AQS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/juc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/JUC/ReentrantReadWriteLock/"><img class="prev-cover" src="/images/cover/juc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ReentrantReadWriteLock</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/11/JUC/CompletableFuture/"><img class="next-cover" src="/images/cover/juc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CompletableFuture</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/11/JUC/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/" title="Atomic原子类"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Atomic原子类</div></div></a></div><div><a href="/2022/01/11/JUC/CAS%E5%8E%9F%E7%90%86/" title="CAS原理"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CAS原理</div></div></a></div><div><a href="/2022/01/11/JUC/CountDownLatch/" title="CountDownLatch"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CountDownLatch</div></div></a></div><div><a href="/2022/01/11/JUC/LongAdder/" title="LongAdder"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">LongAdder</div></div></a></div><div><a href="/2022/01/11/JUC/FutureTask/" title="FutureTask"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">FutureTask</div></div></a></div><div><a href="/2022/01/11/JUC/CyclicBarrier/" title="CyclicBarrier"><img class="cover" src="/images/cover/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">CyclicBarrier</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8CLock"><span class="toc-text">一，Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lock%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.Lock的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Lock%E7%9A%84%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-text">2.Lock的类关系图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CReentrantLock"><span class="toc-text">二，ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-text">1.重入锁的设计目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ReentrantLock%E4%BD%BF%E7%94%A8"><span class="toc-text">2.ReentrantLock使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ReentrantReadWriteLock"><span class="toc-text">3.ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CReentrantLock-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">三，ReentrantLock 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.AQS是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AQS%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">2.AQS的两种功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AQS%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.AQS的内部实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Node%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">4.Node的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%87%8A%E6%94%BE%E9%94%81%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">5.释放锁以及添加线程对于队列的变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%EF%BC%8CReentrantLock-%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">四，ReentrantLock 的源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8A%A0%E9%94%81%E9%80%BB%E8%BE%91"><span class="toc-text">1.加锁逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-lock"><span class="toc-text">ReentrantLock.lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NonfairSync-lock"><span class="toc-text">NonfairSync.lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-acquire"><span class="toc-text">AQS.acquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-selfInterrupt"><span class="toc-text">AQS.selfInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-tryAcquire"><span class="toc-text">AQS.tryAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NonfairSync-tryAcquire"><span class="toc-text">NonfairSync.tryAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-nofairTryAcquire"><span class="toc-text">ReentrantLock.nofairTryAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-addWaiter"><span class="toc-text">AQS.addWaiter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-enq"><span class="toc-text">AQS.enq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-acquireQueued"><span class="toc-text">AQS .acquireQueued</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-shouldParkAfterFailedAcquire"><span class="toc-text">AQS.shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-parkAndCheckInterrupt"><span class="toc-text">AQS.parkAndCheckInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-cancelAcquire"><span class="toc-text">AQS.cancelAcquire</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">2.释放锁的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-unlock"><span class="toc-text">ReentrantLock.unlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-release"><span class="toc-text">AQS.release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-tryRelease"><span class="toc-text">ReentrantLock.tryRelease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-unparkSuccessor"><span class="toc-text">AQS.unparkSuccessor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.公平锁和非公平锁的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FairSync-tryAcquire"><span class="toc-text">FairSync.tryAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FairSync-tryAcquire-1"><span class="toc-text">FairSync .tryAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hasQueuedPredecessors"><span class="toc-text">hasQueuedPredecessors</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%EF%BC%8CCondition-%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-text">五，Condition 条件队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-AQS-ConditionObject"><span class="toc-text">1.AQS.ConditionObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Condition%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.Condition接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-newCondition"><span class="toc-text">3.newCondition()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-AQS-await"><span class="toc-text">4.AQS.await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Condition-addConditionWaiter"><span class="toc-text">5.Condition.addConditionWaiter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-AQS-fullyRelease"><span class="toc-text">6.AQS.fullyRelease</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-isOnSyncQueue"><span class="toc-text">7.isOnSyncQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-signal"><span class="toc-text">8.signal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-doSignal"><span class="toc-text">9.doSignal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-transferForSignal"><span class="toc-text">10.transferForSignal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-AQS-await"><span class="toc-text">11.AQS.await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-checkInterruptWhileWaiting"><span class="toc-text">12.checkInterruptWhileWaiting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-AQS-acquireQueued"><span class="toc-text">12.AQS.acquireQueued</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-reportInterruptAfterWait"><span class="toc-text">12.reportInterruptAfterWait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A2%B3%E7%90%86"><span class="toc-text">13.总结与梳理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/24/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E5%9B%9B%5D%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL[二十四]两阶段提交"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十四]两阶段提交"/></a><div class="content"><a class="title" href="/2022/01/24/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E5%9B%9B%5D%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL[二十四]两阶段提交">MySQL[二十四]两阶段提交</a><time datetime="2022-01-23T16:00:00.000Z" title="发表于 2022-01-24 00:00:00">2022-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/" title="MySQL[二十三]二进制日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十三]二进制日志"/></a><div class="content"><a class="title" href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/" title="MySQL[二十三]二进制日志">MySQL[二十三]二进制日志</a><time datetime="2022-01-22T16:00:00.000Z" title="发表于 2022-01-23 00:00:00">2022-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/22/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%BA%8C%5DCOUNT/" title="MySQL[二十二]COUNT"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十二]COUNT"/></a><div class="content"><a class="title" href="/2022/01/22/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%BA%8C%5DCOUNT/" title="MySQL[二十二]COUNT">MySQL[二十二]COUNT</a><time datetime="2022-01-21T16:00:00.000Z" title="发表于 2022-01-22 00:00:00">2022-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%80%5DLIMIT/" title="MySQL[二十一]LIMIT"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十一]LIMIT"/></a><div class="content"><a class="title" href="/2022/01/21/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%80%5DLIMIT/" title="MySQL[二十一]LIMIT">MySQL[二十一]LIMIT</a><time datetime="2022-01-20T16:00:00.000Z" title="发表于 2022-01-21 00:00:00">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十]海量数据处理"/></a><div class="content"><a class="title" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理">MySQL[二十]海量数据处理</a><time datetime="2022-01-19T16:00:00.000Z" title="发表于 2022-01-20 00:00:00">2022-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/juc.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>