<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL[三]InnoDB索引结构</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>索引其实就是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】。<br>​</p><blockquote><p>为什么有页的概念？<br>​</p></blockquote><blockquote><p>查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p></blockquote><p>​</p><p>数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。<br>​</p><blockquote><p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796442070-30497473-d6d6-4848-9622-3ef7c4be8eab.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5dd411f3&margin=%5Bobject%20Object%5D&name=%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.jpg&originHeight=816&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24988&status=done&style=shadow&taskId=u7ea9c417-2241-4f50-b784-ce1b7ae3a67&title=" alt="索引的层级关系.jpg"></p><p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p><h1 id="一，行格式"><a href="#一，行格式" class="headerlink" title="一，行格式"></a>一，行格式</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p><h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><p>比如我们创建一张表来指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="keyword">VALUES</span>(<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="string">&#x27;eeee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>首先我们来看Compact行格式。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796457336-bb5e4bf7-0f44-4c11-9580-32077f221ac3.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u510eb047&margin=%5Bobject%20Object%5D&name=Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=513&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108011&status=done&style=shadow&taskId=u3c55f797-d70f-44c7-bc54-b58728aaeaf&title=" alt="Compact行格式示意图.png"></p><p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p><h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>额外的信息实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p><h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】。</p><blockquote><p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p></blockquote><p>在Compact行格式中，会把所有的变长字段占用的真实长度全部<strong>逆序</strong>存储在记录的开头位置，形成一个变长字段长度列表。</p><p>比如我们刚才创建的那张表，我们来分析一下：</p><p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p><table><thead><tr><th>列名</th><th>储存内容</th><th>内容长度(十进制表示)</th><th>内容长度(十六进制表示)</th></tr></thead><tbody><tr><td>C1</td><td>‘aaaa’</td><td>4</td><td>0x04</td></tr><tr><td>C2</td><td>‘bbb’</td><td>3</td><td>0x03</td></tr><tr><td>C4</td><td>‘d’</td><td>1</td><td>0x01</td></tr></tbody></table><p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796496893-933ea1aa-d845-4f94-9328-beff8d57dbc4.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8653fe78&margin=%5Bobject%20Object%5D&name=%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=471&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96980&status=done&style=shadow&taskId=u7e13eb1a-bbe3-4c44-8f4e-7237f99dd6f&title=" alt="第一条记录的存储格式.png"></p><p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p><p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p><p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p><p>【L】：真实占用的字节数</p><ol><li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li></ol><blockquote><p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p></blockquote><ol start="2"><li>如果M*W&gt;=255,这个时候再次分为两种情况： <ol><li>如果L&lt;=127，那就用1个字节表示</li><li>否则就用2个字节表示</li></ol></li></ol><blockquote><p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p><p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p><p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p></blockquote><p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p><p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p><h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p><p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p><p>看一下处理过程：</p><ol><li>首先统计出表中允许存储NULL的字段</li><li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li><li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li></ol><p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p><p>这个时候再来看我们上面创建的表中的记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796522793-2b2f0b54-2e1b-4534-97fc-ad5d2ae29267.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua59c3787&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=578&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116004&status=done&style=shadow&taskId=u474c254b-e5cb-420c-939e-50e0762c364&title=" alt="表中记录的存储格式.png"></p><h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651393775-13c8a071-3007-4743-98e6-6bfadf766833.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=nEsCg&originHeight=238&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>接下来来看记录的真实数据。</p><h3 id="2-2-真实数据"><a href="#2-2-真实数据" class="headerlink" title="2.2 真实数据"></a>2.2 真实数据</h3><p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p><p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p><p>在完善下我们开头创建的那张表的记录形象。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651419885-ccc53e84-579f-4e2b-aaa3-c2da800dcf5b.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=EzoHh&originHeight=480&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p><h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p><p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p><blockquote><p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p></blockquote><h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p><h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p><p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p><ol><li>真实数据</li><li>真实数据占用的字节长度</li><li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li></ol><p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p><p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p><blockquote><p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p></blockquote><h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651449173-c7c3df4a-7697-4e98-8461-0f4d8fa25acf.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=YE1nR&originHeight=698&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651459938-08f5b09b-16a1-4981-b0db-58ce8c2776fd.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=yQ6dC&originHeight=427&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p><h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p><p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p><p>分析一下页空间是如何利用的</p><ol><li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li><li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：<table><thead><tr><th>内容</th><th>大小(字节)</th></tr></thead><tbody><tr><td>真实数据的长度</td><td>2</td></tr><tr><td>列是否是NULL值</td><td>1</td></tr><tr><td>头信息</td><td>5</td></tr><tr><td>row_id</td><td>6</td></tr><tr><td>transaction_id</td><td>6</td></tr><tr><td>roll_pointer</td><td>7</td></tr></tbody></table></li></ol><p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p><h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651470552-ca5845c2-4a02-4778-8072-12e7cfc5e936.png#crop=0&crop=0&crop=1&crop=1&id=DwYBu&originHeight=456&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p><blockquote><p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p></blockquote><h1 id="二，页的存储结构"><a href="#二，页的存储结构" class="headerlink" title="二，页的存储结构"></a>二，页的存储结构</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p><p>本节分析存放表中记录的页，官方成为索引页，为了分析方便，我们暂且叫做数据页。</p><blockquote><p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p></blockquote><p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796599016-6db7f08f-012c-4991-beb7-f86a02b783e9.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u24a51a9d&margin=%5Bobject%20Object%5D&name=%E8%A1%8C%E6%A0%BC%E5%BC%8F%26%E9%A1%B5%E7%BB%93%E6%9E%84.png&originHeight=1924&originWidth=2164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=761701&status=done&style=shadow&taskId=ua68b2010-2f09-4933-82b5-8624ccfa018&title=" alt="行格式&amp;页结构.png"></p><p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页专有的一些信息</td></tr><tr><td>Infifmum + Supremum</td><td>最小记录和最大记录</td><td>26</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658751624-f2ae040c-521a-4279-a33a-3d049076dbbb.png#crop=0&crop=0&crop=1&crop=1&id=rhsyy&originHeight=443&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>再次回顾下记录头中5个字节表示的数据。</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>针对当前这个表的行格式简化图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658929002-26d8d2aa-f31f-4424-9364-53bb1e935f02.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=JuPWk&originHeight=328&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>接下来我们往表中插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639659360000-9ea955da-a191-4149-a654-02130cd27262.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=IQRli&originHeight=511&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>分析一下头信息中的每个属性是什么意思。</p><h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p><p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p><blockquote><p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p></blockquote><h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p><h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p><p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p><p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p><p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660568126-eca45a45-699f-4c18-a914-9b0082e4409e.png#crop=0&crop=0&crop=1&crop=1&id=Qa0fp&originHeight=341&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660690280-f21f9cde-a88c-43b7-bed2-e61cdf99821c.png#crop=0&crop=0&crop=1&crop=1&id=yv4uT&originHeight=417&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p><h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p><p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p><h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661137395-fec2e2b7-c0d0-4ecd-8cf0-ff73e86cd98b.png#crop=0&crop=0&crop=1&crop=1&id=GEIoi&originHeight=509&originWidth=1025&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>删除第二条记录以后：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661263287-6bf68c5d-2b08-49f7-9b64-91ff84f8c25f.png#crop=0&crop=0&crop=1&crop=1&id=ehUJN&originHeight=472&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>发生的变化：</p><ul><li>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</li><li>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</li><li>第一条记录的next record指向了第三条记录</li><li>最大记录的 n_owned 值从5 变成了4</li></ul><p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p><p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p><p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p><p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661938956-dbc09fae-e330-4b44-a97c-ad28500fb0c0.png#crop=0&crop=0&crop=1&crop=1&id=N59w2&originHeight=516&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p><h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol><li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li><li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li><li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li></ol><p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663655164-28caa8e4-aceb-4b4e-aaaf-75ab188453c9.png#crop=0&crop=0&crop=1&crop=1&id=xFmTO&originHeight=481&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p><p>注意最大和最小记录的头信息的n_owned属性：</p><ol><li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li><li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li></ol><p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663745413-7924a9ec-b680-4231-8686-eb99c41946df.png#crop=0&crop=0&crop=1&crop=1&id=k3iqz&originHeight=541&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。所以分组是按照下边的步骤进行的：</p><ul><li> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </li><li> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li><li> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663920121-ec3b0a9f-f512-432d-a584-fb3187b0a0bf.png#crop=0&crop=0&crop=1&crop=1&id=caRNN&originHeight=632&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ol><h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p><p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p><h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p><p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p><ol><li>前四个字节代表校验和</li><li>后四个字节代表页面被最后修改时对应的日志序列位置</li></ol><p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p><blockquote><p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p></blockquote><h1 id="三，索引"><a href="#三，索引" class="headerlink" title="三，索引"></a>三，索引</h1><h2 id="1-假如没有索引"><a href="#1-假如没有索引" class="headerlink" title="1.假如没有索引"></a>1.假如没有索引</h2><p>我们先来看看没有索引的情况下，我们进行数据的查找(毕竟没有对比就没有伤害)。</p><h3 id="1-1-在一个页中查找"><a href="#1-1-在一个页中查找" class="headerlink" title="1.1 在一个页中查找"></a>1.1 在一个页中查找</h3><p>假设表中的记录很少，所有的记录仅仅用一个页就存放下了，这个时候按照不同的搜索条件其实可以分为两种情况讨论：</p><p>【以主键为搜索的条件】：可以再页目录中根据二分查找快速定位到槽，在根据槽定位到该组的最小索引记录，然后进行遍历匹配查找。</p><p>【以其他列作为搜索条件】：在数据页中并没有为非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。在这种情况下，只能从最小记录开始依次往后遍历单链表中的每条记录，然后对比每条记录是否符合搜索条件，显然，效率很低。</p><h3 id="1-2-在很多页中查找"><a href="#1-2-在很多页中查找" class="headerlink" title="1.2 在很多页中查找"></a>1.2 在很多页中查找</h3><p>很多时候，表的记录一个页都是存储不下的，这个时候的查找其实分为两个步骤：</p><p>【定位到记录所在的页】</p><p>【从所在的页内查找相应的记录】</p><p>因为我们不能快速的定位到所在的页，所以只能从第一页开始沿着双链表往后遍历定位页，定位到页以后在根据在一个页中的查找方式进行匹配查找，显而易见，这个时候效率低的可怕。</p><blockquote><p>有了痛点，就会有大牛去思考整个生命周期，完善逻辑和资源倾斜，形成一套自己的方法论，想办法为快速查找赋能。</p></blockquote><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>我们先创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><h3 id="2-1-一个简单的索引方案"><a href="#2-1-一个简单的索引方案" class="headerlink" title="2.1 一个简单的索引方案"></a>2.1 一个简单的索引方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？</p><p>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <strong><em>不得不</em></strong> 依次遍历所有的数据页。</p><p>如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？</p><p>对比根据主键值快速定位一条记录从而在页中的位置建立页目录，我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录。</p><p>【<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。】</p><p>假设我们现在每一页只能放三条记录，现在已经放了主键为1,3,5的三条记录。这个时候我们再添加一条主键为4的记录，我们不得不为他分配一个新的页。</p><blockquote><p>注意：新分配的数据页编号可能和原来并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。他们只是通过维护着上一页和下一页的编号而建立了链表关系。</p></blockquote><p>原来页中主键最大的值为5，现在我们新插入一条记录，如果直接放在新页里面，那就会有问题，这不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值得要求，所以在插入主键值为4 的记录的时候需要伴随一次记录的移动，也就是把主键值为5 的记录移动到新分配的页中，然后把主键值为4 的记录插入到原来的页中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796706858-85d2f635-d8a4-40cf-96ad-d575a4929471.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua72ea1d2&margin=%5Bobject%20Object%5D&name=%E9%A1%B5%E5%88%86%E8%A3%82.png&originHeight=689&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27916&status=done&style=shadow&taskId=u163f5ce3-dbab-47a0-bad4-ed0af4cae2f&title=" alt="页分裂.png"></p><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为<code>页分裂</code>。</p><p>【<strong>给所有的页建立一个目录项。</strong>】</p><p>由于数据页的编号可能并不是连续的，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796721543-59286c6b-be1f-4bf0-89c0-3c9d783caf2c.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7a2de81e&margin=%5Bobject%20Object%5D&name=%E6%8F%92%E5%85%A5%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E6%83%85%E6%99%AF.png&originHeight=206&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17346&status=done&style=shadow&taskId=ue4ddf3bb-d1ea-41aa-a3e4-48daab58dfa&title=" alt="插入多条记录后的情景.png"></p><p>因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p><ol><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li><li>页号，我们用<code>page_no</code>表示。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796747935-7d4d34c8-1163-4cae-8461-f44007b8fc07.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uafd00c0b&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BB%BA%E7%AB%8B%E7%9B%AE%E5%BD%95.png&originHeight=537&originWidth=1081&originalType=binary&ratio=1&rotation=0&showTitle=false&size=211150&status=done&style=none&taskId=u664861d2-e96c-4b27-9d3e-0df0e0538f5&title=" alt="推理索引-建立目录.png"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</li><li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录其实就是【索引】。</p><h3 id="2-2-InnoDB中的索引方案"><a href="#2-2-InnoDB中的索引方案" class="headerlink" title="2.2 InnoDB中的索引方案"></a>2.2 InnoDB中的索引方案</h3><p>上面的方案存在什么样的问题？</p><ul><li><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下。</li></ul><p>InnoDB复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。</p><p>那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？通过记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>**1**</code><strong>：目录项记录</strong></li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796769647-30add870-277e-46a6-b85f-eb81c9fffd78.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udd4ebea4&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BC%95%E5%87%BA%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=477&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245132&status=done&style=shadow&taskId=u5c27ff4c-5fe6-43bc-8fc3-5bbf4ebce0e&title=" alt="推理索引-引出目录项记录.png"></p><p>从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</li><li><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>头信息里面有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p>除此之外，两者就没有区别了，页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li><li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li></ol><blockquote><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p><p><strong>当然是再多整一个存储</strong><code>**目录项记录**</code><strong>的页。</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796794024-3c603a8c-379a-4741-b43f-0d09f823f3db.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u74247d36&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=423&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206755&status=done&style=shadow&taskId=uf9035595-4bd9-4c46-8e69-5fa3ae1bf3e&title=" alt="推理索引-多目录项记录.png"></p><p>从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前边假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li>确定<code>目录项记录</code>页</li></ol><blockquote><p>我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></blockquote><ol start="2"><li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？</p><p>为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796830733-a6cde000-9332-4f5a-8a83-0f7e8303a427.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5af42117&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95.png&originHeight=565&originWidth=888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246476&status=done&style=shadow&taskId=ub41ee0ab-63de-4476-9f1f-a9ecedd9f1f&title=" alt="推理索引-多级目录.png"></p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796848198-e8ce79c1-5f89-473a-97bf-03b44b900c28.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b765b2b&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png&originHeight=483&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27024&status=done&style=shadow&taskId=u8446b051-6d0e-476f-acb2-2a089be6d78&title=" alt="多路平衡二叉树.png"></p><p>其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上边的那个节点也称为<code>根节点</code>。</p><p>从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，<code>InnoDB</code>规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的分析我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p><ul><li>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</li><li>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</li><li>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。</li></ul><p>一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录。</p><h3 id="2-3-聚簇索引"><a href="#2-3-聚簇索引" class="headerlink" title="2.3 聚簇索引"></a>2.3 聚簇索引</h3><p>上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li> 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </li></ol><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul><ol start="2"><li> <code>B+</code>树的叶子节点存储的是完整的用户记录。<br>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </li></ol><p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建，<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的<strong>索引即数据，数据即索引</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796876199-b11195b7-5f43-49e4-95b4-9f16f805b7c2.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc673077f&margin=%5Bobject%20Object%5D&name=B%2B%E6%A0%91%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.jpg&originHeight=1878&originWidth=2947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=414971&status=done&style=shadow&taskId=ue286f0f6-c6f0-48b5-a853-ab5a88d3867&title=" alt="B+树主键索引.jpg"></p><h3 id="2-4-二级索引"><a href="#2-4-二级索引" class="headerlink" title="2.4 二级索引"></a>2.4 二级索引</h3><p><code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p><p>我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797313347-a44afddd-2c1b-4011-acc5-577ff4416285.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u807c5795&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png&originHeight=580&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=250264&status=done&style=shadow&taskId=uffdaff61-f70c-4ca9-b584-bb4c6ec8250&title=" alt="二级索引.png"></p><p>这个<code>B+</code>树与上边介绍的聚簇索引有几处不同：</p><ol><li> 使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义： </li><li>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li> <code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。 </li><li> 目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。 </li></ol><p>所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li>确定<code>目录项记录</code>页</li></ol><blockquote><p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p></blockquote><ol start="2"><li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li></ol><blockquote><p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p></blockquote><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录.</li></ol><blockquote><p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p></blockquote><ol start="4"><li>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li></ol><p><strong>我们根据这个以</strong><code>**c2**</code><strong>列大小排序的</strong><code>**B+**</code><strong>树只能确定我们要查找记录的主键值，所以如果我们想根据</strong><code>**c2**</code><strong>列的值查找到完整的用户记录的话，仍然需要到</strong><code>**聚簇索引**</code><strong>中再查一遍，这个过程也被称为</strong><code>**回表**</code><strong>。</strong>也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p><p>为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？</p><p>如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为为c2列建立的索引。</p><p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p><p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p><h3 id="2-5-联合索引"><a href="#2-5-联合索引" class="headerlink" title="2.5 联合索引"></a>2.5 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li></ul><p>为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797330214-15ee3ffb-1ebd-41aa-a48a-6c81ea92814d.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42fac64f&margin=%5Bobject%20Object%5D&name=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png&originHeight=599&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264505&status=done&style=shadow&taskId=uaa1c9645-b635-4e8f-a3d7-7942580366d&title=" alt="联合索引.png"></p><h2 id="3-InnoDB的B-树索引的注意事项"><a href="#3-InnoDB的B-树索引的注意事项" class="headerlink" title="3. InnoDB的B+树索引的注意事项"></a>3. InnoDB的B+树索引的注意事项</h2><h3 id="3-1-跟页面永远固定不动"><a href="#3-1-跟页面永远固定不动" class="headerlink" title="3.1 跟页面永远固定不动"></a>3.1 跟页面永远固定不动</h3><p>前边介绍<code>B+</code>树索引的时候，为了理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p><ul><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程需要特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p><h3 id="3-2-内节点中目录项记录的唯一性"><a href="#3-2-内节点中目录项记录的唯一性" class="headerlink" title="3.2 内节点中目录项记录的唯一性"></a>3.2 内节点中目录项记录的唯一性</h3><p>我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。假设表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797360116-ea5f9dc7-74cc-4191-ae4d-dd56cd80b6f5.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u817bb64e&margin=%5Bobject%20Object%5D&name=%E4%B8%BAc2%E5%BB%BA%E7%AB%8B%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%90%8E%E7%9A%84%E6%A0%91.png&originHeight=434&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77378&status=done&style=shadow&taskId=uc338898e-4933-47a8-9023-5f624b43729&title=" alt="为c2建立二级索引后的树.png"></p><p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中?</p><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的。</p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><h3 id="3-3-一个页面最少存储2条记录"><a href="#3-3-一个页面最少存储2条记录" class="headerlink" title="3.3 一个页面最少存储2条记录"></a>3.3 一个页面最少存储2条记录</h3><p>B+树只需要很少的层级就可以轻松存储数亿条记录，这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录会怎么样？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录，会导致效率很低。</p><blockquote><p>其实让B+数的叶子结点值存储一条记录，让内节点存储多条记录，也还是可以发挥B+数的作用的。但是InnoDB为了避免数的层级过高，要求所有的数据页都至少可以容纳两条记录。</p></blockquote><h2 id="4-MyISAM中的索引方案简单介绍"><a href="#4-MyISAM中的索引方案简单介绍" class="headerlink" title="4. MyISAM中的索引方案简单介绍"></a>4. MyISAM中的索引方案简单介绍</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><ul><li> 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。 </li><li> 使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！<br>这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code>！ </li><li> 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。 </li></ul><blockquote><p>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在MyIsaM数据上使用二分法进行查找。</p></blockquote><h2 id="5-创建和删除索引的语句"><a href="#5-创建和删除索引的语句" class="headerlink" title="5. 创建和删除索引的语句"></a>5. 创建和删除索引的语句</h2><p><code>InnoDB</code>和<code>MyISAM</code>会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。</p><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY<span class="operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们也可以在修改表结构的时候添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure><p>也可以在修改表结构的时候删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</span><br></pre></td></tr></table></figure><blockquote><p>至此，整个索引相关的结构我们就都分析完了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[一]入门</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一，MYSQL入门"><a href="#一，MYSQL入门" class="headerlink" title="一，MYSQL入门"></a>一，MYSQL入门</h3><h4 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1.数据库相关概念"></a>1.数据库相关概念</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DB：数据库：存储数据的仓库，保存了一系列有组织的数据。</span></span><br><span class="line"><span class="attr">DBMS：数据库管理系统：数据库是通过DBMS创建和操作的容器。</span></span><br><span class="line"><span class="attr">SQL：结构化查询语言：专门用来与数据库通信的语言。</span></span><br></pre></td></tr></table></figure><h4 id="2-数据库的好处"><a href="#2-数据库的好处" class="headerlink" title="2.数据库的好处"></a>2.数据库的好处</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.可以持久化数据到本地</span></span><br><span class="line"><span class="attr">2.可以实现结构化查询，方便管理</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库存储数据特点"><a href="#3-数据库存储数据特点" class="headerlink" title="3.数据库存储数据特点"></a>3.数据库存储数据特点</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.将数据放到表中，表放到库中。</span></span><br><span class="line"><span class="attr">2.一个数据库有多张表，每个表都有一个名字，用来标识自己。</span></span><br><span class="line"><span class="attr">表名具有唯一性。</span></span><br><span class="line"><span class="attr">3.表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中类的设计。</span></span><br><span class="line"><span class="attr">4.表有列组成，我们也称为字段。所有表都是由一个列或多个列组成的，</span></span><br><span class="line"><span class="attr">每一列类似Java中的属性。</span></span><br><span class="line"><span class="attr">5.表中的数据按照行来存储，每一行类似于Java中的对象。</span></span><br></pre></td></tr></table></figure><h4 id="4-mysql的安装与使用"><a href="#4-mysql的安装与使用" class="headerlink" title="4.mysql的安装与使用"></a>4.mysql的安装与使用</h4><p><strong>参照mysql安装文档</strong></p><h4 id="5-Mysql常用命令"><a href="#5-Mysql常用命令" class="headerlink" title="5.Mysql常用命令"></a>5.Mysql常用命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">显示数据库-----&gt;show</span> <span class="string">Databases;</span></span><br><span class="line"><span class="meta">使用数据库-----&gt;use</span> <span class="string">数据库名；</span></span><br><span class="line"><span class="meta">显示表----&gt;show</span> <span class="string">tables;</span></span><br><span class="line"><span class="meta">显式指定数据库的表----&gt;show</span> <span class="string">tables from 数据库名；</span></span><br><span class="line"><span class="meta">查看位于那个数据库----&gt;select</span> <span class="string">database();</span></span><br><span class="line"><span class="meta">显示表结构---&gt;desc</span> <span class="string">表名；</span></span><br><span class="line"><span class="meta">查看数据库版本：---&gt;select</span> <span class="string">version();</span></span><br><span class="line"><span class="meta">查看数据库版本2</span>:<span class="string">-----&gt;Dos:mysql --version;</span></span><br><span class="line"><span class="meta">查看数据库信息-----&gt;show</span> <span class="string">CREATE DATABASE mydb1;</span></span><br><span class="line"><span class="meta">查看服务器中的数据库，并把mydb1的字符集修改为utf-8-----&gt;ALTER</span> <span class="string">DATABASE mydb1character set utf8;</span></span><br><span class="line"><span class="meta">删除数据库-----&gt;drop</span> <span class="string">database mydb1;</span></span><br><span class="line"><span class="meta">表中增加一栏信息-----&gt;alter</span> <span class="string">table student add image blob;</span></span><br><span class="line"><span class="meta">删除表-----&gt;drop</span> <span class="string">table student;</span></span><br><span class="line"><span class="meta">修改地址-----&gt;alter</span> <span class="string">table student modify address varchar(100);</span></span><br><span class="line"><span class="meta">删除一个属性-----&gt;</span> <span class="string">alter table student drop image;</span></span><br><span class="line"><span class="meta">修改表名-----&gt;rename</span> <span class="string">table student to students;</span></span><br><span class="line"><span class="meta">查看表的创建细节-----&gt;show</span> <span class="string">create table students;</span></span><br><span class="line"><span class="meta">修改表的字符集为</span> <span class="string">gbk-----&gt;alter table students character set gbk;</span></span><br><span class="line"><span class="meta">列名name修改为studentname-----&gt;alter</span> <span class="string">table students change name studentname varchar(100);</span></span><br></pre></td></tr></table></figure><h4 id="6-mysql语法规范"><a href="#6-mysql语法规范" class="headerlink" title="6.mysql语法规范"></a>6.mysql语法规范</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.不区分大小写，建议关键字大写，表名列名小写。</span></span><br><span class="line"><span class="attr">2.每条命令最好用分号结尾。</span></span><br><span class="line"><span class="attr">3.每条语句可以缩进，换行。</span></span><br><span class="line"><span class="attr">4.注释</span></span><br><span class="line"><span class="attr">单行注释：#注释文字</span></span><br><span class="line">          <span class="meta">--</span> <span class="string">注释文字</span></span><br><span class="line"><span class="meta">多行注释：/*</span> <span class="string">*/</span></span><br></pre></td></tr></table></figure><h3 id="二，DQL查询语言"><a href="#二，DQL查询语言" class="headerlink" title="二，DQL查询语言"></a>二，DQL查询语言</h3><h4 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">**语法：</span> <span class="string">select 查询列表 from 表名**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询列表：表中的字段，常量，表达式，函数**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询的结果是张虚拟的表格**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.查询表中的单个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.查询表中的多个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name,salary,email from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.查询表中的所有字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.查询常量值</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">&#x27;john&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.查询表达式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100*98;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">6.查询函数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">version();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">7.起别名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name as name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">8.去重</span></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工表中涉及到的所有的部门编号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">distinct department_id from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">9.+的作用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#运算符：两个操作数都为数值型，则做加法运算；</span></span><br><span class="line"><span class="comment">#其中一方为字符型，试图将字符型数值转换成数值型，</span></span><br><span class="line"><span class="comment">#如果转换成功，继续做加法运算；否则，将字符型数值</span></span><br><span class="line"><span class="comment">#转换为0；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">10.使用concat实现连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名和性连接成一个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CONCAT(username,PASSWORD) FROM USER;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#任何数与null做运算结果都为null</span></span><br></pre></td></tr></table></figure><h4 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h4><p><strong>语法：</strong></p><p><strong>select 查询列表 from 表名 where 筛选条件</strong></p><p><strong>分类：</strong></p><h5 id="①按照条件表达式筛选"><a href="#①按照条件表达式筛选" class="headerlink" title="①按照条件表达式筛选"></a>①按照条件表达式筛选</h5><p>条件运算符：&gt;,&lt;,=,!=,&gt;=,&lt;=</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工工资&gt;1w2的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee where salary &gt;12000;</span></span><br><span class="line"><span class="meta">查询部门编号！</span>=<span class="string">90号的员工名和部门编号</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name, dep_id from employee where  dep_id 1=90；</span></span><br></pre></td></tr></table></figure><h5 id="②按照逻辑表达式筛选"><a href="#②按照逻辑表达式筛选" class="headerlink" title="②按照逻辑表达式筛选"></a>②按照逻辑表达式筛选</h5><p>逻辑运算符：&amp;&amp;,||,!,AND,OR,NOT</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询工资在一万到两万之见的员工名，工资以及奖金。</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name,salary ,jiangjin where salary between 10000 and 20000;</span></span><br><span class="line"><span class="attr">查询部门编号不在90-110之间，或者工资高于15000的员工信息。</span></span><br><span class="line"><span class="attr">select</span>  <span class="string">* from employee where department&lt;90||department&gt;110 ||salary &gt;15000;</span></span><br></pre></td></tr></table></figure><h5 id="③模糊查询"><a href="#③模糊查询" class="headerlink" title="③模糊查询"></a>③模糊查询</h5><p>like：一般和通配符搭配使用<br>通配符：<br>%任意多个字符，包含0个字符<br>_任意单个字符<br>BETWEEN AND:包含临界值<br>IN:判断某个字段的值是否属于in列表中的某一项<br>IS NULL,IS NOT NULL:=或者！=不能用来判断null<br>安全等于&lt;=&gt;可以判断null</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工名中包含a的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where name like %a%;</span></span><br><span class="line"><span class="attr">查询员工名中第三个字符为e第五个字符为a的员工名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp where name like %__e_a%;</span></span><br><span class="line"><span class="attr">员工名中第二个字符为_的员工名</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name from emp where name like %_\_%;</span></span><br><span class="line"><span class="attr">查询员工编号在100到120之间的所有员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where id between 100 and 120;</span></span><br><span class="line"><span class="attr">查询员工的工种编号是IT_PRIG,AD_PRES,AD_VP中的一个员</span></span><br><span class="line"><span class="attr">工名和工种编号；</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name , id from emp where id in(IT_PRIG,AD_PRES,AD_VP);</span></span><br><span class="line"><span class="attr">查询没有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary , jjl from emp where salary is Null;</span></span><br><span class="line"><span class="attr">查询有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary ,jjl from emp where salary is not null;</span></span><br></pre></td></tr></table></figure><h5 id="④IF-null的使用："><a href="#④IF-null的使用：" class="headerlink" title="④IF null的使用："></a>④IF null的使用：</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工号为176的员工的姓名和部门号和年薪</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name ,department_id , salary*(1+IFNULL(commission_pct,0))*12 &#x27;年薪&#x27;</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees WHERE employee_id =176;</span></span><br></pre></td></tr></table></figure><h4 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h4><p><strong>语法：</strong></p><p><strong>select   查询列表</strong></p><p><strong>from 表</strong></p><p><strong>where 筛选条件</strong></p><p><strong>order by 排序列表 asc 或desc （升序或者降序，默认为升序）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工信息，要求工资从高到低排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by salary desc;</span></span><br><span class="line"><span class="attr">查询部门编号大于等于90的员工信息，按照入职时间先后排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where dep_id &gt;=90 order by createtime asc;</span></span><br><span class="line"><span class="attr">按照员工年薪的高低显示员工的信息和年薪</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* ,年薪 from emp  order by salary*(1+if null(jjl,0))*12 as 年薪 desc;</span></span><br><span class="line"><span class="attr">按姓名长度显示员工的姓名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp order by length(name) asc;</span></span><br><span class="line"><span class="attr">查询员工信息，先按照工资排序，再按照员工编号排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp  order by salary asc,id asc;</span></span><br></pre></td></tr></table></figure><h4 id="4-常见函数"><a href="#4-常见函数" class="headerlink" title="4.常见函数"></a>4.常见函数</h4><p><strong>功能：类似Java中的方法</strong><br><strong>分类：单行函数</strong><br><strong>分组函数</strong></p><h5 id="1-单行函数"><a href="#1-单行函数" class="headerlink" title="1.单行函数"></a>1.单行函数</h5><h6 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1.字符函数"></a>1.字符函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.length</span> <span class="string">获取参数值的字节个数</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by length(name);</span></span><br><span class="line"><span class="meta">2.concat</span> <span class="string">拼接字符串</span></span><br><span class="line"><span class="attr">select</span> <span class="string">concat(last_name,first_name) as 姓名 from emp;</span></span><br><span class="line"><span class="meta">3.upper，lower</span> <span class="string">大小写转换函数</span></span><br><span class="line"><span class="attr">案例：将姓变大写，名字变小写，然后拼接</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">CONCAT(UPPER(last_name),LOWER(first_name))</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.substr,SUBSTRING</span> <span class="string">截取字符串</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2,3);</span></span><br><span class="line"><span class="attr">案例：姓名中首字符大写，其他的小写然后用_拼接显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">CONCAT(</span></span><br><span class="line">    <span class="meta">UPPER(SUBSTR(last_name,</span> <span class="string">1, 1)),</span></span><br><span class="line">    <span class="attr">&#x27;_&#x27;,</span></span><br><span class="line">    <span class="meta">LOWER(SUBSTR(last_name,</span> <span class="string">2))</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">output </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">5.instr</span>:<span class="string">返回字串第一次出现的索引，如果找不到返回0</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">INSTR(&#x27;风急天高猿啸哀&#x27;,&#x27;天&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.trim</span> :<span class="string">去掉前后空格或前后指定字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LENGTH(TRIM(&#x27;   张三丰   &#x27;)) AS out_put;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRIM(&#x27;a&#x27; FROM &#x27;aaaa1aa2aaa3aaa&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">7.lpad</span> :<span class="string">用指定字符填满指定长度（左填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">8.rpad</span>:<span class="string">用指定字符填满指定长度（右填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">RPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">9.replace</span> <span class="string">替换</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">REPLACE(&#x27;千锋培训机构&#x27;,&#x27;千锋&#x27;,&#x27;尚硅谷&#x27;);</span></span><br></pre></td></tr></table></figure><h6 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2.数学函数"></a>2.数学函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.round</span>:<span class="string">四舍五入</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.666);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.567,2);</span></span><br><span class="line"><span class="meta">2.ceil</span> <span class="string">向上取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CEIL(1.52);</span></span><br><span class="line"><span class="meta">3.floor</span> <span class="string">向下取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">FLOOR(1.52);</span></span><br><span class="line"><span class="meta">4.truncate</span>:<span class="string">截断（小数点后保留几位）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRUNCATE(1.65,2);</span></span><br><span class="line"><span class="meta">5.mod</span>:<span class="string">取余</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MOD(10,3);</span></span><br></pre></td></tr></table></figure><h6 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.now</span>:<span class="string">返回当前系统日期时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">NOW();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.curdate</span>:<span class="string">返回当前系统日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURDATE();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.curtime</span>:<span class="string">返回当前时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURTIME();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.获取指定部分的年月日时分秒</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(hiredate) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.str_to_date将字符通过指定的格式转化成日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">STR_TO_DATE(&#x27;1998-3-2&#x27;,&#x27;%Y-%c-%d&#x27;) AS out_put;</span></span><br><span class="line"><span class="attr">案例：查询入职时间为1992-4-3的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">hiredate=STR_TO_DATE(&#x27;2016-3-3&#x27;,&#x27;%Y-%c-%d&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.date_format</span> <span class="string">将日期转换成字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATE_FORMAT(NOW(),&#x27;%y年%m月%d日&#x27;) AS 日期;</span></span><br><span class="line"><span class="meta">案例：查询有奖金的员工名和入职日期（xx月/xx日</span> <span class="string">xx年）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="meta">DATE_FORMAT(hiredate,</span> <span class="string">&#x27;%c月/%d日 %y&#x27;) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL ;</span></span><br></pre></td></tr></table></figure><h6 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SELECT</span> <span class="string">VERSION();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATABASE();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">USER();</span></span><br></pre></td></tr></table></figure><h6 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.if</span>:<span class="string">IF else效果</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">IF(10&gt;5,&#x27;true&#x27;,&#x27;false&#x27;);</span></span><br><span class="line"><span class="attr">案例：查询如果有奖金就备注有，没有就备注没有。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">commission_pct,</span></span><br><span class="line">  <span class="attr">IF(</span></span><br><span class="line">    <span class="attr">commission_pct</span> <span class="string">IS NULL,</span></span><br><span class="line">    <span class="attr">&#x27;没奖金&#x27;,</span></span><br><span class="line">    <span class="attr">&#x27;有奖金&#x27;</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">AS 备注 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.case函数</span></span><br><span class="line"><span class="attr">1)switch-CASE</span></span><br><span class="line"><span class="meta">语法</span>:<span class="string"></span></span><br><span class="line"><span class="attr">CASE</span> <span class="string">要判断的字段或者表达式</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量1 THEN 要显示的值1或者语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量2 THEN 要显示的值2或者语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或者语句n；</span></span><br><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"><span class="meta">2)CASE</span> <span class="string">使用2：</span></span><br><span class="line"><span class="attr">语法：</span></span><br><span class="line"><span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件1 THEN 要显示的值1或语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件2 THEN 要显示的值2或语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或语句n</span></span><br><span class="line"><span class="attr">END</span></span><br><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees ;</span></span><br></pre></td></tr></table></figure><h5 id="2-分组函数"><a href="#2-分组函数" class="headerlink" title="2.分组函数"></a>2.分组函数</h5><p><strong>功能：用作统计使用</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.sum</span> :<span class="string">求和</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.avg：平均值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.max：最大值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MAX(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.min：最小值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.count：计算个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">总结</span></span><br><span class="line"><span class="attr">①.sum,avg一般用于处理数值类型</span></span><br><span class="line"><span class="attr">②.max，min，count用来处理任何类型</span></span><br><span class="line"><span class="attr">③.以上分组函数都忽略null值</span></span><br><span class="line"><span class="attr">④.可以和distinct搭配</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(DISTINCT salary) 纯净,SUM(salary) FROM employees;</span></span><br><span class="line"><span class="attr">6.count的详细介绍</span></span><br><span class="line"><span class="meta">①select</span> <span class="string">COUNT(*) FROM employees;</span></span><br><span class="line"><span class="meta">②select</span> <span class="string">COUNT(1) FROM employees;</span></span><br><span class="line"><span class="meta">③和分组函数一同查询的字段要求是group</span> <span class="string">by后的字段。</span></span><br></pre></td></tr></table></figure><h4 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h4><p><strong>GROUP BY 和分组函数对应</strong><br><strong>分组查询中分组条件分为两类</strong></p><table><thead><tr><th></th><th><strong>数据源</strong></th><th><strong>位置</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td><strong>分组前筛选</strong></td><td>原始表</td><td>GROUP BY 子句的前面</td><td>WHERE</td></tr><tr><td><strong>分组后筛选</strong></td><td>分组后的结果集</td><td>GROUP BY 子句的后面</td><td>HAVING</td></tr></tbody></table><p><strong>分组函数做条件肯定是放在having子句中。</strong><br><strong>group BY 子句支持单个字段分组，多个字段分组</strong><br><strong>（多个字段之间用逗号隔开没有顺序要求），表达式或函数。</strong><br><strong>也可以添加排序，放在整个分组查询的最后。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询每个工种的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY MAX(salary) ASC ;</span></span><br><span class="line"><span class="attr">案例：查询邮箱中包含a字符的，每个部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AVG(salary),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">email LIKE &#x27;%a%&#x27; </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id ;</span></span><br><span class="line"><span class="comment">#select Avg(salary),dep_id from employee where email like %a% group by dep_id ;</span></span><br><span class="line"><span class="attr">案例：查询有奖金的每个领导手下员工的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">manager_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id ;</span></span><br><span class="line"><span class="comment">#select max(salary) ,manage_id from employees where commission_pct is not null group by manager_id;</span></span><br><span class="line"><span class="attr">案例：哪个部门的员工个数大于二？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 2 ;</span></span><br><span class="line"><span class="comment">#select dep_id from emp group by dep_id having count(*)&gt;2;</span></span><br><span class="line"><span class="attr">案例：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MAX(salary) &gt; 12000 ;</span></span><br><span class="line"><span class="comment">#select job_id ,max(salary) from emp where commission_pct IS NOT NULL group by job_id having max(salary)&gt;12000;</span></span><br><span class="line"><span class="attr">案例：查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id ,MIN(salary)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">manager_id&gt;102</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#select manager_id from emp where manager_id&gt;102 group by manager_id having min(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#按照员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(*) AS c</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY LENGTH(last_name) </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">c&gt;5;</span></span><br><span class="line"><span class="comment"># select count(*) from emp group by length(name) having count(*)&gt;5;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资并且按照平均工资的高低显示</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY AVG(salary) ASC;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id order by avg(salary) asc;</span></span><br></pre></td></tr></table></figure><h4 id="6-连接查询"><a href="#6-连接查询" class="headerlink" title="6.连接查询"></a>6.连接查询</h4><p><strong>又称为多表查询，当查询的字段来自多个表时，就会用到连接查询。</strong><br>**笛卡尔乘积现象：表1有m行，表2有n行，结果：m_n行_<br><strong>发生原因：没有有效的连接条件</strong></p><p><strong>分类</strong></p><p>①按年代分类<br>sql92:仅仅支持内连接<br>sql99：不支持全外连接</p><p>②按功能分类</p><table><thead><tr><th>内连接</th><th>外连接</th><th>交叉连接</th></tr></thead><tbody><tr><td>等值连接</td><td>左外连接</td><td></td></tr><tr><td>非等值连接</td><td>右外连接</td><td></td></tr><tr><td>自连接</td><td>全外连接</td><td></td></tr></tbody></table><h5 id="1-等值连接"><a href="#1-等值连接" class="headerlink" title="1.等值连接"></a>1.等值连接</h5><p>①多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序，分组，筛选</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例一：查询女优名对应的男优名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">NAME,</span></span><br><span class="line">  <span class="attr">boyName</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">beauty,</span></span><br><span class="line">  <span class="attr">boys</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">beauty.boyfriend_id = boys.`id` ;</span></span><br><span class="line"><span class="comment">#select name, boyname from girl ,boy where girl.boyfriend_id=boy.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名和对应的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employees.`department_id` = departments.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e,dep d where e.dep.id= d.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名，工种号，工种名。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">emp.`job_id`,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">job </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">emp.`job_id` = job.`job_id` ;</span></span><br><span class="line"><span class="comment">#select name , e.job_id,job_title from emp e,job j where e.job_id=j.id;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的员工名和部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">dep </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL &amp;&amp; emp.`department_id` = dep.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e ,dep d where e.dep_id =d.id &amp;&amp;e.salary_pct is not null;</span></span><br><span class="line"><span class="comment">#案例：查询城市名第二个字符为o的部门</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">l.`city` LIKE &#x27;_o%&#x27; ;</span></span><br><span class="line"><span class="comment">#select dep_name from location l , dep d where l.city like %_o% &amp;&amp; l.id =d.location_id;</span></span><br><span class="line"><span class="comment">#案例：查询每个城市的部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY l.`city` ;</span></span><br><span class="line"><span class="comment">#select count(*),city from loca l,dep d where l.loc_id=d.loc_id group by count(*) asc;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.`department_name`,</span></span><br><span class="line">  <span class="attr">d.manager_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">e.`commission_pct` IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY d.`department_id`,</span></span><br><span class="line">  <span class="meta">d.`department_name`</span> <span class="string">;</span></span><br><span class="line"><span class="comment">#select dep_name ,d.manager_id ,min(salary) from emp e ,dep d where e.`department_id` = d.`department_id` AND e.`commission_pct` IS NOT NULL GROUP BY d.`department_id`,d.`department_name` ;</span></span><br><span class="line"><span class="comment">#案例：查询每个工种的工种名和员工的个数，并且按照员工个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">j.job_title,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">j,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">j.`job_id` = e.`job_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.`job_id`,</span></span><br><span class="line">  <span class="meta">j.`job_title`</span> <span class="string"></span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名，部门名和所在城市</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d,</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">d.`location_id` = l.`location_id` ;</span></span><br></pre></td></tr></table></figure><h5 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2.非等值连接"></a>2.非等值连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工的工资和工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DISTINCT </span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.salary &gt;= j.lowest_sal &amp;&amp; e.salary &lt;= j.highest_sal </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary ASC ;</span></span><br></pre></td></tr></table></figure><h5 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3.自连接"></a>3.自连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工名和上级的名称</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">e.last_name,</span></span><br><span class="line">  <span class="meta">m.last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">m </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.manager_id = m.employee_id ;</span></span><br></pre></td></tr></table></figure><h5 id="4-内连接"><a href="#4-内连接" class="headerlink" title="4.内连接"></a>4.内连接</h5><p><strong>INNER 可以省略</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询员工名，部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.department_id = d.department_id ;</span></span><br><span class="line"><span class="comment">#查询名字中包含e的员工名和工种名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.job_id = j.job_id </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">last_name LIKE &#x27;%e%&#x27; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询部门个数&gt;3的城市名和部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">city,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN locations l </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">d.`location_id` = l.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY city</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按照个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询员工名，部门名，工种名，并按照部门名降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`job_id` = j.`job_id` </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY department_name DESC ;</span></span><br><span class="line"><span class="comment">#查询员工工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level,</span></span><br><span class="line">  <span class="attr">salary</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN employees e </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` ;</span></span><br><span class="line"><span class="comment">#查询每个工资级别的个数，并且降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">grade_level,COUNT(*)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN  job_grades j</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY grade_level</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC;</span></span><br><span class="line"><span class="comment">#查询员工的名字和上级的名字</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">e1.last_name, e2.last_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e1</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN employees e2</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e1.`employee_id`=e2.`manager_id`;</span></span><br></pre></td></tr></table></figure><h5 id="5-左外连接"><a href="#5-左外连接" class="headerlink" title="5.左外连接"></a>5.左外连接</h5><p><strong>语法：</strong><br>SELECT 查询列表<br>FROM 表1 【连接类型】<br>JOIN 表2<br>ON 连接条件<br>WHERE 筛选条件<br>GROUP BY 分组<br>HAVING 筛选条件<br>ORDER BY 排序条件<br><strong>连接类型：</strong><br>内连接：inner<br>左外连接：left<br>右外连接：right<br>全外连接：full<br>交叉连接：cross<br><strong>外连接</strong><br>用于查询一个表中有，另一个表中没有的数据<br>左外连接，left左边是主表<br>右外连接，right右边是主表<br><em>Mysql不支持全外连接</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有男朋友的女生</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">g.`name`,b.`boyName`</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.`id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName` IS NULL;</span></span><br></pre></td></tr></table></figure><h5 id="6-交叉连接"><a href="#6-交叉连接" class="headerlink" title="6.交叉连接"></a>6.交叉连接</h5><p><strong>笛卡尔乘积</strong></p><h4 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h4><p><strong>出现在其它语句中的select语句，称为子查询或内查询</strong><br><strong>外部的查询语句，称为主查询或外查询</strong><br><strong>分类：</strong></p><p>①按照子查询出现的位置：</p><table><thead><tr><th>select后面</th><th>from后面</th><th>where或having后面</th><th>exists后面</th></tr></thead><tbody><tr><td>仅仅支持标量子查询</td><td>支持表子查询</td><td>标量子查询，列子查询</td><td>表子查询</td></tr></tbody></table><p>②按照结果集的行列数不同：</p><table><thead><tr><th>标量子查询</th><th>列子查询</th><th>行子查询</th><th>表子查询</th></tr></thead><tbody><tr><td>结果只有一行一列</td><td>结果一列多行</td><td>一行多列</td><td>多行多列</td></tr></tbody></table><h5 id="1）where或having后面"><a href="#1）where或having后面" class="headerlink" title="1）where或having后面"></a>1）where或having后面</h5><p><strong>特点：</strong><br>子查询一般放在小括号内<br>子查询一般放在条件的右边<br>标量子查询，一般搭配着单行操作符<br>列子查询：一般搭配多行操作符使用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.标量子查询</span></span><br><span class="line"><span class="comment">#谁的工资比Abel高</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">last_name = &#x27;Abel&#x27;) ;</span></span><br><span class="line"><span class="comment">#返回job_id于141号员工相同，salary比143号员工多的员工 姓名，job_id和工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">job_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 141) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 143)</span></span><br><span class="line"><span class="comment">#返回公司工资工资最少的员工的姓名，job_id,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees);</span></span><br><span class="line"><span class="comment">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary) &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">department_id = 50) ;</span></span><br><span class="line"><span class="attr">2.列子查询</span></span><br><span class="line"><span class="attr">多行操作符：</span></span><br><span class="line"><span class="attr">IN</span> <span class="string">/ NOT in：等于列表中的任意一个</span></span><br><span class="line"><span class="attr">ANY</span> <span class="string">/ SOME ：和子查询返回的某一个值比较</span></span><br><span class="line"><span class="attr">ALL</span> <span class="string">：和子查询返回的所有值比较</span></span><br><span class="line"><span class="comment">#返回location_id是1400或者1700的部门中的所有员工姓名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id IN</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string">DISTINCT</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">departments</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">location_id IN (1400, 1700)) ;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门任意工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门所有工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="attr">*********************************</span></span><br><span class="line"><span class="attr">3.行子查询</span></span><br><span class="line"><span class="comment">#查询员工编号最小并且工资最高的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="meta">*</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(employee_id)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="meta">employees)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees)</span></span><br></pre></td></tr></table></figure><h5 id="2）SELECT-后面"><a href="#2）SELECT-后面" class="headerlink" title="2）SELECT 后面"></a>2）SELECT 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询每个部门的员工个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.*,</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">e.department_id = d.department_id) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d ;</span></span><br><span class="line"><span class="comment">#查询员工号等于102的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 102) ;</span></span><br></pre></td></tr></table></figure><h5 id="3）FROM-后面"><a href="#3）FROM-后面" class="headerlink" title="3）FROM 后面"></a>3）FROM 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询每个部门平均工资的工资等级</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string">,aa.department_id</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">AVG(salary)</span> <span class="string">ag,</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">GROUP</span> <span class="string">BY department_id) aa </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN job_grades j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">aa.ag BETWEEN lowest_sal </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">highest_sal ;</span></span><br></pre></td></tr></table></figure><h5 id="4）exists后面（相关子查询）"><a href="#4）exists后面（相关子查询）" class="headerlink" title="4）exists后面（相关子查询）"></a>4）exists后面（相关子查询）</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询有员工的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_name FROM departments d</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">EXISTS(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees  e WHERE d.department_id=e.department_id</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="comment">#查询没有女朋友的男生信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">bo.* FROM boys bo WHERE</span></span><br><span class="line"><span class="meta">bo.`id`</span> <span class="string">NOT IN(SELECT boyfriend_id FROM beauty);</span></span><br></pre></td></tr></table></figure><h5 id="5）子查询经典案例祥讲"><a href="#5）子查询经典案例祥讲" class="headerlink" title="5）子查询经典案例祥讲"></a>5）子查询经典案例祥讲</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.查询工资最低的员工信息：last_name,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,salary FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">salary=(SELECT MIN(salary) FROM employees);</span></span><br><span class="line"><span class="attr">2.查询平均工资最低的部门信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM departments WHERE department_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">3.查询平均工资最低的部门信息和该部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">d.*,a1.ag FROM departments  d JOIN </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">AVG(salary) ag,department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1) a1</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">d.department_id=a1.department_id</span></span><br><span class="line"><span class="attr">4.查询平均工资最高的job信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">j.* FROM jobs j WHERE j.job_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">job_id FROM employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id ORDER BY AVG(salary) DESC LIMIT 1)</span></span><br><span class="line"><span class="attr">5.查询平均工资高于公司平均工资的部门有哪些</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id ,AVG(salary) AS avg1 FROM employees GROUP BY  department_id) e1</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e1.avg1&gt;(SELECT AVG(salary)  AS avg2 FROM employees) </span></span><br><span class="line"><span class="attr">6.查询出公司中所有manager的详细信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id IN(SELECT DISTINCT manager_id FROM employees);</span></span><br><span class="line"><span class="attr">7.各个部门中，最高工资中最低的那个部门的最低工资是多少</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees GROUP BY department_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY MAX(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">8.查询平均工资最高的部门的manager的详细信息：last_name,department_id,email,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,department_id,email,salary FROM employees WHERE employee_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id FROM departments WHERE department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">LIMIT 1))</span></span><br></pre></td></tr></table></figure><h4 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8.分页查询"></a>8.分页查询</h4><p>**语法：limit(currentPage-1)<em>size,size</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询前五条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 0,5;</span></span><br><span class="line"><span class="comment">#查询第11-25条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 10,15;</span></span><br><span class="line"><span class="comment">#查询有奖金的员工，并且工资最高的前十名显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary DESC </span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">0 ,10;</span></span><br></pre></td></tr></table></figure><h4 id="9-联合查询"><a href="#9-联合查询" class="headerlink" title="9.联合查询"></a>9.联合查询</h4><p><strong>要查询的结果来自于多个表，且多个表没有直接的连接关系，单查询的信息一致时</strong><br><strong>特点：</strong><br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以不去除重复项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工部门编号大于90或邮箱包含a的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE department_id&gt;90</span></span><br><span class="line"><span class="attr">UNION</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE email LIKE &#x27;%a%&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="三，DML数据操作语言"><a href="#三，DML数据操作语言" class="headerlink" title="三，DML数据操作语言"></a>三，DML数据操作语言</h3><p><strong>插入insert</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一：插入语句</span></span><br><span class="line"><span class="comment">#插入beauty一行数据</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;波多野吉依&#x27;,&#x27;女&#x27;,&#x27;1998-11-11&#x27;,&#x27;13342969497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,10)</span></span><br><span class="line"><span class="comment">#可以为null的列如何不插入值</span></span><br><span class="line"><span class="attr">直接写null，或列名少写一列</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;小泽玛利亚&#x27;,&#x27;女&#x27;,&#x27;1999-11-11&#x27;,&#x27;13342456497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,11)</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty VALUES(15,&#x27;马蓉&#x27;,&#x27;女&#x27;,&#x27;1989-11-11&#x27;,&#x27;13342456123&#x27;,</span></span><br><span class="line"><span class="attr">NULL,12);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty SET id=16,NAME=&#x27;刘亦菲&#x27;, sex=&#x27;女&#x27;,borndate=&#x27;1989-10-01&#x27;,</span></span><br><span class="line"><span class="attr">phone</span>=<span class="string">&#x27;15945231056&#x27;,boyfriend_id=16;</span></span><br><span class="line"><span class="comment">#insert 嵌套子查询，将一个表的数据插入另一张表</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty (NAME,sex,borndate,phone,boyfriend_id)</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">&#x27;妲己&#x27;,&#x27;女&#x27;,&#x27;1111-11-11&#x27;,&#x27;13146587954&#x27;,0;</span></span><br></pre></td></tr></table></figure><p><strong>修改update</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">二，修改</span></span><br><span class="line"> <span class="attr">UPDATE</span> <span class="string">beauty SET phone=&#x27;110&#x27; WHERE id=16;</span></span><br><span class="line"><span class="attr">多表修改：sql99</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">表1 别名</span></span><br><span class="line"><span class="meta">INNER|LEFT|RIGHT</span> <span class="string">JOIN 表2 别名</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">连接条件</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">列=值</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">筛选条件</span></span><br><span class="line"><span class="comment">#修改张无忌的女朋友手机号为114</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.phone=&#x27;114&#x27;</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.boyName=&#x27;张无忌&#x27;;</span></span><br><span class="line"><span class="comment">#修改没有男朋友的女生的男朋友编号都为4号</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN  boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.`boyfriend_id`=4</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=NULL;</span></span><br></pre></td></tr></table></figure><p><strong>删除delete</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">三，删除</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">和 TRUNCATE 的区别：</span></span><br><span class="line"><span class="attr">1.delete可以加where条件，truncate不行</span></span><br><span class="line"><span class="attr">2.truncate删除效率高</span></span><br><span class="line"><span class="attr">3.加入要删除的表中有自增列，</span></span><br><span class="line"><span class="attr">用delete删除整个表后在插入数据，从断点处开始插入</span></span><br><span class="line"><span class="attr">用truncate删除后在插入数据，从1开始。</span></span><br><span class="line"><span class="attr">4.truncate删除没有返回值，delete有返回值</span></span><br><span class="line"><span class="attr">5.truncate删除不能回滚，delete删除可以回滚</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM beauty WHERE id=17;</span></span><br><span class="line"><span class="meta">语法：truncate</span> <span class="string">TABLE 表名;</span></span><br><span class="line"><span class="comment">#删除张无忌的女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=1;</span></span><br><span class="line"><span class="comment">#删除黄晓明以及他女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">b,g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">b.`id`=g.`boyfriend_id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName`=&#x27;黄晓明&#x27;;</span></span><br><span class="line"><span class="meta">多表删除</span> :<span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">TRUNCATE</span> <span class="string">TABLE boys</span></span><br></pre></td></tr></table></figure><h3 id="四，DDL数据定义语言"><a href="#四，DDL数据定义语言" class="headerlink" title="四，DDL数据定义语言"></a>四，DDL数据定义语言</h3><h4 id="1-库和表的管理"><a href="#1-库和表的管理" class="headerlink" title="1.库和表的管理"></a>1.库和表的管理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一，库的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">DATABASE IF NOT EXISTS mydb1 ;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.更改字符集</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">DATABASE mydb1 CHARACTER SET utf8;</span></span><br><span class="line"><span class="meta">删除</span> <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">DATABASE IF EXISTS school;</span></span><br><span class="line"><span class="attr">二，表的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE book(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">b_name</span> <span class="string">VARCHAR(30),</span></span><br><span class="line"><span class="attr">price</span> <span class="string">DOUBLE,</span></span><br><span class="line"><span class="attr">author_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">publishDate</span> <span class="string">DATE</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">book ;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE author(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">au_name</span> <span class="string">VARCHAR(20),</span></span><br><span class="line"><span class="attr">nation</span> <span class="string">VARCHAR(10)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">author;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.修改列名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book CHANGE COLUMN publishDate pub_date DATETIME;</span></span><br><span class="line"><span class="attr">2.修改列的类型或约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book MODIFY COLUMN pub_date DATE;</span></span><br><span class="line"><span class="attr">3.添加新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author ADD COLUMN annual DOUBLE;</span></span><br><span class="line"><span class="attr">4.删除新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author DROP COLUMN annual;</span></span><br><span class="line"><span class="attr">5.修改表名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author RENAME TO book_author;</span></span><br><span class="line"><span class="meta">删除</span>  <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE IF EXISTS my_employee;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">TABLES;</span></span><br><span class="line"><span class="attr">复制</span></span><br><span class="line"><span class="attr">1.仅仅复制表的结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy LIKE book_author;</span></span><br><span class="line"><span class="attr">2.复制表的结构加数据</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy2</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM book_author;</span></span><br><span class="line"><span class="attr">3.复制部分结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy3 </span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">id,au_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">book_author</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">id=0;</span></span><br></pre></td></tr></table></figure><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p><strong>数值型</strong><br><strong>1.整型</strong></p><table><thead><tr><th>TINYINT</th><th>SMALLINT</th><th>MEDIUMINT</th><th>INT/INTEGER</th><th>BIGINT</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>8</td></tr></tbody></table><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如何设置无符号和有符号(默认有符号)</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_int;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_int(t1 INT,t2 INT UNSIGNED);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_int(t1,t2) VALUES(-1,1);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_int;</span></span><br></pre></td></tr></table></figure><p>1）如果插入的数值超出了整形的范围，会报out of range异常，并且插入<br>临界值。<br>2）如果不设置长度，会有默认的长度。<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配<br>zerofill使用。<br><strong>2.小数</strong><br>①定点数<br>dec（M,D）<br>②浮点数<br>float（4） ，double（8）<br>M，D的意思：M指定一共多少位，D指定小数几位，超出会四舍五入。<br>MD都可以省略，<br>如果是dec，则M默认为10，D默认为0<br>如果是浮点数，则会根据插入数值的精度改变精度<br>定点型精度相对较高。<br><strong>3.字符型</strong><br>①较短的文本<br>CHAR(M)默认为1,VARCHAR(M)<br>M:字符数<br>char：固定长度字符，比较耗费空间，但是效率高。<br>varchar：可变长度字符</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ENUM</span> <span class="string">枚举类</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_char(</span></span><br><span class="line">   <span class="attr">t1</span> <span class="string">ENUM(&#x27;a&#x27;,&#x27;c&#x27;,&#x27;b&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">集合</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_set(</span></span><br><span class="line"><span class="attr">s1</span> <span class="string">SET(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_set(s1) VALUES(&#x27;a,b&#x27;);</span></span><br></pre></td></tr></table></figure><p>BINARY:保存较短的二进制。<br>②较长的文本<br>text（文本）,BLOB(较大的二进制)<br><strong>4.日期型</strong><br>DATE:日期<br>DATETIME:日期加时间，8字节<br>timestamp：跟时区有关系，建议使用，4字节<br>time：时间<br>year：年</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_date(</span></span><br><span class="line"><span class="attr">t1</span> <span class="string">DATETIME,</span></span><br><span class="line"><span class="attr">t2</span> <span class="string">TIMESTAMP</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_date(t1,t2)</span></span><br><span class="line"><span class="attr">VALUES(NOW(),NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM tab_date;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">time_zone=&#x27;+9:00&#x27;;</span></span><br><span class="line"><span class="comment">#设置时区为东9区</span></span><br></pre></td></tr></table></figure><h4 id="3-常见约束"><a href="#3-常见约束" class="headerlink" title="3.常见约束"></a>3.常见约束</h4><p><strong>含义：一种限制，用于限制表中的数据，保证数据的一致性。</strong></p><ol><li> NOT NULL </li><li> DEFAULT </li><li> PRIMARY KEY  唯一，且不为空 </li><li> UNIQUE  唯一，可以为空 </li><li> CHECK Mysql不支持 </li><li> FOREIGN KEY 外键约束，用于限制两个表的关系，<br>用于保证该字段的值必须来自于主表的关联列的值。<br>约束的分类：<br>列级约束：除外键约束<br>表级约束：除了非空，默认。<br>CREATE TABLE 表名(<br>字段1 字段类型 列级约束,<br>字段2 字段类型 列级约束,<br>表级约束<br>); </li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建表时添加列级约束</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_test;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_major(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">major_name</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_test;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">INDEX FROM tab_test;</span></span><br><span class="line"><span class="comment">#查看索引信息</span></span><br><span class="line"><span class="comment">#添加表级约束</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id FOREIGN KEY(major_id) REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id 可以省略</span></span><br></pre></td></tr></table></figure><p>面试题：主键约束和唯一约束的区别：<br>都可以保证唯一性，<br>主键不能为空 ，unique 能为空，但是只能有一个null。<br>主键只能有1个，unique可以有多个。<br>都允许两个列组合成一个约束。<br>面试题：外键：<br>要求在从表设置外键关系<br>从表的外键列类型和主表的关联列类型一致，名称无要求<br>要求主表的关联列必须是主键或者唯一键<br>插入数据应该先插入主表再插入从表<br>删除数据应该先删除从表，在删除主表<br>二，修改表时添加约束</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test2(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) ,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR ,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT , </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT  </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN stu_name  VARCHAR(20) NOT NULL ;</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;</span></span><br><span class="line"><span class="comment">#添加外键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 ADD FOREIGN KEY(major_id) REFERENCES tab_major(id);</span></span><br></pre></td></tr></table></figure><h4 id="4-标识列"><a href="#4-标识列" class="headerlink" title="4.标识列"></a>4.标识列</h4><p>自增长列 AUTO_INCREMENT<br>特点：<br>1.表示必须和一个key搭配<br>2.一个表最多一个标识列<br>3.标识列类型只能是数值型<br>4.标识列可以通过set auto_increment_increment=3;设置步长</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">tab_auto(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">NAME</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br></pre></td></tr></table></figure><h3 id="五，TCL语言：事务控制语言"><a href="#五，TCL语言：事务控制语言" class="headerlink" title="五，TCL语言：事务控制语言"></a>五，TCL语言：事务控制语言</h3><p>事务：一个或一组sql语句组成的执行单元，</p><p>要么全部执行,要么都不执行。<br>存储引擎:在MySQL中的数据用各种不同的技术存储在文件中。<br>通过show ENGINES;来查看mysql支持的存储引擎。<br>innodb引擎支持事务。<br>事务的ACID属性：<br>1.原子性:事务是一个不可分割的工作单位，要么都发生，要么都不发生。<br>2.一致性：事务必须使数据库从一个一致性状态变为另一个一致性状态。<br>3.隔离性：一个事务的执行不能被另一个事务干扰。<br>4.持久性：事务一旦被提交，对数据库事务的改变就是永久性的。</p><p>DELETE 和 TRUNCATE 在事务中的区别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">演示delete</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="meta">演示</span> <span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">TRUNCATE</span>  <span class="string">TABLE tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">是直接删除表中数据，truncate是江表删除，创建一张与原来一样的空表。</span></span><br></pre></td></tr></table></figure><h3 id="六，视图"><a href="#六，视图" class="headerlink" title="六，视图"></a>六，视图</h3><p><strong>含义：虚拟表，和普通表格一样使用</strong><br><strong>通过表动态生成的数据</strong></p><h4 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1.创建视图"></a>1.创建视图</h4><p><strong>语法：</strong><br><strong>CREATE VIEW 视图名</strong><br><strong>AS</strong><br><strong>查询语句 ;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询姓名中包含a字符的员工名，部门名和工种信息</span><br><span class="line">create view view1 as</span><br><span class="line">    select e.last_name,d.department_name ,j.job_title from employees e</span><br><span class="line">inner join departments d on e.department_id = d.department_id</span><br><span class="line">    inner join jobs j on e.job_id = j.job_id</span><br><span class="line">where e.last_name like &#x27;%a%&#x27;;</span><br><span class="line">select * from view1;</span><br><span class="line"># 案例：查询各个部门的平均工资级别</span><br><span class="line">create view view2 as</span><br><span class="line">select j.grade_level ,aa.department_id</span><br><span class="line">    from job_grades j</span><br><span class="line">inner join (select avg(salary) avg_s,department_id from employees  group by department_id) aa</span><br><span class="line">    on aa.avg_s between j.lowest_sal and j.highest_sal;</span><br><span class="line">select * from view2;</span><br><span class="line"># 案例：查询平均工资最低的部门信息</span><br><span class="line">create view view3 as</span><br><span class="line">select avg(salary) avg_s ,department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">order by avg_s asc</span><br><span class="line">limit 1;</span><br><span class="line">select * from view3;</span><br></pre></td></tr></table></figure><h4 id="2-视图修改"><a href="#2-视图修改" class="headerlink" title="2.视图修改"></a>2.视图修改</h4><p><strong>①create OR REPLACE VIEW 视图名 AS 查询语句;</strong><br><strong>②alter VIEW 视图名 AS 查询语句;</strong></p><h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h4><p><strong>DROP VIEW v1,v2;</strong></p><h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4.查看视图"></a><strong>4.查看视图</strong></h4><p><strong>DESC v1;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资，邮箱</span><br><span class="line">CREATE VIEW emp_v1 AS</span><br><span class="line">SELECT last_name ,salary,email FROM employees WHERE</span><br><span class="line">phone_number LIKE &#x27;%011&#x27;;</span><br><span class="line">#创建视图emp_v2,要求查询部门的最高工资高于12000的部门信息</span><br><span class="line">CREATE VIEW v4 AS</span><br><span class="line">SELECT department_id FROM employees GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt; 12000;</span><br><span class="line">CREATE VIEW emp_v2 AS</span><br><span class="line">SELECT * FROM departments WHERE department_id IN(SELECT * FROM v4);</span><br></pre></td></tr></table></figure><h4 id="5-视图的更新"><a href="#5-视图的更新" class="headerlink" title="5.视图的更新"></a>5.视图的更新</h4><p><strong>视图的可更新性和视图中查询的定义有关，以下类型的视图是不能更新的。</strong><br><strong>1.包含以下关键字的sql语句：分组函数，distinct，group by，having，union</strong><br><strong>2.常量视图</strong><br><strong>3.select中包含子查询的</strong><br><strong>4.join</strong><br><strong>5.from 一个不能更新的视图</strong><br><strong>6.where子句的子查询引用了from子句的表</strong></p><h4 id="6-视图和表的对比："><a href="#6-视图和表的对比：" class="headerlink" title="6.视图和表的对比："></a>6.视图和表的对比：</h4><table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td><strong>视图</strong></td><td>CREATE VIEW</td><td>只是保存了sql逻辑</td><td>增删改查，一般不能增删改</td></tr><tr><td><strong>表</strong></td><td>CREATE TABLE</td><td>占用</td><td>增删改查</td></tr></tbody></table><h3 id="七，变量"><a href="#七，变量" class="headerlink" title="七，变量"></a>七，变量</h3><p><strong>系统变量</strong>   ：变量由系统提供，不是用户自定义，属于服务器层面。<br>查看系统所有变量：show GLOBAL VARIABLES;<br>查看满足条件的部分系统变量： SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>查看指定的某个系统变量的值： SELECT  @@global.autocommit;<br>为某个系统变量赋值：set @@global.系统变量名=值;<br><strong>全局变量:GLOBAL</strong><br>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话有效，但不能<br>跨重启。<br><strong>会话变量:SESSION</strong><br>作用域：针对当前的会话有效。<br>用户自定义变量<br><strong>用户变量</strong><br>声明： SET/SELECT  @用户变量名 :=值;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @用户变量名 :=值;<br>使用：select @用户变量名;<br>应用在任何地方。<br>作用域：针对当前会话和连接有效。<br><strong>局部变量</strong><br>作用域：作用在定义它的begin END 块中。<br>声明： DECLARE 变量名 类型  （default 值）;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @变量名 :=值;<br>使用：select @变量名;<br>只能放在begin END 中的第一句话</p><h3 id="八，存储过程和函数"><a href="#八，存储过程和函数" class="headerlink" title="八，存储过程和函数"></a>八，存储过程和函数</h3><h4 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h4><p><strong>一组预先定义好的sql语句集合，理解成批处理语句。</strong><br>1.提高代码的重用性<br>2.简化操作<br>3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率。</p><h5 id="1-创建语法："><a href="#1-创建语法：" class="headerlink" title="1.创建语法："></a>1.创建语法：</h5><p>CREATE PROCEDURE 存储过程名（参数列表）<br>BEGIN<br>一组合法的sql语句;<br>END<br>参数列表：参数模式 参数名 参数类型</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>OUT  ：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出</p><p>如果存储过程只有一句话，begin END 可以省略</p><p>存储过程体中的每条sql语句的结尾需要必须加分号，<br>存储过程的结尾可以使用 DELIMITER 重新设置。</p><h5 id="2-调用"><a href="#2-调用" class="headerlink" title="2.调用"></a>2.调用</h5><p>CALL 存储过程名（实参列表）;</p><h5 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插入到admin表中五条记录</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_a()</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;yin&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;aa&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;bb&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;cc&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;dd&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="comment">#创建存储过程实现 根据女生名查询对应的男生信息</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_b(IN beauty_name VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line">      <span class="attr">SELECT</span> <span class="string">bo.*</span></span><br><span class="line">      <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">      <span class="attr">RIGHT</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">      <span class="attr">WHERE</span> <span class="string">b.name=beauty_name;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_b(&#x27;热巴&#x27;);</span></span><br><span class="line"><span class="comment">#根据女生名返回他的男朋友名</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_d(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SELECT</span> <span class="string">bo.boyName INTO boyName</span></span><br><span class="line">        <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">        <span class="attr">INNER</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">        <span class="attr">WHERE</span> <span class="string">b.name=beautyName;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_d(&#x27;小昭&#x27;,@b_name);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@b_name;</span></span><br><span class="line"><span class="comment">#传入两个值a，b，最终翻倍返回a和b</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_e(INOUT a INT ,INOUT b INT )</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">a=a*2;</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">b=b*2;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@m=10;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@n=20;</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_e(@m,@n);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@m,@n;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除存储过程"><a href="#4-删除存储过程" class="headerlink" title="4.删除存储过程"></a>4.删除存储过程</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE 存储过程名</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE my_a;</span></span><br></pre></td></tr></table></figure><h5 id="5-查看存储过程的信息"><a href="#5-查看存储过程的信息" class="headerlink" title="5.查看存储过程的信息"></a>5.查看存储过程的信息</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE PROCEDURE  my_b;</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>存储过程可以有0/n个返回值：适合批量增删改</strong><br><strong>函数有且仅有一个返回值：适合查询</strong></p><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION 函数名(参数列表) RETURNS 返回类型</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span></span><br></pre></td></tr></table></figure><p>注意：<br>参数列表：参数名，参数类型<br>一定会有return语句</p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p><strong>SELECT 函数名(参数列表)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回公司员工个数</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f1() RETURNS INT</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c INT DEFAULT 0 ;</span></span><br><span class="line">    <span class="attr">SELECT</span> <span class="string">COUNT(*) INTO c FROM employees;</span></span><br><span class="line">    <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f1();</span></span><br><span class="line"><span class="comment">#根据员工名返回他的工资</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f2(NAME VARCHAR(20)) RETURNS DOUBLE</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c DOUBLE;</span></span><br><span class="line">     <span class="attr">SELECT</span> <span class="string">salary INTO c FROM employees WHERE last_name=NAME;</span></span><br><span class="line">     <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@a=&#x27;Hunold&#x27;;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f2(@a);</span></span><br></pre></td></tr></table></figure><h5 id="3-查看"><a href="#3-查看" class="headerlink" title="3.查看"></a>3.查看</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h3 id="九，流程控制"><a href="#九，流程控制" class="headerlink" title="九，流程控制"></a>九，流程控制</h3><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h5 id="1-if-（表达式1，表达式2，表达式3）"><a href="#1-if-（表达式1，表达式2，表达式3）" class="headerlink" title="1.if （表达式1，表达式2，表达式3）"></a>1.if （表达式1，表达式2，表达式3）</h5><p>如果表达式1成立，就返回表达式2的值，否则返回表达式3的值。<br>应用在任何地方</p><h5 id="2-case"><a href="#2-case" class="headerlink" title="2.case"></a>2.case</h5><h6 id="1-switch-CASE"><a href="#1-switch-CASE" class="headerlink" title="1)switch-CASE"></a>1)switch-CASE</h6><p><strong>语法:</strong><br><strong>CASE 要判断的字段或者表达式</strong><br><strong>WHEN 常量1 THEN 要显示的值1或者语句1</strong><br><strong>WHEN 常量2 THEN 要显示的值2或者语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或者语句n；</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br></pre></td></tr></table></figure><h6 id="2-CASE-使用2："><a href="#2-CASE-使用2：" class="headerlink" title="2)CASE 使用2："></a>2)CASE 使用2：</h6><p><strong>语法：</strong><br><strong>CASE</strong><br><strong>WHEN 条件1 THEN 要显示的值1或语句1</strong><br><strong>WHEN 条件2 THEN 要显示的值2或语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或语句n</strong><br><strong>END</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees </span></span><br><span class="line"> <span class="attr">可以放在任何地方</span></span><br><span class="line"><span class="comment"> #创建存储过程，根据传入的成绩，显示等级，90A,80B，70C，60D ，F</span></span><br><span class="line"> <span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">PROCEDURE my_1(IN score INT)</span></span><br><span class="line"> <span class="attr">BEGIN</span></span><br><span class="line"> <span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"> <span class="attr">WHEN</span>  <span class="string">score BETWEEN 90 AND 100</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;A&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 80 AND 90</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;B&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 80</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;C&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 60</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;D&#x27;;</span></span><br><span class="line"> <span class="attr">ELSE</span> <span class="string">SELECT &#x27;E&#x27;;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">CASE;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_1(95);</span></span><br></pre></td></tr></table></figure><h5 id="3-if"><a href="#3-if" class="headerlink" title="3.if"></a>3.if</h5><p><strong>语法：</strong><br><strong>IF 条件1 THEN 语句1;</strong><br><strong>ELSEIF 条件2 THEN 语句2;</strong><br><strong>…</strong><br><strong>ELSE 语句n;</strong><br><strong>END IF;</strong><br>只能用在begin end中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建存储过程，根据传入的成绩，返回等级，90A,80B，70C，60D ，F</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">FUNCTION my_2( score INT) RETURNS CHAR</span></span><br><span class="line"> <span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line">   <span class="attr">IF</span> <span class="string">score &gt;=90 THEN RETURN&#x27;A&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=80 THEN RETURN&#x27;B&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=70 THEN RETURN&#x27;C&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=60 THEN RETURN&#x27;D&#x27;;</span></span><br><span class="line">   <span class="attr">ELSE</span> <span class="string">RETURN&#x27;E&#x27;;</span></span><br><span class="line">   <span class="attr">END</span> <span class="string">IF;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">SELECT</span>  <span class="string">my_2(85);</span></span><br></pre></td></tr></table></figure><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>在存储过程或函数里面使用</strong></p><h5 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h5><p><strong>语法：</strong><br><strong>标签:WHILE 循环条件 DO</strong><br><strong>循环体;</strong><br><strong>END WHILE 标签;</strong><br><strong>循环控制和标签搭配使用</strong></p><h5 id="2-loop"><a href="#2-loop" class="headerlink" title="2.loop"></a>2.loop</h5><p><strong>语法：</strong><br><strong>标签： LOOP</strong><br><strong>循环体;</strong><br><strong>END LOOP 标签;</strong></p><h5 id="3-repeat"><a href="#3-repeat" class="headerlink" title="3.repeat"></a>3.repeat</h5><p><strong>语法：</strong><br><strong>标签： REPEAT</strong><br><strong>循环体;</strong><br><strong>UNTIL 结束循环的条件</strong><br><strong>END REPEAT 标签;</strong></p><p>循环控制<br>ITERATE 类似continue<br>LEAVE   类似break</p><hr><p>left join==left outer join</p><p>a left join b 就是取a和b的交集加a剩下的部分</p><p>inner join</p><p>a inner join b就是取交集</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12610368/1641814968278-9ad396b9-3c05-4a17-816c-26b50cd647c2.jpeg" alt="夜拍.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[二]概述</title>
      <link href="/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一，一条SQL的查询流程"><a href="#一，一条SQL的查询流程" class="headerlink" title="一，一条SQL的查询流程"></a>一，一条SQL的查询流程</h1><ol><li><p>去连接池获取连接</p></li><li><p>查询缓存，命中返回，否则继续向下</p></li><li><p>词法解析&amp;预处理</p><blockquote><p>词法解析拆分SQL，语法分析检查SQL的正确性生成一颗解析树，预处理检查表名，列名，生成一颗解析树。</p></blockquote></li><li><p>优化器优化，优化计划，查询计划</p></li><li><p>执行引擎生成执行计划</p></li><li><p>存储引擎查询SQL，加入缓存，返回结果。</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641449666256-21382ea1-bf47-4ce3-b1ea-5cb8e82965f1.png" alt="image.png"></p><h2 id="1-获取连接"><a href="#1-获取连接" class="headerlink" title="1.获取连接"></a>1.获取连接</h2><p>MySQL支持多种通信协议，可以使用同步/异步的方式，支持长连接，短连接。<br>​</p><h3 id="1-1-通信类型"><a href="#1-1-通信类型" class="headerlink" title="1.1 通信类型"></a>1.1 通信类型</h3><p>​</p><p>一般来说，<strong>连接数据库都是同步连接</strong>。<br>​</p><blockquote><ol><li>同步连接：依赖于被调用方，受限制于被调用方的性能；一般只能一对一。</li><li>异步连接：避免阻塞，但不能节省SQL的执行时间，并发情况下，每个SQL的执行都要单独建立连接，占用大量CPU资源；异步连接必须使用连接池减少线程创建销毁的开销。</li></ol></blockquote><h3 id="1-2-连接方式"><a href="#1-2-连接方式" class="headerlink" title="1.2 连接方式"></a>1.2 连接方式</h3><p>MySQL长短连接都支持，一般我们会在连接池中使用长连接。保持长连接会消耗内存，长时间不活动的连接，MySQL服务器会断开。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">-- 非交互式超时时间，如 JDBC 程序</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;interactive_timeout&#x27;</span>; <span class="comment">-- 交互式超时时间，如数据库工具</span></span><br></pre></td></tr></table></figure><blockquote><p>默认长连接断开时间是8小时。</p></blockquote><p>可以使用 <code>show status;</code>查看当前MySQL有多少个连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Threads_cached</th><th>缓存中的线程连接数</th></tr></thead><tbody><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>为处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>每产生一个连接或者会话，服务端就会创建一个线程来处理。杀死会话本质就是kill 线程。<br>​</p><blockquote><p>可以使用<code>SHOW PROCESSLIST; </code>（root 用户）查看 SQL 的执行状态。<br>​</p></blockquote><blockquote><p>+—-+——+———–+——+———+——+———-+<br>| Id | User | Host      | db   | Command | Time | State    | Info             |<br>+—-+——+———–+——+———+——+———-+<br>| 11 | root | localhost | NULL | Query   |    0 | starting | show processlist |<br>+—-+——+———–+——+———+——+———-+</p></blockquote><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Sleep</td><td>线程正在等待客户端，以向它发送一个新语句</td></tr><tr><td>Query</td><td>线程正在执行查询或往客户端发送数据</td></tr><tr><td>Locked</td><td>该查询被其它查询锁定</td></tr><tr><td>Copying to tmp table on disk</td><td>临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器</td></tr><tr><td>Sending data</td><td>线程正在为 SELECT 语句处理行，同时正在向客户端发送数据</td></tr><tr><td>Sorting for group</td><td>线程正在进行分类，以满足 GROUP BY 要求</td></tr><tr><td>Sorting for order</td><td>线程正在进行分类，以满足 ORDER BY 要求</td></tr></tbody></table><p>在5.7版本，MySQL的默认连接数是151个，我们最大可以修改为16384个 （214）。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> [<span class="keyword">global</span> <span class="operator">|</span> session] max_connections <span class="operator">=</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-3-通信协议"><a href="#1-3-通信协议" class="headerlink" title="1.3 通信协议"></a>1.3 通信协议</h3><p>​</p><ol><li>编程语言的连接模块都是用 TCP 协议连接到 MySQL 服务器的，比如mysql-connector-java-x.x.xx.jar。</li><li>类unix系统上，支持 Socket套接字文件进行进程间通信。<code>/tmp/mysql.sock</code></li><li>windows系统上还支持命名管道和共享内存。</li></ol><p>​</p><h3 id="1-4-通信方式"><a href="#1-4-通信方式" class="headerlink" title="1.4 通信方式"></a>1.4 通信方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641431698698-e3b38143-26dc-439d-8a75-feff85dbc973.png" alt="image.png"><br>MySQL使用了半双工通信，所以客户端发送SQL语句给服务端的时候，不管SQL有多大，都是一次发过去的。<br>​</p><blockquote><p>比如我们用MyBatis动态SQL生成了一个批量插入的语句，插入10万条数据，values后面跟了一长串的内容，或者 where 条件 in 里面的值太多，会出现问题。这个时候我们必须要调整 MySQL 服务器配置 max_allowed_packet 参数的值（默认是 4M），把它调大，否则就会报错。</p></blockquote><p>对于服务端来说，也是一次性发送所有的数据，不能因为你已经取到了想要的数据就中断操作，这个时候会对网络和内存产生大量消耗。在程序里面避免不带 limit 的这种操作，比如一次把所有满足条件的数据全部查出来，一定要先 count 一下。如果数据量的话，可以分批查询。</p><hr><h2 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h2><p>MySQL 的缓存默认是关闭的。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL不推荐使用自带的缓存，命中条件过于苛刻。且表里数据发生变化，整张表的缓存全部失效，MySQL8移除掉了缓存。</p><hr><h2 id="3-语法解析-amp-预处理"><a href="#3-语法解析-amp-预处理" class="headerlink" title="3.语法解析&amp;预处理"></a>3.语法解析&amp;预处理</h2><h3 id="3-1-词法解析"><a href="#3-1-词法解析" class="headerlink" title="3.1 词法解析"></a>3.1 词法解析</h3><p>词法分析就是把一个完整的 SQL 语句打碎成一个个的单词。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>它会打碎成 8 个符号，每个符号是什么类型，从哪里开始到哪里结束。<br>​</p><h3 id="3-2-语法解析"><a href="#3-2-语法解析" class="headerlink" title="3.2 语法解析"></a>3.2 语法解析</h3><p>语法分析会对 SQL 做一些语法检查，比如单引号有没有闭合，然后根据 MySQL 定义的语法规则，根据 SQL 语句生成一个数据结构。这个数据结构我们把它叫做解析树（select_lex）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641432113376-2499bc3f-6277-49aa-8a99-eb135ce35507.png" alt="image.png"></p><blockquote><p>任何数据库的中间件，比如 Mycat，Sharding-JDBC（用到了 Druid Parser），都必须要有词法和语法分析功能。</p></blockquote><h3 id="3-3-预处理"><a href="#3-3-预处理" class="headerlink" title="3.3 预处理"></a>3.3 预处理</h3><p>​</p><p>如果写了一个词法和语法都正确的 SQL，但是表名或者字段不存在，会在哪里报错？是在数据库的执行层还是解析器？<br>​</p><p>实际上还是在解析的时候报错，解析 SQL 的环节里面有个预处理器。它会检查生成的解析树，解决解析器无法解析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理之后得到一个新的解析树。<br>​</p><hr><h2 id="4-查询优化-amp-查询执行计划"><a href="#4-查询优化-amp-查询执行计划" class="headerlink" title="4.查询优化&amp;查询执行计划"></a>4.查询优化&amp;查询执行计划</h2><p>一条SQL语句的执行方式有很多种，但是最终返回的结果都是相同的。查询优化器的目的就是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，那种执行计划开销最小，就用哪种。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看查询的开销</span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-优化器的作用"><a href="#4-1-优化器的作用" class="headerlink" title="4.1 优化器的作用"></a>4.1 优化器的作用</h3><ol><li>多表联查，以哪张表为基准表</li><li>用不用索引，用哪个索引</li><li>。。。。</li></ol><p>​</p><h3 id="4-2-优化器是怎么得到执行计划的"><a href="#4-2-优化器是怎么得到执行计划的" class="headerlink" title="4.2 优化器是怎么得到执行计划的"></a>4.2 优化器是怎么得到执行计划的</h3><ol><li>首先我们要启用优化器的追踪（默认是关闭的）。</li></ol><blockquote><p>开启这开关是会消耗性能的，因为它要把优化分析的结果写到表里面，所以不要轻易开启，或者查看完之后关闭它（改成 off）。</p></blockquote><ol start="2"><li>接着执行一个 SQL 语句，优化器会生成执行计划：</li></ol><ol start="3"><li>这个时候优化器分析的过程已经记录到系统表里面了，我们可以查询：</li></ol><blockquote><p>它是一个 JSON 类型的数据，主要分成三部分，准备阶段、优化阶段和执行阶段。</p></blockquote><blockquote><p>expanded_query 是优化后的 SQL 语句。</p></blockquote><blockquote><p>considered_execution_plans 里面列出了所有的执行计划。</p></blockquote><ol start="4"><li>分析完记得关掉它</li></ol><blockquote><p>通过追踪优化器，可以看到优化器对sql的初始优化，表的读取顺序，为什么采用了这种读取顺序。为什么采用了某个索引或者采用了全表查询。</p></blockquote><h3 id="4-3-优化器得到的结果"><a href="#4-3-优化器得到的结果" class="headerlink" title="4.3 优化器得到的结果"></a>4.3 优化器得到的结果</h3><p>​</p><p>优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。</p><p>当然，这个执行计划是不是一定是最优的执行计划呢？不一定，因为 MySQL 也有可能覆盖不到所有的执行计划。<br>​</p><p>MySQL 提供了一个执行计划的工具。我们在 SQL 语句前面加上 EXPLAIN，就可以看到执行计划的信息。<br>​</p><p><strong>Explain 的结果也不一定最终执行的方式。</strong><br><strong>​</strong></p><h3 id="4-4-选错索引"><a href="#4-4-选错索引" class="headerlink" title="4.4 选错索引"></a>4.4 选错索引</h3><p>这里错误决定分两类，第一，彻底错误。第二，基于成本最低，但执行速度不是最快。</p><ol><li><p>由于InnoDB的 MVCC 功能和随机采样方式，默认随机采取几个数据页，当做总体数据。以部分代表整体，本来就有错误的风险。加上数据不断地添加过程中，索引树可能会分裂，结果更加不准确。 </p><blockquote><ol><li>执行 ANALYZE TABLE ,可以重新构建索引，使索引树不过于分裂。</li><li>调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。</li></ol></blockquote></li><li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。 </p><blockquote><ol><li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li><li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。 </li></ol></blockquote></li></ol><hr><h2 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5. 存储引擎"></a>5. 存储引擎</h2><p>得到执行计划以后，SQL 语句是不是终于可以执行了？</p><ol><li>从逻辑的角度来说，我们的数据是放在哪里的，或者说放在一个什么结构里面？</li></ol><ol start="2"><li>执行计划在哪里执行？是谁去执行？</li></ol><p>表在存储数据的同时，还要组织数据的存储结构，这个存储结构就是由存储引擎决定的，所以也可以把存储引擎叫做表类型。</p><p>在 MySQL 里面，支持多种存储引擎，他们是可以替换的，所以叫做插件式的存储引擎。<br>​</p><h3 id="5-1-查看存储引擎"><a href="#5-1-查看存储引擎" class="headerlink" title="5.1 查看存储引擎"></a>5.1 查看存储引擎</h3><p>我们数据库里面已经存在的表，我们怎么查看它们的存储引擎呢？<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> `数据库名`;</span><br></pre></td></tr></table></figure><p>或者通过 DDL 建表语句来查看。<br>​</p><p>在 MySQL 里面，我们创建的每一张表都可以指定它的存储引擎，而不是一个数据库只能使用一个存储引擎。存储引擎的使用是以表为单位的。而且，创建表之后还可以修改存储引擎。<br>​</p><p>一张表使用的存储引擎决定存储数据的结构，那在服务器上它们是怎么存储的呢？先要找到数据库存放数据的路径：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434256832-de450340-7be5-41be-845e-61c79f6b4f82.png" alt="image.png"><br>默认情况下，每个数据库有一个自己文件夹，以 yhd数据库为例。任何一个存储引擎都有一个 frm 文件，这个是表结构定义文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434747584-0e54ae84-325f-48ba-9586-59d5b480aa92.png" alt="image.png"><br>不同的存储引擎存放数据的方式不一样，产生的文件也不一样，innodb 是 1 个，memory 没有，myisam 是两个。</p><h3 id="5-2-存储引擎比较"><a href="#5-2-存储引擎比较" class="headerlink" title="5.2 存储引擎比较"></a>5.2 存储引擎比较</h3><h4 id="①常见存储引擎"><a href="#①常见存储引擎" class="headerlink" title="①常见存储引擎"></a>①常见存储引擎</h4><p>MyISAM 和 InnoDB 是我们用得最多的两个存储引擎，在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，它是 MySQL 自带的。</p><p>5.5 版本之后默认的存储引擎改成了 InnoDB，最主要的原因还是 InnoDB 支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。</p><h4 id="②数据库支持的存储引擎"><a href="#②数据库支持的存储引擎" class="headerlink" title="②数据库支持的存储引擎"></a>②数据库支持的存储引擎</h4><p>可以用这个命令查看数据库对存储引擎的支持情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines ;</span><br></pre></td></tr></table></figure><p>其中有存储引擎的描述和对事务、XA 协议和 Savepoints 的支持。</p><p>XA 协议用来实现分布式事务（分为本地资源管理器，事务管理器）。</p><p>Savepoints 用来实现子事务（嵌套事务）。创建了一个 Savepoints 之后，事务就可以回滚到这个点，不会影响到创建 Savepoints 之前的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641435383199-5ae5e040-4df5-4a35-94ba-e8e13b19fe54.png" alt="image.png"></p><h4 id="③MyISAM（3-个文件）"><a href="#③MyISAM（3-个文件）" class="headerlink" title="③MyISAM（3  个文件）"></a>③MyISAM（3  个文件）</h4><p>应用范围比较小。表级锁定限制了读/写的性能，因此在 Web 和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p><strong>特点</strong></p><ol><li>支持表级别的锁（插入和更新会锁表）。不支持事务。</li></ol><ol start="2"><li>拥有较高的插入（insert）和查询（select）速度。</li></ol><ol start="3"><li>存储了表的行数（count 速度更快）。</li></ol><p>适合：只读之类的数据分析的项目。</p><h4 id="④InnoDB（2个文件）"><a href="#④InnoDB（2个文件）" class="headerlink" title="④InnoDB（2个文件）"></a>④InnoDB（2个文件）</h4><p>mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全（与 ACID 兼容）的 MySQL存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB 行级锁（不升级为更粗粒度的锁）和 Oracle 风格的一致非锁读提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中，以减少基于主键的常见查询的 I/O。为了保持数据完整性，InnoDB 还支持外键引用完整性约束。</p><p><strong>特点</strong></p><ol><li>支持事务，支持外键，因此数据的完整性、一致性更高。</li></ol><ol start="2"><li>支持行级别的锁和表级别的锁。</li></ol><ol start="3"><li>支持读写并发，写不阻塞读（MVCC）。</li></ol><ol start="4"><li>特殊的索引存放方式，可以减少 IO，提升查询效率。</li></ol><p>适合：经常更新的表，存在并发读写或者有事务处理的业务系统。</p><h4 id="⑤Memory-1个文件"><a href="#⑤Memory-1个文件" class="headerlink" title="⑤Memory(1个文件)"></a>⑤Memory(1个文件)</h4><p>基于内存的存储引擎。</p><p>特征：</p><ul><li>基于内存的表，服务器重启后，表结构会被保留，但表中的数据会被清空。</li><li>不需要进行磁盘IO，比 MYISAM 快了一个数量级。</li><li>表级锁，故并发插入性能较低。</li><li>每一行是固定的，VARCHAR 列在 memory 存储引擎中会变成 CHAR，可能导致内存浪费。</li><li>不支持 BLOB 或 TEXT 列，如果sql返回的结果列中包含 BLOB 或 TEXT，就直接采用 MYISAM 存储引擎，在磁盘上建临时表</li><li>支持哈希索引，B+树索引</li></ul><p>MEMORY 存储引擎在很多地方可以发挥很好的作用：</p><ul><li>用于查找或映射表，例如邮编和州名的映射表</li><li>用于缓存周期性聚合数据的结果</li><li>用于保存数据分析中产生的中间结果。即SQL执行过程中用到的临时表</li><li>监控MySQL内存中的执行情况，例如：information_schema 库下的表基本都是 memory 存储引擎，监控InnoDB缓冲池中page(INNODB_BUFFER_PAGE表)，InnoDB缓冲池状态(INNODB_BUFFER_POOL_STATS表)、InnoDB缓存页淘汰记录(INNODB_BUFFER_PAGE_LRU表)、InnoDB锁等待(INNODB_LOCK_WAITS表)、InnoDB锁信息(INNODB_LOCKS表)、InnoDB中正在执行的事务(INNODB_TRX表)等。</li></ul><p><strong>MEMORY 存储引擎默认 hash 索引，故等值查询特别快。同时也支持B+树索引。虽然查询速度特别快，但依旧无法取代传统的磁盘建表。</strong></p><h4 id="⑥CSV-3个文件"><a href="#⑥CSV-3个文件" class="headerlink" title="⑥CSV(3个文件)"></a>⑥CSV(3个文件)</h4><p>它的表实际上是带有逗号分隔值的文本文件。csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据。因为 csv 表没有索引，所以通常在正常操作期间将数据保存在 innodb 表中，并且只在导入或导出阶段使用 csv 表。</p><p><strong>特点</strong></p><p>不允许空行，不支持索引。格式通用，可以直接编辑，适合在不同数据库之间导入导出。<br>​</p><h3 id="5-3-如何选择存储引擎"><a href="#5-3-如何选择存储引擎" class="headerlink" title="5.3 如何选择存储引擎"></a>5.3 如何选择存储引擎</h3><ol><li>如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。</li></ol><ol start="2"><li>如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。</li></ol><ol start="3"><li>如果需要一个用于查询的临时表，可以选择 Memory。</li></ol><p>​</p><hr><h2 id="6-执行引擎"><a href="#6-执行引擎" class="headerlink" title="6.执行引擎"></a>6.执行引擎</h2><p>执行引擎，它利用存储引擎提供的相应的 API 来完成操作。</p><p>为什么我们修改了表的存储引擎，操作方式不需要做任何改变？因为不同功能的存储引擎实现的 API 是相同的。</p><p>最后把数据返回给客户端，即使没有结果也要返回。<br>​</p><hr><h1 id="二，一条SQL的更新流程"><a href="#二，一条SQL的更新流程" class="headerlink" title="二，一条SQL的更新流程"></a>二，一条SQL的更新流程</h1><p>更新和查询很多地方并没有区别，仅仅在于拿到数据之后的操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641458151710-45fe3a24-a127-401d-abec-75f52f953f3d.png" alt="image.png"></p><h2 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1.内存结构"></a>1.内存结构</h2><p>InnnoDB 的数据都是放在磁盘上的，InnoDB 操作数据有一个最小的逻辑单位，叫做页（索引页和数据页）。我们对于数据的操作，不是每次都直接操作磁盘，因为磁盘的速度太慢了。InnoDB 使用了一种缓冲池的技术，也就是把磁盘读到的页放到一块内存区域里面。这个内存区域就叫 Buffer Pool。<br>​</p><p>下一次读取相同的页，先判断是不是在缓冲池里面，如果是，就直接读取，不用再次访问磁盘。</p><p>修改数据的时候，先修改缓冲池里面的页。内存的数据页和磁盘数据不一致的时候，我们把它叫做脏页。InnoDB 里面有专门的后台线程把 Buffer Pool 的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p><p>Buffer Pool 是 InnoDB 里面非常重要的一个结构，主要分为 3 个部分： Buffer Pool、Change Buffer、Adaptive HashIndex，另外还有一个（redo）log buffer。<br>​</p><h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>Buffer Pool 缓存的是页信息，包括数据页、索引页，默认大小是 128M（134217728 字节），可以调整。</p><p>查看服务器状态，里面有很多跟 Buffer Pool 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>查看参数（系统变量）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES like &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>内存的缓冲池写满了怎么办？（Redis 设置的内存满了怎么办？）InnoDB 用 LRU算法来管理缓冲池（链表实现，不是传统的 LRU，分成了 young 和 old），经过淘汰的数据就是热点数据。</p><p>内存缓冲区对于提升读写性能有很大的作用。当需要更新一个数据页时，如果数据页在 Buffer Pool 中存在，那么就直接更新好了。否则的话就需要从磁盘加载到内存，再对内存的数据页进行操作。也就是说，如果没有命中缓冲池，至少要产生一次磁盘 IO。<br>​</p><h3 id="1-2-ChangeBuffer写缓冲"><a href="#1-2-ChangeBuffer写缓冲" class="headerlink" title="1.2 ChangeBuffer写缓冲"></a>1.2 ChangeBuffer写缓冲</h3><p>如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓冲池中，从而提升更新语句（Insert、Delete、Update）的执行速度。</p><p>这一块区域就是 Change Buffer。5.5 之前叫 Insert Buffer 插入缓冲，现在也能支持 delete 和 update。</p><p>最后把 Change Buffer 记录到数据页的操作叫做 merge。什么时候发生 merge？有几种情况：在访问这个数据页的时候，或者通过后台线程、或者数据库 shut down、redo log 写满时触发。</p><p>如果数据库大部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以使用 Change Buffer（写缓冲）。写多读少的业务，调大这个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_change_buffer_max_size&#x27;;</span><br></pre></td></tr></table></figure><p>代表 Change Buffer 占 Buffer Pool 的比例，默认 25%。<br>​</p><h3 id="1-3-Adaptive-Hash-Index"><a href="#1-3-Adaptive-Hash-Index" class="headerlink" title="1.3 Adaptive Hash Index"></a>1.3 Adaptive Hash Index</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？</p><p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p><p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。<br>​</p><h3 id="1-4-（redo）Log-Buffer"><a href="#1-4-（redo）Log-Buffer" class="headerlink" title="1.4 （redo）Log Buffer"></a>1.4 （redo）Log Buffer</h3><p>​</p><p>如果 Buffer Pool 里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据丢失。如果写操作写到一半，甚至可能会破坏数据文件导致数据库不可用。为了避免这个问题，InnoDB 把所有对页面的修改操作专门写入一个日志文件，并且在数据库启动时从这个文件进行恢复操作（实现 crash-safe）——用它来实现事务的持久性。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478367975-c4e017fe-92ed-440a-8fb3-3efc4c310546.png" alt="image.png"><br>这个文件就是磁盘的 redo log（叫做重做日志），对应于/var/lib/mysql/目录下的ib_logfile0 和 ib_logfile1，每个 48M。这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里 的 WAL 技 术（Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log%&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认 48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为 2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir 路径。</td></tr></tbody></table><p><strong>同样是写磁盘，为什么不直接写到 db file 里面去？为什么先写日志再写磁盘？</strong></p><p>磁盘的最小组成单元是扇区，通常是 512 个字节。操作系统和内存打交道，最小的单位是页 Page。操作系统和磁盘打交道，读写磁盘，最小的单位是块 Block。<br>​</p><p>如果我们所需要的数据是随机分散在不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们所需要的一块数据，依次进行此过程直到找完所有数据，这个就是随机 IO，读取数据速度较慢。</p><p>假设我们已经找到了第一块数据，并且其他所需的数据就在这一块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序 IO。</p><p>刷盘是随机 I/O，而记录日志是顺序 I/O，顺序 I/O 效率更高。因此先把修改写入日志，可以延迟刷盘时机，进而提升系统吞吐。</p><p>当然 redo log 也不是每一次都直接写入磁盘，在 Buffer Pool 里面有一块内存区域（Log Buffer）专门用来保存即将要写入日志文件的数据，默认 16M，它一样可以节省磁盘 IO。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478572344-fc83dc25-3a96-42fd-8017-03423f4d9f49.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>redo log 的内容主要是用于崩溃恢复。磁盘的数据文件，数据来自 buffer pool。redo log 写入磁盘，不是写入数据文件。</p></blockquote><p>那么，Log Buffer 什么时候写入 log file？</p><p>在我们写入数据到磁盘的时候，操作系统本身是有缓存的。flush 就是把操作系统缓冲区写入到磁盘。</p><p>log buffer 写入磁盘的时机，由一个参数控制，默认是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_flush_log_at_trx_commit&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>log buffer 将每秒一次地写入 log file 中，并且 log file 的 flush 操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。</td></tr><tr><td>1（默认，实时写，实时刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，并且刷到磁盘中去。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file。但是 flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次 flush 操作。</td></tr></tbody></table><p>redo log，它又分成内存和磁盘两部分。redo log 有什么特点？</p><ol><li>redo log 是 InnoDB 存储引擎实现的，并不是所有存储引擎都有。</li></ol><ol start="2"><li>不是记录数据页更新之后的状态，而是记录这个页做了什么改动，属于物理日志。（redo log 记录的是执行的结果）</li></ol><ol start="3"><li>redo log 的大小是固定的，前面的内容会被覆盖。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478994184-25e740bb-80a0-48fe-9327-bc4bb7da7192.png" alt="image.png"><br>check point 是当前要覆盖的位置。如果 write pos 跟 check point 重叠，说明 redolog 已经写满，这时候需要同步 redo log 到磁盘中。</p><p>这是 MySQL 的内存结构，总结一下，分为：Buffer pool、change buffer、Adaptive Hash Index、 log buffer。</p><blockquote><p>磁盘结构里面主要是各种各样的表空间，叫做 Table space。</p></blockquote><h3 id="1-5-缓存的疑问"><a href="#1-5-缓存的疑问" class="headerlink" title="1.5 缓存的疑问"></a>1.5 缓存的疑问</h3><p><strong>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</strong></p><p>然后，InnoDB架构中，有非常重要的一个部分——<strong>缓冲池</strong>。该缓冲池需要占用服务器内存，且<strong>专用于MySQL的服务器，建议把80%的内存交给MySQL。</strong></p><p>缓冲池有一个缓存的功能。这个缓存，是InnoDB自带的，而且经常会用到。该缓存功能并不是MySQL架构中的缓存组件。这是两者最大的区别。</p><ul><li>MySQL组件中的缓存 <ol><li>所处位置：MySQL架构中的缓存组件</li><li>缓存内容：缓存的是SQL 和 该SQL的查询结果。如果SQL的大小写，格式，注释不一致，则被认为是不同的SQL，重新查询数据库，并缓存一份数据。</li><li>可否关闭：是可以手动关闭，并卸载该组件的。</li></ol></li><li>InnoDB中的缓存 <ol><li>所处位置：InnoDB架构中的缓冲池</li><li>缓存内容：缓存的是所有需要查找的数据，所在的数据页。</li><li>可否关闭：是InnoDB缓冲池自带的功能，<strong>无法关闭，无法卸载</strong>。如果InnoDB的缓冲池被关闭或卸载，则InnoDB直接瘫痪。所以说缓冲池是InnoDB的最重要的一部分。</li></ol></li></ul><p>不建议使用MySQL的缓存是指，不建议使用MySQL架构中的缓存组件，并不是同时否定了InnoDB中的缓存功能。<br>​</p><hr><h2 id="2-磁盘结构"><a href="#2-磁盘结构" class="headerlink" title="2.磁盘结构"></a>2.磁盘结构</h2><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB 的表空间分为 5 大类。<br>​</p><h3 id="2-1-系统表空间"><a href="#2-1-系统表空间" class="headerlink" title="2.1 系统表空间"></a>2.1 系统表空间</h3><p>在默认情况下 InnoDB 存储引擎有一个共享表空间（对应文件/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>InnoDB 系统表空间包含 InnoDB 数据字典和双写缓冲区，（Change Buffer 和 UndoLogs），如果没有指定 file-per-table，也包含用户创建的表和索引数据。</p><ol><li>undo 在后面介绍，因为有独立的表空间。</li></ol><ol start="2"><li>数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）。</li></ol><ol start="3"><li>双写缓冲（InnoDB 的一大特性）</li></ol><p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641479261038-52879c45-835e-4fae-abcd-1ca4ac1f9c66.png" alt="image.png"></p><p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_doublewrite&#x27;;</span><br></pre></td></tr></table></figure><p>如果这个页本身已经损坏了，用它来做崩溃恢复是没有意义的。所以在对于应用 redo log 之前，需要一个页的副本。如果出现了写入失效，就用页的副本来还原这个页，然后再应用 redo log。这个页的副本就是 double write，InnoDB 的双写技术。通过它实现了数据页的可靠性。</p><p>跟 redo log 一样，double write 由两部分组成，一部分是内存的 double write，一个部分是磁盘上的 double write。因为 double write 是顺序写入的，不会带来很大的开销。</p><p>在MySQL5.7之前，所有的表共享一个系统表空间，这个文件会越来越大，而且它的空间不会收缩。<br>​</p><h3 id="2-2-独占表空间"><a href="#2-2-独占表空间" class="headerlink" title="2.2 独占表空间"></a>2.2 独占表空间</h3><p>我们可以让每张表独占一个表空间。这个开关通过 innodb_file_per_table 设置，默认开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure><p>开启后，则每张表会开辟一个表空间，这个文件就是数据目录下的 ibd 文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间内。<br>​</p><h3 id="2-3-通用表空间"><a href="#2-3-通用表空间" class="headerlink" title="2.3 通用表空间"></a>2.3 通用表空间</h3><p>通用表空间也是一种共享的表空间，跟 ibdata1 类似。</p><p>可以创建一个通用的表空间，用来存储不同数据库的表，数据路径和文件可以自定义。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace ts2673 add datafile &#x27;/var/lib/mysql/ts2673.ibd&#x27; file_block_size=16K engine=innodb;</span><br></pre></td></tr></table></figure><p>在创建表的时候可以指定表空间，用 ALTER 修改表空间可以转移表空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2673(id integer) tablespace ts2673;</span><br></pre></td></tr></table></figure><p>不同表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table t2673;</span><br><span class="line">drop tablespace ts2673;</span><br></pre></td></tr></table></figure><h3 id="2-4-临时表空间"><a href="#2-4-临时表空间" class="headerlink" title="2.4 临时表空间"></a>2.4 临时表空间</h3><p>存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的 ibtmp1 文件。当数据服务器正常关闭时，该表空间被删除，下次重新产生。</p><p><strong>memory向template的过渡，还有磁盘上简历临时表用的什么存储引擎？</strong></p><p>8.0之前，内存临时表用Memory引擎创建，但假如字段中有BLOB或TEXT,或结果太大，就会转用MYISM在磁盘上建表，8.0之后内存临时表由MEMORY引擎更改为TempTable引擎，相比于前者，后者支持以变长方式存储VARCHAR，VARBINARY等变长字段。从MySQL 8.0.13开始，TempTable引擎支持BLOB字段。如果超过内存表大小，则用InnoDB建表。</p><h3 id="2-5-redo-log"><a href="#2-5-redo-log" class="headerlink" title="2.5 redo log"></a>2.5 redo log</h3><h3 id="2-6-undo-log-表空间"><a href="#2-6-undo-log-表空间" class="headerlink" title="2.6 undo log 表空间"></a>2.6 undo log 表空间</h3><p>undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态（不包括 select）。</p><p>如果修改数据时出现异常，可以用 undo log 来实现回滚操作（保持原子性）。</p><p>在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，属于逻辑格式的日志(记录操作)。</p><p>redo Log 和 undo Log 与事务密切相关，统称为事务日志。</p><p>undo Log 的数据默认在系统表空间 ibdata1 文件中，因为共享表空间不会自动收缩，也可以单独创建一个 undo 表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%undo%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-7-一条SQL的更新流程"><a href="#2-7-一条SQL的更新流程" class="headerlink" title="2.7 一条SQL的更新流程"></a>2.7 一条SQL的更新流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>事务开始，从内存或者磁盘取到这条数据，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>记录name = 二十 到redo log</li><li>调用存储引擎接口，在buffer pool 中修改 name =二十</li><li>事务提交</li></ol><p>​</p><blockquote><p>内存和磁盘之间，工作着很多后台线程。</p></blockquote><hr><h2 id="3-后台线程"><a href="#3-后台线程" class="headerlink" title="3.后台线程"></a>3.后台线程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641480352645-ff2557dd-b622-49e2-829c-d058bbe6d559.png" alt="image.png"><br>后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master线程，IO 线程，purge 线程，page cleaner 线程。<br>​</p><h3 id="3-1-Master-线程"><a href="#3-1-Master-线程" class="headerlink" title="3.1 Master 线程"></a>3.1 Master 线程</h3><p>Master Thread是InnoDB存储引擎非常核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。<br>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    thread_sleep(<span class="number">1</span>);<span class="comment">// sleep 1秒</span></span><br><span class="line">        <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">        <span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">        <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">          <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct(默认是75时)</span></span><br><span class="line">            <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;<span class="comment">// 刷新100脏页到磁盘</span></span><br><span class="line">        <span class="keyword">if</span>(no user activity)</span><br><span class="line">            <span class="keyword">goto</span> backgroud loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>) <span class="comment">// 如果过去10内磁盘IO次数小于设置的innodb_io_capacity的值（默认是200）</span></span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer; <span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">    <span class="keyword">do</span> full purge;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; <span class="number">70</span>%)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer pool flush <span class="number">10</span> dirty page;</span><br><span class="line"></span><br><span class="line">    backgroud loop：<span class="comment">// 后台循环</span></span><br><span class="line">    <span class="keyword">do</span> full purge<span class="comment">// 删除无用的undo页 （总是）</span></span><br><span class="line">    <span class="keyword">do</span> merge <span class="number">20</span> insert buffer;<span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idle<span class="comment">// 如果不空闲，就跳回主循环，如果空闲就跳入flush loop</span></span><br><span class="line">        <span class="keyword">goto</span> loop:<span class="comment">// 跳到主循环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop</span><br><span class="line"></span><br><span class="line">    flush loop:<span class="comment">// 刷新循环</span></span><br><span class="line">    <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">    <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct的值（默认75%）</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop;<span class="comment">// 跳到刷新循环，不断刷新脏页，直到符合条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> suspend loop;<span class="comment">// 完成刷新脏页的任务后，跳入suspend loop</span></span><br><span class="line"></span><br><span class="line">    suspend loop:</span><br><span class="line">    suspend_thread();<span class="comment">//master线程挂起，等待事件发生</span></span><br><span class="line">    waiting event;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master Thread具有<strong>最高的线程优先级别</strong>。内部由多个循环组成：<strong>主循环（loop）</strong>、<strong>后台循环</strong>（backgroup loop）、<strong>刷新循环</strong>（flush loop）、<strong>暂停循环</strong>（suspend loop）。Master Thread会<strong>根据数据库运行的状态</strong>在loop、backgroup loop、flush loop和suspend loop中<strong>进行切换</strong>。loop是主循环，大多数的操作都在这个循环中，主要有两大部分的操作——每秒钟的操作和每10秒钟的操作。<br>​</p><h4 id="①每秒钟的操作"><a href="#①每秒钟的操作" class="headerlink" title="①每秒钟的操作"></a>①每秒钟的操作</h4><p>​</p><ol><li>​<strong>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）</strong>；<br>即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这也解释了为什么再大的事务提交的时间也是很短的。 </li><li> <strong>合并插入缓冲（可能）</strong>；<br>合并插入缓冲并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB存储引擎认为当前的IO压力很小，可以执行合并插入缓冲的操作； </li><li> <strong>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</strong>； 刷新100个脏页也不是每秒都会发生的，InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_get_modified_ratio_pct)是否超过了配置文件中 innodb_max_dirty_pages_pct这个参数（默认是75，代表75%），如果超过了这个值，InnoDB存储引擎则认为需要做磁盘同步的操作，将100个脏页写入磁盘中。 </li><li> <strong>如果当前没有用户活动，则切换到background loop(可能)。</strong></li></ol><p><strong>​</strong></p><h4 id="②每十秒的操作"><a href="#②每十秒的操作" class="headerlink" title="②每十秒的操作"></a>②每十秒的操作</h4><ol><li> <strong>刷新100个脏页到磁盘（可能）</strong> InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO能力，因此将100个脏页刷新到磁盘。 </li><li> <strong>合并至多5个插入缓冲（总是）</strong> </li><li> <strong>将日志缓冲刷新到磁盘（总是）</strong> </li><li> <strong>删除无用的Undo页（总是）</strong> </li><li> <strong>刷新100个或者10个脏页到磁盘（总是）</strong> InnoDB存储引擎会执行full purge操作，即删除无用的Undo页。对表进行update，delete这类的操作时，原先的行被标记为删除，但是因为一致性读的关系，需要保留这些行版本的信息。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB存储引擎会立即将其删除。从源代码中可以看出，InnoDB存储引擎在执行full purge 操作时，每次最多尝试回收20个undo页。<br>然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf_get_modified_ratio_pct）,如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%,则只需刷新10%的脏页到磁盘。</li></ol><p>​</p><hr><p>如果当前没有用户活动（数据库空闲）或者数据库关系，就会切换到backgroud loop这个循环。 backgroud loop会执行以下操作：</p><ol><li><strong>删除无用的Undo页（总是）</strong></li><li><strong>合并20个插入缓冲（总是）</strong></li><li><strong>跳回到主循环（总是）</strong></li><li><strong>不断刷新100个页直到符合条件（可能，需要跳转到flush loop中完成）</strong></li></ol><p>如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。<br>​</p><p>1.0.x版本中，InnoDB存储引擎最多只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，那么可能会来不及刷新所有的脏页以及合并插入缓冲。后来，InnoDB存储引擎提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。<br>​</p><p>对于刷新到磁盘的页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p><ol><li>在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%;</li><li>在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity;</li></ol><p>如果用户使用的是SSD类的磁盘，可以将innodb_io_capacity的值调高，直到符合磁盘IO的吞吐量为止；</p><p>另一个问题是参数innodb_max_dirty_pages_pct的默认值，在1.0.x版本之前，该值的默认值是90，意味着脏页占缓冲池的90%。InnoDB存储引擎在每秒刷新缓冲池和flush loop时会判断这个值，如果该值大于innodb_max_dirty_pages_pct,才会刷新100个脏页，如果有很大的内存，或者数据库服务器的压力很大，这时刷新脏页的速度反而会降低。 后来将innodb_max_dirty_pages_pct的默认值改为了75。这样既可以加快刷新脏页的频率，又能够保证磁盘IO的负载。<br>​</p><p>还有一个新的参数是innodb_adaptive_flushing(自适应地刷新)，该值影响每秒刷新脏页的数量。原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页；大于innodb_max_dirty_pages_pct时，刷新100个脏页。随着innodb_adaptive_flushing参数的引入，InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新脏页最合适的数量。buf_flush_get_desired_flush_rate函数通过判断产生重做日志的速率来决定最合适的刷新脏页数量。</p><p>之前每次进行full purge 操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size,该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改。<br>​</p><p>1.2.x版本中再次对Master Thread进行了优化，对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。<br><strong>​</strong></p><h3 id="3-2-IO-线程"><a href="#3-2-IO-线程" class="headerlink" title="3.2 IO 线程"></a>3.2 IO 线程</h3><p>InnoDB中大量使用<strong>AIO (Async IO)</strong> 来处理IO请求。IO Thread的作用，是负责这些 IO 请求的回调（call back）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641481073193-6d2bbd4e-ffaa-49b5-9c2e-c591b8690872." alt="image.png"></p><h3 id="3-3-Purge-线程"><a href="#3-3-Purge-线程" class="headerlink" title="3.3 Purge 线程"></a>3.3 Purge 线程</h3><p>事务被提交后，其所使用的undo log可能不在需要。因此，需要purge thread来回收已经使用并分配的undo页。以前Master Thread来完成释放undo log，InnoDB1.1独立出来，分担主线程压力。<br>​</p><h3 id="3-4-Page-Cleaner-线程"><a href="#3-4-Page-Cleaner-线程" class="headerlink" title="3.4 Page Cleaner 线程"></a>3.4 Page Cleaner 线程</h3><p><strong>​</strong></p><p>负责将脏页刷新到磁盘。以前Master Thread来刷新脏页，InnoDB1.2独立出来，分担主线程压力。<br>​</p><blockquote><p>除了 InnoDB 架构中的日志文件，MySQL 的 Server 层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p></blockquote><hr><h2 id="4-binlog"><a href="#4-binlog" class="headerlink" title="4.binlog"></a>4.binlog</h2><p>binlog 以事件的形式记录了所有的DDL 和DML 语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不一样，它的文件内容是可以追加的，没有固定大小限制。在开启了 binlog 功能的情况下，我们可以把 binlog 导出成 SQL 语句，把所有的操作重放一遍，来实现数据的恢复。binlog 的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的 binlog，然后执行一遍。<br>​</p><p>有了这两个日志之后，来看一下一条更新语句是怎么执行的：<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​</p><ol><li>事务开始，从内存或者磁盘取到这条数据所在的数据页，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>在buffer pool 中修改 name =二十，此时该页变成脏页</li><li>记录name = 二十 到redo log buffer，redo log buffer每秒刷盘。</li><li>redo log 进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</li><li>写入binlog</li><li>事务提交，并回写最终状态到redo log里，代表该事务已经提交</li></ol><p>​</p><blockquote><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便不断写入redo log文件中。一般情况下，每次事务commit时，必须调用 fsync 操作，将redo日志缓冲同步写到磁盘。另外，每次事务提交时同步写到磁盘bin log中。</p></blockquote><blockquote><p>那么就有了一个谁先谁后的问题：redo log 先，bin log 后。</p></blockquote><blockquote><p>两阶段提交的内容：**事务提交时，redo log处于 pre状态 -&gt; 写入bin log -&gt; 事务真正提交。 **</p></blockquote><blockquote><p>当发生崩溃恢复时，查看的是bin log是否完整，如果bin log完整，则代表事务已经提交。</p></blockquote><blockquote><p>如果在两阶段提交过程中，bin log写入失败，则事务无法终止提交，崩溃恢复时就不需要重做。如果bin log写完的一瞬间，服务器宕机了，事务都来不及提交，此时bin log并不是完整的，缺少了最终的commit标记。因此也是提交失败。</p></blockquote><blockquote><p>简单说，redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641482848254-19b6e1b2-0fa7-411d-924b-0c6cb48f511f.png" alt="1.png"></p><hr><h1 id="三，MySQL中支持的字符集和排序规则"><a href="#三，MySQL中支持的字符集和排序规则" class="headerlink" title="三，MySQL中支持的字符集和排序规则"></a>三，MySQL中支持的字符集和排序规则</h1><h2 id="1-MySQL中的utf8和utf8mb4"><a href="#1-MySQL中的utf8和utf8mb4" class="headerlink" title="1.MySQL中的utf8和utf8mb4"></a>1.MySQL中的utf8和utf8mb4</h2><p>utf8字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计MySQL的大叔偷偷的定义了两个概念：</p><ul><li>utf8mb3：阉割过的utf8字符集，只使用1～3个字节表示字符。</li><li>utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符。</li></ul><p>在MySQL中utf8是utf8mb3的别名，所以之后在MySQL中提到utf8就意味着使用1~3个字节来表示一个字符，如果有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4。</p><p>查看字符集：<code>SHOW (CHARACTER SET|CHARSET)</code>。</p><h2 id="2-字符集-amp-比较规则的应用"><a href="#2-字符集-amp-比较规则的应用" class="headerlink" title="2.字符集&amp;比较规则的应用"></a>2.字符集&amp;比较规则的应用</h2><h3 id="2-1-各级别的字符集和比较规则"><a href="#2-1-各级别的字符集和比较规则" class="headerlink" title="2.1 各级别的字符集和比较规则"></a>2.1 各级别的字符集和比较规则</h3><p>MySQL有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><p>接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p><h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;</span>;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用SET语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure><p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p><h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>其中的DEFAULT可以省略，并不影响语句的语义。比方说我们新创建一个名叫charset_demo_db的数据库，在创建的时候指定它使用的字符集为gb2312，比较规则为gb2312_chinese_ci：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE charset_demo_db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| character_set_database | gb2312 |</span><br><span class="line">+------------------------+--------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;</span>;</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| Variable_name      | Value             |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| collation_database | gb2312_chinese_ci |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这个charset_demo_db数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 _<strong>collation_database</strong>_ 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p><h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure><p>比方说我们在刚刚创建的charset_demo_db数据库中创建一个名为t的表，并指定这个表的字符集和比较规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">CREATE TABLE <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    -&gt;     col VARCHAR(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.03</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</p><h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>比如我们修改一下表t中列col的字符集和比较规则可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">ALTER TABLE t MODIFY col <span class="title">VARCHAR</span><span class="params">(<span class="number">10</span>)</span> CHARACTER SET gbk COLLATE gbk_chinese_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 0  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。</p><blockquote><p>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。 </p></blockquote><h3 id="2-2-客户端和服务器通信中的字符集"><a href="#2-2-客户端和服务器通信中的字符集" class="headerlink" title="2.2 客户端和服务器通信中的字符集"></a>2.2 客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果"><a href="#编码和解码使用的字符集不一致的后果" class="headerlink" title="编码和解码使用的字符集不一致的后果"></a>编码和解码使用的字符集不一致的后果</h4><p>如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p><h4 id="从发送请求到接收结果过程中发生的字符集转换"><a href="#从发送请求到接收结果过程中发生的字符集转换" class="headerlink" title="从发送请求到接收结果过程中发生的字符集转换"></a>从发送请求到接收结果过程中发生的字符集转换</h4><ul><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用character_set_client代表的字符集进行解码，将解码后的字符串再按照character_set_connection代表的字符集进行编码。</li><li>如果character_set_connection代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639999607440-c7181f59-0354-43bd-b896-d3bd722cadc4.png" alt="image.png"></p><p>在这个过程中各个系统变量的含义如下：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p><p><strong>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"/>
      <url>/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>#1.成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表数组的最大限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发级别：jdk7历史遗留问题，仅仅在初始化的时候使用到，并不是真正的代表并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算扩容时候生成的一个 标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当node节点hash=-1 表示当前节点已经被迁移了  ，fwd节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//node hash=-2 表示当前节点已经树化 且 当前节点为treebin对象  ，代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">//转化成二进制实际上是 31个 1  可以将一个负数通过位移运算得到一个正数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了兼容7版本的chp保存的，核心代码并没有使用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表，长度一定是2次方数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment"> * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment"> * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="comment">/**表示sizeCtl属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="comment">/**表示transferIndex属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">/**表示baseCount属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">/**表示cellsBusy属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">/**表示cellValue属性在CounterCell中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">/**表示数组第一个元素的偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">                TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">                BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">                CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">                <span class="comment">//表示数组单元所占用空间大小,scale 表示Node[]数组中每一个单元所占用空间大小</span></span><br><span class="line">                <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">                <span class="comment">//1 0000 &amp; 0 1111 = 0</span></span><br><span class="line">                <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">                <span class="comment">//numberOfLeadingZeros() 这个方法是返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一块。</span></span><br><span class="line">                <span class="comment">//8 =&gt; 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line">                <span class="comment">//4 =&gt; 100 numberOfLeadingZeros(4) = 29</span></span><br><span class="line">                <span class="comment">//ASHIFT = 31 - 29 = 2 ？？</span></span><br><span class="line">                <span class="comment">//ABASE + （5 &lt;&lt; ASHIFT）</span></span><br><span class="line">                ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>#2.基础方法<br>##2.1 spread<br>高位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.2 tabAt<br>该方法获取对象中offset偏移地址对应的对象field的值。实际上这段代码的含义等价于tab[i],但是为什么不直接使用 tab[i]来计算呢？</p><p>getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happen-before 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见；</p><p>虽然 table 数组本身是增加了 volatile 属性，但是“volatile 的数组只针对数组的引用具有volatile 的语义，而不是它的元素”。 所以如果有其他线程对这个数组的元素进行写操作，那么当前线程来读的时候不一定能读到最新的值。出于性能考虑，Doug Lea 直接通过 Unsafe 类来对 table 进行操作。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/tabAt.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.3 casTabAt<br>cas设置当前节点为桶位的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.4 setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.5 resizeStamp<br>resizeStamp 用来生成一个和扩容有关的扩容戳，具体有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer.numberOfLeadingZeros 这个方法是返回无符号整数 n 最高位非 0 位前面的 0 的个数。</p><p>比如 10 的二进制是 0000 0000 0000 0000 0000 0000 0000 1010，那么这个方法返回的值就是 28。</p><p>根据 resizeStamp 的运算逻辑，我们来推演一下，假如 n=16，那么 resizeStamp(16)=32796转化为二进制是[0000 0000 0000 0000 1000 0000 0001 1100]</p><p>接着再来看,当第一个线程尝试进行扩容的时候，会执行下面这段代码：</p><p><code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code><br>rs 左移 16 位，相当于原本的二进制低位变成了高位 1000 0000 0001 1100 0000 0000 00000000</p><p>然后再+2 =1000 0000 0001 1100 0000 0000 0000 0000+10=1000 0000 0001 1100 0000 00000000 0010</p><p><strong>高 16 位代表扩容的标记、低 16 位代表并行扩容的线程数</strong></p><p>这样来存储有什么好处呢？</p><p>1，首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责</p><p>2，可以保证每次扩容都生成唯一的生成戳，每次新的扩容，都有一个不同的 n，这个生成戳就是根据 n 来计算出来的一个数字，n 不同，这个数字也不同</p><p>第一个线程尝试扩容的时候，为什么是+2</p><p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在低 16 位上加 1。<br>##2.6 tableSizeFor<br>经过多次位移返回大于等于c的最小的二次方数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">     * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">     * 返回&gt;=c的最小的2的次方数</span></span><br><span class="line"><span class="comment">     * c=28</span></span><br><span class="line"><span class="comment">     * n=27 =&gt; 0b 11011</span></span><br><span class="line"><span class="comment">     * 11011 | 01101 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * 11111 | 00111 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * ....</span></span><br><span class="line"><span class="comment">     * =&gt; 11111 + 1 =100000 = 32</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#3. 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果指定的容量超过允许的最大值，设置为最大值</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果初始容量小于并发级别，那就设置初始容量为并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="comment">//16/0.75 +1 = 22</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 22 - &gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#4.put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key已经存在，是否覆盖，默认是false</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#5 putVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 </span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#6 initTable<br>数组初始化方法，这个方法比较简单，就是初始化一个合适大小的数组。</p><p>sizeCtl ：这个标志是在 Node 数组初始化或者扩容的时候的一个控制位标识，负数代表正在进行初始化或者扩容操作。</p><p>-1 代表正在初始化</p><p>-N 代表有 N-1 个线程正在进行扩容操作，这里不是简单的理解成 n 个线程，sizeCtl 就是-N</p><p>0 标识 Node 数组还没有被初始化，正数代表初始化或者下一次扩容的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">     *      * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">     *      * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">     *      * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#7 addCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//as 表示 LongAdder.cells</span></span><br><span class="line">    <span class="comment">//b 表示LongAdder.base</span></span><br><span class="line">    <span class="comment">//s 表示当前map.table中元素的数量</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//条件一：true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">    <span class="comment">//       false-&gt;表示当前线程应该将数据累加到 base</span></span><br><span class="line">    <span class="comment">//条件二：false-&gt;表示写base成功，数据累加到base中了，当前竞争不激烈，不需要创建cells</span></span><br><span class="line">    <span class="comment">//       true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">//有几种情况进入到if块中？</span></span><br><span class="line">        <span class="comment">//1.true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">        <span class="comment">//2.true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a 表示当前线程hash寻址命中的cell</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//v 表示当前线程写cell时的期望值</span></span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//m 表示当前cells数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//true -&gt; 未竞争  false-&gt;发生竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：as == null || (m = as.length - 1) &lt; 0</span></span><br><span class="line">        <span class="comment">//true-&gt; 表示当前线程是通过 写base竞争失败 然后进入的if块，就需要调用fullAddCount方法去扩容 或者 重试.. LongAdder.longAccumulate</span></span><br><span class="line">        <span class="comment">//条件二：a = as[ThreadLocalRandom.getProbe() &amp; m]) == null   前置条件：cells已经初始化了</span></span><br><span class="line">        <span class="comment">//true-&gt;表示当前线程命中的cell表格是个空，需要当前线程进入fullAddCount方法去初始化 cell，放入当前位置.</span></span><br><span class="line">        <span class="comment">//条件三：!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)</span></span><br><span class="line">        <span class="comment">//      false-&gt;取反得到false，表示当前线程使用cas方式更新当前命中的cell成功</span></span><br><span class="line">        <span class="comment">//      true-&gt;取反得到true,表示当前线程使用cas方式更新当前命中的cell失败，需要进入fullAddCount进行重试 或者 扩容 cells。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">           ) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">//考虑到fullAddCount里面的事情比较累，就让当前线程 不参与到 扩容相关的逻辑了，直接返回到调用点。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前散列表元素个数，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一定是一个put操作调用的addCount</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//tab 表示map.table</span></span><br><span class="line">        <span class="comment">//nt 表示map.nextTable</span></span><br><span class="line">        <span class="comment">//n 表示map.table数组的长度</span></span><br><span class="line">        <span class="comment">//sc 表示sizeCtl的临时值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">             * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">             * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">             * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//条件一：s &gt;= (long)(sc = sizeCtl)</span></span><br><span class="line">        <span class="comment">//       true-&gt; 1.当前sizeCtl为一个负数 表示正在扩容中..</span></span><br><span class="line">        <span class="comment">//              2.当前sizeCtl是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//       false-&gt; 表示当前table尚未达到扩容条件</span></span><br><span class="line">        <span class="comment">//条件二：(tab = table) != null</span></span><br><span class="line">        <span class="comment">//       恒成立 true</span></span><br><span class="line">        <span class="comment">//条件三：(n = tab.length) &lt; MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//       true-&gt;当前table长度小于最大值限制，则可以进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩容批次唯一标识戳</span></span><br><span class="line">            <span class="comment">//16 -&gt; 32 扩容 标识为：1000 0000 0001 1011</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：表示当前table正在扩容</span></span><br><span class="line">            <span class="comment">//         当前线程理论上应该协助table完成扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">                <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">                <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">                <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">                <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">                <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">                <span class="comment">//条件四：(nt = nextTable) == null</span></span><br><span class="line">                <span class="comment">//        true-&gt;表示本次扩容结束</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容正在进行中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//前置条件：当前table正在执行扩容中.. 当前线程有机会参与进扩容。</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程成功参与到扩容任务中，并且将sc低16位值加1，表示多了一个线程参与工作</span></span><br><span class="line">                <span class="comment">//条件失败：1.当前有很多线程都在此处尝试修改sizeCtl，有其它一个线程修改成功了，导致你的sc期望值与内存中的值不一致 修改失败</span></span><br><span class="line">                <span class="comment">//        2.transfer 任务内部的线程也修改了sizeCtl。</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容线程，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="comment">//条件成立，说明当前线程是触发扩容的第一个线程，在transfer方法需要做一些扩容准备工作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//触发扩容条件的线程 不持有nextTable</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#8. transfer<br>ConcurrentHashMap 支持并发扩容，实现方式是，把 Node 数组进行拆分，让每个线程处理自己的区域，假设 table 数组总长度是 64，默认情况下，那么每个线程可以分到 16 个 bucket。然后每个线程处理的范围，按照倒序来做迁移。</p><p>通过 for 自循环处理每个槽位中的链表元素，默认 advace 为真，通过 CAS 设置 transferIndex属性值，并初始化 i 和 bound 值，i 指当前处理的槽位序号，bound 指需要处理的槽位边界，先处理槽位 31 的节点； （bound,i） =(16,31) 从 31 的位置往前推动。</p><p>每存在一个线程执行完扩容操作，就通过 cas 执行 sc-1。</p><p>接着判断(sc-2) !=resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT ; 如果相等，表示当前为整个扩容操作的 最后一个线程，那么意味着整个扩容操作就结束了；如果不相等，说明还得继续。</p><p>这么做的目的，一方面是防止不同扩容之间出现相同的 sizeCtl，另外一方面，还可以避免sizeCtl 的 ABA 问题导致的扩容重叠的情况。</p><p><strong>扩容图解</strong><br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E6%89%A9%E5%AE%B9%E5%9B%BE%E8%A7%A3.png" alt="img.png"><br>判断是否需要扩容，也就是当更新后的键值对总数 baseCount &gt;= 阈值 sizeCtl 时，进行rehash，这里面会有两个逻辑。</p><ol><li>如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容。</li><li>如果当前没有在扩容，则直接触发扩容操作。</li></ol><p>扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。</p><p>而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。</p><p>它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现。</p><p>fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p><p>advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识。</p><p>finishing:这个变量用于提示扩容是否结束用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示扩容之前table数组的长度</span></span><br><span class="line">    <span class="comment">//stride 表示分配给线程任务的步长</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//  stride 固定为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件成立：表示当前线程为触发本次扩容的线程，需要做一些扩容准备工作</span></span><br><span class="line">    <span class="comment">//条件不成立：表示当前线程是协助扩容的线程..</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了一个比扩容之前大一倍的table</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对象属性 nextTable ，方便协助扩容线程 拿到新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录迁移数据整体位置的一个标记。index计数是从1开始计算的。</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 节点，当某个桶位数据处理完毕后，将此桶位设置为fwd节点，其它写线程 或读线程看到后，会有不同逻辑。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标记</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//完成标记</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">//bound 表示分配给当前线程任务的下界限制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//f 桶位的头结点</span></span><br><span class="line">        <span class="comment">//fh 头结点的hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.给当前线程分配任务区间</span></span><br><span class="line"><span class="comment">             * 2.维护当前线程任务进度（i 表示当前处理的桶位）</span></span><br><span class="line"><span class="comment">             * 3.维护map对象全局范围内的进度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//分配任务的开始下标</span></span><br><span class="line">            <span class="comment">//分配任务的结束下标</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1:</span></span><br><span class="line">            <span class="comment">//条件一：--i &gt;= bound</span></span><br><span class="line">            <span class="comment">//成立：表示当前线程的任务尚未完成，还有相应的区间的桶位要处理，--i 就让当前线程处理下一个 桶位.</span></span><br><span class="line">            <span class="comment">//不成立：表示当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CASE2:</span></span><br><span class="line">            <span class="comment">//前置条件：当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="comment">//条件成立：表示对象全局范围内的桶位都分配完毕了，没有区间可分配了，设置当前线程的i变量为-1 跳出循环后，执行退出迁移任务相关的程序</span></span><br><span class="line">            <span class="comment">//条件不成立：表示对象全局范围内的桶位尚未分配完毕，还有区间可分配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CASE3:</span></span><br><span class="line">            <span class="comment">//前置条件：1、当前线程需要分配任务区间  2.全局范围内还有桶位尚未迁移</span></span><br><span class="line">            <span class="comment">//条件成立：说明给当前线程分配任务成功</span></span><br><span class="line">            <span class="comment">//条件失败：说明分配给当前线程失败，应该是和其它线程发生了竞争吧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：i &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：表示当前线程未分配到任务</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//保存sizeCtl 的变量</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明设置sizeCtl 低16位  -1 成功，当前线程可以正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程不是最后一个退出transfer任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//正常退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置条件：【CASE2~CASE4】 当前线程任务尚未处理完，正在进行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位未存放数据，只需要将此处设置为fwd节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位已经迁移过了，当前线程不用再处理了，直接再次更新当前线程任务索引，再次处理下一个桶位 或者 其它操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//CASE4:</span></span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据，而且node节点 不是 fwd节点，说明这些数据需要迁移。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//sync 加锁当前桶位的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//防止在你加锁头对象之前，当前桶位的头对象被其它写线程修改过，导致你目前加锁对象错误...</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">//hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lastRun</span></span><br><span class="line">                        <span class="comment">//可以获取出 当前链表 末尾连续高位不变的 node</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立：说明lastRun引用的链表为 低位链表，那么就让 ln 指向 低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则，说明lastRun引用的链表为 高位链表，就让 hn 指向 高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是 红黑树 代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转换头结点为 treeBin引用 t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//低位双向链表 lo 指向低位链表的头  loTail 指向低位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位双向链表 lo 指向高位链表的头  loTail 指向高位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lc 表示低位链表元素数量</span></span><br><span class="line">                        <span class="comment">//hc 表示高位链表元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代TreeBin中的双向链表，从头结点 至 尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// h 表示循环处理当前元素的 hash</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//使用当前节点 构建出来的 新的 TreeNode</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件成立：表示当前循环节点 属于低位链 节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//条件成立：说明当前低位链表 还没有数据</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="comment">//说明 低位链表已经有数据了，此时当前元素 追加到 低位链表的末尾就行了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">//将低位链表尾指针指向 p 节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点 属于 高位链 节点</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表迁移原理</p><p>1）高低位原理分析</p><p>ConcurrentHashMap 在做链表迁移时，会用高低位来实现，这里有两个问题要分析一下</p><p>1，如何实现高低位链表的区分</p><p>假如有这样一个队列<br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E8%BF%81%E7%A7%BB%E9%AB%98%E4%BD%8E%E4%BD%8D%E5%8E%9F%E7%90%861.png" alt="img_1.png"><br>第 14 个槽位插入新节点之后，链表元素个数已经达到了 8，且数组长度为 16，优先通过扩容来缓解链表过长的问题</p><p>假如当前线程正在处理槽位为 14 的节点，它是一个链表结构，在代码中，首先定义两个变量节点 ln 和 hn，实际就是 lowNode 和 HighNode，分别保存 hash 值的第 x 位为 0 和不等于0 的节点</p><p>通过 fn&amp;n 可以把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值的第 x 位为不等于 0（至于为什么要这么区分，稍后分析），并且通过 lastRun 记录最后要处理的节点。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 14+16(扩容增加的长度)=30</p><p>把 14 槽位的链表单独伶出来，用蓝色表示 fn&amp;n=0 的节点，假如链表的分类是这样</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/ffb2efa924944e02b25e97a2b90bf6f5.png" alt="111"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b;</span><br><span class="line">        lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码遍历，会记录 runBit 以及 lastRun，按照上面这个结构，那么 runBit 应该是蓝色节点，lastRun 应该是第 6 个节点接着，再通过这段代码进行遍历，生成 ln 链以及 hn 链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/3914c7b94d2843b985ea10e5c23a04b0.png" alt="111"><br>接着，通过 CAS 操作，把 hn 链放在 i+n 也就是 14+16 的位置，ln 链保持原来的位置不动。并且设置当前节点为 fwd，表示已经被当前线程迁移完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>迁移完成以后的数据分布如下</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/e7e01e24e3e844c7b31c4d73da2fffed.png" alt="111"><br>2）为什么要做高低位的划分</p><p>要想了解这么设计的目的，我们需要从 ConcurrentHashMap 的根据下标获取对象的算法来看，在 putVal 方法中 1018 行：</p><p><code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code></p><p>通过(n-1) &amp; hash 来获得在 table 中的数组下标来获取节点数据，【&amp;运算是二进制运算符，1&amp; 1=1，其他都为 0】。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/db389ed8b874494ca1f5a8723e8a6973.png" alt="111"><br>#9.helpTransfer<br>如果对应的节点存在，判断这个节点的 hash 是不是等于 MOVED(-1)，说明当前节点是ForwardingNode 节点，意味着有其他线程正在进行扩容，那么当前现在直接帮助它进行扩容，因此调用 helpTransfer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    <span class="comment">//nextTab 引用的是 fwd.nextTable == map.nextTable 理论上是这样。</span></span><br><span class="line">    <span class="comment">//sc 保存map.sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：tab != null 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件二：(f instanceof ForwardingNode) 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件三：((ForwardingNode&lt;K,V&gt;)f).nextTable) != null 恒成立 true</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿当前标的长度 获取 扩容标识戳   假设 16 -&gt; 32 扩容：1000 0000 0001 1011</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：nextTab == nextTable</span></span><br><span class="line">        <span class="comment">//成立：表示当前扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：1.nextTable被设置为Null 了，扩容完毕后，会被设为Null</span></span><br><span class="line">        <span class="comment">//       2.再次出发扩容了...咱们拿到的nextTab 也已经过期了...</span></span><br><span class="line">        <span class="comment">//条件二：table == tab</span></span><br><span class="line">        <span class="comment">//成立：说明 扩容正在进行中，还未完成</span></span><br><span class="line">        <span class="comment">//不成立：说明扩容已经结束了，扩容结束之后，最后退出的线程 会设置 nextTable 为 table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件三：(sc = sizeCtl) &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：说明扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：说明sizeCtl当前是一个大于0的数，此时代表下次扩容的阈值，当前扩容已经结束。</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">            <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">            <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">            <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">            <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">            <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">            <span class="comment">//条件四：transferIndex &lt;= 0</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明map对象全局范围内的任务已经分配完了，当前线程进去也没活干..</span></span><br><span class="line">            <span class="comment">//      false-&gt;还有任务可以分配。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#10.get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//e 当前元素</span></span><br><span class="line">    <span class="comment">//p 目标节点</span></span><br><span class="line">    <span class="comment">//n table数组长度</span></span><br><span class="line">    <span class="comment">//eh 当前元素hash</span></span><br><span class="line">    <span class="comment">//ek 当前元素key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//扰动运算后得到 更散列的hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：(tab = table) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;表示已经put过数据，并且map内部的table也已经初始化完毕</span></span><br><span class="line">    <span class="comment">//false-&gt;表示创建完map后，并没有put过数据，map内部的table是延迟初始化的，只有第一次写数据时会触发创建逻辑。</span></span><br><span class="line">    <span class="comment">//条件二：(n = tab.length) &gt; 0 true-&gt;表示table已经初始化</span></span><br><span class="line">    <span class="comment">//条件三：(e = tabAt(tab, (n - 1) &amp; h)) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;当前key寻址的桶位 有值</span></span><br><span class="line">    <span class="comment">//false-&gt;当前key寻址的桶位中是null，是null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比头结点hash与查询key的hash是否一致</span></span><br><span class="line">        <span class="comment">//条件成立：说明头结点与查询Key的hash值 完全一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">//完全比对 查询key 和 头结点的key</span></span><br><span class="line">            <span class="comment">//条件成立：说明头结点就是查询数据</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件成立：</span></span><br><span class="line">        <span class="comment">//1.-1  fwd 说明当前table正在扩容，且当前查询的这个桶位的数据 已经被迁移走了</span></span><br><span class="line">        <span class="comment">//2.-2  TreeBin节点，需要使用TreeBin 提供的find 方法查询。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前桶位已经形成链表的这种情况</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#11.remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#12.replaceNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算key经过扰动运算后的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f表示桶位头结点</span></span><br><span class="line">        <span class="comment">//n表示当前table数组长度</span></span><br><span class="line">        <span class="comment">//i表示hash命中桶位下标</span></span><br><span class="line">        <span class="comment">//fh表示桶位头结点 hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：tab == null  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件二：(n = tab.length) == 0  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件三：(f = tabAt(tab, i = (n - 1) &amp; hash)) == null true -&gt; 表示命中桶位中为null，直接break， 会返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2：</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前table正在扩容中，当前是个写操作，所以当前线程需要协助table完成扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//当前桶位 可能是 &quot;链表&quot; 也可能 是  &quot;红黑树&quot; TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保留替换之前的数据引用</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//校验标记</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁当前桶位 头结点，加锁成功之后会进入 代码块。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断sync加锁是否为当前桶位 头节点，防止其它线程，在当前线程加锁成功之前，修改过 桶位 的头结点。</span></span><br><span class="line">                <span class="comment">//条件成立：当前桶位头结点 仍然为f，其它线程没修改过。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//条件成立：说明桶位 为 链表 或者 单个 node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//e 表示当前循环处理元素</span></span><br><span class="line">                        <span class="comment">//pred 表示当前循环节点的上一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="comment">//当前节点key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash true-&gt;说明当前节点的hash与查找节点hash一致</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//if 条件成立，说明key 与查询的key完全一致。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//当前节点的value</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件一：cv == null true-&gt;替换的值为null 那么就是一个删除操作</span></span><br><span class="line">                                <span class="comment">//条件二：cv == ev || (ev != null &amp;&amp; cv.equals(ev))  那么是一个替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">//删除 或者 替换</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//条件成立：说明当前是一个替换操作</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//直接替换</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">//条件成立：说明当前节点非头结点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//当前节点的上一个节点，指向当前节点的下一个节点。</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//说明当前节点即为 头结点，只需要将 桶位设置为头结点的下一个节点。</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：TreeBin节点。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//转换为实际类型 TreeBin t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//r 表示 红黑树 根节点</span></span><br><span class="line">                        <span class="comment">//p 表示 红黑树中查找到对应key 一致的node</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：(r = t.root) != null 理论上是成立</span></span><br><span class="line">                        <span class="comment">//条件二：TreeNode.findTreeNode 以当前节点为入口，向下查找key（包括本身节点）</span></span><br><span class="line">                        <span class="comment">//      true-&gt;说明查找到相应key 对应的node节点。会赋值给p</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//保存p.val 到pv</span></span><br><span class="line">                            V pv = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：cv == null  成立：不必对value，就做替换或者删除操作</span></span><br><span class="line">                            <span class="comment">//条件二：cv == pv ||(pv != null &amp;&amp; cv.equals(pv)) 成立：说明“对比值”与当前p节点的值 一致</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//替换或者删除操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                oldVal = pv;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件成立：替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">//删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">//这里没做判断，直接搞了...很疑惑</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当其他线程修改过桶位 头结点时，当前线程 sync 头结点 锁错对象时，validated 为false，会进入下次for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换的值 为null，说明当前是一次删除操作，oldVal ！=null 成立，说明删除成功，更新当前元素个数计数器。</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#13.TreeBin<br>##13.1 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树 根节点 </span></span><br><span class="line">TreeNode&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//链表的头节点</span></span><br><span class="line"><span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//等待者线程（当前lockState是读锁状态）</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.写锁状态 写是独占状态，以散列表来看，真正进入到TreeBin中的写线程 同一时刻 只有一个线程。 1</span></span><br><span class="line"><span class="comment">         * 2.读锁状态 读锁是共享，同一时刻可以有多个线程 同时进入到 TreeBin对象中获取数据。 每一个线程 都会给 lockStat + 4</span></span><br><span class="line"><span class="comment">         * 3.等待者状态（写线程在等待），当TreeBin中有读线程目前正在读取数据时，写线程无法修改数据，那么就将lockState的最低2位 设置为 0b 10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values for lockState</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p>##13.2 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="comment">//设置节点hash为-2 表示此节点是TreeBin节点</span></span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//使用first 引用 treeNode链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    <span class="comment">//r 红黑树的根节点引用</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x表示遍历的当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//强制设置当前插入节点的左右子树为null</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//条件成立：说明当前红黑树 是一个空树，那么设置插入元素 为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点的父节点 一定为 null</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//颜色改为黑色</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//让r引用x所指向的对象。</span></span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非第一次循环，都会来带else分支，此时红黑树已经有数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//k 表示 插入节点的key</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//h 表示 插入节点的hash</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//kc 表示 插入节点key的class类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//p 表示 为查找插入节点的父节点的一个临时节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//dir (-1, 1)</span></span><br><span class="line">                <span class="comment">//-1 表示插入节点的hash值大于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//1 表示插入节点的hash值 小于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//ph p表示 为查找插入节点的父节点的一个临时节点的hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//临时节点 key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点的hash值 小于 当前节点</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的左子节点 或者 继续在左子树上查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入节点的hash值 大于 当前节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的右子节点 或者 继续在右子树上查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果执行到 CASE3，说明当前插入节点的hash 与 当前节点的hash一致，会在case3 做出最终排序。最终</span></span><br><span class="line">                <span class="comment">//拿到的dir 一定不是0，（-1， 1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//xp 想要表示的是 插入节点的 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//条件成立：说明当前p节点 即为插入节点的父节点</span></span><br><span class="line">                <span class="comment">//条件不成立：说明p节点 底下还有层次，需要将p指向 p的左子节点 或者 右子节点，表示继续向下搜索。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置插入节点的父节点 为 当前节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//小于P节点，需要插入到P节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//大于P节点，需要插入到P节点的右子节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//插入节点后，红黑树性质 可能会被破坏，所以需要调用 平衡方法</span></span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将r 赋值给 TreeBin对象的 root引用。</span></span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.3 putTreeVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前循环节点xp 即为 x 节点的爸爸</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//x 表示插入节点</span></span><br><span class="line">            <span class="comment">//f 老的头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明链表有数据</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//设置老的头结点的前置引用为 当前的头结点。</span></span><br><span class="line">                f.prev = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示 当前新插入节点后，新插入节点 与 父节点 形成 “红红相连”</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//平衡红黑树，使其再次符合规范。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.4 find</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e 表示循环迭代的当前节点   迭代的是first引用的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//s 保存的是lock临时状态</span></span><br><span class="line">            <span class="comment">//ek 链表当前节点 的key</span></span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(WAITER|WRITER) =&gt; 0010 | 0001 =&gt; 0011</span></span><br><span class="line">            <span class="comment">//lockState &amp; 0011 != 0 条件成立：说明当前TreeBin 有等待者线程 或者 目前有写操作线程正在加锁</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前置条件：当前TreeBin中 等待者线程 或者 写线程 都没有</span></span><br><span class="line">            <span class="comment">//条件成立：说明添加读锁成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//查询操作</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//w 表示等待者线程</span></span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">//U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER)</span></span><br><span class="line">                    <span class="comment">//1.当前线程查询红黑树结束，释放当前线程的读锁 就是让 lockstate 值 - 4</span></span><br><span class="line">                    <span class="comment">//(READER|WAITER) = 0110 =&gt; 表示当前只有一个线程在读，且“有一个线程在等待”</span></span><br><span class="line">                    <span class="comment">//当前读线程为 TreeBin中的最后一个读线程。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.(w = waiter) != null 说明有一个写线程在等待读操作全部结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用unpark 让 写线程 恢复运行状态。</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#总结<br>在java8中，ConcurrentHashMap使用数组+链表+红黑树的组合方式，利用cas和synchronized保证并发写的安全。</p><p>引入红黑树的原因：链表查询的时间复杂度为On，但是红黑树的查询时间复杂度为O(log(n)),所以在节点比较多的情况下，使用红黑树可以大大提升性能。</p><p>链式桶是一个由node节点组成的链表。树状桶是一颗由TreeNode节点组成的红黑树。输的根节点为TreeBin类型。</p><p>当链表长度大于8整个hash表长度大于64的时候，就会转化为TreeBin。TreeBin作为根节点，其实就是红黑树对象。在ConcurrentHashMap的table数组中，存放的就是TreeBin对象，而不是TreeNoe对象。</p><p>数组table是懒加载的，只有第一次添加元素的时候才会初始化，所以initTable()存在线程安全问题。</p><p>重要的属性就是sizeCtl，用来控制table的初始化和扩容操作的过程：</p><p>● -1代表table正在初始化，其他线程直接join等待。</p><p>● -N代表有N-1个线程正在进行扩容操作，严格来说，当其为负数的时候，只用到了低16位，如果低16位为M，此时有M-1个线程进行扩容。</p><p>● 大于0有两种情况：如果table没有初始化，她就表示table初始化的大小，如果table初始化完了，就表示table的容量，默认是table大小的四分之三。</p><p>Transfer()扩容</p><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程所负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的 Bucket会被替换为一个Forwarding节点，标记当前Bucket已经被其他线程迁移完了。</p><p>helpTransfer()帮助扩容</p><p>ConcurrentHashMap并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</p><p>第一次添加元素时，默认初始长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>put()</p><p>JDK1.8在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用通常不会很激烈，所以使用CAS自旋、synchronized不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢?如果为每 个桶都创建一个ReentrantLock实 例，就会带来大量的内存消耗，反过来，使用CAS自旋、synchronized，内存消耗的增加更小。</p><p>get()</p><p>get()通过UnSafe的getObjectVolatile()来读取数组中的元素。为什么要这样做?虽然HashEntry数组的引用是volatile类型，但是数组内元素的 用不是volatile类型，因此多线程对 数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的元素对象。get()方法通过UnSafe的getObjectVolatile方法来保证元素的读取安全，调用getObjectVolatile()去读取数组元素需要先获得元素在数组中的偏移量，在这里，get()方法根据哈希码计算出偏移量为u，然后通过偏移量u来尝试读取数值。</p>]]></content>
      
      
      <categories>
          
          <category> 1.基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
