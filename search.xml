<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL[一]入门</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一，MYSQL入门"><a href="#一，MYSQL入门" class="headerlink" title="一，MYSQL入门"></a>一，MYSQL入门</h3><h4 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1.数据库相关概念"></a>1.数据库相关概念</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DB：数据库：存储数据的仓库，保存了一系列有组织的数据。</span></span><br><span class="line"><span class="attr">DBMS：数据库管理系统：数据库是通过DBMS创建和操作的容器。</span></span><br><span class="line"><span class="attr">SQL：结构化查询语言：专门用来与数据库通信的语言。</span></span><br></pre></td></tr></table></figure><h4 id="2-数据库的好处"><a href="#2-数据库的好处" class="headerlink" title="2.数据库的好处"></a>2.数据库的好处</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.可以持久化数据到本地</span></span><br><span class="line"><span class="attr">2.可以实现结构化查询，方便管理</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库存储数据特点"><a href="#3-数据库存储数据特点" class="headerlink" title="3.数据库存储数据特点"></a>3.数据库存储数据特点</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.将数据放到表中，表放到库中。</span></span><br><span class="line"><span class="attr">2.一个数据库有多张表，每个表都有一个名字，用来标识自己。</span></span><br><span class="line"><span class="attr">表名具有唯一性。</span></span><br><span class="line"><span class="attr">3.表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中类的设计。</span></span><br><span class="line"><span class="attr">4.表有列组成，我们也称为字段。所有表都是由一个列或多个列组成的，</span></span><br><span class="line"><span class="attr">每一列类似Java中的属性。</span></span><br><span class="line"><span class="attr">5.表中的数据按照行来存储，每一行类似于Java中的对象。</span></span><br></pre></td></tr></table></figure><h4 id="4-mysql的安装与使用"><a href="#4-mysql的安装与使用" class="headerlink" title="4.mysql的安装与使用"></a>4.mysql的安装与使用</h4><p><strong>参照mysql安装文档</strong></p><h4 id="5-Mysql常用命令"><a href="#5-Mysql常用命令" class="headerlink" title="5.Mysql常用命令"></a>5.Mysql常用命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">显示数据库-----&gt;show</span> <span class="string">Databases;</span></span><br><span class="line"><span class="meta">使用数据库-----&gt;use</span> <span class="string">数据库名；</span></span><br><span class="line"><span class="meta">显示表----&gt;show</span> <span class="string">tables;</span></span><br><span class="line"><span class="meta">显式指定数据库的表----&gt;show</span> <span class="string">tables from 数据库名；</span></span><br><span class="line"><span class="meta">查看位于那个数据库----&gt;select</span> <span class="string">database();</span></span><br><span class="line"><span class="meta">显示表结构---&gt;desc</span> <span class="string">表名；</span></span><br><span class="line"><span class="meta">查看数据库版本：---&gt;select</span> <span class="string">version();</span></span><br><span class="line"><span class="meta">查看数据库版本2</span>:<span class="string">-----&gt;Dos:mysql --version;</span></span><br><span class="line"><span class="meta">查看数据库信息-----&gt;show</span> <span class="string">CREATE DATABASE mydb1;</span></span><br><span class="line"><span class="meta">查看服务器中的数据库，并把mydb1的字符集修改为utf-8-----&gt;ALTER</span> <span class="string">DATABASE mydb1character set utf8;</span></span><br><span class="line"><span class="meta">删除数据库-----&gt;drop</span> <span class="string">database mydb1;</span></span><br><span class="line"><span class="meta">表中增加一栏信息-----&gt;alter</span> <span class="string">table student add image blob;</span></span><br><span class="line"><span class="meta">删除表-----&gt;drop</span> <span class="string">table student;</span></span><br><span class="line"><span class="meta">修改地址-----&gt;alter</span> <span class="string">table student modify address varchar(100);</span></span><br><span class="line"><span class="meta">删除一个属性-----&gt;</span> <span class="string">alter table student drop image;</span></span><br><span class="line"><span class="meta">修改表名-----&gt;rename</span> <span class="string">table student to students;</span></span><br><span class="line"><span class="meta">查看表的创建细节-----&gt;show</span> <span class="string">create table students;</span></span><br><span class="line"><span class="meta">修改表的字符集为</span> <span class="string">gbk-----&gt;alter table students character set gbk;</span></span><br><span class="line"><span class="meta">列名name修改为studentname-----&gt;alter</span> <span class="string">table students change name studentname varchar(100);</span></span><br></pre></td></tr></table></figure><h4 id="6-mysql语法规范"><a href="#6-mysql语法规范" class="headerlink" title="6.mysql语法规范"></a>6.mysql语法规范</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.不区分大小写，建议关键字大写，表名列名小写。</span></span><br><span class="line"><span class="attr">2.每条命令最好用分号结尾。</span></span><br><span class="line"><span class="attr">3.每条语句可以缩进，换行。</span></span><br><span class="line"><span class="attr">4.注释</span></span><br><span class="line"><span class="attr">单行注释：#注释文字</span></span><br><span class="line">          <span class="meta">--</span> <span class="string">注释文字</span></span><br><span class="line"><span class="meta">多行注释：/*</span> <span class="string">*/</span></span><br></pre></td></tr></table></figure><h3 id="二，DQL查询语言"><a href="#二，DQL查询语言" class="headerlink" title="二，DQL查询语言"></a>二，DQL查询语言</h3><h4 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">**语法：</span> <span class="string">select 查询列表 from 表名**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询列表：表中的字段，常量，表达式，函数**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询的结果是张虚拟的表格**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.查询表中的单个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.查询表中的多个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name,salary,email from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.查询表中的所有字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.查询常量值</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">&#x27;john&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.查询表达式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100*98;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">6.查询函数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">version();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">7.起别名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name as name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">8.去重</span></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工表中涉及到的所有的部门编号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">distinct department_id from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">9.+的作用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#运算符：两个操作数都为数值型，则做加法运算；</span></span><br><span class="line"><span class="comment">#其中一方为字符型，试图将字符型数值转换成数值型，</span></span><br><span class="line"><span class="comment">#如果转换成功，继续做加法运算；否则，将字符型数值</span></span><br><span class="line"><span class="comment">#转换为0；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">10.使用concat实现连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名和性连接成一个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CONCAT(username,PASSWORD) FROM USER;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#任何数与null做运算结果都为null</span></span><br></pre></td></tr></table></figure><h4 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h4><p><strong>语法：</strong></p><p><strong>select 查询列表 from 表名 where 筛选条件</strong></p><p><strong>分类：</strong></p><h5 id="①按照条件表达式筛选"><a href="#①按照条件表达式筛选" class="headerlink" title="①按照条件表达式筛选"></a>①按照条件表达式筛选</h5><p>条件运算符：&gt;,&lt;,=,!=,&gt;=,&lt;=</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工工资&gt;1w2的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee where salary &gt;12000;</span></span><br><span class="line"><span class="meta">查询部门编号！</span>=<span class="string">90号的员工名和部门编号</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name, dep_id from employee where  dep_id 1=90；</span></span><br></pre></td></tr></table></figure><h5 id="②按照逻辑表达式筛选"><a href="#②按照逻辑表达式筛选" class="headerlink" title="②按照逻辑表达式筛选"></a>②按照逻辑表达式筛选</h5><p>逻辑运算符：&amp;&amp;,||,!,AND,OR,NOT</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询工资在一万到两万之见的员工名，工资以及奖金。</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name,salary ,jiangjin where salary between 10000 and 20000;</span></span><br><span class="line"><span class="attr">查询部门编号不在90-110之间，或者工资高于15000的员工信息。</span></span><br><span class="line"><span class="attr">select</span>  <span class="string">* from employee where department&lt;90||department&gt;110 ||salary &gt;15000;</span></span><br></pre></td></tr></table></figure><h5 id="③模糊查询"><a href="#③模糊查询" class="headerlink" title="③模糊查询"></a>③模糊查询</h5><p>like：一般和通配符搭配使用<br>通配符：<br>%任意多个字符，包含0个字符<br>_任意单个字符<br>BETWEEN AND:包含临界值<br>IN:判断某个字段的值是否属于in列表中的某一项<br>IS NULL,IS NOT NULL:=或者！=不能用来判断null<br>安全等于&lt;=&gt;可以判断null</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工名中包含a的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where name like %a%;</span></span><br><span class="line"><span class="attr">查询员工名中第三个字符为e第五个字符为a的员工名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp where name like %__e_a%;</span></span><br><span class="line"><span class="attr">员工名中第二个字符为_的员工名</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name from emp where name like %_\_%;</span></span><br><span class="line"><span class="attr">查询员工编号在100到120之间的所有员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where id between 100 and 120;</span></span><br><span class="line"><span class="attr">查询员工的工种编号是IT_PRIG,AD_PRES,AD_VP中的一个员</span></span><br><span class="line"><span class="attr">工名和工种编号；</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name , id from emp where id in(IT_PRIG,AD_PRES,AD_VP);</span></span><br><span class="line"><span class="attr">查询没有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary , jjl from emp where salary is Null;</span></span><br><span class="line"><span class="attr">查询有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary ,jjl from emp where salary is not null;</span></span><br></pre></td></tr></table></figure><h5 id="④IF-null的使用："><a href="#④IF-null的使用：" class="headerlink" title="④IF null的使用："></a>④IF null的使用：</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工号为176的员工的姓名和部门号和年薪</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name ,department_id , salary*(1+IFNULL(commission_pct,0))*12 &#x27;年薪&#x27;</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees WHERE employee_id =176;</span></span><br></pre></td></tr></table></figure><h4 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h4><p><strong>语法：</strong></p><p><strong>select   查询列表</strong></p><p><strong>from 表</strong></p><p><strong>where 筛选条件</strong></p><p><strong>order by 排序列表 asc 或desc （升序或者降序，默认为升序）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工信息，要求工资从高到低排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by salary desc;</span></span><br><span class="line"><span class="attr">查询部门编号大于等于90的员工信息，按照入职时间先后排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where dep_id &gt;=90 order by createtime asc;</span></span><br><span class="line"><span class="attr">按照员工年薪的高低显示员工的信息和年薪</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* ,年薪 from emp  order by salary*(1+if null(jjl,0))*12 as 年薪 desc;</span></span><br><span class="line"><span class="attr">按姓名长度显示员工的姓名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp order by length(name) asc;</span></span><br><span class="line"><span class="attr">查询员工信息，先按照工资排序，再按照员工编号排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp  order by salary asc,id asc;</span></span><br></pre></td></tr></table></figure><h4 id="4-常见函数"><a href="#4-常见函数" class="headerlink" title="4.常见函数"></a>4.常见函数</h4><p><strong>功能：类似Java中的方法</strong><br><strong>分类：单行函数</strong><br><strong>分组函数</strong></p><h5 id="1-单行函数"><a href="#1-单行函数" class="headerlink" title="1.单行函数"></a>1.单行函数</h5><h6 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1.字符函数"></a>1.字符函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.length</span> <span class="string">获取参数值的字节个数</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by length(name);</span></span><br><span class="line"><span class="meta">2.concat</span> <span class="string">拼接字符串</span></span><br><span class="line"><span class="attr">select</span> <span class="string">concat(last_name,first_name) as 姓名 from emp;</span></span><br><span class="line"><span class="meta">3.upper，lower</span> <span class="string">大小写转换函数</span></span><br><span class="line"><span class="attr">案例：将姓变大写，名字变小写，然后拼接</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">CONCAT(UPPER(last_name),LOWER(first_name))</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.substr,SUBSTRING</span> <span class="string">截取字符串</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2,3);</span></span><br><span class="line"><span class="attr">案例：姓名中首字符大写，其他的小写然后用_拼接显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">CONCAT(</span></span><br><span class="line">    <span class="meta">UPPER(SUBSTR(last_name,</span> <span class="string">1, 1)),</span></span><br><span class="line">    <span class="attr">&#x27;_&#x27;,</span></span><br><span class="line">    <span class="meta">LOWER(SUBSTR(last_name,</span> <span class="string">2))</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">output </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">5.instr</span>:<span class="string">返回字串第一次出现的索引，如果找不到返回0</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">INSTR(&#x27;风急天高猿啸哀&#x27;,&#x27;天&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.trim</span> :<span class="string">去掉前后空格或前后指定字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LENGTH(TRIM(&#x27;   张三丰   &#x27;)) AS out_put;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRIM(&#x27;a&#x27; FROM &#x27;aaaa1aa2aaa3aaa&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">7.lpad</span> :<span class="string">用指定字符填满指定长度（左填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">8.rpad</span>:<span class="string">用指定字符填满指定长度（右填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">RPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">9.replace</span> <span class="string">替换</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">REPLACE(&#x27;千锋培训机构&#x27;,&#x27;千锋&#x27;,&#x27;尚硅谷&#x27;);</span></span><br></pre></td></tr></table></figure><h6 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2.数学函数"></a>2.数学函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.round</span>:<span class="string">四舍五入</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.666);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.567,2);</span></span><br><span class="line"><span class="meta">2.ceil</span> <span class="string">向上取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CEIL(1.52);</span></span><br><span class="line"><span class="meta">3.floor</span> <span class="string">向下取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">FLOOR(1.52);</span></span><br><span class="line"><span class="meta">4.truncate</span>:<span class="string">截断（小数点后保留几位）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRUNCATE(1.65,2);</span></span><br><span class="line"><span class="meta">5.mod</span>:<span class="string">取余</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MOD(10,3);</span></span><br></pre></td></tr></table></figure><h6 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.now</span>:<span class="string">返回当前系统日期时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">NOW();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.curdate</span>:<span class="string">返回当前系统日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURDATE();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.curtime</span>:<span class="string">返回当前时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURTIME();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.获取指定部分的年月日时分秒</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(hiredate) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.str_to_date将字符通过指定的格式转化成日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">STR_TO_DATE(&#x27;1998-3-2&#x27;,&#x27;%Y-%c-%d&#x27;) AS out_put;</span></span><br><span class="line"><span class="attr">案例：查询入职时间为1992-4-3的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">hiredate=STR_TO_DATE(&#x27;2016-3-3&#x27;,&#x27;%Y-%c-%d&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.date_format</span> <span class="string">将日期转换成字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATE_FORMAT(NOW(),&#x27;%y年%m月%d日&#x27;) AS 日期;</span></span><br><span class="line"><span class="meta">案例：查询有奖金的员工名和入职日期（xx月/xx日</span> <span class="string">xx年）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="meta">DATE_FORMAT(hiredate,</span> <span class="string">&#x27;%c月/%d日 %y&#x27;) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL ;</span></span><br></pre></td></tr></table></figure><h6 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SELECT</span> <span class="string">VERSION();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATABASE();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">USER();</span></span><br></pre></td></tr></table></figure><h6 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.if</span>:<span class="string">IF else效果</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">IF(10&gt;5,&#x27;true&#x27;,&#x27;false&#x27;);</span></span><br><span class="line"><span class="attr">案例：查询如果有奖金就备注有，没有就备注没有。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">commission_pct,</span></span><br><span class="line">  <span class="attr">IF(</span></span><br><span class="line">    <span class="attr">commission_pct</span> <span class="string">IS NULL,</span></span><br><span class="line">    <span class="attr">&#x27;没奖金&#x27;,</span></span><br><span class="line">    <span class="attr">&#x27;有奖金&#x27;</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">AS 备注 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.case函数</span></span><br><span class="line"><span class="attr">1)switch-CASE</span></span><br><span class="line"><span class="meta">语法</span>:<span class="string"></span></span><br><span class="line"><span class="attr">CASE</span> <span class="string">要判断的字段或者表达式</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量1 THEN 要显示的值1或者语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量2 THEN 要显示的值2或者语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或者语句n；</span></span><br><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"><span class="meta">2)CASE</span> <span class="string">使用2：</span></span><br><span class="line"><span class="attr">语法：</span></span><br><span class="line"><span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件1 THEN 要显示的值1或语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件2 THEN 要显示的值2或语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或语句n</span></span><br><span class="line"><span class="attr">END</span></span><br><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees ;</span></span><br></pre></td></tr></table></figure><h5 id="2-分组函数"><a href="#2-分组函数" class="headerlink" title="2.分组函数"></a>2.分组函数</h5><p><strong>功能：用作统计使用</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.sum</span> :<span class="string">求和</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.avg：平均值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.max：最大值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MAX(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.min：最小值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.count：计算个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">总结</span></span><br><span class="line"><span class="attr">①.sum,avg一般用于处理数值类型</span></span><br><span class="line"><span class="attr">②.max，min，count用来处理任何类型</span></span><br><span class="line"><span class="attr">③.以上分组函数都忽略null值</span></span><br><span class="line"><span class="attr">④.可以和distinct搭配</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(DISTINCT salary) 纯净,SUM(salary) FROM employees;</span></span><br><span class="line"><span class="attr">6.count的详细介绍</span></span><br><span class="line"><span class="meta">①select</span> <span class="string">COUNT(*) FROM employees;</span></span><br><span class="line"><span class="meta">②select</span> <span class="string">COUNT(1) FROM employees;</span></span><br><span class="line"><span class="meta">③和分组函数一同查询的字段要求是group</span> <span class="string">by后的字段。</span></span><br></pre></td></tr></table></figure><h4 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h4><p><strong>GROUP BY 和分组函数对应</strong><br><strong>分组查询中分组条件分为两类</strong></p><table><thead><tr><th></th><th><strong>数据源</strong></th><th><strong>位置</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td><strong>分组前筛选</strong></td><td>原始表</td><td>GROUP BY 子句的前面</td><td>WHERE</td></tr><tr><td><strong>分组后筛选</strong></td><td>分组后的结果集</td><td>GROUP BY 子句的后面</td><td>HAVING</td></tr></tbody></table><p><strong>分组函数做条件肯定是放在having子句中。</strong><br><strong>group BY 子句支持单个字段分组，多个字段分组</strong><br><strong>（多个字段之间用逗号隔开没有顺序要求），表达式或函数。</strong><br><strong>也可以添加排序，放在整个分组查询的最后。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询每个工种的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY MAX(salary) ASC ;</span></span><br><span class="line"><span class="attr">案例：查询邮箱中包含a字符的，每个部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AVG(salary),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">email LIKE &#x27;%a%&#x27; </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id ;</span></span><br><span class="line"><span class="comment">#select Avg(salary),dep_id from employee where email like %a% group by dep_id ;</span></span><br><span class="line"><span class="attr">案例：查询有奖金的每个领导手下员工的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">manager_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id ;</span></span><br><span class="line"><span class="comment">#select max(salary) ,manage_id from employees where commission_pct is not null group by manager_id;</span></span><br><span class="line"><span class="attr">案例：哪个部门的员工个数大于二？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 2 ;</span></span><br><span class="line"><span class="comment">#select dep_id from emp group by dep_id having count(*)&gt;2;</span></span><br><span class="line"><span class="attr">案例：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MAX(salary) &gt; 12000 ;</span></span><br><span class="line"><span class="comment">#select job_id ,max(salary) from emp where commission_pct IS NOT NULL group by job_id having max(salary)&gt;12000;</span></span><br><span class="line"><span class="attr">案例：查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id ,MIN(salary)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">manager_id&gt;102</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#select manager_id from emp where manager_id&gt;102 group by manager_id having min(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#按照员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(*) AS c</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY LENGTH(last_name) </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">c&gt;5;</span></span><br><span class="line"><span class="comment"># select count(*) from emp group by length(name) having count(*)&gt;5;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资并且按照平均工资的高低显示</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY AVG(salary) ASC;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id order by avg(salary) asc;</span></span><br></pre></td></tr></table></figure><h4 id="6-连接查询"><a href="#6-连接查询" class="headerlink" title="6.连接查询"></a>6.连接查询</h4><p><strong>又称为多表查询，当查询的字段来自多个表时，就会用到连接查询。</strong><br>**笛卡尔乘积现象：表1有m行，表2有n行，结果：m_n行_<br><strong>发生原因：没有有效的连接条件</strong></p><p><strong>分类</strong></p><p>①按年代分类<br>sql92:仅仅支持内连接<br>sql99：不支持全外连接</p><p>②按功能分类</p><table><thead><tr><th>内连接</th><th>外连接</th><th>交叉连接</th></tr></thead><tbody><tr><td>等值连接</td><td>左外连接</td><td></td></tr><tr><td>非等值连接</td><td>右外连接</td><td></td></tr><tr><td>自连接</td><td>全外连接</td><td></td></tr></tbody></table><h5 id="1-等值连接"><a href="#1-等值连接" class="headerlink" title="1.等值连接"></a>1.等值连接</h5><p>①多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序，分组，筛选</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例一：查询女优名对应的男优名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">NAME,</span></span><br><span class="line">  <span class="attr">boyName</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">beauty,</span></span><br><span class="line">  <span class="attr">boys</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">beauty.boyfriend_id = boys.`id` ;</span></span><br><span class="line"><span class="comment">#select name, boyname from girl ,boy where girl.boyfriend_id=boy.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名和对应的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employees.`department_id` = departments.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e,dep d where e.dep.id= d.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名，工种号，工种名。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">emp.`job_id`,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">job </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">emp.`job_id` = job.`job_id` ;</span></span><br><span class="line"><span class="comment">#select name , e.job_id,job_title from emp e,job j where e.job_id=j.id;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的员工名和部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">dep </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL &amp;&amp; emp.`department_id` = dep.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e ,dep d where e.dep_id =d.id &amp;&amp;e.salary_pct is not null;</span></span><br><span class="line"><span class="comment">#案例：查询城市名第二个字符为o的部门</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">l.`city` LIKE &#x27;_o%&#x27; ;</span></span><br><span class="line"><span class="comment">#select dep_name from location l , dep d where l.city like %_o% &amp;&amp; l.id =d.location_id;</span></span><br><span class="line"><span class="comment">#案例：查询每个城市的部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY l.`city` ;</span></span><br><span class="line"><span class="comment">#select count(*),city from loca l,dep d where l.loc_id=d.loc_id group by count(*) asc;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.`department_name`,</span></span><br><span class="line">  <span class="attr">d.manager_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">e.`commission_pct` IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY d.`department_id`,</span></span><br><span class="line">  <span class="meta">d.`department_name`</span> <span class="string">;</span></span><br><span class="line"><span class="comment">#select dep_name ,d.manager_id ,min(salary) from emp e ,dep d where e.`department_id` = d.`department_id` AND e.`commission_pct` IS NOT NULL GROUP BY d.`department_id`,d.`department_name` ;</span></span><br><span class="line"><span class="comment">#案例：查询每个工种的工种名和员工的个数，并且按照员工个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">j.job_title,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">j,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">j.`job_id` = e.`job_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.`job_id`,</span></span><br><span class="line">  <span class="meta">j.`job_title`</span> <span class="string"></span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名，部门名和所在城市</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d,</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">d.`location_id` = l.`location_id` ;</span></span><br></pre></td></tr></table></figure><h5 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2.非等值连接"></a>2.非等值连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工的工资和工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DISTINCT </span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.salary &gt;= j.lowest_sal &amp;&amp; e.salary &lt;= j.highest_sal </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary ASC ;</span></span><br></pre></td></tr></table></figure><h5 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3.自连接"></a>3.自连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工名和上级的名称</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">e.last_name,</span></span><br><span class="line">  <span class="meta">m.last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">m </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.manager_id = m.employee_id ;</span></span><br></pre></td></tr></table></figure><h5 id="4-内连接"><a href="#4-内连接" class="headerlink" title="4.内连接"></a>4.内连接</h5><p><strong>INNER 可以省略</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询员工名，部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.department_id = d.department_id ;</span></span><br><span class="line"><span class="comment">#查询名字中包含e的员工名和工种名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.job_id = j.job_id </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">last_name LIKE &#x27;%e%&#x27; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询部门个数&gt;3的城市名和部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">city,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN locations l </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">d.`location_id` = l.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY city</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按照个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询员工名，部门名，工种名，并按照部门名降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`job_id` = j.`job_id` </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY department_name DESC ;</span></span><br><span class="line"><span class="comment">#查询员工工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level,</span></span><br><span class="line">  <span class="attr">salary</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN employees e </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` ;</span></span><br><span class="line"><span class="comment">#查询每个工资级别的个数，并且降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">grade_level,COUNT(*)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN  job_grades j</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY grade_level</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC;</span></span><br><span class="line"><span class="comment">#查询员工的名字和上级的名字</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">e1.last_name, e2.last_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e1</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN employees e2</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e1.`employee_id`=e2.`manager_id`;</span></span><br></pre></td></tr></table></figure><h5 id="5-左外连接"><a href="#5-左外连接" class="headerlink" title="5.左外连接"></a>5.左外连接</h5><p><strong>语法：</strong><br>SELECT 查询列表<br>FROM 表1 【连接类型】<br>JOIN 表2<br>ON 连接条件<br>WHERE 筛选条件<br>GROUP BY 分组<br>HAVING 筛选条件<br>ORDER BY 排序条件<br><strong>连接类型：</strong><br>内连接：inner<br>左外连接：left<br>右外连接：right<br>全外连接：full<br>交叉连接：cross<br><strong>外连接</strong><br>用于查询一个表中有，另一个表中没有的数据<br>左外连接，left左边是主表<br>右外连接，right右边是主表<br><em>Mysql不支持全外连接</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有男朋友的女生</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">g.`name`,b.`boyName`</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.`id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName` IS NULL;</span></span><br></pre></td></tr></table></figure><h5 id="6-交叉连接"><a href="#6-交叉连接" class="headerlink" title="6.交叉连接"></a>6.交叉连接</h5><p><strong>笛卡尔乘积</strong></p><h4 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h4><p><strong>出现在其它语句中的select语句，称为子查询或内查询</strong><br><strong>外部的查询语句，称为主查询或外查询</strong><br><strong>分类：</strong></p><p>①按照子查询出现的位置：</p><table><thead><tr><th>select后面</th><th>from后面</th><th>where或having后面</th><th>exists后面</th></tr></thead><tbody><tr><td>仅仅支持标量子查询</td><td>支持表子查询</td><td>标量子查询，列子查询</td><td>表子查询</td></tr></tbody></table><p>②按照结果集的行列数不同：</p><table><thead><tr><th>标量子查询</th><th>列子查询</th><th>行子查询</th><th>表子查询</th></tr></thead><tbody><tr><td>结果只有一行一列</td><td>结果一列多行</td><td>一行多列</td><td>多行多列</td></tr></tbody></table><h5 id="1）where或having后面"><a href="#1）where或having后面" class="headerlink" title="1）where或having后面"></a>1）where或having后面</h5><p><strong>特点：</strong><br>子查询一般放在小括号内<br>子查询一般放在条件的右边<br>标量子查询，一般搭配着单行操作符<br>列子查询：一般搭配多行操作符使用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.标量子查询</span></span><br><span class="line"><span class="comment">#谁的工资比Abel高</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">last_name = &#x27;Abel&#x27;) ;</span></span><br><span class="line"><span class="comment">#返回job_id于141号员工相同，salary比143号员工多的员工 姓名，job_id和工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">job_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 141) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 143)</span></span><br><span class="line"><span class="comment">#返回公司工资工资最少的员工的姓名，job_id,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees);</span></span><br><span class="line"><span class="comment">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary) &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">department_id = 50) ;</span></span><br><span class="line"><span class="attr">2.列子查询</span></span><br><span class="line"><span class="attr">多行操作符：</span></span><br><span class="line"><span class="attr">IN</span> <span class="string">/ NOT in：等于列表中的任意一个</span></span><br><span class="line"><span class="attr">ANY</span> <span class="string">/ SOME ：和子查询返回的某一个值比较</span></span><br><span class="line"><span class="attr">ALL</span> <span class="string">：和子查询返回的所有值比较</span></span><br><span class="line"><span class="comment">#返回location_id是1400或者1700的部门中的所有员工姓名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id IN</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string">DISTINCT</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">departments</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">location_id IN (1400, 1700)) ;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门任意工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门所有工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="attr">*********************************</span></span><br><span class="line"><span class="attr">3.行子查询</span></span><br><span class="line"><span class="comment">#查询员工编号最小并且工资最高的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="meta">*</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(employee_id)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="meta">employees)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees)</span></span><br></pre></td></tr></table></figure><h5 id="2）SELECT-后面"><a href="#2）SELECT-后面" class="headerlink" title="2）SELECT 后面"></a>2）SELECT 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询每个部门的员工个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.*,</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">e.department_id = d.department_id) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d ;</span></span><br><span class="line"><span class="comment">#查询员工号等于102的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 102) ;</span></span><br></pre></td></tr></table></figure><h5 id="3）FROM-后面"><a href="#3）FROM-后面" class="headerlink" title="3）FROM 后面"></a>3）FROM 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询每个部门平均工资的工资等级</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string">,aa.department_id</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">AVG(salary)</span> <span class="string">ag,</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">GROUP</span> <span class="string">BY department_id) aa </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN job_grades j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">aa.ag BETWEEN lowest_sal </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">highest_sal ;</span></span><br></pre></td></tr></table></figure><h5 id="4）exists后面（相关子查询）"><a href="#4）exists后面（相关子查询）" class="headerlink" title="4）exists后面（相关子查询）"></a>4）exists后面（相关子查询）</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询有员工的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_name FROM departments d</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">EXISTS(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees  e WHERE d.department_id=e.department_id</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="comment">#查询没有女朋友的男生信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">bo.* FROM boys bo WHERE</span></span><br><span class="line"><span class="meta">bo.`id`</span> <span class="string">NOT IN(SELECT boyfriend_id FROM beauty);</span></span><br></pre></td></tr></table></figure><h5 id="5）子查询经典案例祥讲"><a href="#5）子查询经典案例祥讲" class="headerlink" title="5）子查询经典案例祥讲"></a>5）子查询经典案例祥讲</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.查询工资最低的员工信息：last_name,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,salary FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">salary=(SELECT MIN(salary) FROM employees);</span></span><br><span class="line"><span class="attr">2.查询平均工资最低的部门信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM departments WHERE department_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">3.查询平均工资最低的部门信息和该部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">d.*,a1.ag FROM departments  d JOIN </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">AVG(salary) ag,department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1) a1</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">d.department_id=a1.department_id</span></span><br><span class="line"><span class="attr">4.查询平均工资最高的job信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">j.* FROM jobs j WHERE j.job_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">job_id FROM employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id ORDER BY AVG(salary) DESC LIMIT 1)</span></span><br><span class="line"><span class="attr">5.查询平均工资高于公司平均工资的部门有哪些</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id ,AVG(salary) AS avg1 FROM employees GROUP BY  department_id) e1</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e1.avg1&gt;(SELECT AVG(salary)  AS avg2 FROM employees) </span></span><br><span class="line"><span class="attr">6.查询出公司中所有manager的详细信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id IN(SELECT DISTINCT manager_id FROM employees);</span></span><br><span class="line"><span class="attr">7.各个部门中，最高工资中最低的那个部门的最低工资是多少</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees GROUP BY department_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY MAX(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">8.查询平均工资最高的部门的manager的详细信息：last_name,department_id,email,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,department_id,email,salary FROM employees WHERE employee_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id FROM departments WHERE department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">LIMIT 1))</span></span><br></pre></td></tr></table></figure><h4 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8.分页查询"></a>8.分页查询</h4><p>**语法：limit(currentPage-1)<em>size,size</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询前五条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 0,5;</span></span><br><span class="line"><span class="comment">#查询第11-25条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 10,15;</span></span><br><span class="line"><span class="comment">#查询有奖金的员工，并且工资最高的前十名显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary DESC </span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">0 ,10;</span></span><br></pre></td></tr></table></figure><h4 id="9-联合查询"><a href="#9-联合查询" class="headerlink" title="9.联合查询"></a>9.联合查询</h4><p><strong>要查询的结果来自于多个表，且多个表没有直接的连接关系，单查询的信息一致时</strong><br><strong>特点：</strong><br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以不去除重复项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工部门编号大于90或邮箱包含a的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE department_id&gt;90</span></span><br><span class="line"><span class="attr">UNION</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE email LIKE &#x27;%a%&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="三，DML数据操作语言"><a href="#三，DML数据操作语言" class="headerlink" title="三，DML数据操作语言"></a>三，DML数据操作语言</h3><p><strong>插入insert</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一：插入语句</span></span><br><span class="line"><span class="comment">#插入beauty一行数据</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;波多野吉依&#x27;,&#x27;女&#x27;,&#x27;1998-11-11&#x27;,&#x27;13342969497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,10)</span></span><br><span class="line"><span class="comment">#可以为null的列如何不插入值</span></span><br><span class="line"><span class="attr">直接写null，或列名少写一列</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;小泽玛利亚&#x27;,&#x27;女&#x27;,&#x27;1999-11-11&#x27;,&#x27;13342456497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,11)</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty VALUES(15,&#x27;马蓉&#x27;,&#x27;女&#x27;,&#x27;1989-11-11&#x27;,&#x27;13342456123&#x27;,</span></span><br><span class="line"><span class="attr">NULL,12);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty SET id=16,NAME=&#x27;刘亦菲&#x27;, sex=&#x27;女&#x27;,borndate=&#x27;1989-10-01&#x27;,</span></span><br><span class="line"><span class="attr">phone</span>=<span class="string">&#x27;15945231056&#x27;,boyfriend_id=16;</span></span><br><span class="line"><span class="comment">#insert 嵌套子查询，将一个表的数据插入另一张表</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty (NAME,sex,borndate,phone,boyfriend_id)</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">&#x27;妲己&#x27;,&#x27;女&#x27;,&#x27;1111-11-11&#x27;,&#x27;13146587954&#x27;,0;</span></span><br></pre></td></tr></table></figure><p><strong>修改update</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">二，修改</span></span><br><span class="line"> <span class="attr">UPDATE</span> <span class="string">beauty SET phone=&#x27;110&#x27; WHERE id=16;</span></span><br><span class="line"><span class="attr">多表修改：sql99</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">表1 别名</span></span><br><span class="line"><span class="meta">INNER|LEFT|RIGHT</span> <span class="string">JOIN 表2 别名</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">连接条件</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">列=值</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">筛选条件</span></span><br><span class="line"><span class="comment">#修改张无忌的女朋友手机号为114</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.phone=&#x27;114&#x27;</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.boyName=&#x27;张无忌&#x27;;</span></span><br><span class="line"><span class="comment">#修改没有男朋友的女生的男朋友编号都为4号</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN  boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.`boyfriend_id`=4</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=NULL;</span></span><br></pre></td></tr></table></figure><p><strong>删除delete</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">三，删除</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">和 TRUNCATE 的区别：</span></span><br><span class="line"><span class="attr">1.delete可以加where条件，truncate不行</span></span><br><span class="line"><span class="attr">2.truncate删除效率高</span></span><br><span class="line"><span class="attr">3.加入要删除的表中有自增列，</span></span><br><span class="line"><span class="attr">用delete删除整个表后在插入数据，从断点处开始插入</span></span><br><span class="line"><span class="attr">用truncate删除后在插入数据，从1开始。</span></span><br><span class="line"><span class="attr">4.truncate删除没有返回值，delete有返回值</span></span><br><span class="line"><span class="attr">5.truncate删除不能回滚，delete删除可以回滚</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM beauty WHERE id=17;</span></span><br><span class="line"><span class="meta">语法：truncate</span> <span class="string">TABLE 表名;</span></span><br><span class="line"><span class="comment">#删除张无忌的女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=1;</span></span><br><span class="line"><span class="comment">#删除黄晓明以及他女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">b,g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">b.`id`=g.`boyfriend_id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName`=&#x27;黄晓明&#x27;;</span></span><br><span class="line"><span class="meta">多表删除</span> :<span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">TRUNCATE</span> <span class="string">TABLE boys</span></span><br></pre></td></tr></table></figure><h3 id="四，DDL数据定义语言"><a href="#四，DDL数据定义语言" class="headerlink" title="四，DDL数据定义语言"></a>四，DDL数据定义语言</h3><h4 id="1-库和表的管理"><a href="#1-库和表的管理" class="headerlink" title="1.库和表的管理"></a>1.库和表的管理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一，库的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">DATABASE IF NOT EXISTS mydb1 ;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.更改字符集</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">DATABASE mydb1 CHARACTER SET utf8;</span></span><br><span class="line"><span class="meta">删除</span> <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">DATABASE IF EXISTS school;</span></span><br><span class="line"><span class="attr">二，表的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE book(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">b_name</span> <span class="string">VARCHAR(30),</span></span><br><span class="line"><span class="attr">price</span> <span class="string">DOUBLE,</span></span><br><span class="line"><span class="attr">author_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">publishDate</span> <span class="string">DATE</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">book ;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE author(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">au_name</span> <span class="string">VARCHAR(20),</span></span><br><span class="line"><span class="attr">nation</span> <span class="string">VARCHAR(10)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">author;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.修改列名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book CHANGE COLUMN publishDate pub_date DATETIME;</span></span><br><span class="line"><span class="attr">2.修改列的类型或约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book MODIFY COLUMN pub_date DATE;</span></span><br><span class="line"><span class="attr">3.添加新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author ADD COLUMN annual DOUBLE;</span></span><br><span class="line"><span class="attr">4.删除新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author DROP COLUMN annual;</span></span><br><span class="line"><span class="attr">5.修改表名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author RENAME TO book_author;</span></span><br><span class="line"><span class="meta">删除</span>  <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE IF EXISTS my_employee;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">TABLES;</span></span><br><span class="line"><span class="attr">复制</span></span><br><span class="line"><span class="attr">1.仅仅复制表的结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy LIKE book_author;</span></span><br><span class="line"><span class="attr">2.复制表的结构加数据</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy2</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM book_author;</span></span><br><span class="line"><span class="attr">3.复制部分结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy3 </span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">id,au_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">book_author</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">id=0;</span></span><br></pre></td></tr></table></figure><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p><strong>数值型</strong><br><strong>1.整型</strong></p><table><thead><tr><th>TINYINT</th><th>SMALLINT</th><th>MEDIUMINT</th><th>INT/INTEGER</th><th>BIGINT</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>8</td></tr></tbody></table><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如何设置无符号和有符号(默认有符号)</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_int;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_int(t1 INT,t2 INT UNSIGNED);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_int(t1,t2) VALUES(-1,1);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_int;</span></span><br></pre></td></tr></table></figure><p>1）如果插入的数值超出了整形的范围，会报out of range异常，并且插入<br>临界值。<br>2）如果不设置长度，会有默认的长度。<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配<br>zerofill使用。<br><strong>2.小数</strong><br>①定点数<br>dec（M,D）<br>②浮点数<br>float（4） ，double（8）<br>M，D的意思：M指定一共多少位，D指定小数几位，超出会四舍五入。<br>MD都可以省略，<br>如果是dec，则M默认为10，D默认为0<br>如果是浮点数，则会根据插入数值的精度改变精度<br>定点型精度相对较高。<br><strong>3.字符型</strong><br>①较短的文本<br>CHAR(M)默认为1,VARCHAR(M)<br>M:字符数<br>char：固定长度字符，比较耗费空间，但是效率高。<br>varchar：可变长度字符</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ENUM</span> <span class="string">枚举类</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_char(</span></span><br><span class="line">   <span class="attr">t1</span> <span class="string">ENUM(&#x27;a&#x27;,&#x27;c&#x27;,&#x27;b&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">集合</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_set(</span></span><br><span class="line"><span class="attr">s1</span> <span class="string">SET(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_set(s1) VALUES(&#x27;a,b&#x27;);</span></span><br></pre></td></tr></table></figure><p>BINARY:保存较短的二进制。<br>②较长的文本<br>text（文本）,BLOB(较大的二进制)<br><strong>4.日期型</strong><br>DATE:日期<br>DATETIME:日期加时间，8字节<br>timestamp：跟时区有关系，建议使用，4字节<br>time：时间<br>year：年</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_date(</span></span><br><span class="line"><span class="attr">t1</span> <span class="string">DATETIME,</span></span><br><span class="line"><span class="attr">t2</span> <span class="string">TIMESTAMP</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_date(t1,t2)</span></span><br><span class="line"><span class="attr">VALUES(NOW(),NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM tab_date;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">time_zone=&#x27;+9:00&#x27;;</span></span><br><span class="line"><span class="comment">#设置时区为东9区</span></span><br></pre></td></tr></table></figure><h4 id="3-常见约束"><a href="#3-常见约束" class="headerlink" title="3.常见约束"></a>3.常见约束</h4><p><strong>含义：一种限制，用于限制表中的数据，保证数据的一致性。</strong></p><ol><li> NOT NULL </li><li> DEFAULT </li><li> PRIMARY KEY  唯一，且不为空 </li><li> UNIQUE  唯一，可以为空 </li><li> CHECK Mysql不支持 </li><li> FOREIGN KEY 外键约束，用于限制两个表的关系，<br>用于保证该字段的值必须来自于主表的关联列的值。<br>约束的分类：<br>列级约束：除外键约束<br>表级约束：除了非空，默认。<br>CREATE TABLE 表名(<br>字段1 字段类型 列级约束,<br>字段2 字段类型 列级约束,<br>表级约束<br>); </li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建表时添加列级约束</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_test;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_major(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">major_name</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_test;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">INDEX FROM tab_test;</span></span><br><span class="line"><span class="comment">#查看索引信息</span></span><br><span class="line"><span class="comment">#添加表级约束</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id FOREIGN KEY(major_id) REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id 可以省略</span></span><br></pre></td></tr></table></figure><p>面试题：主键约束和唯一约束的区别：<br>都可以保证唯一性，<br>主键不能为空 ，unique 能为空，但是只能有一个null。<br>主键只能有1个，unique可以有多个。<br>都允许两个列组合成一个约束。<br>面试题：外键：<br>要求在从表设置外键关系<br>从表的外键列类型和主表的关联列类型一致，名称无要求<br>要求主表的关联列必须是主键或者唯一键<br>插入数据应该先插入主表再插入从表<br>删除数据应该先删除从表，在删除主表<br>二，修改表时添加约束</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test2(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) ,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR ,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT , </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT  </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN stu_name  VARCHAR(20) NOT NULL ;</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;</span></span><br><span class="line"><span class="comment">#添加外键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 ADD FOREIGN KEY(major_id) REFERENCES tab_major(id);</span></span><br></pre></td></tr></table></figure><h4 id="4-标识列"><a href="#4-标识列" class="headerlink" title="4.标识列"></a>4.标识列</h4><p>自增长列 AUTO_INCREMENT<br>特点：<br>1.表示必须和一个key搭配<br>2.一个表最多一个标识列<br>3.标识列类型只能是数值型<br>4.标识列可以通过set auto_increment_increment=3;设置步长</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">tab_auto(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">NAME</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br></pre></td></tr></table></figure><h3 id="五，TCL语言：事务控制语言"><a href="#五，TCL语言：事务控制语言" class="headerlink" title="五，TCL语言：事务控制语言"></a>五，TCL语言：事务控制语言</h3><p>事务：一个或一组sql语句组成的执行单元，</p><p>要么全部执行,要么都不执行。<br>存储引擎:在MySQL中的数据用各种不同的技术存储在文件中。<br>通过show ENGINES;来查看mysql支持的存储引擎。<br>innodb引擎支持事务。<br>事务的ACID属性：<br>1.原子性:事务是一个不可分割的工作单位，要么都发生，要么都不发生。<br>2.一致性：事务必须使数据库从一个一致性状态变为另一个一致性状态。<br>3.隔离性：一个事务的执行不能被另一个事务干扰。<br>4.持久性：事务一旦被提交，对数据库事务的改变就是永久性的。</p><p>DELETE 和 TRUNCATE 在事务中的区别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">演示delete</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="meta">演示</span> <span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">TRUNCATE</span>  <span class="string">TABLE tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">是直接删除表中数据，truncate是江表删除，创建一张与原来一样的空表。</span></span><br></pre></td></tr></table></figure><h3 id="六，视图"><a href="#六，视图" class="headerlink" title="六，视图"></a>六，视图</h3><p><strong>含义：虚拟表，和普通表格一样使用</strong><br><strong>通过表动态生成的数据</strong></p><h4 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1.创建视图"></a>1.创建视图</h4><p><strong>语法：</strong><br><strong>CREATE VIEW 视图名</strong><br><strong>AS</strong><br><strong>查询语句 ;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询姓名中包含a字符的员工名，部门名和工种信息</span><br><span class="line">create view view1 as</span><br><span class="line">    select e.last_name,d.department_name ,j.job_title from employees e</span><br><span class="line">inner join departments d on e.department_id = d.department_id</span><br><span class="line">    inner join jobs j on e.job_id = j.job_id</span><br><span class="line">where e.last_name like &#x27;%a%&#x27;;</span><br><span class="line">select * from view1;</span><br><span class="line"># 案例：查询各个部门的平均工资级别</span><br><span class="line">create view view2 as</span><br><span class="line">select j.grade_level ,aa.department_id</span><br><span class="line">    from job_grades j</span><br><span class="line">inner join (select avg(salary) avg_s,department_id from employees  group by department_id) aa</span><br><span class="line">    on aa.avg_s between j.lowest_sal and j.highest_sal;</span><br><span class="line">select * from view2;</span><br><span class="line"># 案例：查询平均工资最低的部门信息</span><br><span class="line">create view view3 as</span><br><span class="line">select avg(salary) avg_s ,department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">order by avg_s asc</span><br><span class="line">limit 1;</span><br><span class="line">select * from view3;</span><br></pre></td></tr></table></figure><h4 id="2-视图修改"><a href="#2-视图修改" class="headerlink" title="2.视图修改"></a>2.视图修改</h4><p><strong>①create OR REPLACE VIEW 视图名 AS 查询语句;</strong><br><strong>②alter VIEW 视图名 AS 查询语句;</strong></p><h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h4><p><strong>DROP VIEW v1,v2;</strong></p><h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4.查看视图"></a><strong>4.查看视图</strong></h4><p><strong>DESC v1;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资，邮箱</span><br><span class="line">CREATE VIEW emp_v1 AS</span><br><span class="line">SELECT last_name ,salary,email FROM employees WHERE</span><br><span class="line">phone_number LIKE &#x27;%011&#x27;;</span><br><span class="line">#创建视图emp_v2,要求查询部门的最高工资高于12000的部门信息</span><br><span class="line">CREATE VIEW v4 AS</span><br><span class="line">SELECT department_id FROM employees GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt; 12000;</span><br><span class="line">CREATE VIEW emp_v2 AS</span><br><span class="line">SELECT * FROM departments WHERE department_id IN(SELECT * FROM v4);</span><br></pre></td></tr></table></figure><h4 id="5-视图的更新"><a href="#5-视图的更新" class="headerlink" title="5.视图的更新"></a>5.视图的更新</h4><p><strong>视图的可更新性和视图中查询的定义有关，以下类型的视图是不能更新的。</strong><br><strong>1.包含以下关键字的sql语句：分组函数，distinct，group by，having，union</strong><br><strong>2.常量视图</strong><br><strong>3.select中包含子查询的</strong><br><strong>4.join</strong><br><strong>5.from 一个不能更新的视图</strong><br><strong>6.where子句的子查询引用了from子句的表</strong></p><h4 id="6-视图和表的对比："><a href="#6-视图和表的对比：" class="headerlink" title="6.视图和表的对比："></a>6.视图和表的对比：</h4><table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td><strong>视图</strong></td><td>CREATE VIEW</td><td>只是保存了sql逻辑</td><td>增删改查，一般不能增删改</td></tr><tr><td><strong>表</strong></td><td>CREATE TABLE</td><td>占用</td><td>增删改查</td></tr></tbody></table><h3 id="七，变量"><a href="#七，变量" class="headerlink" title="七，变量"></a>七，变量</h3><p><strong>系统变量</strong>   ：变量由系统提供，不是用户自定义，属于服务器层面。<br>查看系统所有变量：show GLOBAL VARIABLES;<br>查看满足条件的部分系统变量： SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>查看指定的某个系统变量的值： SELECT  @@global.autocommit;<br>为某个系统变量赋值：set @@global.系统变量名=值;<br><strong>全局变量:GLOBAL</strong><br>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话有效，但不能<br>跨重启。<br><strong>会话变量:SESSION</strong><br>作用域：针对当前的会话有效。<br>用户自定义变量<br><strong>用户变量</strong><br>声明： SET/SELECT  @用户变量名 :=值;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @用户变量名 :=值;<br>使用：select @用户变量名;<br>应用在任何地方。<br>作用域：针对当前会话和连接有效。<br><strong>局部变量</strong><br>作用域：作用在定义它的begin END 块中。<br>声明： DECLARE 变量名 类型  （default 值）;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @变量名 :=值;<br>使用：select @变量名;<br>只能放在begin END 中的第一句话</p><h3 id="八，存储过程和函数"><a href="#八，存储过程和函数" class="headerlink" title="八，存储过程和函数"></a>八，存储过程和函数</h3><h4 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h4><p><strong>一组预先定义好的sql语句集合，理解成批处理语句。</strong><br>1.提高代码的重用性<br>2.简化操作<br>3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率。</p><h5 id="1-创建语法："><a href="#1-创建语法：" class="headerlink" title="1.创建语法："></a>1.创建语法：</h5><p>CREATE PROCEDURE 存储过程名（参数列表）<br>BEGIN<br>一组合法的sql语句;<br>END<br>参数列表：参数模式 参数名 参数类型</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>OUT  ：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出</p><p>如果存储过程只有一句话，begin END 可以省略</p><p>存储过程体中的每条sql语句的结尾需要必须加分号，<br>存储过程的结尾可以使用 DELIMITER 重新设置。</p><h5 id="2-调用"><a href="#2-调用" class="headerlink" title="2.调用"></a>2.调用</h5><p>CALL 存储过程名（实参列表）;</p><h5 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插入到admin表中五条记录</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_a()</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;yin&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;aa&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;bb&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;cc&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;dd&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="comment">#创建存储过程实现 根据女生名查询对应的男生信息</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_b(IN beauty_name VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line">      <span class="attr">SELECT</span> <span class="string">bo.*</span></span><br><span class="line">      <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">      <span class="attr">RIGHT</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">      <span class="attr">WHERE</span> <span class="string">b.name=beauty_name;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_b(&#x27;热巴&#x27;);</span></span><br><span class="line"><span class="comment">#根据女生名返回他的男朋友名</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_d(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SELECT</span> <span class="string">bo.boyName INTO boyName</span></span><br><span class="line">        <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">        <span class="attr">INNER</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">        <span class="attr">WHERE</span> <span class="string">b.name=beautyName;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_d(&#x27;小昭&#x27;,@b_name);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@b_name;</span></span><br><span class="line"><span class="comment">#传入两个值a，b，最终翻倍返回a和b</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_e(INOUT a INT ,INOUT b INT )</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">a=a*2;</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">b=b*2;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@m=10;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@n=20;</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_e(@m,@n);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@m,@n;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除存储过程"><a href="#4-删除存储过程" class="headerlink" title="4.删除存储过程"></a>4.删除存储过程</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE 存储过程名</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE my_a;</span></span><br></pre></td></tr></table></figure><h5 id="5-查看存储过程的信息"><a href="#5-查看存储过程的信息" class="headerlink" title="5.查看存储过程的信息"></a>5.查看存储过程的信息</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE PROCEDURE  my_b;</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>存储过程可以有0/n个返回值：适合批量增删改</strong><br><strong>函数有且仅有一个返回值：适合查询</strong></p><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION 函数名(参数列表) RETURNS 返回类型</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span></span><br></pre></td></tr></table></figure><p>注意：<br>参数列表：参数名，参数类型<br>一定会有return语句</p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p><strong>SELECT 函数名(参数列表)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回公司员工个数</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f1() RETURNS INT</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c INT DEFAULT 0 ;</span></span><br><span class="line">    <span class="attr">SELECT</span> <span class="string">COUNT(*) INTO c FROM employees;</span></span><br><span class="line">    <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f1();</span></span><br><span class="line"><span class="comment">#根据员工名返回他的工资</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f2(NAME VARCHAR(20)) RETURNS DOUBLE</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c DOUBLE;</span></span><br><span class="line">     <span class="attr">SELECT</span> <span class="string">salary INTO c FROM employees WHERE last_name=NAME;</span></span><br><span class="line">     <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@a=&#x27;Hunold&#x27;;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f2(@a);</span></span><br></pre></td></tr></table></figure><h5 id="3-查看"><a href="#3-查看" class="headerlink" title="3.查看"></a>3.查看</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h3 id="九，流程控制"><a href="#九，流程控制" class="headerlink" title="九，流程控制"></a>九，流程控制</h3><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h5 id="1-if-（表达式1，表达式2，表达式3）"><a href="#1-if-（表达式1，表达式2，表达式3）" class="headerlink" title="1.if （表达式1，表达式2，表达式3）"></a>1.if （表达式1，表达式2，表达式3）</h5><p>如果表达式1成立，就返回表达式2的值，否则返回表达式3的值。<br>应用在任何地方</p><h5 id="2-case"><a href="#2-case" class="headerlink" title="2.case"></a>2.case</h5><h6 id="1-switch-CASE"><a href="#1-switch-CASE" class="headerlink" title="1)switch-CASE"></a>1)switch-CASE</h6><p><strong>语法:</strong><br><strong>CASE 要判断的字段或者表达式</strong><br><strong>WHEN 常量1 THEN 要显示的值1或者语句1</strong><br><strong>WHEN 常量2 THEN 要显示的值2或者语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或者语句n；</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br></pre></td></tr></table></figure><h6 id="2-CASE-使用2："><a href="#2-CASE-使用2：" class="headerlink" title="2)CASE 使用2："></a>2)CASE 使用2：</h6><p><strong>语法：</strong><br><strong>CASE</strong><br><strong>WHEN 条件1 THEN 要显示的值1或语句1</strong><br><strong>WHEN 条件2 THEN 要显示的值2或语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或语句n</strong><br><strong>END</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees </span></span><br><span class="line"> <span class="attr">可以放在任何地方</span></span><br><span class="line"><span class="comment"> #创建存储过程，根据传入的成绩，显示等级，90A,80B，70C，60D ，F</span></span><br><span class="line"> <span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">PROCEDURE my_1(IN score INT)</span></span><br><span class="line"> <span class="attr">BEGIN</span></span><br><span class="line"> <span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"> <span class="attr">WHEN</span>  <span class="string">score BETWEEN 90 AND 100</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;A&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 80 AND 90</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;B&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 80</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;C&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 60</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;D&#x27;;</span></span><br><span class="line"> <span class="attr">ELSE</span> <span class="string">SELECT &#x27;E&#x27;;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">CASE;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_1(95);</span></span><br></pre></td></tr></table></figure><h5 id="3-if"><a href="#3-if" class="headerlink" title="3.if"></a>3.if</h5><p><strong>语法：</strong><br><strong>IF 条件1 THEN 语句1;</strong><br><strong>ELSEIF 条件2 THEN 语句2;</strong><br><strong>…</strong><br><strong>ELSE 语句n;</strong><br><strong>END IF;</strong><br>只能用在begin end中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建存储过程，根据传入的成绩，返回等级，90A,80B，70C，60D ，F</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">FUNCTION my_2( score INT) RETURNS CHAR</span></span><br><span class="line"> <span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line">   <span class="attr">IF</span> <span class="string">score &gt;=90 THEN RETURN&#x27;A&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=80 THEN RETURN&#x27;B&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=70 THEN RETURN&#x27;C&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=60 THEN RETURN&#x27;D&#x27;;</span></span><br><span class="line">   <span class="attr">ELSE</span> <span class="string">RETURN&#x27;E&#x27;;</span></span><br><span class="line">   <span class="attr">END</span> <span class="string">IF;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">SELECT</span>  <span class="string">my_2(85);</span></span><br></pre></td></tr></table></figure><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>在存储过程或函数里面使用</strong></p><h5 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h5><p><strong>语法：</strong><br><strong>标签:WHILE 循环条件 DO</strong><br><strong>循环体;</strong><br><strong>END WHILE 标签;</strong><br><strong>循环控制和标签搭配使用</strong></p><h5 id="2-loop"><a href="#2-loop" class="headerlink" title="2.loop"></a>2.loop</h5><p><strong>语法：</strong><br><strong>标签： LOOP</strong><br><strong>循环体;</strong><br><strong>END LOOP 标签;</strong></p><h5 id="3-repeat"><a href="#3-repeat" class="headerlink" title="3.repeat"></a>3.repeat</h5><p><strong>语法：</strong><br><strong>标签： REPEAT</strong><br><strong>循环体;</strong><br><strong>UNTIL 结束循环的条件</strong><br><strong>END REPEAT 标签;</strong></p><p>循环控制<br>ITERATE 类似continue<br>LEAVE   类似break</p><hr><p>left join==left outer join</p><p>a left join b 就是取a和b的交集加a剩下的部分</p><p>inner join</p><p>a inner join b就是取交集</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12610368/1641814968278-9ad396b9-3c05-4a17-816c-26b50cd647c2.jpeg" alt="夜拍.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[二]概述</title>
      <link href="/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一，一条SQL的查询流程"><a href="#一，一条SQL的查询流程" class="headerlink" title="一，一条SQL的查询流程"></a>一，一条SQL的查询流程</h1><ol><li><p>去连接池获取连接</p></li><li><p>查询缓存，命中返回，否则继续向下</p></li><li><p>词法解析&amp;预处理</p><blockquote><p>词法解析拆分SQL，语法分析检查SQL的正确性生成一颗解析树，预处理检查表名，列名，生成一颗解析树。</p></blockquote></li><li><p>优化器优化，优化计划，查询计划</p></li><li><p>执行引擎生成执行计划</p></li><li><p>存储引擎查询SQL，加入缓存，返回结果。</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641449666256-21382ea1-bf47-4ce3-b1ea-5cb8e82965f1.png" alt="image.png"></p><h2 id="1-获取连接"><a href="#1-获取连接" class="headerlink" title="1.获取连接"></a>1.获取连接</h2><p>MySQL支持多种通信协议，可以使用同步/异步的方式，支持长连接，短连接。<br>​</p><h3 id="1-1-通信类型"><a href="#1-1-通信类型" class="headerlink" title="1.1 通信类型"></a>1.1 通信类型</h3><p>​</p><p>一般来说，<strong>连接数据库都是同步连接</strong>。<br>​</p><blockquote><ol><li>同步连接：依赖于被调用方，受限制于被调用方的性能；一般只能一对一。</li><li>异步连接：避免阻塞，但不能节省SQL的执行时间，并发情况下，每个SQL的执行都要单独建立连接，占用大量CPU资源；异步连接必须使用连接池减少线程创建销毁的开销。</li></ol></blockquote><h3 id="1-2-连接方式"><a href="#1-2-连接方式" class="headerlink" title="1.2 连接方式"></a>1.2 连接方式</h3><p>MySQL长短连接都支持，一般我们会在连接池中使用长连接。保持长连接会消耗内存，长时间不活动的连接，MySQL服务器会断开。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">-- 非交互式超时时间，如 JDBC 程序</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;interactive_timeout&#x27;</span>; <span class="comment">-- 交互式超时时间，如数据库工具</span></span><br></pre></td></tr></table></figure><blockquote><p>默认长连接断开时间是8小时。</p></blockquote><p>可以使用 <code>show status;</code>查看当前MySQL有多少个连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Threads_cached</th><th>缓存中的线程连接数</th></tr></thead><tbody><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>为处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>每产生一个连接或者会话，服务端就会创建一个线程来处理。杀死会话本质就是kill 线程。<br>​</p><blockquote><p>可以使用<code>SHOW PROCESSLIST; </code>（root 用户）查看 SQL 的执行状态。<br>​</p></blockquote><blockquote><p>+—-+——+———–+——+———+——+———-+<br>| Id | User | Host      | db   | Command | Time | State    | Info             |<br>+—-+——+———–+——+———+——+———-+<br>| 11 | root | localhost | NULL | Query   |    0 | starting | show processlist |<br>+—-+——+———–+——+———+——+———-+</p></blockquote><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Sleep</td><td>线程正在等待客户端，以向它发送一个新语句</td></tr><tr><td>Query</td><td>线程正在执行查询或往客户端发送数据</td></tr><tr><td>Locked</td><td>该查询被其它查询锁定</td></tr><tr><td>Copying to tmp table on disk</td><td>临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器</td></tr><tr><td>Sending data</td><td>线程正在为 SELECT 语句处理行，同时正在向客户端发送数据</td></tr><tr><td>Sorting for group</td><td>线程正在进行分类，以满足 GROUP BY 要求</td></tr><tr><td>Sorting for order</td><td>线程正在进行分类，以满足 ORDER BY 要求</td></tr></tbody></table><p>在5.7版本，MySQL的默认连接数是151个，我们最大可以修改为16384个 （214）。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> [<span class="keyword">global</span> <span class="operator">|</span> session] max_connections <span class="operator">=</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-3-通信协议"><a href="#1-3-通信协议" class="headerlink" title="1.3 通信协议"></a>1.3 通信协议</h3><p>​</p><ol><li>编程语言的连接模块都是用 TCP 协议连接到 MySQL 服务器的，比如mysql-connector-java-x.x.xx.jar。</li><li>类unix系统上，支持 Socket套接字文件进行进程间通信。<code>/tmp/mysql.sock</code></li><li>windows系统上还支持命名管道和共享内存。</li></ol><p>​</p><h3 id="1-4-通信方式"><a href="#1-4-通信方式" class="headerlink" title="1.4 通信方式"></a>1.4 通信方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641431698698-e3b38143-26dc-439d-8a75-feff85dbc973.png" alt="image.png"><br>MySQL使用了半双工通信，所以客户端发送SQL语句给服务端的时候，不管SQL有多大，都是一次发过去的。<br>​</p><blockquote><p>比如我们用MyBatis动态SQL生成了一个批量插入的语句，插入10万条数据，values后面跟了一长串的内容，或者 where 条件 in 里面的值太多，会出现问题。这个时候我们必须要调整 MySQL 服务器配置 max_allowed_packet 参数的值（默认是 4M），把它调大，否则就会报错。</p></blockquote><p>对于服务端来说，也是一次性发送所有的数据，不能因为你已经取到了想要的数据就中断操作，这个时候会对网络和内存产生大量消耗。在程序里面避免不带 limit 的这种操作，比如一次把所有满足条件的数据全部查出来，一定要先 count 一下。如果数据量的话，可以分批查询。</p><hr><h2 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h2><p>MySQL 的缓存默认是关闭的。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL不推荐使用自带的缓存，命中条件过于苛刻。且表里数据发生变化，整张表的缓存全部失效，MySQL8移除掉了缓存。</p><hr><h2 id="3-语法解析-amp-预处理"><a href="#3-语法解析-amp-预处理" class="headerlink" title="3.语法解析&amp;预处理"></a>3.语法解析&amp;预处理</h2><h3 id="3-1-词法解析"><a href="#3-1-词法解析" class="headerlink" title="3.1 词法解析"></a>3.1 词法解析</h3><p>词法分析就是把一个完整的 SQL 语句打碎成一个个的单词。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>它会打碎成 8 个符号，每个符号是什么类型，从哪里开始到哪里结束。<br>​</p><h3 id="3-2-语法解析"><a href="#3-2-语法解析" class="headerlink" title="3.2 语法解析"></a>3.2 语法解析</h3><p>语法分析会对 SQL 做一些语法检查，比如单引号有没有闭合，然后根据 MySQL 定义的语法规则，根据 SQL 语句生成一个数据结构。这个数据结构我们把它叫做解析树（select_lex）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641432113376-2499bc3f-6277-49aa-8a99-eb135ce35507.png" alt="image.png"></p><blockquote><p>任何数据库的中间件，比如 Mycat，Sharding-JDBC（用到了 Druid Parser），都必须要有词法和语法分析功能。</p></blockquote><h3 id="3-3-预处理"><a href="#3-3-预处理" class="headerlink" title="3.3 预处理"></a>3.3 预处理</h3><p>​</p><p>如果写了一个词法和语法都正确的 SQL，但是表名或者字段不存在，会在哪里报错？是在数据库的执行层还是解析器？<br>​</p><p>实际上还是在解析的时候报错，解析 SQL 的环节里面有个预处理器。它会检查生成的解析树，解决解析器无法解析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理之后得到一个新的解析树。<br>​</p><hr><h2 id="4-查询优化-amp-查询执行计划"><a href="#4-查询优化-amp-查询执行计划" class="headerlink" title="4.查询优化&amp;查询执行计划"></a>4.查询优化&amp;查询执行计划</h2><p>一条SQL语句的执行方式有很多种，但是最终返回的结果都是相同的。查询优化器的目的就是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，那种执行计划开销最小，就用哪种。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看查询的开销</span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-优化器的作用"><a href="#4-1-优化器的作用" class="headerlink" title="4.1 优化器的作用"></a>4.1 优化器的作用</h3><ol><li>多表联查，以哪张表为基准表</li><li>用不用索引，用哪个索引</li><li>。。。。</li></ol><p>​</p><h3 id="4-2-优化器是怎么得到执行计划的"><a href="#4-2-优化器是怎么得到执行计划的" class="headerlink" title="4.2 优化器是怎么得到执行计划的"></a>4.2 优化器是怎么得到执行计划的</h3><ol><li>首先我们要启用优化器的追踪（默认是关闭的）。</li></ol><blockquote><p>开启这开关是会消耗性能的，因为它要把优化分析的结果写到表里面，所以不要轻易开启，或者查看完之后关闭它（改成 off）。</p></blockquote><ol start="2"><li>接着执行一个 SQL 语句，优化器会生成执行计划：</li></ol><ol start="3"><li>这个时候优化器分析的过程已经记录到系统表里面了，我们可以查询：</li></ol><blockquote><p>它是一个 JSON 类型的数据，主要分成三部分，准备阶段、优化阶段和执行阶段。</p></blockquote><blockquote><p>expanded_query 是优化后的 SQL 语句。</p></blockquote><blockquote><p>considered_execution_plans 里面列出了所有的执行计划。</p></blockquote><ol start="4"><li>分析完记得关掉它</li></ol><blockquote><p>通过追踪优化器，可以看到优化器对sql的初始优化，表的读取顺序，为什么采用了这种读取顺序。为什么采用了某个索引或者采用了全表查询。</p></blockquote><h3 id="4-3-优化器得到的结果"><a href="#4-3-优化器得到的结果" class="headerlink" title="4.3 优化器得到的结果"></a>4.3 优化器得到的结果</h3><p>​</p><p>优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。</p><p>当然，这个执行计划是不是一定是最优的执行计划呢？不一定，因为 MySQL 也有可能覆盖不到所有的执行计划。<br>​</p><p>MySQL 提供了一个执行计划的工具。我们在 SQL 语句前面加上 EXPLAIN，就可以看到执行计划的信息。<br>​</p><p><strong>Explain 的结果也不一定最终执行的方式。</strong><br><strong>​</strong></p><h3 id="4-4-选错索引"><a href="#4-4-选错索引" class="headerlink" title="4.4 选错索引"></a>4.4 选错索引</h3><p>这里错误决定分两类，第一，彻底错误。第二，基于成本最低，但执行速度不是最快。</p><ol><li><p>由于InnoDB的 MVCC 功能和随机采样方式，默认随机采取几个数据页，当做总体数据。以部分代表整体，本来就有错误的风险。加上数据不断地添加过程中，索引树可能会分裂，结果更加不准确。 </p><blockquote><ol><li>执行 ANALYZE TABLE ,可以重新构建索引，使索引树不过于分裂。</li><li>调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。</li></ol></blockquote></li><li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。 </p><blockquote><ol><li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li><li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。 </li></ol></blockquote></li></ol><hr><h2 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5. 存储引擎"></a>5. 存储引擎</h2><p>得到执行计划以后，SQL 语句是不是终于可以执行了？</p><ol><li>从逻辑的角度来说，我们的数据是放在哪里的，或者说放在一个什么结构里面？</li></ol><ol start="2"><li>执行计划在哪里执行？是谁去执行？</li></ol><p>表在存储数据的同时，还要组织数据的存储结构，这个存储结构就是由存储引擎决定的，所以也可以把存储引擎叫做表类型。</p><p>在 MySQL 里面，支持多种存储引擎，他们是可以替换的，所以叫做插件式的存储引擎。<br>​</p><h3 id="5-1-查看存储引擎"><a href="#5-1-查看存储引擎" class="headerlink" title="5.1 查看存储引擎"></a>5.1 查看存储引擎</h3><p>我们数据库里面已经存在的表，我们怎么查看它们的存储引擎呢？<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> `数据库名`;</span><br></pre></td></tr></table></figure><p>或者通过 DDL 建表语句来查看。<br>​</p><p>在 MySQL 里面，我们创建的每一张表都可以指定它的存储引擎，而不是一个数据库只能使用一个存储引擎。存储引擎的使用是以表为单位的。而且，创建表之后还可以修改存储引擎。<br>​</p><p>一张表使用的存储引擎决定存储数据的结构，那在服务器上它们是怎么存储的呢？先要找到数据库存放数据的路径：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434256832-de450340-7be5-41be-845e-61c79f6b4f82.png" alt="image.png"><br>默认情况下，每个数据库有一个自己文件夹，以 yhd数据库为例。任何一个存储引擎都有一个 frm 文件，这个是表结构定义文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434747584-0e54ae84-325f-48ba-9586-59d5b480aa92.png" alt="image.png"><br>不同的存储引擎存放数据的方式不一样，产生的文件也不一样，innodb 是 1 个，memory 没有，myisam 是两个。</p><h3 id="5-2-存储引擎比较"><a href="#5-2-存储引擎比较" class="headerlink" title="5.2 存储引擎比较"></a>5.2 存储引擎比较</h3><h4 id="①常见存储引擎"><a href="#①常见存储引擎" class="headerlink" title="①常见存储引擎"></a>①常见存储引擎</h4><p>MyISAM 和 InnoDB 是我们用得最多的两个存储引擎，在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，它是 MySQL 自带的。</p><p>5.5 版本之后默认的存储引擎改成了 InnoDB，最主要的原因还是 InnoDB 支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。</p><h4 id="②数据库支持的存储引擎"><a href="#②数据库支持的存储引擎" class="headerlink" title="②数据库支持的存储引擎"></a>②数据库支持的存储引擎</h4><p>可以用这个命令查看数据库对存储引擎的支持情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines ;</span><br></pre></td></tr></table></figure><p>其中有存储引擎的描述和对事务、XA 协议和 Savepoints 的支持。</p><p>XA 协议用来实现分布式事务（分为本地资源管理器，事务管理器）。</p><p>Savepoints 用来实现子事务（嵌套事务）。创建了一个 Savepoints 之后，事务就可以回滚到这个点，不会影响到创建 Savepoints 之前的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641435383199-5ae5e040-4df5-4a35-94ba-e8e13b19fe54.png" alt="image.png"></p><h4 id="③MyISAM（3-个文件）"><a href="#③MyISAM（3-个文件）" class="headerlink" title="③MyISAM（3  个文件）"></a>③MyISAM（3  个文件）</h4><p>应用范围比较小。表级锁定限制了读/写的性能，因此在 Web 和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p><strong>特点</strong></p><ol><li>支持表级别的锁（插入和更新会锁表）。不支持事务。</li></ol><ol start="2"><li>拥有较高的插入（insert）和查询（select）速度。</li></ol><ol start="3"><li>存储了表的行数（count 速度更快）。</li></ol><p>适合：只读之类的数据分析的项目。</p><h4 id="④InnoDB（2个文件）"><a href="#④InnoDB（2个文件）" class="headerlink" title="④InnoDB（2个文件）"></a>④InnoDB（2个文件）</h4><p>mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全（与 ACID 兼容）的 MySQL存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB 行级锁（不升级为更粗粒度的锁）和 Oracle 风格的一致非锁读提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中，以减少基于主键的常见查询的 I/O。为了保持数据完整性，InnoDB 还支持外键引用完整性约束。</p><p><strong>特点</strong></p><ol><li>支持事务，支持外键，因此数据的完整性、一致性更高。</li></ol><ol start="2"><li>支持行级别的锁和表级别的锁。</li></ol><ol start="3"><li>支持读写并发，写不阻塞读（MVCC）。</li></ol><ol start="4"><li>特殊的索引存放方式，可以减少 IO，提升查询效率。</li></ol><p>适合：经常更新的表，存在并发读写或者有事务处理的业务系统。</p><h4 id="⑤Memory-1个文件"><a href="#⑤Memory-1个文件" class="headerlink" title="⑤Memory(1个文件)"></a>⑤Memory(1个文件)</h4><p>基于内存的存储引擎。</p><p>特征：</p><ul><li>基于内存的表，服务器重启后，表结构会被保留，但表中的数据会被清空。</li><li>不需要进行磁盘IO，比 MYISAM 快了一个数量级。</li><li>表级锁，故并发插入性能较低。</li><li>每一行是固定的，VARCHAR 列在 memory 存储引擎中会变成 CHAR，可能导致内存浪费。</li><li>不支持 BLOB 或 TEXT 列，如果sql返回的结果列中包含 BLOB 或 TEXT，就直接采用 MYISAM 存储引擎，在磁盘上建临时表</li><li>支持哈希索引，B+树索引</li></ul><p>MEMORY 存储引擎在很多地方可以发挥很好的作用：</p><ul><li>用于查找或映射表，例如邮编和州名的映射表</li><li>用于缓存周期性聚合数据的结果</li><li>用于保存数据分析中产生的中间结果。即SQL执行过程中用到的临时表</li><li>监控MySQL内存中的执行情况，例如：information_schema 库下的表基本都是 memory 存储引擎，监控InnoDB缓冲池中page(INNODB_BUFFER_PAGE表)，InnoDB缓冲池状态(INNODB_BUFFER_POOL_STATS表)、InnoDB缓存页淘汰记录(INNODB_BUFFER_PAGE_LRU表)、InnoDB锁等待(INNODB_LOCK_WAITS表)、InnoDB锁信息(INNODB_LOCKS表)、InnoDB中正在执行的事务(INNODB_TRX表)等。</li></ul><p><strong>MEMORY 存储引擎默认 hash 索引，故等值查询特别快。同时也支持B+树索引。虽然查询速度特别快，但依旧无法取代传统的磁盘建表。</strong></p><h4 id="⑥CSV-3个文件"><a href="#⑥CSV-3个文件" class="headerlink" title="⑥CSV(3个文件)"></a>⑥CSV(3个文件)</h4><p>它的表实际上是带有逗号分隔值的文本文件。csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据。因为 csv 表没有索引，所以通常在正常操作期间将数据保存在 innodb 表中，并且只在导入或导出阶段使用 csv 表。</p><p><strong>特点</strong></p><p>不允许空行，不支持索引。格式通用，可以直接编辑，适合在不同数据库之间导入导出。<br>​</p><h3 id="5-3-如何选择存储引擎"><a href="#5-3-如何选择存储引擎" class="headerlink" title="5.3 如何选择存储引擎"></a>5.3 如何选择存储引擎</h3><ol><li>如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。</li></ol><ol start="2"><li>如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。</li></ol><ol start="3"><li>如果需要一个用于查询的临时表，可以选择 Memory。</li></ol><p>​</p><hr><h2 id="6-执行引擎"><a href="#6-执行引擎" class="headerlink" title="6.执行引擎"></a>6.执行引擎</h2><p>执行引擎，它利用存储引擎提供的相应的 API 来完成操作。</p><p>为什么我们修改了表的存储引擎，操作方式不需要做任何改变？因为不同功能的存储引擎实现的 API 是相同的。</p><p>最后把数据返回给客户端，即使没有结果也要返回。<br>​</p><hr><h1 id="二，一条SQL的更新流程"><a href="#二，一条SQL的更新流程" class="headerlink" title="二，一条SQL的更新流程"></a>二，一条SQL的更新流程</h1><p>更新和查询很多地方并没有区别，仅仅在于拿到数据之后的操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641458151710-45fe3a24-a127-401d-abec-75f52f953f3d.png" alt="image.png"></p><h2 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1.内存结构"></a>1.内存结构</h2><p>InnnoDB 的数据都是放在磁盘上的，InnoDB 操作数据有一个最小的逻辑单位，叫做页（索引页和数据页）。我们对于数据的操作，不是每次都直接操作磁盘，因为磁盘的速度太慢了。InnoDB 使用了一种缓冲池的技术，也就是把磁盘读到的页放到一块内存区域里面。这个内存区域就叫 Buffer Pool。<br>​</p><p>下一次读取相同的页，先判断是不是在缓冲池里面，如果是，就直接读取，不用再次访问磁盘。</p><p>修改数据的时候，先修改缓冲池里面的页。内存的数据页和磁盘数据不一致的时候，我们把它叫做脏页。InnoDB 里面有专门的后台线程把 Buffer Pool 的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p><p>Buffer Pool 是 InnoDB 里面非常重要的一个结构，主要分为 3 个部分： Buffer Pool、Change Buffer、Adaptive HashIndex，另外还有一个（redo）log buffer。<br>​</p><h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>Buffer Pool 缓存的是页信息，包括数据页、索引页，默认大小是 128M（134217728 字节），可以调整。</p><p>查看服务器状态，里面有很多跟 Buffer Pool 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>查看参数（系统变量）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES like &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>内存的缓冲池写满了怎么办？（Redis 设置的内存满了怎么办？）InnoDB 用 LRU算法来管理缓冲池（链表实现，不是传统的 LRU，分成了 young 和 old），经过淘汰的数据就是热点数据。</p><p>内存缓冲区对于提升读写性能有很大的作用。当需要更新一个数据页时，如果数据页在 Buffer Pool 中存在，那么就直接更新好了。否则的话就需要从磁盘加载到内存，再对内存的数据页进行操作。也就是说，如果没有命中缓冲池，至少要产生一次磁盘 IO。<br>​</p><h3 id="1-2-ChangeBuffer写缓冲"><a href="#1-2-ChangeBuffer写缓冲" class="headerlink" title="1.2 ChangeBuffer写缓冲"></a>1.2 ChangeBuffer写缓冲</h3><p>如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓冲池中，从而提升更新语句（Insert、Delete、Update）的执行速度。</p><p>这一块区域就是 Change Buffer。5.5 之前叫 Insert Buffer 插入缓冲，现在也能支持 delete 和 update。</p><p>最后把 Change Buffer 记录到数据页的操作叫做 merge。什么时候发生 merge？有几种情况：在访问这个数据页的时候，或者通过后台线程、或者数据库 shut down、redo log 写满时触发。</p><p>如果数据库大部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以使用 Change Buffer（写缓冲）。写多读少的业务，调大这个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_change_buffer_max_size&#x27;;</span><br></pre></td></tr></table></figure><p>代表 Change Buffer 占 Buffer Pool 的比例，默认 25%。<br>​</p><h3 id="1-3-Adaptive-Hash-Index"><a href="#1-3-Adaptive-Hash-Index" class="headerlink" title="1.3 Adaptive Hash Index"></a>1.3 Adaptive Hash Index</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？</p><p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p><p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。<br>​</p><h3 id="1-4-（redo）Log-Buffer"><a href="#1-4-（redo）Log-Buffer" class="headerlink" title="1.4 （redo）Log Buffer"></a>1.4 （redo）Log Buffer</h3><p>​</p><p>如果 Buffer Pool 里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据丢失。如果写操作写到一半，甚至可能会破坏数据文件导致数据库不可用。为了避免这个问题，InnoDB 把所有对页面的修改操作专门写入一个日志文件，并且在数据库启动时从这个文件进行恢复操作（实现 crash-safe）——用它来实现事务的持久性。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478367975-c4e017fe-92ed-440a-8fb3-3efc4c310546.png" alt="image.png"><br>这个文件就是磁盘的 redo log（叫做重做日志），对应于/var/lib/mysql/目录下的ib_logfile0 和 ib_logfile1，每个 48M。这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里 的 WAL 技 术（Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log%&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认 48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为 2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir 路径。</td></tr></tbody></table><p><strong>同样是写磁盘，为什么不直接写到 db file 里面去？为什么先写日志再写磁盘？</strong></p><p>磁盘的最小组成单元是扇区，通常是 512 个字节。操作系统和内存打交道，最小的单位是页 Page。操作系统和磁盘打交道，读写磁盘，最小的单位是块 Block。<br>​</p><p>如果我们所需要的数据是随机分散在不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们所需要的一块数据，依次进行此过程直到找完所有数据，这个就是随机 IO，读取数据速度较慢。</p><p>假设我们已经找到了第一块数据，并且其他所需的数据就在这一块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序 IO。</p><p>刷盘是随机 I/O，而记录日志是顺序 I/O，顺序 I/O 效率更高。因此先把修改写入日志，可以延迟刷盘时机，进而提升系统吞吐。</p><p>当然 redo log 也不是每一次都直接写入磁盘，在 Buffer Pool 里面有一块内存区域（Log Buffer）专门用来保存即将要写入日志文件的数据，默认 16M，它一样可以节省磁盘 IO。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478572344-fc83dc25-3a96-42fd-8017-03423f4d9f49.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>redo log 的内容主要是用于崩溃恢复。磁盘的数据文件，数据来自 buffer pool。redo log 写入磁盘，不是写入数据文件。</p></blockquote><p>那么，Log Buffer 什么时候写入 log file？</p><p>在我们写入数据到磁盘的时候，操作系统本身是有缓存的。flush 就是把操作系统缓冲区写入到磁盘。</p><p>log buffer 写入磁盘的时机，由一个参数控制，默认是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_flush_log_at_trx_commit&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>log buffer 将每秒一次地写入 log file 中，并且 log file 的 flush 操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。</td></tr><tr><td>1（默认，实时写，实时刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，并且刷到磁盘中去。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file。但是 flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次 flush 操作。</td></tr></tbody></table><p>redo log，它又分成内存和磁盘两部分。redo log 有什么特点？</p><ol><li>redo log 是 InnoDB 存储引擎实现的，并不是所有存储引擎都有。</li></ol><ol start="2"><li>不是记录数据页更新之后的状态，而是记录这个页做了什么改动，属于物理日志。（redo log 记录的是执行的结果）</li></ol><ol start="3"><li>redo log 的大小是固定的，前面的内容会被覆盖。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478994184-25e740bb-80a0-48fe-9327-bc4bb7da7192.png" alt="image.png"><br>check point 是当前要覆盖的位置。如果 write pos 跟 check point 重叠，说明 redolog 已经写满，这时候需要同步 redo log 到磁盘中。</p><p>这是 MySQL 的内存结构，总结一下，分为：Buffer pool、change buffer、Adaptive Hash Index、 log buffer。</p><blockquote><p>磁盘结构里面主要是各种各样的表空间，叫做 Table space。</p></blockquote><h3 id="1-5-缓存的疑问"><a href="#1-5-缓存的疑问" class="headerlink" title="1.5 缓存的疑问"></a>1.5 缓存的疑问</h3><p><strong>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</strong></p><p>然后，InnoDB架构中，有非常重要的一个部分——<strong>缓冲池</strong>。该缓冲池需要占用服务器内存，且<strong>专用于MySQL的服务器，建议把80%的内存交给MySQL。</strong></p><p>缓冲池有一个缓存的功能。这个缓存，是InnoDB自带的，而且经常会用到。该缓存功能并不是MySQL架构中的缓存组件。这是两者最大的区别。</p><ul><li>MySQL组件中的缓存 <ol><li>所处位置：MySQL架构中的缓存组件</li><li>缓存内容：缓存的是SQL 和 该SQL的查询结果。如果SQL的大小写，格式，注释不一致，则被认为是不同的SQL，重新查询数据库，并缓存一份数据。</li><li>可否关闭：是可以手动关闭，并卸载该组件的。</li></ol></li><li>InnoDB中的缓存 <ol><li>所处位置：InnoDB架构中的缓冲池</li><li>缓存内容：缓存的是所有需要查找的数据，所在的数据页。</li><li>可否关闭：是InnoDB缓冲池自带的功能，<strong>无法关闭，无法卸载</strong>。如果InnoDB的缓冲池被关闭或卸载，则InnoDB直接瘫痪。所以说缓冲池是InnoDB的最重要的一部分。</li></ol></li></ul><p>不建议使用MySQL的缓存是指，不建议使用MySQL架构中的缓存组件，并不是同时否定了InnoDB中的缓存功能。<br>​</p><hr><h2 id="2-磁盘结构"><a href="#2-磁盘结构" class="headerlink" title="2.磁盘结构"></a>2.磁盘结构</h2><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB 的表空间分为 5 大类。<br>​</p><h3 id="2-1-系统表空间"><a href="#2-1-系统表空间" class="headerlink" title="2.1 系统表空间"></a>2.1 系统表空间</h3><p>在默认情况下 InnoDB 存储引擎有一个共享表空间（对应文件/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>InnoDB 系统表空间包含 InnoDB 数据字典和双写缓冲区，（Change Buffer 和 UndoLogs），如果没有指定 file-per-table，也包含用户创建的表和索引数据。</p><ol><li>undo 在后面介绍，因为有独立的表空间。</li></ol><ol start="2"><li>数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）。</li></ol><ol start="3"><li>双写缓冲（InnoDB 的一大特性）</li></ol><p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641479261038-52879c45-835e-4fae-abcd-1ca4ac1f9c66.png" alt="image.png"></p><p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_doublewrite&#x27;;</span><br></pre></td></tr></table></figure><p>如果这个页本身已经损坏了，用它来做崩溃恢复是没有意义的。所以在对于应用 redo log 之前，需要一个页的副本。如果出现了写入失效，就用页的副本来还原这个页，然后再应用 redo log。这个页的副本就是 double write，InnoDB 的双写技术。通过它实现了数据页的可靠性。</p><p>跟 redo log 一样，double write 由两部分组成，一部分是内存的 double write，一个部分是磁盘上的 double write。因为 double write 是顺序写入的，不会带来很大的开销。</p><p>在MySQL5.7之前，所有的表共享一个系统表空间，这个文件会越来越大，而且它的空间不会收缩。<br>​</p><h3 id="2-2-独占表空间"><a href="#2-2-独占表空间" class="headerlink" title="2.2 独占表空间"></a>2.2 独占表空间</h3><p>我们可以让每张表独占一个表空间。这个开关通过 innodb_file_per_table 设置，默认开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure><p>开启后，则每张表会开辟一个表空间，这个文件就是数据目录下的 ibd 文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间内。<br>​</p><h3 id="2-3-通用表空间"><a href="#2-3-通用表空间" class="headerlink" title="2.3 通用表空间"></a>2.3 通用表空间</h3><p>通用表空间也是一种共享的表空间，跟 ibdata1 类似。</p><p>可以创建一个通用的表空间，用来存储不同数据库的表，数据路径和文件可以自定义。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace ts2673 add datafile &#x27;/var/lib/mysql/ts2673.ibd&#x27; file_block_size=16K engine=innodb;</span><br></pre></td></tr></table></figure><p>在创建表的时候可以指定表空间，用 ALTER 修改表空间可以转移表空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2673(id integer) tablespace ts2673;</span><br></pre></td></tr></table></figure><p>不同表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table t2673;</span><br><span class="line">drop tablespace ts2673;</span><br></pre></td></tr></table></figure><h3 id="2-4-临时表空间"><a href="#2-4-临时表空间" class="headerlink" title="2.4 临时表空间"></a>2.4 临时表空间</h3><p>存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的 ibtmp1 文件。当数据服务器正常关闭时，该表空间被删除，下次重新产生。</p><p><strong>memory向template的过渡，还有磁盘上简历临时表用的什么存储引擎？</strong></p><p>8.0之前，内存临时表用Memory引擎创建，但假如字段中有BLOB或TEXT,或结果太大，就会转用MYISM在磁盘上建表，8.0之后内存临时表由MEMORY引擎更改为TempTable引擎，相比于前者，后者支持以变长方式存储VARCHAR，VARBINARY等变长字段。从MySQL 8.0.13开始，TempTable引擎支持BLOB字段。如果超过内存表大小，则用InnoDB建表。</p><h3 id="2-5-redo-log"><a href="#2-5-redo-log" class="headerlink" title="2.5 redo log"></a>2.5 redo log</h3><h3 id="2-6-undo-log-表空间"><a href="#2-6-undo-log-表空间" class="headerlink" title="2.6 undo log 表空间"></a>2.6 undo log 表空间</h3><p>undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态（不包括 select）。</p><p>如果修改数据时出现异常，可以用 undo log 来实现回滚操作（保持原子性）。</p><p>在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，属于逻辑格式的日志(记录操作)。</p><p>redo Log 和 undo Log 与事务密切相关，统称为事务日志。</p><p>undo Log 的数据默认在系统表空间 ibdata1 文件中，因为共享表空间不会自动收缩，也可以单独创建一个 undo 表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%undo%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-7-一条SQL的更新流程"><a href="#2-7-一条SQL的更新流程" class="headerlink" title="2.7 一条SQL的更新流程"></a>2.7 一条SQL的更新流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>事务开始，从内存或者磁盘取到这条数据，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>记录name = 二十 到redo log</li><li>调用存储引擎接口，在buffer pool 中修改 name =二十</li><li>事务提交</li></ol><p>​</p><blockquote><p>内存和磁盘之间，工作着很多后台线程。</p></blockquote><hr><h2 id="3-后台线程"><a href="#3-后台线程" class="headerlink" title="3.后台线程"></a>3.后台线程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641480352645-ff2557dd-b622-49e2-829c-d058bbe6d559.png" alt="image.png"><br>后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master线程，IO 线程，purge 线程，page cleaner 线程。<br>​</p><h3 id="3-1-Master-线程"><a href="#3-1-Master-线程" class="headerlink" title="3.1 Master 线程"></a>3.1 Master 线程</h3><p>Master Thread是InnoDB存储引擎非常核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。<br>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    thread_sleep(<span class="number">1</span>);<span class="comment">// sleep 1秒</span></span><br><span class="line">        <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">        <span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">        <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">          <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct(默认是75时)</span></span><br><span class="line">            <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;<span class="comment">// 刷新100脏页到磁盘</span></span><br><span class="line">        <span class="keyword">if</span>(no user activity)</span><br><span class="line">            <span class="keyword">goto</span> backgroud loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>) <span class="comment">// 如果过去10内磁盘IO次数小于设置的innodb_io_capacity的值（默认是200）</span></span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer; <span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">    <span class="keyword">do</span> full purge;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; <span class="number">70</span>%)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer pool flush <span class="number">10</span> dirty page;</span><br><span class="line"></span><br><span class="line">    backgroud loop：<span class="comment">// 后台循环</span></span><br><span class="line">    <span class="keyword">do</span> full purge<span class="comment">// 删除无用的undo页 （总是）</span></span><br><span class="line">    <span class="keyword">do</span> merge <span class="number">20</span> insert buffer;<span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idle<span class="comment">// 如果不空闲，就跳回主循环，如果空闲就跳入flush loop</span></span><br><span class="line">        <span class="keyword">goto</span> loop:<span class="comment">// 跳到主循环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop</span><br><span class="line"></span><br><span class="line">    flush loop:<span class="comment">// 刷新循环</span></span><br><span class="line">    <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">    <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct的值（默认75%）</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop;<span class="comment">// 跳到刷新循环，不断刷新脏页，直到符合条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> suspend loop;<span class="comment">// 完成刷新脏页的任务后，跳入suspend loop</span></span><br><span class="line"></span><br><span class="line">    suspend loop:</span><br><span class="line">    suspend_thread();<span class="comment">//master线程挂起，等待事件发生</span></span><br><span class="line">    waiting event;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master Thread具有<strong>最高的线程优先级别</strong>。内部由多个循环组成：<strong>主循环（loop）</strong>、<strong>后台循环</strong>（backgroup loop）、<strong>刷新循环</strong>（flush loop）、<strong>暂停循环</strong>（suspend loop）。Master Thread会<strong>根据数据库运行的状态</strong>在loop、backgroup loop、flush loop和suspend loop中<strong>进行切换</strong>。loop是主循环，大多数的操作都在这个循环中，主要有两大部分的操作——每秒钟的操作和每10秒钟的操作。<br>​</p><h4 id="①每秒钟的操作"><a href="#①每秒钟的操作" class="headerlink" title="①每秒钟的操作"></a>①每秒钟的操作</h4><p>​</p><ol><li>​<strong>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）</strong>；<br>即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这也解释了为什么再大的事务提交的时间也是很短的。 </li><li> <strong>合并插入缓冲（可能）</strong>；<br>合并插入缓冲并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB存储引擎认为当前的IO压力很小，可以执行合并插入缓冲的操作； </li><li> <strong>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</strong>； 刷新100个脏页也不是每秒都会发生的，InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_get_modified_ratio_pct)是否超过了配置文件中 innodb_max_dirty_pages_pct这个参数（默认是75，代表75%），如果超过了这个值，InnoDB存储引擎则认为需要做磁盘同步的操作，将100个脏页写入磁盘中。 </li><li> <strong>如果当前没有用户活动，则切换到background loop(可能)。</strong></li></ol><p><strong>​</strong></p><h4 id="②每十秒的操作"><a href="#②每十秒的操作" class="headerlink" title="②每十秒的操作"></a>②每十秒的操作</h4><ol><li> <strong>刷新100个脏页到磁盘（可能）</strong> InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO能力，因此将100个脏页刷新到磁盘。 </li><li> <strong>合并至多5个插入缓冲（总是）</strong> </li><li> <strong>将日志缓冲刷新到磁盘（总是）</strong> </li><li> <strong>删除无用的Undo页（总是）</strong> </li><li> <strong>刷新100个或者10个脏页到磁盘（总是）</strong> InnoDB存储引擎会执行full purge操作，即删除无用的Undo页。对表进行update，delete这类的操作时，原先的行被标记为删除，但是因为一致性读的关系，需要保留这些行版本的信息。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB存储引擎会立即将其删除。从源代码中可以看出，InnoDB存储引擎在执行full purge 操作时，每次最多尝试回收20个undo页。<br>然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf_get_modified_ratio_pct）,如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%,则只需刷新10%的脏页到磁盘。</li></ol><p>​</p><hr><p>如果当前没有用户活动（数据库空闲）或者数据库关系，就会切换到backgroud loop这个循环。 backgroud loop会执行以下操作：</p><ol><li><strong>删除无用的Undo页（总是）</strong></li><li><strong>合并20个插入缓冲（总是）</strong></li><li><strong>跳回到主循环（总是）</strong></li><li><strong>不断刷新100个页直到符合条件（可能，需要跳转到flush loop中完成）</strong></li></ol><p>如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。<br>​</p><p>1.0.x版本中，InnoDB存储引擎最多只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，那么可能会来不及刷新所有的脏页以及合并插入缓冲。后来，InnoDB存储引擎提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。<br>​</p><p>对于刷新到磁盘的页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p><ol><li>在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%;</li><li>在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity;</li></ol><p>如果用户使用的是SSD类的磁盘，可以将innodb_io_capacity的值调高，直到符合磁盘IO的吞吐量为止；</p><p>另一个问题是参数innodb_max_dirty_pages_pct的默认值，在1.0.x版本之前，该值的默认值是90，意味着脏页占缓冲池的90%。InnoDB存储引擎在每秒刷新缓冲池和flush loop时会判断这个值，如果该值大于innodb_max_dirty_pages_pct,才会刷新100个脏页，如果有很大的内存，或者数据库服务器的压力很大，这时刷新脏页的速度反而会降低。 后来将innodb_max_dirty_pages_pct的默认值改为了75。这样既可以加快刷新脏页的频率，又能够保证磁盘IO的负载。<br>​</p><p>还有一个新的参数是innodb_adaptive_flushing(自适应地刷新)，该值影响每秒刷新脏页的数量。原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页；大于innodb_max_dirty_pages_pct时，刷新100个脏页。随着innodb_adaptive_flushing参数的引入，InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新脏页最合适的数量。buf_flush_get_desired_flush_rate函数通过判断产生重做日志的速率来决定最合适的刷新脏页数量。</p><p>之前每次进行full purge 操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size,该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改。<br>​</p><p>1.2.x版本中再次对Master Thread进行了优化，对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。<br><strong>​</strong></p><h3 id="3-2-IO-线程"><a href="#3-2-IO-线程" class="headerlink" title="3.2 IO 线程"></a>3.2 IO 线程</h3><p>InnoDB中大量使用<strong>AIO (Async IO)</strong> 来处理IO请求。IO Thread的作用，是负责这些 IO 请求的回调（call back）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641481073193-6d2bbd4e-ffaa-49b5-9c2e-c591b8690872." alt="image.png"></p><h3 id="3-3-Purge-线程"><a href="#3-3-Purge-线程" class="headerlink" title="3.3 Purge 线程"></a>3.3 Purge 线程</h3><p>事务被提交后，其所使用的undo log可能不在需要。因此，需要purge thread来回收已经使用并分配的undo页。以前Master Thread来完成释放undo log，InnoDB1.1独立出来，分担主线程压力。<br>​</p><h3 id="3-4-Page-Cleaner-线程"><a href="#3-4-Page-Cleaner-线程" class="headerlink" title="3.4 Page Cleaner 线程"></a>3.4 Page Cleaner 线程</h3><p><strong>​</strong></p><p>负责将脏页刷新到磁盘。以前Master Thread来刷新脏页，InnoDB1.2独立出来，分担主线程压力。<br>​</p><blockquote><p>除了 InnoDB 架构中的日志文件，MySQL 的 Server 层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p></blockquote><hr><h2 id="4-binlog"><a href="#4-binlog" class="headerlink" title="4.binlog"></a>4.binlog</h2><p>binlog 以事件的形式记录了所有的DDL 和DML 语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不一样，它的文件内容是可以追加的，没有固定大小限制。在开启了 binlog 功能的情况下，我们可以把 binlog 导出成 SQL 语句，把所有的操作重放一遍，来实现数据的恢复。binlog 的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的 binlog，然后执行一遍。<br>​</p><p>有了这两个日志之后，来看一下一条更新语句是怎么执行的：<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​</p><ol><li>事务开始，从内存或者磁盘取到这条数据所在的数据页，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>在buffer pool 中修改 name =二十，此时该页变成脏页</li><li>记录name = 二十 到redo log buffer，redo log buffer每秒刷盘。</li><li>redo log 进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</li><li>写入binlog</li><li>事务提交，并回写最终状态到redo log里，代表该事务已经提交</li></ol><p>​</p><blockquote><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便不断写入redo log文件中。一般情况下，每次事务commit时，必须调用 fsync 操作，将redo日志缓冲同步写到磁盘。另外，每次事务提交时同步写到磁盘bin log中。</p></blockquote><blockquote><p>那么就有了一个谁先谁后的问题：redo log 先，bin log 后。</p></blockquote><blockquote><p>两阶段提交的内容：**事务提交时，redo log处于 pre状态 -&gt; 写入bin log -&gt; 事务真正提交。 **</p></blockquote><blockquote><p>当发生崩溃恢复时，查看的是bin log是否完整，如果bin log完整，则代表事务已经提交。</p></blockquote><blockquote><p>如果在两阶段提交过程中，bin log写入失败，则事务无法终止提交，崩溃恢复时就不需要重做。如果bin log写完的一瞬间，服务器宕机了，事务都来不及提交，此时bin log并不是完整的，缺少了最终的commit标记。因此也是提交失败。</p></blockquote><blockquote><p>简单说，redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641482848254-19b6e1b2-0fa7-411d-924b-0c6cb48f511f.png" alt="1.png"></p><hr><h1 id="三，MySQL中支持的字符集和排序规则"><a href="#三，MySQL中支持的字符集和排序规则" class="headerlink" title="三，MySQL中支持的字符集和排序规则"></a>三，MySQL中支持的字符集和排序规则</h1><h2 id="1-MySQL中的utf8和utf8mb4"><a href="#1-MySQL中的utf8和utf8mb4" class="headerlink" title="1.MySQL中的utf8和utf8mb4"></a>1.MySQL中的utf8和utf8mb4</h2><p>utf8字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计MySQL的大叔偷偷的定义了两个概念：</p><ul><li>utf8mb3：阉割过的utf8字符集，只使用1～3个字节表示字符。</li><li>utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符。</li></ul><p>在MySQL中utf8是utf8mb3的别名，所以之后在MySQL中提到utf8就意味着使用1~3个字节来表示一个字符，如果有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4。</p><p>查看字符集：<code>SHOW (CHARACTER SET|CHARSET)</code>。</p><h2 id="2-字符集-amp-比较规则的应用"><a href="#2-字符集-amp-比较规则的应用" class="headerlink" title="2.字符集&amp;比较规则的应用"></a>2.字符集&amp;比较规则的应用</h2><h3 id="2-1-各级别的字符集和比较规则"><a href="#2-1-各级别的字符集和比较规则" class="headerlink" title="2.1 各级别的字符集和比较规则"></a>2.1 各级别的字符集和比较规则</h3><p>MySQL有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><p>接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p><h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;</span>;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用SET语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure><p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p><h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>其中的DEFAULT可以省略，并不影响语句的语义。比方说我们新创建一个名叫charset_demo_db的数据库，在创建的时候指定它使用的字符集为gb2312，比较规则为gb2312_chinese_ci：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE charset_demo_db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| character_set_database | gb2312 |</span><br><span class="line">+------------------------+--------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;</span>;</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| Variable_name      | Value             |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| collation_database | gb2312_chinese_ci |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这个charset_demo_db数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 _<strong>collation_database</strong>_ 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p><h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure><p>比方说我们在刚刚创建的charset_demo_db数据库中创建一个名为t的表，并指定这个表的字符集和比较规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">CREATE TABLE <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    -&gt;     col VARCHAR(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.03</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</p><h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>比如我们修改一下表t中列col的字符集和比较规则可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">ALTER TABLE t MODIFY col <span class="title">VARCHAR</span><span class="params">(<span class="number">10</span>)</span> CHARACTER SET gbk COLLATE gbk_chinese_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 0  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。</p><blockquote><p>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。 </p></blockquote><h3 id="2-2-客户端和服务器通信中的字符集"><a href="#2-2-客户端和服务器通信中的字符集" class="headerlink" title="2.2 客户端和服务器通信中的字符集"></a>2.2 客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果"><a href="#编码和解码使用的字符集不一致的后果" class="headerlink" title="编码和解码使用的字符集不一致的后果"></a>编码和解码使用的字符集不一致的后果</h4><p>如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p><h4 id="从发送请求到接收结果过程中发生的字符集转换"><a href="#从发送请求到接收结果过程中发生的字符集转换" class="headerlink" title="从发送请求到接收结果过程中发生的字符集转换"></a>从发送请求到接收结果过程中发生的字符集转换</h4><ul><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用character_set_client代表的字符集进行解码，将解码后的字符串再按照character_set_connection代表的字符集进行编码。</li><li>如果character_set_connection代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639999607440-c7181f59-0354-43bd-b896-d3bd722cadc4.png" alt="image.png"></p><p>在这个过程中各个系统变量的含义如下：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p><p><strong>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"/>
      <url>/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>#1.成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表数组的最大限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发级别：jdk7历史遗留问题，仅仅在初始化的时候使用到，并不是真正的代表并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算扩容时候生成的一个 标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当node节点hash=-1 表示当前节点已经被迁移了  ，fwd节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//node hash=-2 表示当前节点已经树化 且 当前节点为treebin对象  ，代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">//转化成二进制实际上是 31个 1  可以将一个负数通过位移运算得到一个正数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了兼容7版本的chp保存的，核心代码并没有使用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表，长度一定是2次方数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment"> * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment"> * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="comment">/**表示sizeCtl属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="comment">/**表示transferIndex属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">/**表示baseCount属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">/**表示cellsBusy属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">/**表示cellValue属性在CounterCell中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">/**表示数组第一个元素的偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">                TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">                BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">                CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">                <span class="comment">//表示数组单元所占用空间大小,scale 表示Node[]数组中每一个单元所占用空间大小</span></span><br><span class="line">                <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">                <span class="comment">//1 0000 &amp; 0 1111 = 0</span></span><br><span class="line">                <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">                <span class="comment">//numberOfLeadingZeros() 这个方法是返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一块。</span></span><br><span class="line">                <span class="comment">//8 =&gt; 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line">                <span class="comment">//4 =&gt; 100 numberOfLeadingZeros(4) = 29</span></span><br><span class="line">                <span class="comment">//ASHIFT = 31 - 29 = 2 ？？</span></span><br><span class="line">                <span class="comment">//ABASE + （5 &lt;&lt; ASHIFT）</span></span><br><span class="line">                ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>#2.基础方法<br>##2.1 spread<br>高位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.2 tabAt<br>该方法获取对象中offset偏移地址对应的对象field的值。实际上这段代码的含义等价于tab[i],但是为什么不直接使用 tab[i]来计算呢？</p><p>getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happen-before 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见；</p><p>虽然 table 数组本身是增加了 volatile 属性，但是“volatile 的数组只针对数组的引用具有volatile 的语义，而不是它的元素”。 所以如果有其他线程对这个数组的元素进行写操作，那么当前线程来读的时候不一定能读到最新的值。出于性能考虑，Doug Lea 直接通过 Unsafe 类来对 table 进行操作。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/tabAt.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.3 casTabAt<br>cas设置当前节点为桶位的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.4 setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.5 resizeStamp<br>resizeStamp 用来生成一个和扩容有关的扩容戳，具体有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer.numberOfLeadingZeros 这个方法是返回无符号整数 n 最高位非 0 位前面的 0 的个数。</p><p>比如 10 的二进制是 0000 0000 0000 0000 0000 0000 0000 1010，那么这个方法返回的值就是 28。</p><p>根据 resizeStamp 的运算逻辑，我们来推演一下，假如 n=16，那么 resizeStamp(16)=32796转化为二进制是[0000 0000 0000 0000 1000 0000 0001 1100]</p><p>接着再来看,当第一个线程尝试进行扩容的时候，会执行下面这段代码：</p><p><code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code><br>rs 左移 16 位，相当于原本的二进制低位变成了高位 1000 0000 0001 1100 0000 0000 00000000</p><p>然后再+2 =1000 0000 0001 1100 0000 0000 0000 0000+10=1000 0000 0001 1100 0000 00000000 0010</p><p><strong>高 16 位代表扩容的标记、低 16 位代表并行扩容的线程数</strong></p><p>这样来存储有什么好处呢？</p><p>1，首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责</p><p>2，可以保证每次扩容都生成唯一的生成戳，每次新的扩容，都有一个不同的 n，这个生成戳就是根据 n 来计算出来的一个数字，n 不同，这个数字也不同</p><p>第一个线程尝试扩容的时候，为什么是+2</p><p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在低 16 位上加 1。<br>##2.6 tableSizeFor<br>经过多次位移返回大于等于c的最小的二次方数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">     * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">     * 返回&gt;=c的最小的2的次方数</span></span><br><span class="line"><span class="comment">     * c=28</span></span><br><span class="line"><span class="comment">     * n=27 =&gt; 0b 11011</span></span><br><span class="line"><span class="comment">     * 11011 | 01101 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * 11111 | 00111 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * ....</span></span><br><span class="line"><span class="comment">     * =&gt; 11111 + 1 =100000 = 32</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#3. 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果指定的容量超过允许的最大值，设置为最大值</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果初始容量小于并发级别，那就设置初始容量为并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="comment">//16/0.75 +1 = 22</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 22 - &gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#4.put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key已经存在，是否覆盖，默认是false</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#5 putVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 </span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#6 initTable<br>数组初始化方法，这个方法比较简单，就是初始化一个合适大小的数组。</p><p>sizeCtl ：这个标志是在 Node 数组初始化或者扩容的时候的一个控制位标识，负数代表正在进行初始化或者扩容操作。</p><p>-1 代表正在初始化</p><p>-N 代表有 N-1 个线程正在进行扩容操作，这里不是简单的理解成 n 个线程，sizeCtl 就是-N</p><p>0 标识 Node 数组还没有被初始化，正数代表初始化或者下一次扩容的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">     *      * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">     *      * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">     *      * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#7 addCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//as 表示 LongAdder.cells</span></span><br><span class="line">    <span class="comment">//b 表示LongAdder.base</span></span><br><span class="line">    <span class="comment">//s 表示当前map.table中元素的数量</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//条件一：true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">    <span class="comment">//       false-&gt;表示当前线程应该将数据累加到 base</span></span><br><span class="line">    <span class="comment">//条件二：false-&gt;表示写base成功，数据累加到base中了，当前竞争不激烈，不需要创建cells</span></span><br><span class="line">    <span class="comment">//       true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">//有几种情况进入到if块中？</span></span><br><span class="line">        <span class="comment">//1.true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">        <span class="comment">//2.true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a 表示当前线程hash寻址命中的cell</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//v 表示当前线程写cell时的期望值</span></span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//m 表示当前cells数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//true -&gt; 未竞争  false-&gt;发生竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：as == null || (m = as.length - 1) &lt; 0</span></span><br><span class="line">        <span class="comment">//true-&gt; 表示当前线程是通过 写base竞争失败 然后进入的if块，就需要调用fullAddCount方法去扩容 或者 重试.. LongAdder.longAccumulate</span></span><br><span class="line">        <span class="comment">//条件二：a = as[ThreadLocalRandom.getProbe() &amp; m]) == null   前置条件：cells已经初始化了</span></span><br><span class="line">        <span class="comment">//true-&gt;表示当前线程命中的cell表格是个空，需要当前线程进入fullAddCount方法去初始化 cell，放入当前位置.</span></span><br><span class="line">        <span class="comment">//条件三：!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)</span></span><br><span class="line">        <span class="comment">//      false-&gt;取反得到false，表示当前线程使用cas方式更新当前命中的cell成功</span></span><br><span class="line">        <span class="comment">//      true-&gt;取反得到true,表示当前线程使用cas方式更新当前命中的cell失败，需要进入fullAddCount进行重试 或者 扩容 cells。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">           ) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">//考虑到fullAddCount里面的事情比较累，就让当前线程 不参与到 扩容相关的逻辑了，直接返回到调用点。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前散列表元素个数，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一定是一个put操作调用的addCount</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//tab 表示map.table</span></span><br><span class="line">        <span class="comment">//nt 表示map.nextTable</span></span><br><span class="line">        <span class="comment">//n 表示map.table数组的长度</span></span><br><span class="line">        <span class="comment">//sc 表示sizeCtl的临时值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">             * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">             * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">             * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//条件一：s &gt;= (long)(sc = sizeCtl)</span></span><br><span class="line">        <span class="comment">//       true-&gt; 1.当前sizeCtl为一个负数 表示正在扩容中..</span></span><br><span class="line">        <span class="comment">//              2.当前sizeCtl是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//       false-&gt; 表示当前table尚未达到扩容条件</span></span><br><span class="line">        <span class="comment">//条件二：(tab = table) != null</span></span><br><span class="line">        <span class="comment">//       恒成立 true</span></span><br><span class="line">        <span class="comment">//条件三：(n = tab.length) &lt; MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//       true-&gt;当前table长度小于最大值限制，则可以进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩容批次唯一标识戳</span></span><br><span class="line">            <span class="comment">//16 -&gt; 32 扩容 标识为：1000 0000 0001 1011</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：表示当前table正在扩容</span></span><br><span class="line">            <span class="comment">//         当前线程理论上应该协助table完成扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">                <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">                <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">                <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">                <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">                <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">                <span class="comment">//条件四：(nt = nextTable) == null</span></span><br><span class="line">                <span class="comment">//        true-&gt;表示本次扩容结束</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容正在进行中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//前置条件：当前table正在执行扩容中.. 当前线程有机会参与进扩容。</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程成功参与到扩容任务中，并且将sc低16位值加1，表示多了一个线程参与工作</span></span><br><span class="line">                <span class="comment">//条件失败：1.当前有很多线程都在此处尝试修改sizeCtl，有其它一个线程修改成功了，导致你的sc期望值与内存中的值不一致 修改失败</span></span><br><span class="line">                <span class="comment">//        2.transfer 任务内部的线程也修改了sizeCtl。</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容线程，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="comment">//条件成立，说明当前线程是触发扩容的第一个线程，在transfer方法需要做一些扩容准备工作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//触发扩容条件的线程 不持有nextTable</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#8. transfer<br>ConcurrentHashMap 支持并发扩容，实现方式是，把 Node 数组进行拆分，让每个线程处理自己的区域，假设 table 数组总长度是 64，默认情况下，那么每个线程可以分到 16 个 bucket。然后每个线程处理的范围，按照倒序来做迁移。</p><p>通过 for 自循环处理每个槽位中的链表元素，默认 advace 为真，通过 CAS 设置 transferIndex属性值，并初始化 i 和 bound 值，i 指当前处理的槽位序号，bound 指需要处理的槽位边界，先处理槽位 31 的节点； （bound,i） =(16,31) 从 31 的位置往前推动。</p><p>每存在一个线程执行完扩容操作，就通过 cas 执行 sc-1。</p><p>接着判断(sc-2) !=resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT ; 如果相等，表示当前为整个扩容操作的 最后一个线程，那么意味着整个扩容操作就结束了；如果不相等，说明还得继续。</p><p>这么做的目的，一方面是防止不同扩容之间出现相同的 sizeCtl，另外一方面，还可以避免sizeCtl 的 ABA 问题导致的扩容重叠的情况。</p><p><strong>扩容图解</strong><br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E6%89%A9%E5%AE%B9%E5%9B%BE%E8%A7%A3.png" alt="img.png"><br>判断是否需要扩容，也就是当更新后的键值对总数 baseCount &gt;= 阈值 sizeCtl 时，进行rehash，这里面会有两个逻辑。</p><ol><li>如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容。</li><li>如果当前没有在扩容，则直接触发扩容操作。</li></ol><p>扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。</p><p>而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。</p><p>它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现。</p><p>fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p><p>advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识。</p><p>finishing:这个变量用于提示扩容是否结束用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示扩容之前table数组的长度</span></span><br><span class="line">    <span class="comment">//stride 表示分配给线程任务的步长</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//  stride 固定为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件成立：表示当前线程为触发本次扩容的线程，需要做一些扩容准备工作</span></span><br><span class="line">    <span class="comment">//条件不成立：表示当前线程是协助扩容的线程..</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了一个比扩容之前大一倍的table</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对象属性 nextTable ，方便协助扩容线程 拿到新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录迁移数据整体位置的一个标记。index计数是从1开始计算的。</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 节点，当某个桶位数据处理完毕后，将此桶位设置为fwd节点，其它写线程 或读线程看到后，会有不同逻辑。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标记</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//完成标记</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">//bound 表示分配给当前线程任务的下界限制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//f 桶位的头结点</span></span><br><span class="line">        <span class="comment">//fh 头结点的hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.给当前线程分配任务区间</span></span><br><span class="line"><span class="comment">             * 2.维护当前线程任务进度（i 表示当前处理的桶位）</span></span><br><span class="line"><span class="comment">             * 3.维护map对象全局范围内的进度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//分配任务的开始下标</span></span><br><span class="line">            <span class="comment">//分配任务的结束下标</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1:</span></span><br><span class="line">            <span class="comment">//条件一：--i &gt;= bound</span></span><br><span class="line">            <span class="comment">//成立：表示当前线程的任务尚未完成，还有相应的区间的桶位要处理，--i 就让当前线程处理下一个 桶位.</span></span><br><span class="line">            <span class="comment">//不成立：表示当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CASE2:</span></span><br><span class="line">            <span class="comment">//前置条件：当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="comment">//条件成立：表示对象全局范围内的桶位都分配完毕了，没有区间可分配了，设置当前线程的i变量为-1 跳出循环后，执行退出迁移任务相关的程序</span></span><br><span class="line">            <span class="comment">//条件不成立：表示对象全局范围内的桶位尚未分配完毕，还有区间可分配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CASE3:</span></span><br><span class="line">            <span class="comment">//前置条件：1、当前线程需要分配任务区间  2.全局范围内还有桶位尚未迁移</span></span><br><span class="line">            <span class="comment">//条件成立：说明给当前线程分配任务成功</span></span><br><span class="line">            <span class="comment">//条件失败：说明分配给当前线程失败，应该是和其它线程发生了竞争吧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：i &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：表示当前线程未分配到任务</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//保存sizeCtl 的变量</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明设置sizeCtl 低16位  -1 成功，当前线程可以正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程不是最后一个退出transfer任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//正常退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置条件：【CASE2~CASE4】 当前线程任务尚未处理完，正在进行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位未存放数据，只需要将此处设置为fwd节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位已经迁移过了，当前线程不用再处理了，直接再次更新当前线程任务索引，再次处理下一个桶位 或者 其它操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//CASE4:</span></span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据，而且node节点 不是 fwd节点，说明这些数据需要迁移。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//sync 加锁当前桶位的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//防止在你加锁头对象之前，当前桶位的头对象被其它写线程修改过，导致你目前加锁对象错误...</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">//hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lastRun</span></span><br><span class="line">                        <span class="comment">//可以获取出 当前链表 末尾连续高位不变的 node</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立：说明lastRun引用的链表为 低位链表，那么就让 ln 指向 低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则，说明lastRun引用的链表为 高位链表，就让 hn 指向 高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是 红黑树 代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转换头结点为 treeBin引用 t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//低位双向链表 lo 指向低位链表的头  loTail 指向低位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位双向链表 lo 指向高位链表的头  loTail 指向高位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lc 表示低位链表元素数量</span></span><br><span class="line">                        <span class="comment">//hc 表示高位链表元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代TreeBin中的双向链表，从头结点 至 尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// h 表示循环处理当前元素的 hash</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//使用当前节点 构建出来的 新的 TreeNode</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件成立：表示当前循环节点 属于低位链 节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//条件成立：说明当前低位链表 还没有数据</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="comment">//说明 低位链表已经有数据了，此时当前元素 追加到 低位链表的末尾就行了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">//将低位链表尾指针指向 p 节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点 属于 高位链 节点</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表迁移原理</p><p>1）高低位原理分析</p><p>ConcurrentHashMap 在做链表迁移时，会用高低位来实现，这里有两个问题要分析一下</p><p>1，如何实现高低位链表的区分</p><p>假如有这样一个队列<br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E8%BF%81%E7%A7%BB%E9%AB%98%E4%BD%8E%E4%BD%8D%E5%8E%9F%E7%90%861.png" alt="img_1.png"><br>第 14 个槽位插入新节点之后，链表元素个数已经达到了 8，且数组长度为 16，优先通过扩容来缓解链表过长的问题</p><p>假如当前线程正在处理槽位为 14 的节点，它是一个链表结构，在代码中，首先定义两个变量节点 ln 和 hn，实际就是 lowNode 和 HighNode，分别保存 hash 值的第 x 位为 0 和不等于0 的节点</p><p>通过 fn&amp;n 可以把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值的第 x 位为不等于 0（至于为什么要这么区分，稍后分析），并且通过 lastRun 记录最后要处理的节点。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 14+16(扩容增加的长度)=30</p><p>把 14 槽位的链表单独伶出来，用蓝色表示 fn&amp;n=0 的节点，假如链表的分类是这样</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/ffb2efa924944e02b25e97a2b90bf6f5.png" alt="111"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b;</span><br><span class="line">        lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码遍历，会记录 runBit 以及 lastRun，按照上面这个结构，那么 runBit 应该是蓝色节点，lastRun 应该是第 6 个节点接着，再通过这段代码进行遍历，生成 ln 链以及 hn 链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/3914c7b94d2843b985ea10e5c23a04b0.png" alt="111"><br>接着，通过 CAS 操作，把 hn 链放在 i+n 也就是 14+16 的位置，ln 链保持原来的位置不动。并且设置当前节点为 fwd，表示已经被当前线程迁移完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>迁移完成以后的数据分布如下</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/e7e01e24e3e844c7b31c4d73da2fffed.png" alt="111"><br>2）为什么要做高低位的划分</p><p>要想了解这么设计的目的，我们需要从 ConcurrentHashMap 的根据下标获取对象的算法来看，在 putVal 方法中 1018 行：</p><p><code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code></p><p>通过(n-1) &amp; hash 来获得在 table 中的数组下标来获取节点数据，【&amp;运算是二进制运算符，1&amp; 1=1，其他都为 0】。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/db389ed8b874494ca1f5a8723e8a6973.png" alt="111"><br>#9.helpTransfer<br>如果对应的节点存在，判断这个节点的 hash 是不是等于 MOVED(-1)，说明当前节点是ForwardingNode 节点，意味着有其他线程正在进行扩容，那么当前现在直接帮助它进行扩容，因此调用 helpTransfer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    <span class="comment">//nextTab 引用的是 fwd.nextTable == map.nextTable 理论上是这样。</span></span><br><span class="line">    <span class="comment">//sc 保存map.sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：tab != null 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件二：(f instanceof ForwardingNode) 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件三：((ForwardingNode&lt;K,V&gt;)f).nextTable) != null 恒成立 true</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿当前标的长度 获取 扩容标识戳   假设 16 -&gt; 32 扩容：1000 0000 0001 1011</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：nextTab == nextTable</span></span><br><span class="line">        <span class="comment">//成立：表示当前扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：1.nextTable被设置为Null 了，扩容完毕后，会被设为Null</span></span><br><span class="line">        <span class="comment">//       2.再次出发扩容了...咱们拿到的nextTab 也已经过期了...</span></span><br><span class="line">        <span class="comment">//条件二：table == tab</span></span><br><span class="line">        <span class="comment">//成立：说明 扩容正在进行中，还未完成</span></span><br><span class="line">        <span class="comment">//不成立：说明扩容已经结束了，扩容结束之后，最后退出的线程 会设置 nextTable 为 table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件三：(sc = sizeCtl) &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：说明扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：说明sizeCtl当前是一个大于0的数，此时代表下次扩容的阈值，当前扩容已经结束。</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">            <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">            <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">            <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">            <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">            <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">            <span class="comment">//条件四：transferIndex &lt;= 0</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明map对象全局范围内的任务已经分配完了，当前线程进去也没活干..</span></span><br><span class="line">            <span class="comment">//      false-&gt;还有任务可以分配。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#10.get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//e 当前元素</span></span><br><span class="line">    <span class="comment">//p 目标节点</span></span><br><span class="line">    <span class="comment">//n table数组长度</span></span><br><span class="line">    <span class="comment">//eh 当前元素hash</span></span><br><span class="line">    <span class="comment">//ek 当前元素key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//扰动运算后得到 更散列的hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：(tab = table) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;表示已经put过数据，并且map内部的table也已经初始化完毕</span></span><br><span class="line">    <span class="comment">//false-&gt;表示创建完map后，并没有put过数据，map内部的table是延迟初始化的，只有第一次写数据时会触发创建逻辑。</span></span><br><span class="line">    <span class="comment">//条件二：(n = tab.length) &gt; 0 true-&gt;表示table已经初始化</span></span><br><span class="line">    <span class="comment">//条件三：(e = tabAt(tab, (n - 1) &amp; h)) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;当前key寻址的桶位 有值</span></span><br><span class="line">    <span class="comment">//false-&gt;当前key寻址的桶位中是null，是null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比头结点hash与查询key的hash是否一致</span></span><br><span class="line">        <span class="comment">//条件成立：说明头结点与查询Key的hash值 完全一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">//完全比对 查询key 和 头结点的key</span></span><br><span class="line">            <span class="comment">//条件成立：说明头结点就是查询数据</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件成立：</span></span><br><span class="line">        <span class="comment">//1.-1  fwd 说明当前table正在扩容，且当前查询的这个桶位的数据 已经被迁移走了</span></span><br><span class="line">        <span class="comment">//2.-2  TreeBin节点，需要使用TreeBin 提供的find 方法查询。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前桶位已经形成链表的这种情况</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#11.remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#12.replaceNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算key经过扰动运算后的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f表示桶位头结点</span></span><br><span class="line">        <span class="comment">//n表示当前table数组长度</span></span><br><span class="line">        <span class="comment">//i表示hash命中桶位下标</span></span><br><span class="line">        <span class="comment">//fh表示桶位头结点 hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：tab == null  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件二：(n = tab.length) == 0  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件三：(f = tabAt(tab, i = (n - 1) &amp; hash)) == null true -&gt; 表示命中桶位中为null，直接break， 会返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2：</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前table正在扩容中，当前是个写操作，所以当前线程需要协助table完成扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//当前桶位 可能是 &quot;链表&quot; 也可能 是  &quot;红黑树&quot; TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保留替换之前的数据引用</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//校验标记</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁当前桶位 头结点，加锁成功之后会进入 代码块。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断sync加锁是否为当前桶位 头节点，防止其它线程，在当前线程加锁成功之前，修改过 桶位 的头结点。</span></span><br><span class="line">                <span class="comment">//条件成立：当前桶位头结点 仍然为f，其它线程没修改过。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//条件成立：说明桶位 为 链表 或者 单个 node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//e 表示当前循环处理元素</span></span><br><span class="line">                        <span class="comment">//pred 表示当前循环节点的上一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="comment">//当前节点key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash true-&gt;说明当前节点的hash与查找节点hash一致</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//if 条件成立，说明key 与查询的key完全一致。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//当前节点的value</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件一：cv == null true-&gt;替换的值为null 那么就是一个删除操作</span></span><br><span class="line">                                <span class="comment">//条件二：cv == ev || (ev != null &amp;&amp; cv.equals(ev))  那么是一个替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">//删除 或者 替换</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//条件成立：说明当前是一个替换操作</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//直接替换</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">//条件成立：说明当前节点非头结点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//当前节点的上一个节点，指向当前节点的下一个节点。</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//说明当前节点即为 头结点，只需要将 桶位设置为头结点的下一个节点。</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：TreeBin节点。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//转换为实际类型 TreeBin t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//r 表示 红黑树 根节点</span></span><br><span class="line">                        <span class="comment">//p 表示 红黑树中查找到对应key 一致的node</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：(r = t.root) != null 理论上是成立</span></span><br><span class="line">                        <span class="comment">//条件二：TreeNode.findTreeNode 以当前节点为入口，向下查找key（包括本身节点）</span></span><br><span class="line">                        <span class="comment">//      true-&gt;说明查找到相应key 对应的node节点。会赋值给p</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//保存p.val 到pv</span></span><br><span class="line">                            V pv = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：cv == null  成立：不必对value，就做替换或者删除操作</span></span><br><span class="line">                            <span class="comment">//条件二：cv == pv ||(pv != null &amp;&amp; cv.equals(pv)) 成立：说明“对比值”与当前p节点的值 一致</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//替换或者删除操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                oldVal = pv;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件成立：替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">//删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">//这里没做判断，直接搞了...很疑惑</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当其他线程修改过桶位 头结点时，当前线程 sync 头结点 锁错对象时，validated 为false，会进入下次for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换的值 为null，说明当前是一次删除操作，oldVal ！=null 成立，说明删除成功，更新当前元素个数计数器。</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#13.TreeBin<br>##13.1 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树 根节点 </span></span><br><span class="line">TreeNode&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//链表的头节点</span></span><br><span class="line"><span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//等待者线程（当前lockState是读锁状态）</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.写锁状态 写是独占状态，以散列表来看，真正进入到TreeBin中的写线程 同一时刻 只有一个线程。 1</span></span><br><span class="line"><span class="comment">         * 2.读锁状态 读锁是共享，同一时刻可以有多个线程 同时进入到 TreeBin对象中获取数据。 每一个线程 都会给 lockStat + 4</span></span><br><span class="line"><span class="comment">         * 3.等待者状态（写线程在等待），当TreeBin中有读线程目前正在读取数据时，写线程无法修改数据，那么就将lockState的最低2位 设置为 0b 10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values for lockState</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p>##13.2 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="comment">//设置节点hash为-2 表示此节点是TreeBin节点</span></span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//使用first 引用 treeNode链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    <span class="comment">//r 红黑树的根节点引用</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x表示遍历的当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//强制设置当前插入节点的左右子树为null</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//条件成立：说明当前红黑树 是一个空树，那么设置插入元素 为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点的父节点 一定为 null</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//颜色改为黑色</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//让r引用x所指向的对象。</span></span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非第一次循环，都会来带else分支，此时红黑树已经有数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//k 表示 插入节点的key</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//h 表示 插入节点的hash</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//kc 表示 插入节点key的class类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//p 表示 为查找插入节点的父节点的一个临时节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//dir (-1, 1)</span></span><br><span class="line">                <span class="comment">//-1 表示插入节点的hash值大于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//1 表示插入节点的hash值 小于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//ph p表示 为查找插入节点的父节点的一个临时节点的hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//临时节点 key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点的hash值 小于 当前节点</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的左子节点 或者 继续在左子树上查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入节点的hash值 大于 当前节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的右子节点 或者 继续在右子树上查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果执行到 CASE3，说明当前插入节点的hash 与 当前节点的hash一致，会在case3 做出最终排序。最终</span></span><br><span class="line">                <span class="comment">//拿到的dir 一定不是0，（-1， 1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//xp 想要表示的是 插入节点的 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//条件成立：说明当前p节点 即为插入节点的父节点</span></span><br><span class="line">                <span class="comment">//条件不成立：说明p节点 底下还有层次，需要将p指向 p的左子节点 或者 右子节点，表示继续向下搜索。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置插入节点的父节点 为 当前节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//小于P节点，需要插入到P节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//大于P节点，需要插入到P节点的右子节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//插入节点后，红黑树性质 可能会被破坏，所以需要调用 平衡方法</span></span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将r 赋值给 TreeBin对象的 root引用。</span></span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.3 putTreeVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前循环节点xp 即为 x 节点的爸爸</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//x 表示插入节点</span></span><br><span class="line">            <span class="comment">//f 老的头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明链表有数据</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//设置老的头结点的前置引用为 当前的头结点。</span></span><br><span class="line">                f.prev = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示 当前新插入节点后，新插入节点 与 父节点 形成 “红红相连”</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//平衡红黑树，使其再次符合规范。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.4 find</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e 表示循环迭代的当前节点   迭代的是first引用的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//s 保存的是lock临时状态</span></span><br><span class="line">            <span class="comment">//ek 链表当前节点 的key</span></span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(WAITER|WRITER) =&gt; 0010 | 0001 =&gt; 0011</span></span><br><span class="line">            <span class="comment">//lockState &amp; 0011 != 0 条件成立：说明当前TreeBin 有等待者线程 或者 目前有写操作线程正在加锁</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前置条件：当前TreeBin中 等待者线程 或者 写线程 都没有</span></span><br><span class="line">            <span class="comment">//条件成立：说明添加读锁成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//查询操作</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//w 表示等待者线程</span></span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">//U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER)</span></span><br><span class="line">                    <span class="comment">//1.当前线程查询红黑树结束，释放当前线程的读锁 就是让 lockstate 值 - 4</span></span><br><span class="line">                    <span class="comment">//(READER|WAITER) = 0110 =&gt; 表示当前只有一个线程在读，且“有一个线程在等待”</span></span><br><span class="line">                    <span class="comment">//当前读线程为 TreeBin中的最后一个读线程。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.(w = waiter) != null 说明有一个写线程在等待读操作全部结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用unpark 让 写线程 恢复运行状态。</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#总结<br>在java8中，ConcurrentHashMap使用数组+链表+红黑树的组合方式，利用cas和synchronized保证并发写的安全。</p><p>引入红黑树的原因：链表查询的时间复杂度为On，但是红黑树的查询时间复杂度为O(log(n)),所以在节点比较多的情况下，使用红黑树可以大大提升性能。</p><p>链式桶是一个由node节点组成的链表。树状桶是一颗由TreeNode节点组成的红黑树。输的根节点为TreeBin类型。</p><p>当链表长度大于8整个hash表长度大于64的时候，就会转化为TreeBin。TreeBin作为根节点，其实就是红黑树对象。在ConcurrentHashMap的table数组中，存放的就是TreeBin对象，而不是TreeNoe对象。</p><p>数组table是懒加载的，只有第一次添加元素的时候才会初始化，所以initTable()存在线程安全问题。</p><p>重要的属性就是sizeCtl，用来控制table的初始化和扩容操作的过程：</p><p>● -1代表table正在初始化，其他线程直接join等待。</p><p>● -N代表有N-1个线程正在进行扩容操作，严格来说，当其为负数的时候，只用到了低16位，如果低16位为M，此时有M-1个线程进行扩容。</p><p>● 大于0有两种情况：如果table没有初始化，她就表示table初始化的大小，如果table初始化完了，就表示table的容量，默认是table大小的四分之三。</p><p>Transfer()扩容</p><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程所负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的 Bucket会被替换为一个Forwarding节点，标记当前Bucket已经被其他线程迁移完了。</p><p>helpTransfer()帮助扩容</p><p>ConcurrentHashMap并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</p><p>第一次添加元素时，默认初始长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>put()</p><p>JDK1.8在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用通常不会很激烈，所以使用CAS自旋、synchronized不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢?如果为每 个桶都创建一个ReentrantLock实 例，就会带来大量的内存消耗，反过来，使用CAS自旋、synchronized，内存消耗的增加更小。</p><p>get()</p><p>get()通过UnSafe的getObjectVolatile()来读取数组中的元素。为什么要这样做?虽然HashEntry数组的引用是volatile类型，但是数组内元素的 用不是volatile类型，因此多线程对 数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的元素对象。get()方法通过UnSafe的getObjectVolatile方法来保证元素的读取安全，调用getObjectVolatile()去读取数组元素需要先获得元素在数组中的偏移量，在这里，get()方法根据哈希码计算出偏移量为u，然后通过偏移量u来尝试读取数值。</p>]]></content>
      
      
      <categories>
          
          <category> 1.基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
