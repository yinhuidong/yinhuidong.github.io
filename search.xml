<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL[十四]redo日志</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一，什么是redo日志"><a href="#一，什么是redo日志" class="headerlink" title="一，什么是redo日志"></a>一，什么是redo日志</h1><p>InnoDB存储引擎是以页为单位来管理存储空间的，我们的CRUD操作其实都是在访问页面。在真正访问页面之前，需要把磁盘中的页加载到内存的BufferPool，之后才能访问，但是因为事务要保持持久性，如果我们仅仅在内存的缓冲池修改了页面，假设事务提交后突然发生故障，导致内存的数据都消失了，那么这个已经提交的事务在数据库做的更改就丢失了。</p><p>如何保证持久性呢？可以在事务提交完成之前，把事务修改的所有页面都刷新到磁盘。不过这样做存在一些问题：</p><ol><li>刷新一个完整的数据页过于浪费</li><li>随机IO效率比较低</li></ol><p>事实上仅仅是为了保证事务的持久性，没有必要每次提交事务的时候就把该事务在内存修改过的全部页面刷新到磁盘，只需要把修改的内容记录一下就好，这样在事务提交的时候，就会把这个记录刷新到磁盘。即使系统因为崩溃而重启只需要按照记录的内容重新更新数据页即可恢复数据，上述记录修改的内容就叫做重做日志（redo log）。</p><p>相比于在事务提交的时候将所有修改过的内存中的页面刷新到磁盘，重做日志有以下好处：</p><ol><li>redo日志占用空间小：在存储表空间ID，页号，偏移量以及需要更新的值时，需要的存储空间很小。</li><li>redo日志是顺序写入磁盘的：在执行事务过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</li></ol><h1 id="二，redo日志格式"><a href="#二，redo日志格式" class="headerlink" title="二，redo日志格式"></a>二，redo日志格式</h1><p>重做日志本质上仅仅是记录了一下事务对数据库进行了哪些修改。针对事务对数据库的不同修改场景MySQL定义了很多种重做日志，但是大部分类型的重做日志都有以下的通用结构。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864487599-72623029-d1bd-486a-93d7-f34d2fe58221.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufbd9f38f&margin=%5Bobject%20Object%5D&name=1.png&originHeight=354&originWidth=1024&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112563&status=done&style=none&taskId=ue7c47d23-75ab-4475-8af2-31b72226448&title=" alt="1.png"></p><table><thead><tr><th>type</th><th>重做日志的类型</th></tr></thead><tbody><tr><td>space ID</td><td>表空间ID</td></tr><tr><td>page number</td><td>页号</td></tr><tr><td>Data</td><td>日志的具体内容</td></tr></tbody></table><h2 id="1-简单的redo日志类型"><a href="#1-简单的redo日志类型" class="headerlink" title="1. 简单的redo日志类型"></a>1. 简单的redo日志类型</h2><p>行格式里面有一个隐藏列叫做row_id。为row_id进行赋值的方式如下：</p><ol><li>服务器会在内存中维护一个全局变量，每当像某个包含row_id隐藏列的表插入一条记录的时候，就会把这个全局变量的值当做新记录row_id的值，并且把这个全局变量自增1。</li><li>每当这个全局变量的值是256的整数倍的时候，就会把这个变量的值刷新到系统表空间页号为7的页面中一个叫做Max Row ID的属性中。</li><li>当系统启动的时候，会将Max Row ID属性加载到内存，并把这个值加上256之后赋值给前面提到的全局变量。</li></ol><p>这个Max Row ID占用的存储空间是8字节。当某个事务向某个包含row_id的表插入一条记录并且该记录分配的row_id值为256的整数倍的时候，就会像系统表空间页号为7的页面的相应偏移量处写入8字节的值。但是这个写入操作实际上是在内存缓冲区完成的，我们需要把这次修改以redo日志的形式记录下来，这样在事务提交之后，即使系统崩溃，也可以将该页面恢复成崩溃前的状态。在这种对页面的修改特别简单的时候，重做日志仅仅需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体修改后的内容是什么就可以了。这也叫做物理日志。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864497144-c6bbeee2-d119-4f70-a1cd-8f30e19a648f.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63b5c32f&margin=%5Bobject%20Object%5D&name=2.png&originHeight=346&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128345&status=done&style=none&taskId=ucca73287-3001-4a4e-9fcf-6be09c76605&title=" alt="2.png"></p><blockquote><p>offset表示页面中的偏移量。如果写入的是字节序列类型的重做日志，还需要有一个len属性记录实际写入的长度。</p></blockquote><h2 id="2-复杂的redo日志类型"><a href="#2-复杂的redo日志类型" class="headerlink" title="2.复杂的redo日志类型"></a>2.复杂的redo日志类型</h2><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）。</p><p>这时我们如果使用简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p><ul><li> 方案一：在每个修改的地方都记录一条<code>redo</code>日志。<br>也就是有多少个修改的记录，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多。 </li><li> 方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。<br><code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中太浪费了。 </li></ul><p>正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，<code>InnoDB</code>提出了一些新的<code>redo</code>日志类型。</p><p>这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p><ul><li>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</li><li>逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640864506052-682d177e-e56e-41a2-ae87-d0b12033c1a1.jpeg#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u21fe8e28&margin=%5Bobject%20Object%5D&name=3.jpg&originHeight=502&originWidth=2551&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155669&status=done&style=none&taskId=ud78277be-d3e8-4dbf-8c90-73c67ad2679&title=" alt="3.jpg"></p><p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了什么，<code>PAGE_HEAP_TOP</code>的值修改为了什么，<code>PAGE_N_HEAP</code>的值修改为了什么等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统崩溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p><blockquote><p>日志格式说了一堆核心其实就是：<strong>重做日志会把事务执行过程中对数据库所做的所有修改都记录下来，在之后系统因为崩溃而重启后可以把事务所做的任何修改都恢复过来。</strong></p><p>为了节省重做日志占用的空间大小，InnoDB还对重做日志中的某些数据进行了压缩处理，比如表空间ID&amp;page number 一般占用4字节来存储，但是经过压缩之后占用的空间就更小了。</p></blockquote><h1 id="三，Mini-Transcation"><a href="#三，Mini-Transcation" class="headerlink" title="三，Mini-Transcation"></a>三，Mini-Transcation</h1><h2 id="1-以组的形式写入redo日志"><a href="#1-以组的形式写入redo日志" class="headerlink" title="1.以组的形式写入redo日志"></a>1.以组的形式写入redo日志</h2><p>语句在执行过程中可能修改若干个页面。比如我们前边说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被<code>InnoDB</code>人为的划分成了若干个不可分割的组，比如：</p><ul><li>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</li><li>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li><li>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li><li>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</li></ul><p>怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p><ul><li> 情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864518399-d8ca4351-4d13-4bd4-9d2f-d2f8b9cf827f.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u216a45d8&margin=%5Bobject%20Object%5D&name=4.png&originHeight=1184&originWidth=2626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=682116&status=done&style=none&taskId=ufb2d27cf-ca13-47d8-8933-70b4495df9c&title=" alt="4.png"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864527311-d990febe-3bbf-430d-8193-c555bfcb6a28.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u77a21299&margin=%5Bobject%20Object%5D&name=5.png&originHeight=1214&originWidth=2736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=716516&status=done&style=none&taskId=u9acd0af1-5494-4f70-a01c-37f3834f243&title=" alt="5.png"> </li><li> 情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864555961-e408cdd7-cfe0-4ca8-9abd-3f23e263791a.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua72872eb&margin=%5Bobject%20Object%5D&name=6.png&originHeight=1166&originWidth=2628&originalType=binary&ratio=1&rotation=0&showTitle=false&size=114382&status=done&style=none&taskId=u3f7aabf6-811a-44fb-9762-57c4045b0a9&title=" alt="6.png"><br>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864564352-6b5aea0c-fbaa-4b8b-bdd6-94c83b589b89.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uafb41cc9&margin=%5Bobject%20Object%5D&name=7.png&originHeight=1202&originWidth=2652&originalType=binary&ratio=1&rotation=0&showTitle=false&size=786814&status=done&style=none&taskId=u060ba959-ed05-4ba7-aa1c-1f0b67f001f&title=" alt="7.png"><br>如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表等，我们在介绍表空间那一篇中介绍过的各种东西），反正总共需要记录的<code>redo</code>日志有二、三十条。 </li></ul><blockquote><p>其实不光是悲观插入一条记录会生成许多条redo日志，InnoDB为了其他的一些功能，在乐观插入时也可能产生多条redo日志。</p></blockquote><p><code>InnoDB</code>认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统崩溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统崩溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是<code>InnoDB</code>所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统崩溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p><ul><li> 有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。<br>如何把这些<code>redo</code>日志划分到一个组里边儿呢？<code>InnoDB</code>做了一个很简单的操作，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864573578-9668a610-aeba-4131-87cd-fbe9ab8dfa1b.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7b288267&margin=%5Bobject%20Object%5D&name=8.png&originHeight=268&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50315&status=done&style=none&taskId=u9fe14e16-5e51-4acd-a72b-547c4eed975&title=" alt="8.png"><br>所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864581619-ef9856b6-4148-4179-a2c0-6ef3fac46de2.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uebe2359f&margin=%5Bobject%20Object%5D&name=9.png&originHeight=684&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81836&status=done&style=none&taskId=u0b4690f2-55d0-46d3-824c-1a896362c67&title=" alt="9.png"><br>这样在系统崩溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前边解析到的<code>redo</code>日志。 </li><li> 有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。<br>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，<code>InnoDB</code>不想浪费一个比特位。虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864589834-ee10f8e7-b2d5-49be-883f-bb87c130c80a.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uce73ec9d&margin=%5Bobject%20Object%5D&name=10.png&originHeight=640&originWidth=1704&originalType=binary&ratio=1&rotation=0&showTitle=false&size=287797&status=done&style=none&taskId=u91331d85-1eb9-47fd-bb64-955a160bd0e&title=" alt="10.png"><br>如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。 </li></ul><h2 id="2-Mini-Transaction"><a href="#2-Mini-Transaction" class="headerlink" title="2.Mini-Transaction"></a>2.Mini-Transaction</h2><p><code>MySQL</code>把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864597409-0355aaab-6e93-4e2a-ba36-16219408aa78.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u065b9c9e&margin=%5Bobject%20Object%5D&name=11.png&originHeight=1380&originWidth=1764&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103182&status=done&style=none&taskId=ue8afcf6a-afa4-4881-8189-394a28a5db0&title=" alt="11.png"></p><h1 id="四，redo日志的写入过程"><a href="#四，redo日志的写入过程" class="headerlink" title="四，redo日志的写入过程"></a>四，redo日志的写入过程</h1><h2 id="1-redo-log-block"><a href="#1-redo-log-block" class="headerlink" title="1.redo log block"></a>1.redo log block</h2><p><code>InnoDB</code>为了更好的进行系统崩溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>。一个<code>redo log block</code>的示意图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641864021669-f9e4073a-fe36-4537-be44-a395924f907f.png#clientId=u243d2ae4-ef44-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf4c03a91&margin=%5Bobject%20Object%5D&name=image.png&originHeight=764&originWidth=1306&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71145&status=done&style=none&taskId=uab13cea9-5436-42a0-8b3f-16678b944c2&title=" alt="image.png"></p><p>真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641864242219-2be35389-a760-41ab-a7fe-b3eafe265d4e.png#clientId=u243d2ae4-ef44-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufe5375ac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=908&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149840&status=done&style=none&taskId=ua653d992-91b4-40fa-b171-5b2a8010523&title=" alt="image.png"></p><p>其中<code>log block header</code>的几个属性的意思分别如下：</p><ul><li><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li></ul><p><code>log block trailer</code>中属性的意思如下：</p><ul><li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li></ul><h2 id="2-redo-日志缓冲区"><a href="#2-redo-日志缓冲区" class="headerlink" title="2.redo 日志缓冲区"></a>2.redo 日志缓冲区</h2><p><code>InnoDB</code>为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864625032-625f8c90-46bb-4a14-a50c-ad70e7dce61c.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8bcc1d13&margin=%5Bobject%20Object%5D&name=14.png&originHeight=864&originWidth=2838&originalType=binary&ratio=1&rotation=0&showTitle=false&size=553662&status=done&style=none&taskId=ud5c09ca4-6b88-4de9-a09b-d3967214a4d&title=" alt="14.png"></p><p>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p><h2 id="3-redo-log-日志写入log-buffer"><a href="#3-redo-log-日志写入log-buffer" class="headerlink" title="3.redo log 日志写入log buffer"></a>3.redo log 日志写入log buffer</h2><p>向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以<code>InnoDB</code>特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864634044-307e6617-8881-422a-a1b4-6b65a460cde3.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u29330ff2&margin=%5Bobject%20Object%5D&name=15.png&originHeight=1024&originWidth=2828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=706746&status=done&style=none&taskId=u3bbeba33-8aa5-49d0-9f2a-f71c2f269e8&title=" alt="15.png"></p><p>一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p><ul><li>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</li><li>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</li></ul><p>每个<code>mtr</code>都会产生一组<code>redo</code>日志，不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864644524-f2d41097-c851-43f7-9284-f213732bd421.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5a52634d&margin=%5Bobject%20Object%5D&name=16.png&originHeight=1094&originWidth=2818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=762512&status=done&style=none&taskId=ub1ed7d29-40e2-4d9a-bebf-0937e001a43&title=" alt="16.png"></p><p>从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p><h1 id="五，redo-日志文件"><a href="#五，redo-日志文件" class="headerlink" title="五，redo 日志文件"></a>五，redo 日志文件</h1><h2 id="1-redo日志刷盘时机"><a href="#1-redo日志刷盘时机" class="headerlink" title="1.redo日志刷盘时机"></a>1.redo日志刷盘时机</h2><p><code>mtr</code>运行过程中产生的一组<code>redo</code>日志在<code>mtr</code>结束时会被复制到<code>log buffer</code>中，在一些情况下它们会被刷新到磁盘里，比如：</p><ul><li> <code>log buffer</code>空间不足时<br><code>log buffer</code>的大小是有限的（通过系统变量<code>innodb_log_buffer_size</code>指定），如果不停的往这个有限大小的<code>log buffer</code>里塞入日志，很快它就会被填满。<code>InnoDB</code>认为如果当前写入<code>log buffer</code>的<code>redo</code>日志量已经占满了<code>log buffer</code>总容量的大约一半左右，就需要把这些日志刷新到磁盘上。 </li><li> 事务提交时<br>之所以使用<code>redo</code>日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的<code>Buffer Pool</code>页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的<code>redo</code>日志刷新到磁盘。 </li><li> 将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中（再一次 强调，redo 日志是顺序刷新的，所以在将某个脏页对应的 redo 日志从 redo log buffer 刷新到磁盘时，也会保证将在其之前产生的 redo 日志也刷新到磁盘）。 </li><li> 后台线程不停的刷<br>后台有一个线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo</code>日志到磁盘。 </li><li> 正常关闭服务器时 </li><li> 做所谓的<code>checkpoint</code>时 </li><li> 其他的一些情况… </li></ul><h2 id="2-redo日志文件组"><a href="#2-redo日志文件组" class="headerlink" title="2.redo日志文件组"></a>2.redo日志文件组</h2><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，<code>log buffer</code>中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的<code>redo</code>日志文件不满意，可以通过下边几个启动参数来调节：</p><ul><li> <code>innodb_log_group_home_dir</code><br>该参数指定了<code>redo</code>日志文件所在的目录，默认值就是当前的数据目录。 </li><li> <code>innodb_log_file_size</code><br>该参数指定了每个<code>redo</code>日志文件的大小，在<code>MySQL 5.7.21</code>这个版本中的默认值为<code>48MB</code>， </li><li> <code>innodb_log_files_in_group</code><br>该参数指定<code>redo</code>日志文件的个数，默认值为2，最大值为100。 </li></ul><p>磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0</code>、<code>1</code>、<code>2</code>…）的形式进行命名。在将<code>redo</code>日志写入<code>日志文件组</code>时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写，同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864656682-963826be-2fa2-4598-9033-606039356e57.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uaa3d5ef3&margin=%5Bobject%20Object%5D&name=17.png&originHeight=586&originWidth=1734&originalType=binary&ratio=1&rotation=0&showTitle=false&size=311573&status=done&style=none&taskId=u051c8364-6b34-4392-9b9d-e1f31520ad8&title=" alt="17.png"></p><p>总共的<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p><blockquote><p>如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的redo日志覆盖掉前边写的redo日志？当然可能了！所以InnoDB提出了checkpoint的概念。</p></blockquote><h2 id="3-redo日志文件格式"><a href="#3-redo日志文件格式" class="headerlink" title="3.redo日志文件格式"></a>3.redo日志文件格式</h2><p><code>log buffer</code>本质上是一片连续的内存空间，被划分成了若干个<code>512</code>字节大小的<code>block</code>。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的block组成。</p><p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</li></ul><p>所以我们前边所说的<code>循环</code>使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864666580-772cbeb7-f939-4dd8-8478-efea9d4151a6.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2dc0fb0c&margin=%5Bobject%20Object%5D&name=18.png&originHeight=1024&originWidth=2806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=591545&status=done&style=none&taskId=uf7825917-db29-4e0d-b498-ccb3858542a&title=" alt="18.png"></p><p>普通block的格式我们在了解<code>log buffer</code>的时候都说过了，就是<code>log block header</code>、<code>log block body</code>、<code>log block trialer</code>这三个部分。这里需要介绍一下每个<code>redo</code>日志文件前2048个字节，也就是前4个特殊block的格式都是什么作用。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864675232-a3665df8-b4a1-46f9-98f4-64fc979f9e51.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7b53cd73&margin=%5Bobject%20Object%5D&name=19.png&originHeight=1136&originWidth=2802&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132931&status=done&style=none&taskId=u77c738bc-8c15-4c0f-906a-0e806683b7d&title=" alt="19.png"><br>从图中可以看出来，这4个block分别是：</p><ul><li><p> <code>log file header</code>：描述该<code>redo</code>日志文件的一些整体属性<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640864685580-5d17b490-ff01-4e39-a31b-ef6c2ff624d5.jpeg#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue90cf3d3&margin=%5Bobject%20Object%5D&name=20.jpg&originHeight=1593&originWidth=2467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=183282&status=done&style=none&taskId=u7f79975e-ede8-444b-8dff-d57bf42876f&title=" alt="20.jpg"><br>各个属性的具体释义如下：  </p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_HEADER_FORMAT</code></td><td><code>4</code></td><td><code>redo</code>日志的版本，在<code>MySQL 5.7.21</code>中该值永远为1</td></tr><tr><td><code>LOG_HEADER_PAD1</code></td><td><code>4</code></td><td>做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td><code>LOG_HEADER_START_LSN</code></td><td><code>8</code></td><td>标记本<code>redo</code>日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值。</td></tr><tr><td><code>LOG_HEADER_CREATOR</code></td><td><code>32</code></td><td>一个字符串，标记本<code>redo</code>日志文件的创建者是谁。正常运行时该值为<code>MySQL</code>的版本号，比如：<code>&quot;MySQL 5.7.21&quot;</code>，使用<code>mysqlbackup</code>命令创建的<code>redo</code>日志文件的该值为<code>&quot;ibbackup&quot;</code>和创建时间。</td></tr><tr><td><code>LOG_BLOCK_CHECKSUM</code></td><td><code>4</code></td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table></li><li><p> <code>checkpoint1</code>：记录关于<code>checkpoint</code>的一些属性，看一下它的结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640864698163-e1185f2f-8cfa-429f-a4a2-404ec8518c4c.jpeg#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u32a54e19&margin=%5Bobject%20Object%5D&name=21.jpg&originHeight=1593&originWidth=2467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=222295&status=done&style=none&taskId=u61cbdb66-d4ec-4f02-b6bd-32dcd7c3766&title=" alt="21.jpg"><br>各个属性的具体释义如下：  </p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td><code>LOG_CHECKPOINT_NO</code></td><td><code>8</code></td><td>服务器做<code>checkpoint</code>的编号，每做一次<code>checkpoint</code>，该值就加1。</td></tr><tr><td><code>LOG_CHECKPOINT_LSN</code></td><td><code>8</code></td><td>服务器做<code>checkpoint</code>结束时对应的<code>LSN</code>值，系统崩溃恢复时将从该值开始。</td></tr><tr><td><code>LOG_CHECKPOINT_OFFSET</code></td><td><code>8</code></td><td>上个属性中的<code>LSN</code>值在<code>redo</code>日志文件组中的偏移量</td></tr><tr><td><code>LOG_CHECKPOINT_LOG_BUF_SIZE</code></td><td><code>8</code></td><td>服务器在做<code>checkpoint</code>操作时对应的<code>log buffer</code>的大小</td></tr><tr><td><code>LOG_BLOCK_CHECKSUM</code></td><td><code>4</code></td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table></li><li><p> 第三个block未使用，忽略 </p></li><li><p> <code>checkpoint2</code>：结构和<code>checkpoint1</code>一样。 </p></li></ul><h1 id="六，Log-Sequence-Number"><a href="#六，Log-Sequence-Number" class="headerlink" title="六，Log Sequence Number"></a>六，Log Sequence Number</h1><p>自系统开始运行，就不断的在修改页面，也就意味着会不断的生成<code>redo</code>日志。<code>redo</code>日志的量在不断的递增。<code>InnoDB</code>为记录已经写入的<code>redo</code>日志量，设计了一个称之为<code>Log Sequence Number</code>的全局变量，翻译过来就是：<code>日志序列号</code>，简称<code>lsn</code>。<code>InnoDB</code>规定初始的<code>lsn</code>值为<code>8704</code>（也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值为<code>8704</code>）。</p><p>在向<code>log buffer</code>中写入<code>redo</code>日志时不是一条一条写入的，而是以一个<code>mtr</code>生成的一组<code>redo</code>日志为单位进行写入的。而且实际上是把日志内容写在了<code>log block body</code>处。但是在统计<code>lsn</code>的增长量时，是按照实际写入的日志量加上占用的<code>log block header</code>和<code>log block trailer</code>来计算的。我们来看一个例子：</p><ul><li> 系统第一次启动后初始化<code>log buffer</code>时，<code>buf_free</code>（就是标记下一条<code>redo</code>日志应该写入到<code>log buffer</code>的位置的变量）就会指向第一个<code>block</code>的偏移量为12字节（<code>log block header</code>的大小）的地方，那么<code>lsn</code>值也会跟着增加12：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864709610-a13d0013-b7b9-43b7-a161-151236b0596c.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u175705fd&margin=%5Bobject%20Object%5D&name=22.png&originHeight=692&originWidth=2600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=437626&status=done&style=none&taskId=u4cbca53f-ec16-496f-b610-d49ea0b6378&title=" alt="22.png"> </li><li> 如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864719076-5bbd616f-afe0-4a71-a152-6d8a29a70f27.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6f691c2a&margin=%5Bobject%20Object%5D&name=23.png&originHeight=612&originWidth=2654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=426566&status=done&style=none&taskId=u4e68bd52-b1e9-42ad-a8f9-158c6e867f2&title=" alt="23.png"><br>我们假设上图中<code>mtr_1</code>产生的<code>redo</code>日志量为200字节，那么<code>lsn</code>就要在<code>8716</code>的基础上增加<code>200</code>，变为<code>8916</code>。 </li><li> 如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较大，也就是待插入的block剩余空闲空间不足以容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数加上额外占用的<code>log block header</code>和<code>log block trailer</code>的字节数，就像这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864728936-2a814700-924e-4236-9a03-81213c71844b.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9f9ca8d5&margin=%5Bobject%20Object%5D&name=24.png&originHeight=996&originWidth=2828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=755556&status=done&style=none&taskId=uc07adc05-b654-4c52-9ac6-3930c7e8ac1&title=" alt="24.png"><br>我们假设上图中<code>mtr_2</code>产生的<code>redo</code>日志量为1000字节，为了将<code>mtr_2</code>产生的<code>redo</code>日志写入<code>log buffer</code>，我们不得不额外多分配两个block，所以<code>lsn</code>的值需要在<code>8916</code>的基础上增加<code>1000 + 12×2 + 4 × 2 = 1032</code>。 </li></ul><p>从上边的描述中可以看出来，每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p><h2 id="1-flushed-to-disk-lsn"><a href="#1-flushed-to-disk-lsn" class="headerlink" title="1.flushed_to_disk_lsn"></a>1.flushed_to_disk_lsn</h2><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。所以<code>InnoDB</code>提出了一个称之为<code>buf_next_to_write</code>的全局变量，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864739527-34db3929-710e-4041-b4ef-1becced73694.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u94e6ad2a&margin=%5Bobject%20Object%5D&name=25.png&originHeight=696&originWidth=1488&originalType=binary&ratio=1&rotation=0&showTitle=false&size=379537&status=done&style=none&taskId=u77b5d0e0-b522-4178-a11d-062b2a18075&title=" alt="25.png"></p><p><code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，<code>InnoDB</code>提出了一个表示刷新到磁盘中的<code>redo</code>日志量的全局变量，称之为<code>flushed_to_disk_lsn</code>。系统第一次启动时，该变量的值和初始的<code>lsn</code>值是相同的，都是<code>8704</code>。随着系统的运行，<code>redo</code>日志被不断写入<code>log buffer</code>，但是并不会立即刷新到磁盘，<code>lsn</code>的值就和<code>flushed_to_disk_lsn</code>的值拉开了差距。我们推理一下：</p><ul><li>系统第一次启动后，向<code>log buffer</code>中写入了<code>mtr_1</code>、<code>mtr_2</code>、<code>mtr_3</code>这三个<code>mtr</code>产生的<code>redo</code>日志，假设这三个<code>mtr</code>开始和结束时对应的lsn值分别是： <ul><li><code>mtr_1</code>：8716 ～ 8916</li><li><code>mtr_2</code>：8916 ～ 9948</li><li><code>mtr_3</code>：9948 ～ 10000</li></ul></li></ul><p>此时的<code>lsn</code>已经增长到了10000，但是由于没有刷新操作，所以此时<code>flushed_to_disk_lsn</code>的值仍为<code>8704</code>，如图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864750935-f12dffd0-0d76-4929-9bff-9dcbb2d5be9e.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u57283172&margin=%5Bobject%20Object%5D&name=26.png&originHeight=1034&originWidth=1634&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93271&status=done&style=none&taskId=u3eabb779-7af8-4b51-8e36-7fa0072c2a1&title=" alt="26.png"></p><ul><li> 随后进行将<code>log buffer</code>中的block刷新到<code>redo</code>日志文件的操作，假设将<code>mtr_1</code>和<code>mtr_2</code>的日志刷新到磁盘，那么<code>flushed_to_disk_lsn</code>就应该增长<code>mtr_1</code>和<code>mtr_2</code>写入的日志量，所以<code>flushed_to_disk_lsn</code>的值增长到了<code>9948</code>，如图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864761524-39c96423-198f-41cf-b64d-f5848258dd62.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5694f54c&margin=%5Bobject%20Object%5D&name=27.png&originHeight=1054&originWidth=1680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=545789&status=done&style=none&taskId=u2b41f4eb-1206-4f50-81a3-517bb8a0cd1&title=" alt="27.png"> </li></ul><p>综上所述，当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p><blockquote><p>应用程序向磁盘写入文件时其实是先写到操作系统的缓冲区中去，如果某个写入操作要等到操作系统确认已经写到磁盘时才返回，那需要调用一下操作系统提供的<code>fsync</code>函数。其实只有当系统执行了<code>fsync</code>函数后，<code>flushed_to_disk_lsn</code>的值才会跟着增长，当仅仅把<code>log buffer</code>中的日志写入到操作系统缓冲区却没有显式的刷新到磁盘时，另外的一个称之为<code>write_lsn</code>的值跟着增长。</p></blockquote><h2 id="2-lsn值和redo日志文件偏移量的对应关系"><a href="#2-lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="2.lsn值和redo日志文件偏移量的对应关系"></a>2.lsn值和redo日志文件偏移量的对应关系</h2><p>因为<code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（当然有时候要加上<code>log block header</code>和<code>log block trailer</code>的大小），这样<code>mtr</code>产生的日志写到磁盘中时，很容易计算某一个<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864772681-83ca98a1-2b47-451c-b72a-d04b22f534a3.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u146be48e&margin=%5Bobject%20Object%5D&name=28.png&originHeight=582&originWidth=1578&originalType=binary&ratio=1&rotation=0&showTitle=false&size=258385&status=done&style=none&taskId=udbf909f0-a3fe-4128-b50e-f6ddc90ae87&title=" alt="28.png"></p><p>初始时的<code>LSN</code>值是<code>8704</code>，对应文件偏移量<code>2048</code>，之后每个<code>mtr</code>向磁盘中写入多少字节日志，<code>lsn</code>的值就增长多少。</p><h2 id="3-flush链表中的LSN"><a href="#3-flush链表中的LSN" class="headerlink" title="3.flush链表中的LSN"></a>3.flush链表中的LSN</h2><p>一个<code>mtr</code>代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的<code>redo</code>日志，在<code>mtr</code>结束时，会把这一组<code>redo</code>日志写入到<code>log buffer</code>中。除此之外，在<code>mtr</code>结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。</p><p>当第一次修改某个缓存在<code>Buffer Pool</code>中的页面时，就会把这个页面对应的控制块插入到<code>flush链表</code>的头部，之后再修改该页面时由于它已经在<code>flush</code>链表中了，就不再次插入了。也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p><ul><li><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</li><li><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</li></ul><p>接着上边<code>flushed_to_disk_lsn</code>的例子看一下：</p><ul><li> 假设<code>mtr_1</code>执行过程中修改了<code>页a</code>，那么在<code>mtr_1</code>执行结束时，就会将<code>页a</code>对应的控制块加入到<code>flush链表</code>的头部。并且将<code>mtr_1</code>开始时对应的<code>lsn</code>，也就是<code>8716</code>写入<code>页a</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_1</code>结束时对应的<code>lsn</code>，也就是8916写入<code>页a</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下（<code>oldest_modification</code>缩写成了<code>o_m</code>，<code>newest_modification</code>缩写成了<code>n_m</code>）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864784232-afbab3ff-b849-464a-903f-e9451b29bda7.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua2732566&margin=%5Bobject%20Object%5D&name=29.png&originHeight=850&originWidth=1592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=359132&status=done&style=none&taskId=u9746ce10-ff17-4ac3-a16f-94f116746e9&title=" alt="29.png"> </li><li> 接着假设<code>mtr_2</code>执行过程中又修改了<code>页b</code>和<code>页c</code>两个页面，那么在<code>mtr_2</code>执行结束时，就会将<code>页b</code>和<code>页c</code>对应的控制块都加入到<code>flush链表</code>的头部。并且将<code>mtr_2</code>开始时对应的<code>lsn</code>，也就是8916写入<code>页b</code>和<code>页c</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_2</code>结束时对应的<code>lsn</code>，也就是9948写入<code>页b</code>和<code>页c</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864792670-4fff07de-c242-4435-abd1-a395d7cb0212.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6d749ce4&margin=%5Bobject%20Object%5D&name=30.png&originHeight=638&originWidth=2310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=400105&status=done&style=none&taskId=uf40efa4b-706f-44dc-86a8-84e2098a814&title=" alt="30.png"><br>从图中可以看出来，每次新插入到<code>flush链表</code>中的节点都是被放在了头部，也就是说<code>flush链表</code>中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早。 </li><li> 接着假设<code>mtr_3</code>执行过程中修改了<code>页b</code>和<code>页d</code>，不过<code>页b</code>之前已经被修改过了，所以它对应的控制块已经被插入到了<code>flush</code>链表，所以在<code>mtr_3</code>执行结束时，只需要将<code>页d</code>对应的控制块都加入到<code>flush链表</code>的头部即可。所以需要将<code>mtr_3</code>开始时对应的<code>lsn</code>，也就是9948写入<code>页d</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_3</code>结束时对应的<code>lsn</code>，也就是10000写入<code>页d</code>对应的控制块的<code>newest_modification</code>属性中。另外，由于<code>页b</code>在<code>mtr_3</code>执行过程中又发生了一次修改，所以需要更新<code>页b</code>对应的控制块中<code>newest_modification</code>的值为10000。画个图表示一下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864803589-2d9a04e5-51e2-49c9-8e11-14e59db61c53.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7f465b43&margin=%5Bobject%20Object%5D&name=31.png&originHeight=646&originWidth=2866&originalType=binary&ratio=1&rotation=0&showTitle=false&size=472625&status=done&style=none&taskId=u47725c53-d335-4b69-8639-00da9b1a978&title=" alt="31.png"> </li></ul><p>总结一下上边说的，就是：<strong>flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</strong></p><h1 id="七，checkpoint"><a href="#七，checkpoint" class="headerlink" title="七，checkpoint"></a>七，checkpoint</h1><p><code>redo</code>日志文件组容量是有限的，我们不得不选择循环使用<code>redo</code>日志文件组中的文件，但是这会造成最后写的<code>redo</code>日志与最开始写的<code>redo</code>日志<code>追尾</code>，这时应该想到：redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说：判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。我们看一下前边的那个例子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864814179-88627650-6c19-452b-af5c-923e0a1c7ab9.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u68f75a23&margin=%5Bobject%20Object%5D&name=32.png&originHeight=1232&originWidth=1946&originalType=binary&ratio=1&rotation=0&showTitle=false&size=570522&status=done&style=none&taskId=u97475867-1c62-4084-b6ff-37bdd8e87ce&title=" alt="32.png"></p><p>如图，虽然<code>mtr_1</code>和<code>mtr_2</code>生成的<code>redo</code>日志都已经被写到了磁盘上，但是它们修改的脏页仍然留在<code>Buffer Pool</code>中，所以它们生成的<code>redo</code>日志在磁盘上的空间是不可以被覆盖的。之后随着系统的运行，如果<code>页a</code>被刷新到了磁盘，那么它对应的控制块就会从<code>flush链表</code>中移除，就像这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864822121-4553e8b1-d602-4486-878d-0245450abd51.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua0dba545&margin=%5Bobject%20Object%5D&name=33.png&originHeight=1234&originWidth=1602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=508938&status=done&style=none&taskId=ua087ec5f-573d-4b0e-8dcf-0680cf0a109&title=" alt="33.png"></p><p>这样<code>mtr_1</code>生成的<code>redo</code>日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。<code>InnoDB</code>提出了一个全局变量<code>checkpoint_lsn</code>来代表当前系统中可以被覆盖的<code>redo</code>日志总量是多少，这个变量初始值也是<code>8704</code>。</p><p>比方说现在<code>页a</code>被刷新到了磁盘，<code>mtr_1</code>生成的<code>redo</code>日志就可以被覆盖了，所以我们可以进行一个增加<code>checkpoint_lsn</code>的操作，我们把这个过程称之为做一次<code>checkpoint</code>。做一次<code>checkpoint</code>其实可以分为两个步骤：</p><ul><li> 步骤一：计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。<br><code>redo</code>日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的<code>oldest_modification</code>值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的<code>oldest_modification</code>赋值给<code>checkpoint_lsn</code>。<br>比方说当前系统中<code>页a</code>已经被刷新到磁盘，那么<code>flush链表</code>的尾节点就是<code>页c</code>，该节点就是当前系统中最早修改的脏页了，它的<code>oldest_modification</code>值为8916，我们就把8916赋值给<code>checkpoint_lsn</code>（也就是说在redo日志对应的lsn值小于8916时就可以被覆盖掉）。 </li><li> 步骤二：将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。<br><code>InnoDB</code>维护了一个目前系统做了多少次<code>checkpoint</code>的变量<code>checkpoint_no</code>，每做一次<code>checkpoint</code>，该变量的值就加1。我们前边说过计算一个<code>lsn</code>值对应的<code>redo</code>日志文件组偏移量是很容易的，所以可以计算得到该<code>checkpoint_lsn</code>在<code>redo</code>日志文件组中对应的偏移量<code>checkpoint_offset</code>，然后把这三个值都写到<code>redo</code>日志文件组的管理信息中。<br>我们说过，每一个<code>redo</code>日志文件都有<code>2048</code>个字节的管理信息，但是上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。不过我们是存储到<code>checkpoint1</code>中还是<code>checkpoint2</code>中呢？<code>InnoDB</code>规定，当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中。 </li></ul><p>记录完<code>checkpoint</code>的信息之后，<code>redo</code>日志文件组中各个<code>lsn</code>值的关系就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864832987-8aa99b0b-ad9f-4c2b-9a44-18c2563e5b18.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u793e2893&margin=%5Bobject%20Object%5D&name=34.png&originHeight=578&originWidth=1380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66537&status=done&style=none&taskId=u30aa57b3-7511-4be2-ae70-8b231c862bf&title=" alt="34.png"></p><h2 id="1-批量从flush链表中刷出脏页"><a href="#1-批量从flush链表中刷出脏页" class="headerlink" title="1.批量从flush链表中刷出脏页"></a>1.批量从flush链表中刷出脏页</h2><p>一般情况下都是后台的线程在对<code>LRU链表</code>和<code>flush链表</code>进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统<code>lsn</code>值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘，这样这些脏页对应的<code>redo</code>日志就没用了，然后就可以去做<code>checkpoint</code>了。</p><h2 id="2-查看系统中的各种LSN值"><a href="#2-查看系统中的各种LSN值" class="headerlink" title="2.查看系统中的各种LSN值"></a>2.查看系统中的各种LSN值</h2><p>我们可以使用<code>SHOW ENGINE INNODB STATUS</code>命令查看当前<code>InnoDB</code>存储引擎中的各种<code>LSN</code>值的情况，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line">---</span><br><span class="line">Log sequence number 124476971</span><br><span class="line">Log flushed up to   124099769</span><br><span class="line">Pages flushed up to 124052503</span><br><span class="line">Last checkpoint at  124052494</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">24 log i/o&#x27;s done, 2.00 log i/o&#x27;s/second</span><br><span class="line">----------------------</span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Log sequence number</code>：代表系统中的<code>lsn</code>值，也就是当前系统已经写入的<code>redo</code>日志量，包括写入<code>log buffer</code>中的日志。</li><li><code>Log flushed up to</code>：代表<code>flushed_to_disk_lsn</code>的值，也就是当前系统已经写入磁盘的<code>redo</code>日志量。</li><li><code>Pages flushed up to</code>：代表<code>flush链表</code>中被最早修改的那个页面对应的<code>oldest_modification</code>属性值。</li><li><code>Last checkpoint at</code>：当前系统的<code>checkpoint_lsn</code>值。</li></ul><h2 id="3-innodb-flush-log-at-trx-commit的用法"><a href="#3-innodb-flush-log-at-trx-commit的用法" class="headerlink" title="3.innodb_flush_log_at_trx_commit的用法"></a>3.innodb_flush_log_at_trx_commit的用法</h2><p>为了保证事务的<code>持久性</code>，用户线程在事务提交时需要将该事务执行过程中产生的所有<code>redo</code>日志都刷新到磁盘上。这一条要求太狠了，会很明显的降低数据库性能。如果对事务的<code>持久性</code>要求不是那么强烈的话，可以选择修改一个称为<code>innodb_flush_log_at_trx_commit</code>的系统变量的值，该变量有3个可选的值：</p><ul><li> <code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志，这个任务是交给后台线程做的。<br>这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将<code>redo</code>日志刷新到磁盘，那么该事务对页面的修改会丢失。 </li><li> <code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘，可以保证事务的<code>持久性</code>。<code>1</code>也是<code>innodb_flush_log_at_trx_commit</code>的默认值。 </li><li> <code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中，但并不需要保证将日志真正的刷新到磁盘。<br>这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了。 </li></ul><h1 id="八，崩溃恢复"><a href="#八，崩溃恢复" class="headerlink" title="八，崩溃恢复"></a>八，崩溃恢复</h1><p>在服务器不挂的情况下，<code>redo</code>日志不仅没用，反而让性能变得更差。但是万一数据库挂了，我们就可以在重启时根据<code>redo</code>日志中的记录就可以将页面恢复到系统崩溃前的状态。我们接下来大致看一下恢复过程。</p><h2 id="1-确定恢复的起点"><a href="#1-确定恢复的起点" class="headerlink" title="1.确定恢复的起点"></a>1.确定恢复的起点</h2><p><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖，也就是说这些<code>redo</code>日志对应的脏页都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。对于<code>checkpoint_lsn</code>之后的<code>redo</code>日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从<code>checkpoint_lsn</code>开始读取<code>redo</code>日志来恢复页面。</p><p>当然，<code>redo</code>日志文件组的第一个文件的管理信息中有两个block都存储了<code>checkpoint_lsn</code>的信息，我们当然是要选取最近发生的那次checkpoint的信息。衡量<code>checkpoint</code>发生时间早晚的信息就是所谓的<code>checkpoint_no</code>，只要把<code>checkpoint1</code>和<code>checkpoint2</code>这两个block中的<code>checkpoint_no</code>值读出来比一下大小，哪个的<code>checkpoint_no</code>值更大，说明哪个block存储的就是最近的一次<code>checkpoint</code>信息。这样我们就能拿到最近发生的<code>checkpoint</code>对应的<code>checkpoint_lsn</code>值以及它在<code>redo</code>日志文件组中的偏移量<code>checkpoint_offset</code>。</p><h2 id="2-确定恢复的终点"><a href="#2-确定恢复的终点" class="headerlink" title="2.确定恢复的终点"></a>2.确定恢复的终点</h2><p><code>redo</code>日志恢复的起点确定了，那终点是哪个呢？这个还得从block的结构说起。在写<code>redo</code>日志的时候都是顺序写的，写满了一个block之后会再往下一个block中写。</p><p>普通block的<code>log block header</code>部分有一个称之为<code>LOG_BLOCK_HDR_DATA_LEN</code>的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为<code>512</code>。如果该属性的值不为<code>512</code>，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。</p><h2 id="3-怎么恢复"><a href="#3-怎么恢复" class="headerlink" title="3.怎么恢复"></a>3.怎么恢复</h2><p>确定了需要扫描哪些<code>redo</code>日志进行崩溃恢复之后，接下来就是怎么进行恢复了。假设现在的<code>redo</code>日志文件中有5条<code>redo</code>日志，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864845397-5c752767-6330-4db0-a29f-7ca86577f27f.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u52381dfe&margin=%5Bobject%20Object%5D&name=35.png&originHeight=484&originWidth=1588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52404&status=done&style=none&taskId=ua678c768-0959-4cae-92d2-3d95bf42085&title=" alt="35.png"></p><p>由于<code>redo 0</code>在<code>checkpoint_lsn</code>后前边，恢复时可以不管它。现在可以按照<code>redo</code>日志的顺序依次扫描<code>checkpoint_lsn</code>之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。这样没什么问题，不过<code>InnoDB</code>还是想了一些办法加快这个恢复的过程：</p><ul><li> 使用哈希表<br>根据<code>redo</code>日志的<code>space ID</code>和<code>page number</code>属性计算出散列值，把<code>space ID</code>和<code>page number</code>相同的<code>redo</code>日志放到哈希表的同一个槽里，如果有多个<code>space ID</code>和<code>page number</code>都相同的<code>redo</code>日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864854531-b5649b49-9232-483a-97d5-f3e93563f711.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u38ebf05a&margin=%5Bobject%20Object%5D&name=36.png&originHeight=878&originWidth=1506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=487842&status=done&style=none&taskId=u290553e7-6d79-4869-adac-78da4fffc0b&title=" alt="36.png"><br>之后就可以遍历哈希表，因为对同一个页面进行修改的<code>redo</code>日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO），这样可以加快恢复速度。另外需要注意一点的是，同一个页面的<code>redo</code>日志是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复，如果不按照生成时间顺序进行排序的话，那么可能出现错误。比如原先的修改操作是先插入一条记录，再删除该条记录，如果恢复时不按照这个顺序来，就可能变成先删除一条记录，再插入一条记录，这显然是错误的。 </li><li> 跳过已经刷新到磁盘的页面<br><code>checkpoint_lsn</code>之前的<code>redo</code>日志对应的脏页确定都已经刷到磁盘了，但是<code>checkpoint_lsn</code>之后的<code>redo</code>日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次<code>checkpoint</code>后，可能后台线程又不断的从<code>LRU链表</code>和<code>flush链表</code>中将一些脏页刷出<code>Buffer Pool</code>。这些在<code>checkpoint_lsn</code>之后的<code>redo</code>日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据<code>redo</code>日志的内容修改该页面了。<br>那在恢复时怎么知道某个<code>redo</code>日志对应的脏页是否在崩溃发生时已经刷新到磁盘了呢？这还得从页面的结构说起，每个页面都有一个称之为<code>File Header</code>的部分，在<code>File Header</code>里有一个称之为<code>FIL_PAGE_LSN</code>的属性，该属性记载了最近一次修改页面时对应的<code>lsn</code>值（其实就是页面控制块中的<code>newest_modification</code>值）。如果在做了某次<code>checkpoint</code>之后有脏页被刷新到磁盘中，那么该页对应的<code>FIL_PAGE_LSN</code>代表的<code>lsn</code>值肯定大于<code>checkpoint_lsn</code>的值，凡是符合这种情况的页面就不需要重复执行lsn值小于<code>FIL_PAGE_LSN</code>的redo日志了，所以更进一步提升了崩溃恢复的速度。 </li></ul><h1 id="九，LOG-BLOCK-HDR-NO是如何计算的"><a href="#九，LOG-BLOCK-HDR-NO是如何计算的" class="headerlink" title="九，LOG_BLOCK_HDR_NO是如何计算的"></a>九，LOG_BLOCK_HDR_NO是如何计算的</h1><p>对于实际存储<code>redo</code>日志的普通的<code>log block</code>来说，在<code>log block header</code>处有一个称之为<code>LOG_BLOCK_HDR_NO</code>的属性，我们说这个属性代表一个唯一的标号。这个属性是初次使用该block时分配的，跟当时的系统<code>lsn</code>值有关。使用下边的公式计算该block的<code>LOG_BLOCK_HDR_NO</code>值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((lsn / 512) &amp; 0x3FFFFFFFUL) + 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640864865474-9b8bdc06-3e44-4a51-93aa-be1366ae7520.png#clientId=u4334628b-f1a0-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf2818478&margin=%5Bobject%20Object%5D&name=37.png&originHeight=420&originWidth=2580&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51118&status=done&style=none&taskId=u29b43df7-e13a-4c7e-8b6f-d4c848c7347&title=" alt="37.png"></p><p>从图中可以看出，<code>0x3FFFFFFFUL</code>对应的二进制数的前2位为0，后30位的值都为<code>1</code>。一个二进制位与0做与运算（<code>&amp;</code>）的结果肯定是0，一个二进制位与1做与运算（<code>&amp;</code>）的结果就是原值。让一个数和<code>0x3FFFFFFFUL</code>做与运算的意思就是要将该值的前2个比特位的值置为0，这样该值就肯定小于或等于<code>0x3FFFFFFFUL</code>了。这也就说明了，不论lsn多大，<code>((lsn / 512) &amp; 0x3FFFFFFFUL)</code>的值肯定在<code>0``~~0x3FFFFFFFUL~~</code><del>之间，再加1的话肯定在</del><code>~~1~~``0x40000000UL</code>之间。而<code>0x40000000UL</code>这个值就代表着<code>1GB</code>。也就是说系统最多能产生不重复的<code>LOG_BLOCK_HDR_NO</code>值只有<code>1GB</code>个。InnoDB规定<code>redo</code>日志文件组中包含的所有文件大小总和不得超过512GB，一个block大小是512字节，也就是说redo日志文件组中包含的block块最多为1GB个，所以有1GB个不重复的编号值也就够用了。</p><p>另外，<code>LOG_BLOCK_HDR_NO</code>值的第一个比特位比较特殊，称之为<code>flush bit</code>，如果该值为1，代表着本block是在某次将<code>log buffer</code>中的block刷新到磁盘的操作中的第一个被刷入的block。</p><h1 id="十，double-write"><a href="#十，double-write" class="headerlink" title="十，double write"></a>十，double write</h1><p><strong>​</strong></p><h2 id="1-脏页刷盘风险"><a href="#1-脏页刷盘风险" class="headerlink" title="1.脏页刷盘风险"></a>1.脏页刷盘风险</h2><p>​</p><p>关于IO的最小单位：</p><ol><li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li><li>文件系统IO的最小单位是4K（也有1K的）</li><li>磁盘IO的最小单位是512字节</li></ol><p>因此，存在IO写入导致page损坏的风险：<br>​</p><p>​<img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641862404239-30566dce-d370-47b7-9867-76a9d4cb6daf.png#clientId=u49cb4bc4-7246-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc6fbd209&margin=%5Bobject%20Object%5D&originHeight=386&originWidth=472&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u24e449ed-e0a1-48ab-9270-c44159416df&title="><br>​</p><h2 id="2-doublewrite：两次写"><a href="#2-doublewrite：两次写" class="headerlink" title="2.doublewrite：两次写"></a>2.doublewrite：两次写</h2><p>提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。<br>​</p><h3 id="2-1-Double-write解决了什么问题"><a href="#2-1-Double-write解决了什么问题" class="headerlink" title="2.1 Double write解决了什么问题"></a>2.1 Double write解决了什么问题</h3><p>​</p><p>一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。<br>​</p><h3 id="2-2使用情景"><a href="#2-2使用情景" class="headerlink" title="2.2使用情景"></a>2.2使用情景</h3><p>​</p><p>当数据库正在从内存想磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。<br>​</p><h3 id="2-3-double-write工作流程"><a href="#2-3-double-write工作流程" class="headerlink" title="2.3 double write工作流程"></a>2.3 double write工作流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641862404231-823dd86f-17a6-4811-986d-18bb15f62fd0.png#clientId=u49cb4bc4-7246-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2f315b90&margin=%5Bobject%20Object%5D&originHeight=460&originWidth=650&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3b87208b-8e06-405e-b283-ee617200e0d&title="></p><p>doublewrite由两部分组成，一部分为内存中的<code>doublewrite buffer</code>，其大小为2MB，另一部分是磁盘上共享表空间(ibdata x)中连续的128个页，即2个区(extent)，大小也是2M。</p><ol><li>当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的<code>doublewrite buffer</code>中；</li><li>接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；</li><li>待第二步完成后，再将<code>doublewrite buffer</code>中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)</li></ol><h3 id="2-4-doublewrite的崩溃恢复"><a href="#2-4-doublewrite的崩溃恢复" class="headerlink" title="2.4 doublewrite的崩溃恢复"></a>2.4 doublewrite的崩溃恢复</h3><p>​</p><p>如果操作系统在将页写入磁盘的过程中发生崩溃，在恢复过程中，<code>innodb</code>存储引擎可以从共享表空间的<code>doublewrite</code>中找到该页的一个最近的副本，将其复制到表空间文件，再应用<code>redo log</code>，就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</p><blockquote><p><em>Q：为什么</em><code>_log write_</code><em>不需要</em><code>_doublewrite_</code><em>的支持？</em><br><em>A：因为</em><code>_redolog_</code><em>写入的单位就是512字节，也就是磁盘IO的最小单位，所以无所谓数据损坏。</em></p></blockquote><p>​</p><h2 id="3-doublewrite的副作用"><a href="#3-doublewrite的副作用" class="headerlink" title="3.doublewrite的副作用"></a>3.doublewrite的副作用</h2><h3 id="3-1-double-write带来的写负载"><a href="#3-1-double-write带来的写负载" class="headerlink" title="3.1 double write带来的写负载"></a>3.1 double write带来的写负载</h3><ol><li>double write是一个buffer, 但其实它是开在物理文件上的一个buffer, 其实也就是file, 所以它会导致系统有更多的fsync操作, 而硬盘的fsync性能是很慢的, 所以它会降低mysql的整体性能。</li><li>但是，doublewrite buffer写入磁盘共享表空间这个过程是连续存储，是顺序写，性能非常高，(约占写的10%)，牺牲一点写性能来保证数据页的完整还是很有必要的。<h3 id="3-2-监控double-write工作负载"><a href="#3-2-监控double-write工作负载" class="headerlink" title="3.2 监控double write工作负载"></a>3.2 监控double write工作负载</h3></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like <span class="string">&#x27;%dblwr%&#x27;</span>;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Innodb_dblwr_pages_written | <span class="number">7</span>     |</span><br><span class="line">| Innodb_dblwr_writes        | <span class="number">3</span>     |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line"><span class="number">2</span> <span class="function">rows in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>关注点：Innodb_dblwr_pages_written / Innodb_dblwr_writes<br>​</p><p>开启doublewrite后，每次脏页刷新必须要先写doublewrite，而doublewrite存在于磁盘上的是两个连续的区，每个区由连续的页组成，一般情况下一个区最多有64个页，所以一次IO写入应该可以最多写64个页。<br>​</p><p>而根据以上系统Innodb_dblwr_pages_written与Innodb_dblwr_writes的比例来看，大概在3左右，远远还没到64(如果约等于64，那么说明系统的写压力非常大，有大量的脏页要往磁盘上写)，所以从这个角度也可以看出，系统写入压力并不高。<br>​</p><h3 id="3-3-关闭double-write适合的场景"><a href="#3-3-关闭double-write适合的场景" class="headerlink" title="3.3 关闭double write适合的场景"></a>3.3 关闭double write适合的场景</h3><ol><li>海量DML</li><li>不惧怕数据损坏和丢失</li><li>系统写负载成为主要负载<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;%double%&#x27;</span>;</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| Variable_name      | Value |</span><br><span class="line">+--------------------+-------+</span><br><span class="line">| innodb_doublewrite | ON    |</span><br><span class="line">+--------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br></pre></td></tr></table></figure>作为InnoDB的一个关键特性，doublewrite功能默认是开启的，但是在上述特殊的一些场景也可以视情况关闭，来提高数据库写性能。静态参数，配置文件修改，重启数据库。<h3 id="3-4-为什么没有把double-write里面的数据写到data-page里面呢？"><a href="#3-4-为什么没有把double-write里面的数据写到data-page里面呢？" class="headerlink" title="3.4 为什么没有把double write里面的数据写到data page里面呢？"></a>3.4 为什么没有把double write里面的数据写到data page里面呢？</h3></li></ol><ol><li>double write里面的数据是连续的，如果直接写到data page里面，而data page的页又是离散的，写入会很慢。</li><li>double write里面的数据没有办法被及时的覆盖掉，导致double write的压力很大；短时间内可能会出现double write溢出的情况。<h1 id="十一，总结"><a href="#十一，总结" class="headerlink" title="十一，总结"></a>十一，总结</h1></li></ol><p>redo日志记录了事务执行过程中都修改了哪些内容。</p><p>事务提交时只将执行过程中产生的redo日志刷新到磁盘，而不是将所有修改过的页面都刷新到磁盘。这样做有两个好处：</p><ol><li>redo日志占用的空间非常小</li><li>redo日志是顺序写入磁盘的</li></ol><p>一条redo日志由下面几部分组成。</p><ol><li>type：这条redo日志的类型</li><li>space ID:表空间ID</li><li>page number :页号</li><li>data：这条redo日志的具体内容</li></ol><p>redo日志的类型有简单和复杂之分。简单类型的redo日志是纯粹的物理日志，复杂类型的redo日志兼有物理日志和逻辑日志的特性。</p><p>一个MTR可以包含一组redo日志。在进行崩溃恢复时，这一组redo日志作为一个不可分割的整体来处理。</p><p>redo日志存放在大小为512字节的block中。每一个block被分为3部分：</p><ol><li>log block header</li><li>log block body</li><li>log block trailer</li></ol><p>redo日志缓冲区是一片连续的内存空间，由若干个block组成；可以通过启动选项innodb_log_buffer_size 来调整他的大小。</p><p>redo日志文件组由若干个日志文件组成，这些redo日志文件是被循环使用的。redo日志文件组中每个文件的大小都一样，格式也一样，都是由两部分组成的：</p><ol><li>前2048字节用来存储一些管理信息</li><li>从第2048字节往后的字节用来存储log buffer中的block镜像</li></ol><p>lsn指已经写入的redo日志量，flushed_to_disk_lsn指刷新到磁盘中的redo日志量，flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的lsn值进行排序。被多次更新的页面不会重复插入到flush链表，但是会更新newest_modification属性的值。checkpoint_lsn表示当前系统中可以被覆盖的redo日志总量是多少。</p><p>redo日志占用的磁盘空间在他对应的脏页已经被刷新到磁盘后即可被覆盖。执行一次checkpoint的意思就是增加checkpoint_lsn的值，然后把相关信息放到日志文件的管理信息中。</p><p>innodb_flush_log_at_trx_commit系统变量控制着在事务提交时是否将该事务运行过程中产生的redo刷新到磁盘。</p><p>在崩溃恢复过程中，从redo日志文件组第一个文件的管理信息中取出最近发生的那次checkpoint信息，然后从checkpoint_lsn在日志文件组中对应的偏移量开始，一直扫描日志文件中的block，直到某个block的LOG_BLOCK_HDR_DATA_LEN值不等于512为止。再恢复过程中，使用hash表可加快恢复过程，并且会跳过已经刷新到磁盘的页面。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十三]事务</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%89%5D%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%89%5D%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一，事务的起源"><a href="#一，事务的起源" class="headerlink" title="一，事务的起源"></a>一，事务的起源</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h3><p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。设计数据库的大叔们把这种要么全做，要么全不做的规则称之为<code>原子性</code>。但是在现实世界中的一个不可分割的操作却可能对应着数据库世界若干条不同的操作，数据库中的一条操作也可能被分解成若干个步骤（比如先修改缓存页，之后再刷新到磁盘等），最要命的是在任何一个可能的时间都可能发生意想不到的错误（可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的）而使操作执行不下去。为了保证在数据库世界中某些操作的原子性，MySQL需要保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子。</p><h3 id="2-隔离性（Isolation）"><a href="#2-隔离性（Isolation）" class="headerlink" title="2.隔离性（Isolation）"></a>2.隔离性（Isolation）</h3><p>现实世界中的两次状态转换应该是互不影响的，所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以<code>原子性</code>的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为<code>隔离性</code>。这时MySQL就需要采取一些措施来让访问相同数据的不同状态转换对应的数据库操作的执行顺序有一定规律。</p><h3 id="3-一致性（Consistency）"><a href="#3-一致性（Consistency）" class="headerlink" title="3.一致性（Consistency）"></a>3.一致性（Consistency）</h3><p>我们生活的这个世界存在着形形色色的约束，比如身份证号不能重复，性别只能是男或者女，高考的分数只能在0～750之间，人民币面值最大只能是100（现在是2019年），红绿灯只有3种颜色，房价不能为负的。 只有符合这些约束的数据才是有效的。数据库世界只是现实世界的一个映射，现实世界中存在的约束当然也要在数据库世界中有所体现。如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合<code>一致性</code>的。</p><p>如何保证数据库中数据的一致性（就是符合所有现实世界的约束）呢？这其实靠两方面的努力：</p><ul><li><p> 数据库本身能为我们保证一部分一致性需求（就是数据库自身可以保证一部分现实世界的约束永远有效）。<br>我们知道<code>MySQL</code>数据库可以为表建立主键、唯一索引、外键、声明某个列为<code>NOT NULL</code>来拒绝<code>NULL</code>值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么<code>MySQL</code>就会报错并且拒绝插入。除了这些我们已经非常熟悉的保证一致性的功能，<code>MySQL</code>还支持<code>CHECK</code>语法来自定义约束，比如这样：<br>上述例子中的<code>CHECK</code>语句本意是想规定<code>balance</code>列不能存储小于0的数字，对应的现实世界的意思就是银行账户余额不能小于0。但是很遗憾，MySQL仅仅支持CHECK语法，但实际上并没有一点卵用，也就是说即使我们使用上述带有<code>CHECK</code>子句的建表语句来创建<code>account</code>表，那么在后续插入或更新记录时，<code>MySQL</code>并不会去检查<code>CHECK</code>子句中的约束是否成立。<br>虽然<code>CHECK</code>子句对一致性检查没什么卵用，但是我们还是可以通过定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    name VARCHAR(100) COMMENT &#x27;客户名称&#x27;,</span><br><span class="line">    balance INT COMMENT &#x27;余额&#x27;,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    CHECK (balance &gt;= 0) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>其它的一些数据库，比如SQL Server或者Oracle支持的CHECK语法是有实实在在的作用的，每次进行插入或更新记录之前都会检查一下数据是否符合CHECK子句中指定的约束条件是否成立，如果不成立的话就会拒绝插入或更新。</p></blockquote></li><li><p> 更多的一致性需求需要靠写业务代码的程序员自己保证。<br>为建立现实世界和数据库世界的对应关系，理论上应该把现实世界中的所有约束都反应到数据库世界中，但是在更改数据库数据时进行一致性检查是一个耗费性能的工作，比方说我们为<code>account</code>表建立了一个触发器，每当插入或者更新记录时都会校验一下<code>balance</code>列的值是不是大于0，这就会影响到插入或更新的速度。仅仅是校验一行记录符不符合一致性需求倒也不是什么大问题，有的一致性需求简直变态，比方说银行会建立一张代表账单的表，里边儿记录了每个账户的每笔交易，每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。如果在数据库层面实现这个一致性需求的话，每次发生交易时，都需要将所有的收入加起来减去所有的支出，再将所有的账户余额加起来，看看两个值相不相等。如果账单表里有几亿条记录，光是这个校验的过程可能就要跑好几个小时，这样的性能代价是完全承受不起的。<br>现实生活中复杂的一致性需求比比皆是，而由于性能问题把一致性需求交给数据库去解决这是不现实的，所以这个锅就甩给了业务端程序员。比方说我们的<code>account</code>表，我们也可以不建立触发器，只要编写业务的程序员在自己的业务代码里判断一下，当某个操作会将<code>balance</code>列的值更新为小于0的值时，就不执行该操作就好了！ </p></li></ul><p><code>原子性</code>和<code>隔离性</code>都会对<code>一致性</code>产生影响，比如我们现实世界中转账操作完成后，有一个<code>一致性</code>需求就是参与转账的账户的总的余额是不变的。如果数据库不遵循<code>原子性</code>要求，也就是转了一半就不转了，那最后就是不符合一致性需求的；类似的，如果数据库不遵循<code>隔离性</code>要求，也就是说可能不符合<code>一致性</code>需求了。所以说，数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。那满足<code>原子性</code>和<code>隔离性</code>的操作一定就满足<code>一致性</code>么？那倒也不一定，那不满足<code>原子性</code>和<code>隔离性</code>的操作就一定不满足<code>一致性</code>么？这也不一定，只要最后的结果符合所有现实世界中的约束，那么就是符合<code>一致性</code>的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4.持久性（Durability）"></a>4.持久性（Durability）</h3><p>当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则被MySQL称为<code>持久性</code>。当把现实世界的状态转换映射到数据库世界时，<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉。</p><h2 id="二，事务的概念"><a href="#二，事务的概念" class="headerlink" title="二，事务的概念"></a>二，事务的概念</h2><p>我们把<code>原子性</code>（<code>Atomicity</code>）、<code>隔离性</code>（<code>Isolation</code>）、<code>一致性</code>（<code>Consistency</code>）和<code>持久性</code>（<code>Durability</code>）这四个词对应的英文单词首字母提取出来就是<code>A</code>、<code>I</code>、<code>C</code>、<code>D</code>，稍微变换一下顺序可以组成一个完整的英文单词：<code>ACID</code>。MySQL叔为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称之为一个<code>事务</code>（英文名是：<code>transaction</code>）。</p><p>我们现在知道<code>事务</code>是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把<code>事务</code>大致上划分成了这么几个状态：</p><ul><li> 活动的（active）<br>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。 </li><li> 部分提交的（partially committed）<br>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在<code>部分提交的</code>状态。 </li><li> 失败的（failed）<br>当事务处在<code>活动的</code>或者<code>部分提交的</code>状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在<code>失败的</code>状态。 </li><li> 中止的（aborted）<br>如果事务执行了半截而变为<code>失败的</code>状态，那么就需要把已经修改的数据调整为未修改之前的数据，换句话说，就是要撤销失败事务对当前数据库造成的影响。书面一点的话，我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。 </li><li> 提交的（committed）<br>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了<code>提交的</code>状态。 </li></ul><p>随着事务对应的数据库操作执行到不同阶段，事务的状态也在不断变化，一个基本的状态转换图如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640695115396-9200b034-6e54-4ad3-8d79-7811c0764acd.png#clientId=ufeb1ac38-ae67-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud43f14a4&margin=%5Bobject%20Object%5D&name=%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B.png&originHeight=894&originWidth=1664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=510408&status=done&style=none&taskId=u8bfc0302-fd35-429e-ae45-62b1c3a155d&title=" alt="事务流程.png"></p><p>从图中大家也可以看出了，只有当事务处于提交的或者中止的状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p><h2 id="三，MySQL中事务的语法"><a href="#三，MySQL中事务的语法" class="headerlink" title="三，MySQL中事务的语法"></a>三，MySQL中事务的语法</h2><p>我们说<code>事务</code>的本质其实只是一系列数据库操作，只不过这些数据库操作符合<code>ACID</code>特性而已，那么<code>MySQL</code>中如何将某些操作放到一个事务里去执行的呢？</p><h3 id="1-开启事务"><a href="#1-开启事务" class="headerlink" title="1.开启事务"></a>1.开启事务</h3><p>我们可以使用下边两种语句之一来开启一个事务：</p><ul><li><p> <code>BEGIN [WORK];</code><br><code>BEGIN</code>语句代表开启一个事务，后边的单词<code>WORK</code>可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure></li><li><p><code>START TRANSACTION;</code><br><code>START TRANSACTION</code>语句和<code>BEGIN</code>语句有着相同的功效，都标志着开启一个事务，比如这样：<br>不过比<code>BEGIN</code>语句牛逼一点儿的是，可以在<code>START TRANSACTION</code>语句后边跟随几个<code>修饰符</code>，就是它们几个： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; 加入事务的语句...</span><br></pre></td></tr></table></figure><ul><li><p> <code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。  </p><blockquote><p>其实只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TMEPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。</p></blockquote></li><li><p> <code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。 </p></li><li><p> <code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。 </p></li></ul></li></ul><p>比如我们想开启一个只读事务的话，直接把<code>READ ONLY</code>这个修饰符加在<code>START TRANSACTION</code>语句后边就好，比如这样： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY;</span><br></pre></td></tr></table></figure><p>如果我们想在<code>START TRANSACTION</code>后边跟随多个<code>修饰符</code>的话，可以使用逗号将<code>修饰符</code>分开，比如开启一个只读事务和一致性读，就可以这样写： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ ONLY, WITH CONSISTENT SNAPSHOT;</span><br></pre></td></tr></table></figure><p>或者开启一个读写事务和一致性读，就可以这样写： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT</span><br></pre></td></tr></table></figure><p>不过这里需要注意的一点是，<code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为<code>只读</code>的也设置为<code>读写</code>的，所以我们不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式。 </p><h3 id="2-提交事务"><a href="#2-提交事务" class="headerlink" title="2.提交事务"></a>2.提交事务</h3><p>开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT [WORK]</span><br></pre></td></tr></table></figure><p><code>COMMIT</code>语句就代表提交一个事务，后边的<code>WORK</code>可有可无。转账举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="3-手动中止事务"><a href="#3-手动中止事务" class="headerlink" title="3.手动中止事务"></a>3.手动中止事务</h3><p>如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK]</span><br></pre></td></tr></table></figure><p><code>ROLLBACK</code>语句就代表中止并回滚一个事务，后边的<code>WORK</code>可有可无类似的。转账举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里需要强调一下，<code>ROLLBACK</code>语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</p><blockquote><p>我们这里所说的开启、提交、中止事务的语法只是针对使用黑框框时通过mysql客户端程序与服务器进行交互时控制事务的语法，如果大家使用的是别的客户端程序，比如JDBC之类的，那需要参考相应的文档来看看如何控制事务。</p></blockquote><h3 id="4-支持事务的存储引擎"><a href="#4-支持事务的存储引擎" class="headerlink" title="4.支持事务的存储引擎"></a>4.支持事务的存储引擎</h3><p><code>MySQL</code>中并不是所有存储引擎都支持事务的功能，目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持（NDB存储引擎不是我们的重点），如果某个事务中包含了修改使用不支持事务的存储引擎的表，那么对该使用不支持事务的存储引擎的表所做的修改将无法进行回滚。比方说我们有两个表，<code>tbl1</code>使用支持事务的存储引擎<code>InnoDB</code>，<code>tbl2</code>使用不支持事务的存储引擎<code>MyISAM</code>，它们的建表语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl1 (</span><br><span class="line">    i int</span><br><span class="line">) engine=InnoDB;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl2 (</span><br><span class="line">    i int</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>我们看看先开启一个事务，写一条插入语句后再回滚该事务，<code>tbl1</code>和<code>tbl2</code>的表现有什么不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl1 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl1;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，对于使用支持事务的存储引擎的<code>tbl1</code>表来说，我们在插入一条记录再回滚后，<code>tbl1</code>就恢复到没有插入记录时的状态了。再看看<code>tbl2</code>表的表现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tbl2 VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl2;</span><br><span class="line">+------+</span><br><span class="line">| i    |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，虽然我们使用了<code>ROLLBACK</code>语句来回滚事务，但是插入的那条记录还是留在了<code>tbl2</code>表中。</p><h3 id="5-自动提交"><a href="#5-自动提交" class="headerlink" title="5.自动提交"></a>5.自动提交</h3><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>可以看到它的默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。假如我们在转账时不以<code>START TRANSACTION</code>或者<code>BEGIN</code>语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下边两种方法之一：</p><ul><li> 显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。<br>这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。 </li><li> 把系统变量<code>autocommit</code>的值设置为<code>OFF</code>，就像这样：<br>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = OFF;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-隐式提交"><a href="#6-隐式提交" class="headerlink" title="6.隐式提交"></a>6.隐式提交</h3><p>当我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为<code>OFF</code>时，事务就不会进行<code>自动提交</code>，但是如果我们输入了某些语句之后就会<code>悄悄的</code>提交掉，就像我们输入了<code>COMMIT</code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为<code>隐式提交</code>，这些会导致事务隐式提交的语句包括：</p><ul><li><p> 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：<code>DDL</code>）。<br>所谓的数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等等这些东西。当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p> 隐式使用或修改<code>mysql</code>数据库中的表<br>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。 </p></li><li><p> 事务控制或关于锁定的语句<br>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：<br>或者当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会隐式的提交前边语句所属的事务。<br>或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT ... # 事务中的一条语句</span><br><span class="line">UPDATE ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其它语句</span><br><span class="line"></span><br><span class="line">BEGIN; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p> 加载数据的语句<br>比如我们使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。 </p></li><li><p> 关于<code>MySQL</code>复制的一些语句<br>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时也会隐式的提交前边语句所属的事务。 </p></li><li><p> 其它的一些语句<br>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、 <code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前边语句所属的事务。 </p></li></ul><h3 id="7-保存点"><a href="#7-保存点" class="headerlink" title="7.保存点"></a>7.保存点</h3><p>如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用<code>ROLLBACK</code>语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。所以MySQL提出了一个<code>保存点</code>（英文：<code>savepoint</code>）的概念，就是在事务对应的数据库语句中打几个点，我们在调用<code>ROLLBACK</code>语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词<code>WORK</code>和<code>SAVEPOINT</code>是可有可无的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;</span><br></pre></td></tr></table></figure><p>不过如果<code>ROLLBACK</code>语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</p><p>如果我们想删除某个保存点，可以使用这个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELEASE SAVEPOINT 保存点名称;</span><br></pre></td></tr></table></figure><p>下边还是以转账的例子展示一下<code>保存点</code>的用法，在执行完扣除第一个账户的钱<code>10</code>元的语句之后打一个<code>保存点</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |      11 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SAVEPOINT s1;    # 一个保存点</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE account SET balance = balance + 1 WHERE id = 2; # 更新错了</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK TO s1;  # 回滚到保存点s1处</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM account;</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 狗哥   |       1 |</span><br><span class="line">|  2 | 猫爷   |       2 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十二]InnoDB之BufferPool</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%BA%8C%5DInnoDB%E4%B9%8BBufferPool/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%BA%8C%5DInnoDB%E4%B9%8BBufferPool/</url>
      
        <content type="html"><![CDATA[<h1 id="一，缓存的重要性"><a href="#一，缓存的重要性" class="headerlink" title="一，缓存的重要性"></a>一，缓存的重要性</h1><p>对于使用<code>InnoDB</code>作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以<code>页</code>的形式存放在<code>表空间</code>中的，而所谓的<code>表空间</code>只不过是<code>InnoDB</code>对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是磁盘太慢了，所以<code>InnoDB</code>存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其<code>缓存</code>起来，这样将来有请求再次访问该页面时，就可以省去磁盘<code>IO</code>的开销了。</p><h1 id="二，InnoDB的Buffer-Pool"><a href="#二，InnoDB的Buffer-Pool" class="headerlink" title="二，InnoDB的Buffer Pool"></a>二，InnoDB的Buffer Pool</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640692719739-2a4a2c42-463b-4bb9-9628-5f513cf6af7a.jpeg#clientId=ubc6de47a-2285-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf96ce3e6&margin=%5Bobject%20Object%5D&name=BufferPool.jpg&originHeight=3134&originWidth=2791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=670441&status=done&style=none&taskId=ua4826271-d9b1-4095-8d82-d0212d81af6&title=" alt="BufferPool.jpg"></p><h3 id="1-啥是个Buffer-Pool"><a href="#1-啥是个Buffer-Pool" class="headerlink" title="1.啥是个Buffer Pool"></a>1.啥是个Buffer Pool</h3><p>为了缓存磁盘中的页，在<code>MySQL</code>服务器启动的时候就向操作系统申请了一片连续的内存，叫做<code>Buffer Pool</code>（中文名是<code>缓冲池</code>）。那它有多大呢？这个其实看我们机器的配置，默认情况下<code>Buffer Pool</code>只有<code>128M</code>大小，但是可以在启动服务器的时候配置<code>innodb_buffer_pool_size</code>参数的值，它表示<code>Buffer Pool</code>的大小，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure><p>其中，<code>268435456</code>的单位是字节，也就是我指定<code>Buffer Pool</code>的大小为<code>256M</code>。需要注意的是，<code>Buffer Pool</code>也不能太小，最小值为<code>5M</code>(当小于该值时会自动设置成<code>5M</code>)。</p><h3 id="2-Buffer-Pool内部组成"><a href="#2-Buffer-Pool内部组成" class="headerlink" title="2.Buffer Pool内部组成"></a>2.Buffer Pool内部组成</h3><p><code>Buffer Pool</code>中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是<code>16KB</code>。为了更好的管理这些在<code>Buffer Pool</code>中的缓存页，<code>InnoDB</code>为每一个缓存页都创建了一些所谓的<code>控制信息</code>，这些控制信息包括该页所属的表空间编号、页号、缓存页在<code>Buffer Pool</code>中的地址、链表节点信息、一些锁信息以及<code>LSN</code>信息（锁和<code>LSN</code>先忽略），当然还有一些别的控制信息，暂时省略。</p><p>每个缓存页对应的控制信息占用的内存大小是相同的，我们就把每个页对应的控制信息占用的一块内存称为一个<code>控制块</code>，控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 后边。</p><p>每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，这个用不到的那点儿内存空间就被称为<code>碎片</code>。当然，如果把<code>Buffer Pool</code>的大小设置的刚刚好的话，也可能不会产生<code>碎片</code>。</p><blockquote><p>每个控制块大约占用缓存页大小的5%，在MySQL5.7.21这个版本中，每个控制块占用的大小是808字节。而我们设置的innodb_buffer_pool_size并不包含这部分控制块占用的内存空间大小，也就是说InnoDB在为Buffer Pool向操作系统申请连续的内存空间时，这片连续的内存空间一般会比innodb_buffer_pool_size的值大5%左右。</p></blockquote><h3 id="3-free链表的管理"><a href="#3-free链表的管理" class="headerlink" title="3.free链表的管理"></a>3.free链表的管理</h3><p>当我们最初启动<code>MySQL</code>服务器的时候，需要完成对<code>Buffer Pool</code>的初始化过程，就是先向操作系统申请<code>Buffer Pool</code>的内存空间，然后把它划分成若干对控制块和缓存页。但是此时并没有真实的磁盘页被缓存到<code>Buffer Pool</code>中（因为还没有用到），之后随着程序的运行，会不断的有磁盘上的页被缓存到<code>Buffer Pool</code>中。那么问题来了，从磁盘上读取一个页到<code>Buffer Pool</code>中的时候该放到哪个缓存页的位置呢？或者说怎么区分<code>Buffer Pool</code>中哪些缓存页是空闲的，哪些已经被使用了呢？我们最好在某个地方记录一下Buffer Pool中哪些缓存页是可用的，我们可以把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code>（或者说空闲链表）。刚刚完成初始化的<code>Buffer Pool</code>中所有的缓存页都是空闲的，所以每一个缓存页对应的控制块都会被加入到<code>free链表</code>中。</p><p>为了管理好这个<code>free链表</code>，特意为这个链表定义了一个<code>基节点</code>，里边儿包含着链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。这里需要注意的是，链表的基节点占用的内存空间并不包含在为<code>Buffer Pool</code>申请的一大片连续内存空间之内，而是单独申请的一块内存空间。</p><blockquote><p>链表基节点占用的内存空间并不大，在MySQL5.7.21这个版本里，每个基节点只占用40字节大小。后边我们即将介绍许多不同的链表，它们的基节点和free链表的基节点的内存分配方式是一样的，都是单独申请的一块40字节大小的内存空间，并不包含在为Buffer Pool申请的一大片连续内存空间之内。</p></blockquote><p>有了这个<code>free链表</code>之后，每当需要从磁盘中加载一个页到<code>Buffer Pool</code>中时，就从<code>free链表</code>中取一个空闲的缓存页，并且把该缓存页对应的<code>控制块</code>的信息填上（就是该页所在的表空间、页号之类的信息），然后把该缓存页对应的<code>free链表</code>节点从链表中移除，表示该缓存页已经被使用了。</p><h3 id="4-缓存页的哈希处理"><a href="#4-缓存页的哈希处理" class="headerlink" title="4.缓存页的哈希处理"></a>4.缓存页的哈希处理</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？难不成需要依次遍历<code>Buffer Pool</code>中各个缓存页么？</p><p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p><p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。</p><h3 id="5-flush链表的管理"><a href="#5-flush链表的管理" class="headerlink" title="5.flush链表的管理"></a>5.flush链表的管理</h3><p>如果我们修改了<code>Buffer Pool</code>中某个缓存页的数据，那它就和磁盘上的页不一致了，这样的缓存页也被称为<code>脏页</code>（英文名：<code>dirty page</code>）。最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，我们一般一般异步同步磁盘。</p><p>但是如果不立即同步到磁盘的话，那之后再同步的时候我们怎么知道<code>Buffer Pool</code>中哪些页是<code>脏页</code>，哪些页从来没被修改过呢？创建一个存储脏页的链表，凡是修改过的缓存页对应的控制块都会作为一个节点加入到一个链表中，因为这个链表节点对应的缓存页都是需要被刷新到磁盘上的，所以也叫<code>flush链表</code>。链表的构造和<code>free链表</code>差不多。</p><h3 id="6-LRU链表的管理"><a href="#6-LRU链表的管理" class="headerlink" title="6.LRU链表的管理"></a>6.LRU链表的管理</h3><h4 id="6-1-缓存不够的窘境"><a href="#6-1-缓存不够的窘境" class="headerlink" title="6.1 缓存不够的窘境"></a>6.1 缓存不够的窘境</h4><p><code>Buffer Pool</code>对应的内存大小毕竟是有限的，如果需要缓存的页占用的内存大小超过了<code>Buffer Pool</code>大小，也就是<code>free链表</code>中已经没有多余的空闲缓存页咋办？当然是把某些旧的缓存页从<code>Buffer Pool</code>中移除，然后再把新的页放进来， 那么移除哪些缓存页呢？</p><p>我们设立<code>Buffer Pool</code>的初衷就是想减少和磁盘的<code>IO</code>交互，最好每次在访问某个页的时候它都已经被缓存到<code>Buffer Pool</code>中了。假设我们一共访问了<code>n</code>次页，那么被访问的页已经在缓存中的次数除以<code>n</code>就是所谓的<code>缓存命中率</code>，我们的期望就是让<code>缓存命中率</code>越高越好。所以是留下最近很频繁使用的。</p><h4 id="6-2简单的LRU链表"><a href="#6-2简单的LRU链表" class="headerlink" title="6.2简单的LRU链表"></a>6.2简单的LRU链表</h4><p>管理<code>Buffer Pool</code>的缓存页其实也是这个道理，当<code>Buffer Pool</code>中不再有空闲的缓存页时，就需要淘汰掉部分最近很少使用的缓存页。怎么知道哪些缓存页最近频繁使用，哪些最近很少使用呢？我们可以再创建一个链表，由于这个链表是为了<code>按照最近最少使用</code>的原则去淘汰缓存页的，所以这个链表可以被称为<code>LRU链表</code>（LRU的英文全称：Least Recently Used）。当我们需要访问某个页时，可以这样处理<code>LRU链表</code>：</p><ul><li>如果该页不在<code>Buffer Pool</code>中，在把该页从磁盘加载到<code>Buffer Pool</code>中的缓存页时，就把该缓存页对应的<code>控制块</code>作为节点塞到链表的头部。</li><li>如果该页已经缓存在<code>Buffer Pool</code>中，则直接把该页对应的<code>控制块</code>移动到<code>LRU链表</code>的头部。</li></ul><p>也就是说：只要我们使用到某个缓存页，就把该缓存页调整到<code>LRU链表</code>的头部，这样<code>LRU链表</code>尾部就是最近最少使用的缓存页了。 所以当<code>Buffer Pool</code>中的空闲缓存页使用完时，到<code>LRU链表</code>的尾部找些缓存页淘汰。</p><h4 id="6-3划分区域的LRU链表"><a href="#6-3划分区域的LRU链表" class="headerlink" title="6.3划分区域的LRU链表"></a>6.3划分区域的LRU链表</h4><p>上边的这个简单的<code>LRU</code>链表有问题，因为存在这两种比较尴尬的情况：</p><ul><li><p>情况一：<code>InnoDB</code>提供了一个服务——<code>预读</code>（英文名：<code>read ahead</code>）。所谓<code>预读</code>，就是<code>InnoDB</code>认为执行当前的请求可能之后会读取某些页面，就预先把它们加载到<code>Buffer Pool</code>中。根据触发方式的不同，<code>预读</code>又可以细分为下边两种： </p><ul><li><p> 线性预读<br><code>InnoDB</code>提供了一个系统变量<code>innodb_read_ahead_threshold</code>，如果顺序访问了某个区（<code>extent</code>）的页面超过这个系统变量的值，就会触发一次<code>异步</code>读取下一个区中全部的页面到<code>Buffer Pool</code>的请求，<code>异步</code>读取意味着从磁盘中加载这些被预读的页面并不会影响到当前工作线程的正常执行。这个<code>innodb_read_ahead_threshold</code>系统变量的值默认是<code>56</code>，我们可以在服务器启动时通过启动参数或者服务器运行过程中直接调整该系统变量的值，不过它是一个全局变量，注意使用<code>SET GLOBAL</code>命令来修改。  </p><blockquote><p>InnoDB是怎么实现异步读取的呢？在Windows或者Linux平台上，可能是直接调用操作系统内核提供的AIO接口，在其它类Unix操作系统中，使用了一种模拟AIO接口的方式来实现异步读取，其实就是让别的线程去读取需要预读的页面。</p></blockquote></li><li><p> 随机预读<br>如果<code>Buffer Pool</code>中已经缓存了某个区的13个连续的页面，不论这些页面是不是顺序读取的，都会触发一次<code>异步</code>读取本区中所有其的页面到<code>Buffer Pool</code>的请求。<code>InnoDB</code>同时提供了<code>innodb_random_read_ahead</code>系统变量，它的默认值为<code>OFF</code>，也就意味着<code>InnoDB</code>并不会默认开启随机预读的功能，如果我们想开启该功能，可以通过修改启动参数或者直接使用<code>SET GLOBAL</code>命令把该变量的值设置为<code>ON</code>。 </p></li></ul></li></ul><p>如果预读到<code>Buffer Pool</code>中的页成功的被使用到，那就可以极大的提高语句执行的效率。可是如果用不到呢？这些预读的页都会放到<code>LRU</code>链表的头部，但是如果此时<code>Buffer Pool</code>的容量不太大而且很多预读的页面都没有用到的话，这就会导致处在<code>LRU链表</code>尾部的一些缓存页会很快的被淘汰掉，也就是所谓的<code>劣币驱逐良币</code>，会大大降低缓存命中率。 </p><ul><li> 情况二：有一些扫描全表的查询语句（比如没有建立合适的索引或者压根儿没有WHERE子句的查询）。<br>扫描全表意味着将访问到该表所在的所有页！假设这个表中记录非常多的话，那该表会占用特别多的<code>页</code>，当需要访问这些页时，会把它们统统都加载到<code>Buffer Pool</code>中，这也就意味着<code>Buffer Pool</code>中的所有页都被换了一次，其他查询语句在执行时又得执行一次从磁盘加载到<code>Buffer Pool</code>的操作。而这种全表扫描的语句执行的频率也不高，每次执行都要把<code>Buffer Pool</code>中的缓存页换一次，这严重的影响到其他查询对 <code>Buffer Pool</code>的使用，从而大大降低了缓存命中率。 </li></ul><p>总结一下上边说的可能降低<code>Buffer Pool</code>的两种情况：</p><ul><li>加载到<code>Buffer Pool</code>中的页不一定被用到。</li><li>如果非常多的使用频率偏低的页被同时加载到<code>Buffer Pool</code>时，可能会把那些使用频率非常高的页从<code>Buffer Pool</code>中淘汰掉。</li></ul><p>因为有这两种情况的存在，所以<code>InnoDB</code>把这个<code>LRU链表</code>按照一定比例分成两截，分别是：</p><ul><li>一部分存储使用频率非常高的缓存页，所以这一部分链表也叫做<code>热数据</code>，或者称<code>young区域</code>。</li><li>另一部分存储使用频率不是很高的缓存页，所以这一部分链表也叫做<code>冷数据</code>，或者称<code>old区域</code>。</li></ul><p>我们是按照某个比例将LRU链表分成两半的，不是某些节点固定是young区域的，某些节点固定是old区域的，随着程序的运行，某个节点所属的区域也可能发生变化。那这个划分成两截的比例怎么确定呢？对于<code>InnoDB</code>存储引擎来说，我们可以通过查看系统变量<code>innodb_old_blocks_pct</code>的值来确定<code>old</code>区域在<code>LRU链表</code>中所占的比例，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;innodb_old_blocks_pct&#x27;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_old_blocks_pct | 37    |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出来，默认情况下，<code>old</code>区域在<code>LRU链表</code>中所占的比例是<code>37%</code>，也就是说<code>old</code>区域大约占<code>LRU链表</code>的<code>3/8</code>。这个比例我们是可以设置的，我们可以在启动时修改<code>innodb_old_blocks_pct</code>参数来控制<code>old</code>区域在<code>LRU链表</code>中所占的比例，比方说这样修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct = 40</span><br></pre></td></tr></table></figure><p>这样我们在启动服务器后，<code>old</code>区域占<code>LRU链表</code>的比例就是<code>40%</code>。当然，如果在服务器运行期间，我们也可以修改这个系统变量的值，不过需要注意的是，这个系统变量属于<code>全局变量</code>，一经修改，会对所有客户端生效，所以我们只能这样修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL innodb_old_blocks_pct = 40;</span><br></pre></td></tr></table></figure><p>有了这个被划分成<code>young</code>和<code>old</code>区域的<code>LRU</code>链表之后，<code>InnoDB</code>就可以针对我们上边提到的两种可能降低缓存命中率的情况进行优化：</p><ul><li> 针对预读的页面可能不进行后续访问情况的优化<br><code>InnoDB</code>规定，当磁盘上的某个页面在初次加载到Buffer Pool中的某个缓存页时，该缓存页对应的控制块会被放到old区域的头部。这样针对预读到<code>Buffer Pool</code>却不进行后续访问的页面就会被逐渐从<code>old</code>区域逐出，而不会影响<code>young</code>区域中被使用比较频繁的缓存页。 </li><li> 针对全表扫描时，短时间内访问大量使用频率非常低的页面情况的优化<br>在进行全表扫描时，虽然首次被加载到<code>Buffer Pool</code>的页被放到了<code>old</code>区域的头部，但是后续会被马上访问到，每次进行访问的时候又会把该页放到<code>young</code>区域的头部，这样仍然会把那些使用频率比较高的页面给顶下去。<br>全表扫描有一个特点，那就是它的执行频率非常低，而且在执行全表扫描的过程中，即使某个页面中有很多条记录，也就是去多次访问这个页面所花费的时间也是非常少的。所以我们只需要规定，在对某个处在<code>old</code>区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该页面就不会被从old区域移动到young区域的头部，否则将它移动到young区域的头部。上述的这个间隔时间是由系统变量<code>innodb_old_blocks_time</code>控制的： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;innodb_old_blocks_time&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| innodb_old_blocks_time | 1000  |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这个<code>innodb_old_blocks_time</code>的默认值是<code>1000</code>，它的单位是毫秒，也就意味着对于从磁盘上被加载到<code>LRU</code>链表的<code>old</code>区域的某个页来说，如果第一次和最后一次访问该页面的时间间隔小于<code>1s</code>（很明显在一次全表扫描的过程中，多次访问一个页面中的时间不会超过<code>1s</code>），那么该页是不会被加入到<code>young</code>区域的。 当然，像<code>innodb_old_blocks_pct</code>一样，我们也可以在服务器启动或运行时设置<code>innodb_old_blocks_time</code>的值。 这里需要注意的是，如果我们把<code>innodb_old_blocks_time</code>的值设置为<code>0</code>，那么每次我们访问一个页面时就会把该页面放到<code>young</code>区域的头部。</p><p>综上所述，正是因为将<code>LRU</code>链表划分为<code>young</code>和<code>old</code>区域这两个部分，又添加了<code>innodb_old_blocks_time</code>这个系统变量，才使得预读机制和全表扫描造成的缓存命中率降低的问题得到了遏制，因为用不到的预读页面以及全表扫描的页面都只会被放到<code>old</code>区域，而不影响<code>young</code>区域中的缓存页。</p><h4 id="6-4-更进一步优化LRU链表"><a href="#6-4-更进一步优化LRU链表" class="headerlink" title="6.4 更进一步优化LRU链表"></a>6.4 更进一步优化LRU链表</h4><p>对于<code>young</code>区域的缓存页来说，我们每次访问一个缓存页就要把它移动到<code>LRU链表</code>的头部，这样开销太大了，毕竟在<code>young</code>区域的缓存页都是热点数据，也就是可能被经常访问的，这样频繁的对<code>LRU链表</code>进行节点移动操作不太好，为了解决这个问题其实我们还可以提出一些优化策略，比如只有被访问的缓存页位于<code>young</code>区域的<code>1/4</code>的后边，才会被移动到<code>LRU链表</code>头部，这样就可以降低调整<code>LRU链表</code>的频率，从而提升性能（也就是说如果某个缓存页对应的节点在<code>young</code>区域的<code>1/4</code>中，再次访问该缓存页时也不会将其移动到<code>LRU</code>链表头部）。</p><blockquote><p>介绍随机预读的时候曾说，如果Buffer Pool中有某个区的13个连续页面就会触发随机预读，这其实是不严谨的（但是MySQL文档就是这么说的），其实还要求这13个页面是非常热的页面，所谓的非常热，指的是这些页面在整个young区域的头1/4处。</p></blockquote><p>还有针对<code>LRU链表</code>的优化措施，核心就是尽量高效的提高 <strong><em>Buffer Pool</em></strong> 的缓存命中率。</p><h3 id="7-其他的一些链表"><a href="#7-其他的一些链表" class="headerlink" title="7.其他的一些链表"></a>7.其他的一些链表</h3><p>为了更好的管理<code>Buffer Pool</code>中的缓存页，除了我们上边提到的一些措施，<code>InnoDB</code>还引进了其他的一些<code>链表</code>，比如<code>unzip LRU链表</code>用于管理解压页，<code>zip clean链表</code>用于管理没有被解压的压缩页，<code>zip free数组</code>中每一个元素都代表一个链表，它们组成所谓的<code>伙伴系统</code>来为压缩页提供内存空间等等，为了更好的管理这个<code>Buffer Pool</code>引入了各种链表或其他数据结构。</p><h3 id="8-刷新脏页到磁盘"><a href="#8-刷新脏页到磁盘" class="headerlink" title="8.刷新脏页到磁盘"></a>8.刷新脏页到磁盘</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，这样可以不影响用户线程处理正常的请求。主要有两种刷新路径：</p><ul><li> 从<code>LRU链表</code>的冷数据中刷新一部分页面到磁盘。<br>后台线程会定时从<code>LRU链表</code>尾部开始扫描一些页面，扫描的页面数量可以通过系统变量<code>innodb_lru_scan_depth</code>来指定，如果从里边儿发现脏页，会把它们刷新到磁盘。这种刷新页面的方式被称之为<code>BUF_FLUSH_LRU</code>。 </li><li> 从<code>flush链表</code>中刷新一部分页面到磁盘。<br>后台线程也会定时从<code>flush链表</code>中刷新一部分页面到磁盘，刷新的速率取决于当时系统是不是很繁忙。这种刷新页面的方式被称之为<code>BUF_FLUSH_LIST</code>。 </li></ul><p>有时候后台线程刷新脏页的进度比较慢，导致用户线程在准备加载一个磁盘页到<code>Buffer Pool</code>时没有可用的缓存页，这时就会尝试看看<code>LRU链表</code>尾部有没有可以直接释放掉的未修改页面，如果没有的话会不得不将<code>LRU链表</code>尾部的一个脏页同步刷新到磁盘（和磁盘交互是很慢的，这会降低处理用户请求的速度）。这种刷新单个页面到磁盘中的刷新方式被称之为<code>BUF_FLUSH_SINGLE_PAGE</code>。</p><p>当然，有时候系统特别繁忙时，也可能出现用户线程批量的从<code>flush链表</code>中刷新脏页的情况，很显然在处理用户请求过程中去刷新脏页是一种严重降低处理速度的行为，这属于一种迫不得已的情况。</p><h3 id="9-多个Buffer-Pool实例"><a href="#9-多个Buffer-Pool实例" class="headerlink" title="9.多个Buffer Pool实例"></a>9.多个Buffer Pool实例</h3><p><code>Buffer Pool</code>本质是<code>InnoDB</code>向操作系统申请的一块连续的内存空间，在多线程环境下，访问<code>Buffer Pool</code>中的各种链表都需要加锁处理，在<code>Buffer Pool</code>特别大而且多线程并发访问特别高的情况下，单一的<code>Buffer Pool</code>可能会影响请求的处理速度。所以在<code>Buffer Pool</code>特别大的时候，我们可以把它们拆分成若干个小的<code>Buffer Pool</code>，每个<code>Buffer Pool</code>都称为一个<code>实例</code>，它们都是独立的，独立的去申请内存空间，独立的管理各种链表，所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。我们可以在服务器启动的时候通过设置<code>innodb_buffer_pool_instances</code>的值来修改<code>Buffer Pool</code>实例的个数，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure><p>这样就表明我们要创建2个<code>Buffer Pool</code>实例。</p><p>每个<code>Buffer Pool</code>实例实际占多少内存空间呢？其实使用这个公式算出来的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><p>也就是总共的大小除以实例的个数，结果就是每个<code>Buffer Pool</code>实例占用的大小。</p><p>不过也不是说<code>Buffer Pool</code>实例创建的越多越好，分别管理各个<code>Buffer Pool</code>也是需要性能开销的，<code>InnoDB</code>规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances 的值修改为1。而MySQL希望在<code>Buffer Pool</code>大于或等于1G的时候设置多个<code>Buffer Pool</code>实例。</p><h3 id="10-innodb-buffer-pool-chunk-size"><a href="#10-innodb-buffer-pool-chunk-size" class="headerlink" title="10.innodb_buffer_pool_chunk_size"></a>10.innodb_buffer_pool_chunk_size</h3><p>在<code>MySQL 5.7.5</code>之前，<code>Buffer Pool</code>的大小只能在服务器启动时通过配置<code>innodb_buffer_pool_size</code>启动参数来调整大小，在服务器运行过程中是不允许调整该值的。不过<code>MySQL</code>在<code>5.7.5</code>以及之后的版本中支持了在服务器运行过程中调整<code>Buffer Pool</code>大小的功能，但是有一个问题，就是每次当我们要重新调整<code>Buffer Pool</code>大小时，都需要重新向操作系统申请一块连续的内存空间，然后将旧的<code>Buffer Pool</code>中的内容复制到这一块新空间，这是极其耗时的。所以<code>MySQL</code>决定不再一次性为某个<code>Buffer Pool</code>实例向操作系统申请一大片连续的内存空间，而是以一个所谓的<code>chunk</code>为单位向操作系统申请空间。也就是说一个<code>Buffer Pool</code>实例其实是由若干个<code>chunk</code>组成的，一个<code>chunk</code>就代表一片连续的内存空间，里边儿包含了若干缓存页与其对应的控制块。</p><p>正是因为发明了这个<code>chunk</code>的概念，我们在服务器运行期间调整<code>Buffer Pool</code>的大小时就是以<code>chunk</code>为单位增加或者删除内存空间，而不需要重新向操作系统申请一片大的内存，然后进行缓存页的复制。这个所谓的<code>chunk</code>的大小是我们在启动操作<code>MySQL</code>服务器时通过<code>innodb_buffer_pool_chunk_size</code>启动参数指定的，它的默认值是<code>134217728</code>，也就是<code>128M</code>。不过需要注意的是，innodb_buffer_pool_chunk_size的值只能在服务器启动时指定，在服务器运行过程中是不可以修改的。</p><blockquote><p>为什么不允许在服务器运行过程中修改innodb_buffer_pool_chunk_size的值？因为innodb_buffer_pool_chunk_size的值代表InnoDB向操作系统申请的一片连续的内存空间的大小，如果你在服务器运行过程中修改了该值，就意味着要重新向操作系统申请连续的内存空间并且将原先的缓存页和它们对应的控制块复制到这个新的内存空间中，这是十分耗时的操作！ 另外，这个innodb_buffer_pool_chunk_size的值并不包含缓存页对应的控制块的内存空间大小，所以实际上InnoDB向操作系统申请连续内存空间时，每个chunk的大小要比innodb_buffer_pool_chunk_size的值大一些，约5%。</p></blockquote><h3 id="11-配置Buffer-Pool时的注意事项"><a href="#11-配置Buffer-Pool时的注意事项" class="headerlink" title="11.配置Buffer Pool时的注意事项"></a>11.配置Buffer Pool时的注意事项</h3><ul><li><p> <code>innodb_buffer_pool_size</code>必须是<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的倍数（这主要是想保证每一个<code>Buffer Pool</code>实例中包含的<code>chunk</code>数量相同）。<br>假设我们指定的<code>innodb_buffer_pool_chunk_size</code>的值是<code>128M</code>，<code>innodb_buffer_pool_instances</code>的值是<code>16</code>，那么这两个值的乘积就是<code>2G</code>，也就是说<code>innodb_buffer_pool_size</code>的值必须是<code>2G</code>或者<code>2G</code>的整数倍。比方说我们在启动<code>MySQL</code>服务器是这样指定启动参数的：<br>默认的<code>innodb_buffer_pool_chunk_size</code>值是<code>128M</code>，指定的<code>innodb_buffer_pool_instances</code>的值是<code>16</code>，所以<code>innodb_buffer_pool_size</code>的值必须是<code>2G</code>或者<code>2G</code>的整数倍，上边例子中指定的<code>innodb_buffer_pool_size</code>的值是<code>8G</code>，符合规定，所以在服务器启动完成之后我们查看一下该变量的值就是我们指定的<code>8G</code>（8589934592字节）：<br>如果我们指定的<code>innodb_buffer_pool_size</code>大于<code>2G</code>并且不是<code>2G</code>的整数倍，那么服务器会自动的把<code>innodb_buffer_pool_size</code>的值调整为<code>2G</code>的整数倍，比方说我们在启动服务器时指定的<code>innodb_buffer_pool_size</code>的值是<code>9G</code>：<br>那么服务器会自动把<code>innodb_buffer_pool_size</code>的值调整为<code>10G，</code>10737418240字节。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size=8G --innodb-buffer-pool-instances=16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| Variable_name           | Value      |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| innodb_buffer_pool_size | 8589934592 |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size=9G --innodb-buffer-pool-instances=16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">+-------------------------+-------------+</span><br><span class="line">| Variable_name           | Value       |</span><br><span class="line">+-------------------------+-------------+</span><br><span class="line">| innodb_buffer_pool_size | 10737418240 |</span><br><span class="line">+-------------------------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p> 如果在服务器启动时，<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的值已经大于<code>innodb_buffer_pool_size</code>的值，那么<code>innodb_buffer_pool_chunk_size</code>的值会被服务器自动设置为<code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code>的值。<br>比方说我们在启动服务器时指定的<code>innodb_buffer_pool_size</code>的值为<code>2G</code>，<code>innodb_buffer_pool_instances</code>的值为16，<code>innodb_buffer_pool_chunk_size</code>的值为<code>256M</code>：<br>由于<code>256M × 16 = 4G</code>，而<code>4G &gt; 2G</code>，所以<code>innodb_buffer_pool_chunk_size</code>值会被服务器改写为<code>innodb_buffer_pool_size/innodb_buffer_pool_instances</code>的值，也就是：<code>2G/16 = 128M</code>（134217728字节）。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --innodb-buffer-pool-size=2G --innodb-buffer-pool-instances=16 --innodb-buffer-pool-chunk-size=256M</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| Variable_name           | Value      |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">| innodb_buffer_pool_size | 2147483648 |</span><br><span class="line">+-------------------------+------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;innodb_buffer_pool_chunk_size&#x27;;</span><br><span class="line">+-------------------------------+-----------+</span><br><span class="line">| Variable_name                 | Value     |</span><br><span class="line">+-------------------------------+-----------+</span><br><span class="line">| innodb_buffer_pool_chunk_size | 134217728 |</span><br><span class="line">+-------------------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-Buffer-Pool中存储的其它信息"><a href="#12-Buffer-Pool中存储的其它信息" class="headerlink" title="12.Buffer Pool中存储的其它信息"></a>12.Buffer Pool中存储的其它信息</h3><p><code>Buffer Pool</code>的缓存页除了用来缓存磁盘上的页面以外，还可以存储锁信息、自适应哈希索引等信息。</p><h3 id="13-查看Buffer-Pool的状态信息"><a href="#13-查看Buffer-Pool的状态信息" class="headerlink" title="13.查看Buffer Pool的状态信息"></a>13.查看Buffer Pool的状态信息</h3><p><code>MySQL</code>给我们提供了<code>SHOW ENGINE INNODB STATUS</code>语句来查看关于<code>InnoDB</code>存储引擎运行过程中的一些状态信息，其中就包括<code>Buffer Pool</code>的一些信息，我们看一下（为了突出重点，我们只把输出中关于<code>Buffer Pool</code>的部分提取了出来）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total memory allocated 13218349056;</span><br><span class="line">Dictionary memory allocated 4014231</span><br><span class="line">Buffer pool size   786432</span><br><span class="line">Free buffers       8174</span><br><span class="line">Database pages     710576</span><br><span class="line">Old database pages 262143</span><br><span class="line">Modified db pages  124941</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 6195930012, not young 78247510485</span><br><span class="line">108.18 youngs/s, 226.15 non-youngs/s</span><br><span class="line">Pages read 2748866728, created 29217873, written 4845680877</span><br><span class="line">160.77 reads/s, 3.80 creates/s, 190.16 writes/s</span><br><span class="line">Buffer pool hit rate 956 / 1000, young-making rate 30 / 1000 not 605 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 710576, unzip_LRU len: 118</span><br><span class="line">I/O sum[134264]:cur[144], unzip sum[16]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">(...省略后边的许多状态)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>我们来详细看一下这里边的每个值都代表什么意思：</p><ul><li> <code>Total memory allocated</code>：代表<code>Buffer Pool</code>向操作系统申请的连续内存空间大小，包括全部控制块、缓存页、以及碎片的大小。 </li><li> <code>Dictionary memory allocated</code>：为数据字典信息分配的内存空间大小，注意这个内存空间和<code>Buffer Pool</code>没啥关系，不包括在<code>Total memory allocated</code>中。 </li><li> <code>Buffer pool size</code>：代表该<code>Buffer Pool</code>可以容纳多少缓存<code>页</code>，注意，单位是<code>页</code>！ </li><li> <code>Free buffers</code>：代表当前<code>Buffer Pool</code>还有多少空闲缓存页，也就是<code>free链表</code>中还有多少个节点。 </li><li> <code>Database pages</code>：代表<code>LRU</code>链表中的页的数量，包含<code>young</code>和<code>old</code>两个区域的节点数量。 </li><li> <code>Old database pages</code>：代表<code>LRU</code>链表<code>old</code>区域的节点数量。 </li><li> <code>Modified db pages</code>：代表脏页数量，也就是<code>flush链表</code>中节点的数量。 </li><li> <code>Pending reads</code>：正在等待从磁盘上加载到<code>Buffer Pool</code>中的页面数量。<br>当准备从磁盘中加载某个页面时，会先为这个页面在<code>Buffer Pool</code>中分配一个缓存页以及它对应的控制块，然后把这个控制块添加到<code>LRU</code>的<code>old</code>区域的头部，但是这个时候真正的磁盘页并没有被加载进来，<code>Pending reads</code>的值会跟着加1。 </li><li> <code>Pending writes LRU</code>：即将从<code>LRU</code>链表中刷新到磁盘中的页面数量。 </li><li> <code>Pending writes flush list</code>：即将从<code>flush</code>链表中刷新到磁盘中的页面数量。 </li><li> <code>Pending writes single page</code>：即将以单个页面的形式刷新到磁盘中的页面数量。 </li><li> <code>Pages made young</code>：代表<code>LRU</code>链表中曾经从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。<br>这里需要注意，一个节点每次只有从<code>old</code>区域移动到<code>young</code>区域头部时才会将<code>Pages made young</code>的值加1，也就是说如果该节点本来就在<code>young</code>区域，由于它符合在<code>young</code>区域1/4后边的要求，下一次访问这个页面时也会将它移动到<code>young</code>区域头部，但这个过程并不会导致<code>Pages made young</code>的值加1。 </li><li> <code>Page made not young</code>：在将<code>innodb_old_blocks_time</code>设置的值大于0时，首次访问或者后续访问某个处在<code>old</code>区域的节点时由于不符合时间间隔的限制而不能将其移动到<code>young</code>区域头部时，<code>Page made not young</code>的值会加1。<br>这里需要注意，对于处在<code>young</code>区域的节点，如果由于它在<code>young</code>区域的1/4处而导致它没有被移动到<code>young</code>区域头部，这样的访问并不会将<code>Page made not young</code>的值加1。 </li><li> <code>youngs/s</code>：代表每秒从<code>old</code>区域被移动到<code>young</code>区域头部的节点数量。 </li><li> <code>non-youngs/s</code>：代表每秒由于不满足时间限制而不能从<code>old</code>区域移动到<code>young</code>区域头部的节点数量。 </li><li> <code>Pages read</code>、<code>created</code>、<code>written</code>：代表读取，创建，写入了多少页。后边跟着读取、创建、写入的速率。 </li><li> <code>Buffer pool hit rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次该页面已经被缓存到<code>Buffer Pool</code>了。 </li><li> <code>young-making rate</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问使页面移动到<code>young</code>区域的头部了。</li></ul><p><strong>需要注意的一点是，这里统计的将页面移动到</strong><code>**young**</code><strong>区域的头部次数不仅仅包含从</strong><code>**old**</code><strong>区域移动到</strong><code>**young**</code><strong>区域头部的次数，还包括从</strong><code>**young**</code><strong>区域移动到</strong><code>**young**</code><strong>区域头部的次数（访问某个</strong><code>**young**</code><strong>区域的节点，只要该节点在</strong><code>**young**</code><strong>区域的1/4处往后，就会把它移动到</strong><code>**young**</code><strong>区域的头部）。</strong> </p><ul><li> <code>not (young-making rate)</code>：表示在过去某段时间，平均访问1000次页面，有多少次访问没有使页面移动到<code>young</code>区域的头部。</li></ul><p><strong>需要注意的一点是，这里统计的没有将页面移动到</strong><code>**young**</code><strong>区域的头部次数不仅仅包含因为设置了</strong><code>**innodb_old_blocks_time**</code><strong>系统变量而导致访问了</strong><code>**old**</code><strong>区域中的节点但没把它们移动到</strong><code>**young**</code><strong>区域的次数，还包含因为该节点在</strong><code>**young**</code><strong>区域的前1/4处而没有被移动到</strong><code>**young**</code><strong>区域头部的次数。</strong> </p><ul><li> <code>LRU len</code>：代表<code>LRU链表</code>中节点的数量。 </li><li> <code>unzip_LRU</code>：代表<code>unzip_LRU链表</code>中节点的数量。 </li><li> <code>I/O sum</code>：最近50s读取磁盘页的总数。 </li><li> <code>I/O cur</code>：现在正在读取的磁盘页数量。 </li><li> <code>I/O unzip sum</code>：最近50s解压的页面数量。 </li><li> <code>I/O unzip cur</code>：正在解压的页面数量。 </li></ul><h1 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h1><ol><li> 磁盘太慢，用内存作为缓存很有必要。 </li><li> <code>Buffer Pool</code>本质上是<code>InnoDB</code>向操作系统申请的一段连续的内存空间，可以通过<code>innodb_buffer_pool_size</code>来调整它的大小。 </li><li> <code>Buffer Pool</code>向操作系统申请的连续内存由控制块和缓存页组成，每个控制块和缓存页都是一一对应的，在填充足够多的控制块和缓存页的组合后，<code>Buffer Pool</code>剩余的空间可能产生不够填充一组控制块和缓存页，这部分空间不能被使用，也被称为<code>碎片</code>。 </li><li> <code>InnoDB</code>使用了许多<code>链表</code>来管理<code>Buffer Pool</code>。 </li><li> <code>free链表</code>中每一个节点都代表一个空闲的缓存页，在将磁盘中的页加载到<code>Buffer Pool</code>时，会从<code>free链表</code>中寻找空闲的缓存页。 </li><li> 为了快速定位某个页是否被加载到<code>Buffer Pool</code>，使用<code>表空间号 + 页号</code>作为<code>key</code>，缓存页作为<code>value</code>，建立哈希表。 </li><li> 在<code>Buffer Pool</code>中被修改的页称为<code>脏页</code>，脏页并不是立即刷新，而是被加入到<code>flush链表</code>中，待之后的某个时刻同步到磁盘上。 </li><li> <code>LRU链表</code>分为<code>young</code>和<code>old</code>两个区域，可以通过<code>innodb_old_blocks_pct</code>来调节<code>old</code>区域所占的比例。首次从磁盘上加载到<code>Buffer Pool</code>的页会被放到<code>old</code>区域的头部，在<code>innodb_old_blocks_time</code>间隔时间内访问该页不会把它移动到<code>young</code>区域头部。在<code>Buffer Pool</code>没有可用的空闲缓存页时，会首先淘汰掉<code>old</code>区域的一些页。 </li><li> 我们可以通过指定<code>innodb_buffer_pool_instances</code>来控制<code>Buffer Pool</code>实例的个数，每个<code>Buffer Pool</code>实例中都有各自独立的链表，互不干扰。 </li><li> 自<code>MySQL 5.7.5</code>版本之后，可以在服务器运行过程中调整<code>Buffer Pool</code>大小。每个<code>Buffer Pool</code>实例由若干个<code>chunk</code>组成，每个<code>chunk</code>的大小可以在服务器启动时通过启动参数调整。 </li><li> 可以用下边的命令查看<code>Buffer Pool</code>的状态信息：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十一]高性能MySQL调优实战</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%80%5D%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%E4%B8%80%5D%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一，数据库应该如何优化"><a href="#一，数据库应该如何优化" class="headerlink" title="一，数据库应该如何优化"></a>一，数据库应该如何优化</h1><p>数据库优化有很多层面。</p><h2 id="1-SQL与索引"><a href="#1-SQL与索引" class="headerlink" title="1.SQL与索引"></a>1.SQL与索引</h2><p>因为 SQL 语句是在我们的应用端编写的，所以第一步，我们可以在程序中对 SQL 语句进行优化，最终的目标是用到索引。这个是容易的也是最常用的优化手段。</p><h2 id="2-表与存储引擎"><a href="#2-表与存储引擎" class="headerlink" title="2.表与存储引擎"></a>2.表与存储引擎</h2><p>数据是存放在表里面的，表又是以不同的格式存放在存储引擎中的，所以我们可以选用特定的存储引擎，或者对表进行分区，对表结构进行拆分或者冗余处理，或者对表结构比如字段的定义进行优化。</p><h2 id="3-架构"><a href="#3-架构" class="headerlink" title="3.架构"></a>3.架构</h2><p>对于数据库的服务，我们可以对它的架构进行优化。如果只有一台数据库的服务器，我们可以运行多个实例，做集群的方案，做负载均衡。或者基于主从复制实现读写分离，让写的服务都访问 master 服务器，读的请求都访问从服务器，slave 服务器自动 master 主服务器同步数据。或者在数据库前面加一层缓存，达到减少数据库的压力，提升访问速度的目的。为了分散数据库服务的存储压力和访问压力，我们也可以把不同的数据分布到不同的服务节点，这个就是分库分表（scale out）。</p><p>注意主从（replicate）和分片（shard）的区别：</p><ol><li> 主从通过数据冗余实现高可用，和实现读写分离。 </li><li> 分片通过拆分数据分散存储和访问压力。 </li></ol><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4.配置"></a>4.配置</h2><p>数据库配置的优化，比如连接数，缓冲区大小等等，优化配置的目的都是为了更高效地利用硬件。</p><h2 id="5-操作系统与硬件"><a href="#5-操作系统与硬件" class="headerlink" title="5.操作系统与硬件"></a>5.操作系统与硬件</h2><p>从上往下，成本收益比慢慢地在增加。所以肯定不是查询一慢就堆硬件，堆硬件叫做向上的扩展（scale up）。</p><h1 id="二，慢日志查询"><a href="#二，慢日志查询" class="headerlink" title="二，慢日志查询"></a>二，慢日志查询</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。<code>long_query_time</code>的默认值为10，意思是运行10秒以上的语句。由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p><h2 id="2-实操"><a href="#2-实操" class="headerlink" title="2.实操"></a>2.实操</h2><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</p><p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><h3 id="2-1查看及开启"><a href="#2-1查看及开启" class="headerlink" title="2.1查看及开启"></a>2.1查看及开启</h3><h4 id="①日志"><a href="#①日志" class="headerlink" title="①日志"></a>①日志</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow_query_log%&#x27;;</span><br></pre></td></tr></table></figure><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log=1;</span><br></pre></td></tr></table></figure><p>只对窗口生效，重启服务失效。</p><h4 id="②时间"><a href="#②时间" class="headerlink" title="②时间"></a>②时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL long_query_time=0.1;</span><br></pre></td></tr></table></figure><p>全局变量设置，对所有客户端有效。但必须是设置后进行登录的客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION long_query_time=0.1; #session可省略</span><br></pre></td></tr></table></figure><p>对当前会话连接立即生效，对其他客户端无效。</p><p><strong>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time，而非大于等于。</strong></p><h4 id="③永久生效"><a href="#③永久生效" class="headerlink" title="③永久生效"></a>③永久生效</h4><p>修改配置文件my.cnf（其它系统变量也是如此）</p><p>[mysqld]下增加或修改参数</p><p>slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件 <a href="#fn1">[1]</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log =1</span><br><span class="line">slow_query_log_file=/var/lib/mysql/yhd-slow.log </span><br><span class="line">long_query_time=3</span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><h3 id="2-2Case"><a href="#2-2Case" class="headerlink" title="2.2Case"></a>2.2Case</h3><p>记录慢SQL并后续分析</p><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="3-日志分析工具-mysqldumpslow"><a href="#3-日志分析工具-mysqldumpslow" class="headerlink" title="3.日志分析工具-mysqldumpslow"></a>3.日志分析工具-mysqldumpslow</h2><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code>。</p><p>查看mysqldumpslow的帮助信息（windows下需要安装perl环境）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure><blockquote><p>-a: 不将数字抽象成N，字符串抽象成S<br>-s: 是表示按照何种方式排序；<br>c: 访问次数<br>l: 锁定时间<br>r: 返回记录<br>t: 查询时间<br>al:平均锁定时间<br>ar:平均返回记录数<br>at:平均查询时间<br>-t: 即为返回前面多少条的数据；<br>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p></blockquote><h3 id="3-1常用SQL"><a href="#3-1常用SQL" class="headerlink" title="3.1常用SQL"></a>3.1常用SQL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/yhd-slow.log</span><br><span class="line">得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/yhd-slow.log</span><br><span class="line">得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/yhd-slow.log</span><br><span class="line">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/yhd-slow.log | more</span><br></pre></td></tr></table></figure><h2 id="4-SHOW-PROCESSLIST"><a href="#4-SHOW-PROCESSLIST" class="headerlink" title="4.SHOW PROCESSLIST"></a>4.SHOW PROCESSLIST</h2><p>作用：查询所有用户正在干什么。</p><p>如果出现不顺眼的：kill [id]</p><h1 id="三，EXPLAIN调优实战"><a href="#三，EXPLAIN调优实战" class="headerlink" title="三，EXPLAIN调优实战"></a>三，EXPLAIN调优实战</h1><h2 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1.准备数据"></a>1.准备数据</h2><p>员工表插入500w数据，部门表插入10w数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept`</span><br><span class="line">(</span><br><span class="line">    `id`       <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `deptName` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `address`  <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `ceo`      <span class="type">INT</span>     <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp`</span><br><span class="line">(</span><br><span class="line">    `id`     <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `empno`  <span class="type">INT</span>     <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name`   <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age`    <span class="type">INT</span>(<span class="number">3</span>)      <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `deptId` <span class="type">INT</span>(<span class="number">11</span>)     <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">    #<span class="keyword">CONSTRAINT</span> `fk_dept_id` <span class="keyword">FOREIGN</span> KEY (`deptId`) <span class="keyword">REFERENCES</span> `t_dept` (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line">#生成随机字符串</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n</span><br><span class="line">        DO</span><br><span class="line">            <span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建往emp表中插入数据的存储过程</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_emp(<span class="keyword">START</span> <span class="type">INT</span>, max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT</span><br><span class="line">        #循环</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (empno, NAME, age, deptid)</span><br><span class="line">        <span class="keyword">VALUES</span> ((<span class="keyword">START</span> <span class="operator">+</span> i), rand_string(<span class="number">6</span>), rand_num(<span class="number">30</span>, <span class="number">50</span>), rand_num(<span class="number">1</span>, <span class="number">10000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">        <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建往dept表中插入数据的存储过程</span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `insert_dept`(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept (deptname, address, ceo) <span class="keyword">VALUES</span> (rand_string(<span class="number">8</span>), rand_string(<span class="number">10</span>), rand_num(<span class="number">1</span>, <span class="number">500000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">        <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#执行存储过程，往dept表添加<span class="number">10</span>万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_dept(<span class="number">100000</span>);</span><br><span class="line">#执行存储过程，往emp表添加<span class="number">500</span>万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_emp(<span class="number">100000</span>, <span class="number">5000000</span>);</span><br></pre></td></tr></table></figure><h2 id="2-批量删除索引"><a href="#2-批量删除索引" class="headerlink" title="2.批量删除索引"></a>2.批量删除索引</h2><p><strong>建立好的索引在哪里？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> t_emp ; <span class="comment">-- 只能查看索引，但不能删除。</span></span><br><span class="line">information_schema.STATISTICS <span class="comment">-- 存储索引的表（元数据库，统计表），我们可以对表数据进行删除操作。</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong></p><ol><li>删除某一个索引</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_xxx ON emp</span><br></pre></td></tr></table></figure><ol start="2"><li>查出该表有哪些索引，索引名–&gt;集合</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> t_emp</span><br><span class="line"><span class="comment">-- 元数据：meta DATA  描述数据的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> index_name</span><br><span class="line"><span class="keyword">FROM</span> information_schema.STATISTICS</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;t_emp&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> table_schema <span class="operator">=</span> <span class="string">&#x27;mydb&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> index_name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> seq_in_index <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="3-单表使用索引"><a href="#3-单表使用索引" class="headerlink" title="3.单表使用索引"></a>3.单表使用索引</h2><p>建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_deptid_name <span class="keyword">ON</span> emp(age,deptid,NAME);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> emp(NAME);</span><br></pre></td></tr></table></figure><h3 id="3-1-全值匹配"><a href="#3-1-全值匹配" class="headerlink" title="3.1 全值匹配"></a>3.1 全值匹配</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 单表查询<span class="operator">-</span>全值匹配</span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.age <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">  <span class="keyword">and</span> deptid <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPLAIN</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> emp.age <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">  <span class="keyword">and</span> deptid <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">AND</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491456170-c377987c-20e4-48d3-8c57-1c281333f915.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u99be6438&margin=%5Bobject%20Object%5D&name=1.png&originHeight=669&originWidth=1627&originalType=binary&ratio=1&rotation=0&showTitle=false&size=72502&status=done&style=none&taskId=u55d8c0c7-c4a1-426d-9c8a-ac028ee5610&title=" alt="1.png"></p><h3 id="3-2-最左前缀法则"><a href="#3-2-最左前缀法则" class="headerlink" title="3.2 最左前缀法则"></a>3.2 最左前缀法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 单表查询-左前缀法则</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=1 AND deptid=1 AND NAME=&#x27;aaa&#x27;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=1 AND deptid=1;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=1 AND NAME=&#x27;aaa&#x27; AND deptid=1;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE deptid=1 AND NAME =&#x27;aaa&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491464294-700567fe-de9c-4bec-a160-19f057af9664.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uad589f02&margin=%5Bobject%20Object%5D&name=2.png&originHeight=370&originWidth=1675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77031&status=done&style=none&taskId=u84a1a60b-a4c9-431b-aab3-390a731d305&title=" alt="2.png"></p><p><strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</strong></p><h3 id="3-3-索引列上计算-函数导致索引失效"><a href="#3-3-索引列上计算-函数导致索引失效" class="headerlink" title="3.3 索引列上计算/函数导致索引失效"></a>3.3 索引列上计算/函数导致索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 单表查询-操作索引列导致索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name  LIKE &#x27;abc%&#x27;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE LEFT(emp.name,3) = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491470761-e9ab9bf0-b0fd-466b-a22e-78f9db05ac18.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0f50ef69&margin=%5Bobject%20Object%5D&name=3.png&originHeight=212&originWidth=1776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40690&status=done&style=none&taskId=ubc30bbc7-0caa-4576-8310-56d52ce4621&title=" alt="3.png"></p><h3 id="3-4-范围查询导致的索引失效"><a href="#3-4-范围查询导致的索引失效" class="headerlink" title="3.4 范围查询导致的索引失效"></a>3.4 范围查询导致的索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line">SELECT </span><br><span class="line">  SQL_NO_CACHE * </span><br><span class="line">FROM</span><br><span class="line">  emp </span><br><span class="line">WHERE emp.name = &#x27;abc&#x27;</span><br><span class="line">  AND emp.deptId &gt; 20 </span><br><span class="line">  AND  emp.age = 30 ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491478562-2407f3a6-238e-4a41-9c40-f13d878a64be.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0fd297ca&margin=%5Bobject%20Object%5D&name=4.png&originHeight=278&originWidth=1778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30777&status=done&style=none&taskId=u447c694d-200e-4a12-9594-cdfab0c4284&title=" alt="4.png"></p><p><strong>应用开发中范围查询，例如： 金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。</strong></p><h3 id="3-5-不等于-或者-lt-gt-索引失效"><a href="#3-5-不等于-或者-lt-gt-索引失效" class="headerlink" title="3.5  不等于(!= 或者&lt;&gt;)索引失效"></a>3.5  不等于(!= 或者&lt;&gt;)索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name &lt;&gt;  &#x27;abc&#x27; ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491485131-265339c4-634a-4f9d-85ff-425d9bf11bbd.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ueb6021dc&margin=%5Bobject%20Object%5D&name=5.png&originHeight=83&originWidth=1769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19058&status=done&style=none&taskId=u795a528f-33c3-4c30-ae8e-f7b4a90376e&title=" alt="5.png"></p><h3 id="3-6-is-not-null无法使用索引，is-null可使用索引"><a href="#3-6-is-not-null无法使用索引，is-null可使用索引" class="headerlink" title="3.6 is not null无法使用索引，is null可使用索引"></a>3.6 is not null无法使用索引，is null可使用索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age IS NULL;</span><br><span class="line">#用到索引  </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE age IS NOT NULL;</span><br><span class="line">#未用到索引</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491492669-05d3cbe9-c4fc-46b6-976d-47d7ad05f8da.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63f28bbf&margin=%5Bobject%20Object%5D&name=6.png&originHeight=193&originWidth=1780&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37313&status=done&style=none&taskId=u4db37747-2dc5-4415-accd-910c1ea3e91&title=" alt="6.png"></p><h3 id="3-7-like以-开头索引失效"><a href="#3-7-like以-开头索引失效" class="headerlink" title="3.7 like以%开头索引失效"></a>3.7 like以%开头索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE NAME LIKE &#x27;%aaa&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491500063-fb3c4a33-f97d-4266-a05c-86fde429b288.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubdad3760&margin=%5Bobject%20Object%5D&name=7.png&originHeight=216&originWidth=1803&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24797&status=done&style=none&taskId=ub22f6bde-0c42-4eec-b801-c53dbdc66c9&title=" alt="7.png"></p><h3 id="3-8-类型转换导致索引失效"><a href="#3-8-类型转换导致索引失效" class="headerlink" title="3.8 类型转换导致索引失效"></a>3.8 类型转换导致索引失效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE NAME=123;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491506837-e3685860-d2c5-4f77-894b-268f1612d6e8.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u969914ec&margin=%5Bobject%20Object%5D&name=8.png&originHeight=224&originWidth=1812&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25560&status=done&style=none&taskId=uda038af4-3c43-413f-a932-5e758817a2c&title=" alt="8.png"></p><p><strong>设计实体类属性时，一定要与数据库字段类型相对应，否则会出现类型转换的情况，导致索引失效。</strong></p><h2 id="4-关联查询优化"><a href="#4-关联查询优化" class="headerlink" title="4. 关联查询优化"></a>4. 关联查询优化</h2><h3 id="4-1-左外连接"><a href="#4-1-左外连接" class="headerlink" title="4.1 左外连接"></a>4.1 左外连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from emp left join dept on emp.deptId=dept.id;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491513538-f2345fca-602d-43eb-b2fe-5b2e4fe417a0.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubd7e078b&margin=%5Bobject%20Object%5D&name=9.png&originHeight=267&originWidth=1765&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27831&status=done&style=none&taskId=ub2ea1fc8-943f-4fe1-a479-e7462d30827&title=" alt="9.png"></p><p>这种情况下，驱动表无法避免全表扫描，但是因为被驱动表的主键存在索引并且是两张表关联查询的关联条件，所以可以避免被驱动表的全表扫描。</p><h3 id="4-2-内连接-TODO"><a href="#4-2-内连接-TODO" class="headerlink" title="4.2 内连接(TODO)"></a>4.2 内连接(TODO)</h3><p>内连接MySQL会自动为我们选择驱动表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain  select * from dept  straight_join emp on emp.deptId=dept.id;</span><br><span class="line">## 1. dept 全表扫描   10w</span><br><span class="line">## 2. emp deptid  ref</span><br><span class="line">explain    select * from dept join emp on emp.deptId=dept.id;</span><br><span class="line">## 1. emp 500w</span><br><span class="line">## 2. dept id ref</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491521056-21c44295-fdf0-48cd-af31-2727388d6406.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf7b1a531&margin=%5Bobject%20Object%5D&name=10.png&originHeight=256&originWidth=1768&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47117&status=done&style=none&taskId=u15296664-5f58-4728-9a31-6cf5d2f00e3&title=" alt="10.png"></p><ol><li> 保证被驱动表的join字段被索引 </li><li> left join 时，选择小表作为驱动表，大表作为被驱动表 </li><li> inner join 时，mysql会自动将小结果集的表选为驱动表。选择相信mysql优化策略。 </li><li> 子查询尽量不要放在被驱动表，衍生表建不了索引。 </li><li> 能够直接多表关联的尽量直接关联，不用子查询。 </li><li> 两张表的连接查询，比方说 left join  right、inner join 等，他们的连表方式是什么？ </li><li> 连表查询一共三种算法：nlj  bnl  bka 算法 。 </li><li> right join 底层，会给你转化为left join。 </li></ol><h3 id="4-3-子查询优化"><a href="#4-3-子查询优化" class="headerlink" title="4.3 子查询优化"></a>4.3 子查询优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#①不推荐</span><br><span class="line">explain SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  emp</span><br><span class="line">WHERE emp.id NOT IN   -- not in 导致无法对in进行优化，用不了exists</span><br><span class="line">  (SELECT</span><br><span class="line">    dept.ceo</span><br><span class="line">  FROM</span><br><span class="line">    dept</span><br><span class="line">  WHERE dept.ceo IS NOT NULL) ; -- is not null 导致索引失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#②推荐</span><br><span class="line">explain SELECT</span><br><span class="line">  emp.*</span><br><span class="line">FROM</span><br><span class="line">  emp</span><br><span class="line">  LEFT JOIN dept</span><br><span class="line">    ON emp.id = dept.ceo  -- 如果ceo没有索引，两张表都是全表扫描，如果ceo有索引，被驱动表就是ref级别</span><br><span class="line">WHERE dept.id IS NULL ;</span><br><span class="line"># 尝试在ceo创建索引后，确实是  create index idx_ceo on dept(ceo);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491529644-b74d14b2-2509-40c7-8b55-901771849bcd.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u913673e1&margin=%5Bobject%20Object%5D&name=11.png&originHeight=687&originWidth=1774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66874&status=done&style=none&taskId=ua21a55b1-35c9-405e-96fd-65dc0b7e4de&title=" alt="11.png"></p><p><strong>尽量不要使用not in  或者 not exists，会使索引失效。</strong></p><p>MySQL自动做出的子查询优化，物化子查询，转为半连接</p><p>物化子查询：把子查询的结果查出来后，建立一个临时表，“物化”-&gt;变成一张内存临时表</p><p>半连接：把子查询转化为类似连接查询的方式，但又不是真正的连接查询，所以叫 半 连接优化</p><h2 id="5-排序分组优化"><a href="#5-排序分组优化" class="headerlink" title="5.排序分组优化"></a>5.排序分组优化</h2><h3 id="5-1-无过滤，不索引"><a href="#5-1-无过滤，不索引" class="headerlink" title="5.1 无过滤，不索引"></a>5.1 无过滤，不索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY age,deptid; </span><br><span class="line">#没用上索引，Using filesort </span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY age,deptid LIMIT 10; </span><br><span class="line">#使用上索引 null</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491536353-0bd6fd69-2673-476c-b248-b2e80fcbffcb.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u24d10f43&margin=%5Bobject%20Object%5D&name=12.png&originHeight=183&originWidth=1582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37338&status=done&style=none&taskId=u1edba00b-5e34-4259-95c8-083f2f0c62f&title=" alt="12.png"></p><p>因为<code>order by</code>的字段顺序和索引的顺序一样，所以此时会先尝试内存排序，但是因为上面的sql没有limit，导致内存放不下，使用了文件排序（文件系统级别，相当于在磁盘做排序），所以第一条sql效率更低。</p><p><strong>order后面的字段想要使用索引，必须要有过滤条件，limit也行。</strong></p><h3 id="5-2顺序错，必排序"><a href="#5-2顺序错，必排序" class="headerlink" title="5.2顺序错，必排序"></a>5.2顺序错，必排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid;</span><br><span class="line"></span><br><span class="line"># Using index condition</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid,NAME;</span><br><span class="line"></span><br><span class="line"># Using index condition</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid,empno;</span><br><span class="line"></span><br><span class="line"># Using index condition; Using filesort</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY NAME,deptid;</span><br><span class="line"></span><br><span class="line"># Using index condition; Using filesort</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE deptid=45 ORDER BY age;</span><br><span class="line"># Using where; Using filesort</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491544580-01f4c526-3629-4473-a484-3a22cb9faaa0.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u54b993fc&margin=%5Bobject%20Object%5D&name=13.png&originHeight=419&originWidth=1785&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105747&status=done&style=none&taskId=ubcd427eb-7240-496b-9649-1864b3852cf&title=" alt="13.png">在SQL语句中的顺序一定要和定义索引中的字段顺序完全一致。</p><h3 id="5-3-方向反，必排序"><a href="#5-3-方向反，必排序" class="headerlink" title="5.3 方向反，必排序"></a>5.3 方向反，必排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid DESC, NAME DESC ;</span><br><span class="line">#Using where</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE age=45 ORDER BY deptid ASC, NAME DESC ;</span><br><span class="line">#Using index condition; Using filesort</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640491551554-8a74b76b-19e2-46fe-a3a3-7035195101c4.png#clientId=u59747a0e-b9d8-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8058c6b1&margin=%5Bobject%20Object%5D&name=14.png&originHeight=183&originWidth=1778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44088&status=done&style=none&taskId=u5310533d-7e53-441e-ae67-7c0797b75c8&title=" alt="14.png"></p><p><strong>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</strong></p><p>要么全升序、要么全降序。有升有降无法使用索引。</p><h3 id="5-4-索引的选择"><a href="#5-4-索引的选择" class="headerlink" title="5.4 索引的选择"></a>5.4 索引的选择</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640502174193-eabb2dc2-2270-4142-87a8-15983e19f611.png#clientId=u74e58dfd-b4b5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u33361d21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=367&originWidth=1779&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79336&status=done&style=shadow&taskId=u89a45289-9231-4915-8ba6-b6af12a6b1b&title=" alt="image.png"></p><p><strong>两个索引同时存在，mysql自动选择最优的方案，但是，随着数据量的变化，选择的索引也会随之变化的。</strong></p><p>所有的排序都是在条件过滤之后才执行的，所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。</p><p>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围（过滤条件）字段上。反之，亦然。</p><p>扫描行数的多少，就是explain里的rows，可以说明一个需要扫描的行数多，一个扫描行数少，扫描行数多，代表成本高，扫描行数少代表成本少。优化器最终是对比成本值的大小来选取索引的。准确的说，是MySQL基于成本，优化器是在server层。</p><p>有时候优化器会选择错索引为什么？</p><ol><li><p>主要是出在优化器预估行数上，这个涉及到了一条sql的执行流程，语法分析，词法分析之后，进入优化阶段，由优化器进行优化，在优化阶段，会尽可能的生成全部的执行计划，然后对比一下哪一个成本值最低，就选它，所以优化器有一个选择索引，选择表的连接顺序的过程，索引不同，成本不同，读表顺序不同，成本不同，索引的选取，需要存储引擎提供统计信息，innodb中，统计信息是随机采样，随机选取8个索引页，取平均值，当做该索引的全部情况，也就是部分代表整体，也就是最终导致rows那里是个预估值，而不是准确的。所以有时候MySQL选错了索引，有一定概率，是由于这个随机采样造成的。而随机采样的不准确，是由于数据不断添加导致索引页的分裂，导致有些页内数据较少。  </p><blockquote><p>解决方案：</p><ol><li> 执行一下alter table +表名 就可以使统计信息稍微准确点，他会重新构建索引，使索引页保持紧凑，这个就是B+树的分裂。 </li><li> 调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。 </li></ol></blockquote></li><li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。  </p><blockquote><p>解决方案：</p><ol><li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li><li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。</li></ol></blockquote></li></ol><h3 id="5-5-双路排序-amp-单路排序"><a href="#5-5-双路排序-amp-单路排序" class="headerlink" title="5.5  双路排序&amp;单路排序"></a>5.5  双路排序&amp;单路排序</h3><p>如果不在索引列上，filesort有两种算法： mysql就要启动双路排序和单路排序。</p><p><strong>双路排序</strong></p><p>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</p><p>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p><p>取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p><p><strong>单路排序</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论</strong></p><p>由于单路是后出的，总体而言好过双路。</p><p>但是用单路有问题：</p><p>在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I/O。</p><p>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><p><strong>优化策略</strong></p><p>增大sort_buffer_size参数的设置</p><p>增大max_length_for_sort_data参数的设置</p><p>减少select 后面的查询的字段。</p><p><strong>提高order by的速度</strong></p><ol><li>Order by时select * 是一个大忌。只Query需要的字段， 这点非常重要。</li></ol><blockquote><p>当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</p><p>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</p></blockquote><ol start="2"><li>尝试提高 sort_buffer_size</li></ol><blockquote><p>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的  1M-8M之间调整。 MySQL5.7，InnoDB存储引擎默认值是1048576字节，1MB。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%sort_buffer_size%&#x27;;</span><br></pre></td></tr></table></figure><ol start="3"><li>尝试提高 max_length_for_sort_data</li></ol><blockquote><p>提高这个参数， 会增加用改进算法的概率。</p><p>但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%max_length_for_sort_data%&#x27;; #默认1024字节</span><br></pre></td></tr></table></figure><h3 id="5-6-分组优化"><a href="#5-6-分组优化" class="headerlink" title="5.6 分组优化"></a>5.6 分组优化</h3><p>group by 使用索引的原则几乎跟order by一致 ，唯一区别：</p><p>group by 先排序再分组，遵照索引建的最佳左前缀法则</p><p>当无法使用索引列，增大max_length_for_sort_data和sort_buffer_size参数的设置</p><p>where高于having,能写在where限定的条件就不要写在having中了</p><p>group by没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引。</p><h2 id="6-覆盖索引"><a href="#6-覆盖索引" class="headerlink" title="6. 覆盖索引"></a>6. 覆盖索引</h2><p>禁止使用select *，禁止查询与业务无关字段，尽量使用覆盖索引，防止回表。</p><p><strong>覆盖索引减少了 IO 次数，减少了数据的访问量，可以大大地提升查询效率。</strong></p><h1 id="四，追踪优化器"><a href="#四，追踪优化器" class="headerlink" title="四，追踪优化器"></a>四，追踪优化器</h1><p>前面的原理篇详细分析过，在此不再赘述。</p><h1 id="五，-分库分表"><a href="#五，-分库分表" class="headerlink" title="五， 分库分表"></a>五， 分库分表</h1><p>从维度来说分成两种，一种是垂直，一种是水平。</p><p>垂直切分：基于表或字段划分，表结构不同。我们有单库的分表，也有多库的分库。</p><p>水平切分：基于数据划分，表结构相同，数据不同，也有同库的水平切分和多库的切分。</p><h2 id="1-垂直切分"><a href="#1-垂直切分" class="headerlink" title="1.垂直切分"></a>1.垂直切分</h2><p>垂直分表有两种，一种是单库的，一种是多库的。</p><h3 id="1-1-单库垂直分表"><a href="#1-1-单库垂直分表" class="headerlink" title="1.1 单库垂直分表"></a>1.1 单库垂直分表</h3><p>单库分表，比如：商户信息表，拆分成基本信息表，联系方式表，结算信息表，附件表等等。</p><p>可以考虑根据冷热点字段拆分，是否经常发生修改操作拆分，根据字段功能拆分。</p><h3 id="1-2-多库垂直分表"><a href="#1-2-多库垂直分表" class="headerlink" title="1.2 多库垂直分表"></a>1.2 多库垂直分表</h3><p>多库垂直分表就是把原来存储在一个库的不同的表，拆分到不同的数据库。</p><p>比如电商平台的消费系统：一开始，商品表，商品详情表，订单表，用户表，支付记录表，库存表，风控表都在一个库里面，随着数据的增长和业务的扩张，可以考虑将商品和商品详情表单独放到一个库，订单表单独放到一个库，支付记录单独放到一个库，库存表单独放到一个库，风控表单独放到一个库。</p><p>当我们对原来的一张表做了分库的处理，如果某些业务系统的数据还是有一个非常快的增长速度，比如说订单数据库的订单表，数据量达到了几个亿，这个时候硬件限制导致的性能问题还是会出现，所以从这个角度来说垂直切分并没有从根本上解决单库单表数据量过大的问题。在这个时候，我们还需要对我们的数据做一个水平的切分。</p><h2 id="2-水平拆分"><a href="#2-水平拆分" class="headerlink" title="2.水平拆分"></a>2.水平拆分</h2><p>当我们的客户表数量已经到达数千万甚至上亿的时候，单表的存储容量和查询效率都会出现问题，我们需要进一步对单张表的数据进行水平切分。水平切分的每个数据库的表结构都是一样的，只是存储的数据不一样，比如每个库存储 1000 万的数据。</p><p>水平切分也可以分成两种，一种是单库的，一种是多库的。</p><h3 id="2-1-单库水平分表"><a href="#2-1-单库水平分表" class="headerlink" title="2.1 单库水平分表"></a>2.1 单库水平分表</h3><p>银行的交易流水表，所有进出的交易都需要登记这张表，因为绝大部分时候客户都是查询当天的交易和一个月以内的交易数据，所以我们根据使用频率把这张表拆分成三张表：</p><p>当天表：只存储当天的数据。</p><p>当月表：在夜间运行一个定时任务，前一天的数据，全部迁移到当月表。用的是 insert into select，然后 delete。</p><p>历史表：同样是通过定时任务，把登记时间超过 30 天的数据，迁移到 history历史表（历史表的数据非常大，我们按照月度，每个月建立分区）。</p><p>跟分区一样，这种方式虽然可以一定程度解决单表查询性能的问题，但是并不能解决单机存储瓶颈的问题。</p><h3 id="2-2-多库水平分表"><a href="#2-2-多库水平分表" class="headerlink" title="2.2 多库水平分表"></a>2.2 多库水平分表</h3><p>比如客户表，我们拆分到多个库存储，表结构是完全一样的。</p><p><img src="https://img-blog.csdnimg.cn/2021022621260117.jpg#pic_center#crop=0&crop=0&crop=1&crop=1&id=KoEDL&originHeight=171&originWidth=643&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>一般我们说的分库分表都是跨库的分表。</p><h2 id="3-分库分表带来的问题"><a href="#3-分库分表带来的问题" class="headerlink" title="3. 分库分表带来的问题"></a>3. 分库分表带来的问题</h2><h3 id="3-1-跨库关联查询"><a href="#3-1-跨库关联查询" class="headerlink" title="3.1 跨库关联查询"></a>3.1 跨库关联查询</h3><p>比如查询合同信息的时候要关联客户数据，由于是合同数据和客户数据是在不同的数据库，那么我们肯定不能直接使用 join 的这种方式去做关联查询。</p><p><strong>解决方案</strong></p><h4 id="①字段冗余"><a href="#①字段冗余" class="headerlink" title="①字段冗余"></a>①字段冗余</h4><p>比如我们查询合同库的合同表的时候需要关联客户库的客户表，我们可以直接把一些经常关联查询的客户字段放到合同表，通过这种方式避免跨库关联查询的问题。</p><h4 id="②数据同步"><a href="#②数据同步" class="headerlink" title="②数据同步"></a>②数据同步</h4><p>比如商户系统要查询产品系统的产品表，我们干脆在商户系统创建一张产品表，通过 ETL 或者其他方式定时同步产品数据。</p><h4 id="③全局表（广播表）"><a href="#③全局表（广播表）" class="headerlink" title="③全局表（广播表）"></a>③全局表（广播表）</h4><p>比如行名行号信息被很多业务系统用到，如果我们放在核心系统，每个系统都要去关联查询，这个时候我们可以在所有的数据库都存储相同的基础数据。</p><h4 id="④ER表"><a href="#④ER表" class="headerlink" title="④ER表"></a>④ER表</h4><p>我们有些表的数据是存在逻辑的主外键关系的，比如订单表 order_info，存的是汇总的商品数，商品金额；订单明细表 order_detail，是每个商品的价格，个数等等。或者叫做从属关系，父表和子表的关系。他们之间会经常有关联查询的操作，如果父表的数据和子表的数据分别存储在不同的数据库，跨库关联查询也比较麻烦。所以我们能不能把父表的数据和从属于父表的数据落到一个节点上呢？</p><p>比如 order_id=1001 的数据在 node1，它所有的明细数据也放到 node1；order_id=1002 的数据在 node2，它所有的明细数据都放到 node2，这样在关联查询的时候依然是在一个数据库。</p><p>上面的思路都是通过合理的数据分布避免跨库关联查询，实际上在我们的业务中，也是尽量不要用跨库关联查询，如果出现了这种情况，就要分析一下业务或者数据拆分是不是合理。如果还是出现了需要跨库关联的情况，那我们就只能用最后一种办法。</p><h4 id="⑤系统层组装"><a href="#⑤系统层组装" class="headerlink" title="⑤系统层组装"></a>⑤系统层组装</h4><p>在不同的数据库节点把符合条件数据的数据查询出来，然后重新组装，返回给客户端。</p><h3 id="3-2-分布式事务"><a href="#3-2-分布式事务" class="headerlink" title="3.2 分布式事务"></a>3.2 分布式事务</h3><p>具体分布式事务会单独写一篇文章</p><h3 id="3-3-排序，翻页，函数计算问题"><a href="#3-3-排序，翻页，函数计算问题" class="headerlink" title="3.3 排序，翻页，函数计算问题"></a>3.3 排序，翻页，函数计算问题</h3><p>跨节点多库进行查询时，会出现 limit 分页，order by 排序的问题。比如有两个节点，节点 1 存的是奇数 id=1,3,5,7,9……；节点 2 存的是偶数 id=2,4,6,8,10……</p><p>执行 select * from user_info order by id limit 0,10</p><p>需要在两个节点上各取出 10 条，然后合并数据，重新排序。</p><p>max、min、sum、count 之类的函数在进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。</p><h3 id="3-4-全局主键避重"><a href="#3-4-全局主键避重" class="headerlink" title="3.4 全局主键避重"></a>3.4 全局主键避重</h3><p>MySQL 的数据库里面字段有一个自增的属性，Oracle 也有 Sequence 序列。如果是一个数据库，那么可以保证 ID 是不重复的，但是水平分表以后，每个表都按照自己的规律自增，肯定会出现 ID 重复的问题，这个时候我们就不能用本地自增的方式了。</p><p><strong>解决方案</strong></p><h4 id="①UUID"><a href="#①UUID" class="headerlink" title="①UUID"></a>①UUID</h4><p>UUID 标准形式包含 32 个 16 进制数字，分为 5 段，形式为 8-4-4-4-12 的 36 个字符，例如：c4e7956c-03e7-472c-8909-d733803e79a9。</p><p>UUID 是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显，由于 UUID 非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在 InnoDB 中，UUID 的无序性会引起数据位置频繁变动，导致分页。</p><h4 id="②数据库"><a href="#②数据库" class="headerlink" title="②数据库"></a>②数据库</h4><p>把序号维护在数据库的一张表中。这张表记录了全局主键的类型、位数、起始值，当前值。当其他应用需要获得全局 ID 时，先 for update 锁行，取到值+1 后并且更新后返回。并发性比较差。</p><h4 id="③redis"><a href="#③redis" class="headerlink" title="③redis"></a>③redis</h4><p>基于 Redis 的 INT 自增的特性，使用批量的方式降低数据库的写压力，每次获取一段区间的 ID 号段，用完之后再去数据库获取，可以大大减轻数据库的压力。</p><h4 id="④雪花算法"><a href="#④雪花算法" class="headerlink" title="④雪花算法"></a>④雪花算法</h4><p>优点：毫秒数在高位，生成的 ID 整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上 QPS 约为 409.6w/s(1000*2^12)，并且整个分布式系统内不会产生 ID 碰撞；可根据自身业务灵活分配 bit 位。</p><p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成 ID 重复。</p><h2 id="4-多数据源-读写数据源的解决方案"><a href="#4-多数据源-读写数据源的解决方案" class="headerlink" title="4. 多数据源/读写数据源的解决方案"></a>4. 多数据源/读写数据源的解决方案</h2><p>分析一下 SQL 执行经过的流程：</p><p>DAO——Mapper（ORM）——JDBC——代理——数据库服务</p><h3 id="4-1-客户端DAO-层"><a href="#4-1-客户端DAO-层" class="headerlink" title="4.1 客户端DAO 层"></a>4.1 客户端DAO 层</h3><p>在我们连接到某一个数据源之前，我们先根据配置的分片规则，判断需要连接到哪些节点，再建立连接。</p><p>Spring 中提供了一个抽象类 AbstractRoutingDataSource，可以实现数据源的动态切换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）aplication.properties 定义多个数据源</span><br><span class="line">2）创建@TargetDataSource 注解</span><br><span class="line">3）创建 DynamicDataSource 继承 AbstractRoutingDataSource</span><br><span class="line">4）多数据源配置类 DynamicDataSourceConfig</span><br><span class="line">5）创建切面类 DataSourceAspect，对添加了@TargetDataSource 注解的</span><br><span class="line">类进行拦截设置数据源。</span><br><span class="line">6）在 启 动 类 上 自 动 装 配 数 据 源 配 置</span><br><span class="line">@Import(&#123;DynamicDataSourceConfig.class&#125;)</span><br><span class="line">7）在 实 现 类 上 加 上 注 解 ， 如 @TargetDataSource(name =</span><br><span class="line">DataSourceNames.SECOND)，调用</span><br></pre></td></tr></table></figure><p>在 DAO 层实现的优势：不需要依赖 ORM 框架，即使替换了 ORM 框架也不受影响。实现简单（不需要解析 SQL 和路由规则），可以灵活地定制。</p><p>缺点：不能复用，不能跨语言。</p><h3 id="4-2-ORM框架层"><a href="#4-2-ORM框架层" class="headerlink" title="4.2 ORM框架层"></a>4.2 ORM框架层</h3><p>比如我们用 MyBatis 连接数据库，也可以指定数据源。我们可以基于 MyBatis 插件的拦截机制（拦截 query 和 update 方法），实现数据源的选择。</p><h3 id="4-3-驱动层"><a href="#4-3-驱动层" class="headerlink" title="4.3 驱动层"></a>4.3 驱动层</h3><p>不管是MyBatis还是Hibernate，还是Spring的JdbcTemplate，本质上都是对JDBC的封装，所以第三层就是驱动层。比如 Sharding-JDBC，就是对 JDBC 的对象进行了封装。JDBC 的核心对象：</p><p>DataSource：数据源</p><p>Connection：数据库连接</p><p>Statement：语句对象</p><p>ResultSet：结果集</p><p>那我们只要对这几个对象进行封装或者拦截或者代理，就可以实现分片的操作。</p><h3 id="4-4-代理层"><a href="#4-4-代理层" class="headerlink" title="4.4 代理层"></a>4.4 代理层</h3><p>前面三种都是在客户端实现的，也就是说不同的项目都要做同样的改动，不同的编程语言也有不同的实现，所以我们能不能把这种选择数据源和实现路由的逻辑提取出来，做成一个公共的服务给所有的客户端使用呢？</p><p>这个就是第四层，代理层。比如 Mycat 和 Sharding-Proxy，都是属于这一层。</p><h3 id="4-5-数据库服务"><a href="#4-5-数据库服务" class="headerlink" title="4.5 数据库服务"></a>4.5 数据库服务</h3><p>某些特定的数据库或者数据库的特定版本可以实现这个功能。</p><h1 id="六，主从复制"><a href="#六，主从复制" class="headerlink" title="六，主从复制"></a>六，主从复制</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h2><p><img src="https://www.yuque.com/api/filetransfer/images?url=https://img-blog.csdnimg.cn/20210226212524335.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU5NjAyMg==,size_16,color_FFFFFF,t_70%23pic_center&sign=b2cf46d51564b6f2c46bcffc3adcd48b84ede22cae502691d18e85e1cd079c10#crop=0&crop=0&crop=1&crop=1&id=zSBEv&originHeight=282&originWidth=566&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>MySQL复制过程分成三步：</p><ol><li> master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events； </li><li> slave将master的binary log events拷贝到它的中继日志（relay log）； </li><li> slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，slave会从master读取binlog来进行数据同步。 </li></ol><h2 id="2-与Redis主从复制的差别"><a href="#2-与Redis主从复制的差别" class="headerlink" title="2.与Redis主从复制的差别"></a>2.与Redis主从复制的差别</h2><ol><li> redis主从复制是将主机的所有数据都拷贝给从机，并且是近乎实时的。 </li><li> mysql主从复制不会将建立连接以前的数据发送给从机，并且是异步，且串行化的。 </li></ol><h2 id="3-复制的基本原则"><a href="#3-复制的基本原则" class="headerlink" title="3.复制的基本原则"></a>3.复制的基本原则</h2><p>每个slave只有一个master</p><p>每个slave只能有一个唯一的服务器ID</p><p>每个master可以有多个salve</p><h2 id="4-复制的最大问题"><a href="#4-复制的最大问题" class="headerlink" title="4.复制的最大问题"></a>4.复制的最大问题</h2><p>延时</p><p>全同步可以避免，但性能会极差，正常情况下半同步，且容忍一部分数据不一致。如果不容忍数据不一致，只有强制读主。</p><h2 id="5-一主一从常见配置"><a href="#5-一主一从常见配置" class="headerlink" title="5.一主一从常见配置"></a>5.一主一从常见配置</h2><ol><li>MySQL版本一致且后台以服务运行</li><li>主从配置都在【mysqld】节点下，且全部小写</li><li>主机修改my.ini文件</li></ol><blockquote><ol><li> 主服务器唯一ID server-id=1 </li><li> 启用二进制日志  </li><li> 设置不要复制的数据库  </li><li> 设置需要复制的数据库  </li><li> 设置logbin格式  </li></ol></blockquote><blockquote><p>log-bin=自己的本地路径/data/mysqlbin</p></blockquote><blockquote><p>binlog-ignore-db=mysql</p></blockquote><blockquote><p>binlog-do-db=需要复制的主数据库名字</p></blockquote><blockquote><p>binlog_fromat=STATEMENT(默认)</p></blockquote><h1 id="七，硬件层面的配置"><a href="#七，硬件层面的配置" class="headerlink" title="七，硬件层面的配置"></a>七，硬件层面的配置</h1><h2 id="1-选择合适的CPU"><a href="#1-选择合适的CPU" class="headerlink" title="1.选择合适的CPU"></a>1.选择合适的CPU</h2><p>数据库分为两大类，在线事务处理和在线分析处理。</p><p>InnoDB储存引擎一般应用于OLTP的数据库应用，这种应用的特点如下：</p><ol><li> 用户操作的并发量大 </li><li> 事务处理时间一般比较短 </li><li> 查询的语句较为简单，一般都走索引 </li><li> 复杂查询比较少 </li></ol><p>在当前的MySQL数据库版本中，一条SQL语句只能在一个CPU工作，并不支持多CPU。若cpu支持多核，innodb版本应该选择1.1或者更高。另外如果是多核cpu，可以通过修改参数innodb_read_io_threads和innodb_write_io_threads来增大IO的线程，这样也可以更充分的利用cpu的多核性能。</p><h2 id="2-内存的重要性"><a href="#2-内存的重要性" class="headerlink" title="2.内存的重要性"></a>2.内存的重要性</h2><p>内存大小直接反映数据库的性能。Innodb存储引擎既缓存数据，又缓存索引，并且将它们缓存于一个很大的缓冲池中，即InnoDB Buffer Pool。因此，内存的大小直接影像数据库的性能。</p><h2 id="3-磁盘对数据库性能的影响"><a href="#3-磁盘对数据库性能的影响" class="headerlink" title="3.磁盘对数据库性能的影响"></a>3.磁盘对数据库性能的影响</h2><h2 id="4-合理设置RAID类型"><a href="#4-合理设置RAID类型" class="headerlink" title="4.合理设置RAID类型"></a>4.合理设置RAID类型</h2><h2 id="5-操作系统的选择"><a href="#5-操作系统的选择" class="headerlink" title="5.操作系统的选择"></a>5.操作系统的选择</h2><h2 id="6-文件系统的选择"><a href="#6-文件系统的选择" class="headerlink" title="6.文件系统的选择"></a>6.文件系统的选择</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[十]Explain&amp;optimizer trace</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%8D%81%5DExplain&amp;optimizer%20trace/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%8D%81%5DExplain&amp;optimizer%20trace/</url>
      
        <content type="html"><![CDATA[<h1 id="一，Explain"><a href="#一，Explain" class="headerlink" title="一，Explain"></a>一，Explain</h1><p>一条查询语句在经过<code>MySQL</code>查询优化器的各种基于成本和规则的优化会后生成一个所谓的<code>执行计划</code>，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个<code>EXPLAIN</code>，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280260945-c936b3bf-33bc-4f56-8d2c-3b3a37fe7a08.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63d468a1&margin=%5Bobject%20Object%5D&name=1.png&originHeight=112&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3820&status=done&style=none&taskId=u13c516c3-ac6f-4988-8981-5ccc1136386&title=" alt="1.png"></p><p>其实除了以<code>SELECT</code>开头的查询语句，其余的<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>以及<code>UPDATE</code>语句前边都可以加上<code>EXPLAIN</code>这个词儿，用来查看这些语句的执行计划，不过我们这里对<code>SELECT</code>语句更感兴趣，所以后边只会以<code>SELECT</code>语句为例来描述<code>EXPLAIN</code>语句的用法。我们先把<code>EXPLAIN</code>语句输出的各个列的作用先大致罗列一下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td></tr><tr><td><code>select_type</code></td><td><code>SELECT</code>关键字对应的那个查询的类型</td></tr><tr><td><code>table</code></td><td>表名</td></tr><tr><td><code>partitions</code></td><td>匹配的分区信息</td></tr><tr><td><code>type</code></td><td>针对单表的访问方法</td></tr><tr><td><code>possible_keys</code></td><td>可能用到的索引</td></tr><tr><td><code>key</code></td><td>实际上使用的索引</td></tr><tr><td><code>key_len</code></td><td>实际使用到的索引长度</td></tr><tr><td><code>ref</code></td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td><code>rows</code></td><td>预估的需要读取的记录条数</td></tr><tr><td><code>filtered</code></td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td><code>Extra</code></td><td>一些额外的信息</td></tr></tbody></table><p>我们前面创建过一张<code>single_table</code>表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="1-执行计划输出中各列详解"><a href="#1-执行计划输出中各列详解" class="headerlink" title="1.执行计划输出中各列详解"></a>1.执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名。所以我们看一条比较简单的查询语句：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280274365-43dda4af-2f66-465c-abfb-647b465bc8b3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u078f92e2&margin=%5Bobject%20Object%5D&name=2.png&originHeight=121&originWidth=950&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4213&status=done&style=none&taskId=ue1f9160c-2764-48a6-9c06-4df370be589&title=" alt="2.png"></p><p>这个查询语句只涉及对<code>s1</code>表的单表查询，所以<code>EXPLAIN</code>输出中只有一条记录，其中的<code>table</code>列的值是<code>s1</code>，表明这条记录是用来说明对<code>s1</code>表的单表访问方法的。</p><p>下边我们看一下一个连接查询的执行计划：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280282078-c817d0b7-eec8-4fac-b9ee-bfcde6afb3ff.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u198071a8&margin=%5Bobject%20Object%5D&name=3.png&originHeight=129&originWidth=1199&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5766&status=done&style=none&taskId=ufd1691fc-bc9e-4bf2-b272-a981164853f&title=" alt="3.png"></p><p>可以看到这个连接查询的执行计划中有两条记录，这两条记录的<code>table</code>列分别是<code>s1</code>和<code>s2</code>，这两条记录用来分别说明对<code>s1</code>表和<code>s2</code>表的访问方法是什么。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>我们知道我们写的查询语句一般都以<code>SELECT</code>关键字开头，比较简单的查询语句里只有一个<code>SELECT</code>关键字，比如下边这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>稍微复杂一点的连接查询中也只有一个<code>SELECT</code>关键字，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2</span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>但是下边两种情况下在一条查询语句中会出现多个<code>SELECT</code>关键字：</p><ul><li><p> 查询中包含子查询的情况<br>比如下边这个查询语句中就包含2个<code>SELECT</code>关键字：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT key3 FROM s2);</span><br></pre></td></tr></table></figure></li><li><p> 查询中包含<code>UNION</code>语句的情况<br>比如下边这个查询语句中也包含2个<code>SELECT</code>关键字：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1  UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure></li></ul><p>查询语句中每出现一个<code>SELECT</code>关键字，<code>MySQL</code>就会为它分配一个唯一的<code>id</code>值。这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下边这个查询中只有一个<code>SELECT</code>关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280291489-d6fd669d-dbf3-4054-a672-8352fce214a2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4dfdf582&margin=%5Bobject%20Object%5D&name=4.png&originHeight=122&originWidth=1202&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9275&status=done&style=none&taskId=u460df76a-a444-4d5b-a7ca-7d7a5c7026b&title=" alt="4.png"></p><p>对于连接查询来说，一个<code>SELECT</code>关键字后边的<code>FROM</code>子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280298828-57ae0bb0-9f11-4fc1-a716-dcd5b9fb003b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue0905b12&margin=%5Bobject%20Object%5D&name=5.png&originHeight=141&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12198&status=done&style=none&taskId=u9124e447-4620-4012-9fbc-82044c4a955&title=" alt="5.png"></p><p>可以看到，上述连接查询中参与连接的<code>s1</code>和<code>s2</code>表分别对应一条记录，但是这两条记录对应的<code>id</code>值都是<code>1</code>。在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，<strong>出现在前边的表表示驱动表，出现在后边的表表示被驱动表</strong>。所以从上边的<code>EXPLAIN</code>输出中我们可以看出，查询优化器准备让<code>s1</code>表作为驱动表，让<code>s2</code>表作为被驱动表来执行查询。</p><p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值，比如这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280305890-e78bef80-48fd-4ace-805c-cb03ea315780.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u515a991c&margin=%5Bobject%20Object%5D&name=6.png&originHeight=137&originWidth=1276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13575&status=done&style=none&taskId=ub9ed2c7d-641b-4e47-ba2e-ed467048a13&title=" alt="6.png"></p><p>从输出结果中我们可以看到，<code>s1</code>表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是<code>1</code>，<code>s2</code>表在子查询中，子查询有一个独立的<code>SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280313651-8d89c1be-d533-4331-bbb7-e2d48b436318.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u776fd7cc&margin=%5Bobject%20Object%5D&name=7.png&originHeight=158&originWidth=1452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16676&status=done&style=none&taskId=ub79395b5-7ac6-4798-a418-550eee0aadc&title=" alt="7.png"></p><p>虽然我们的查询语句是一个子查询，但是执行计划中<code>s1</code>和<code>s2</code>表对应的记录的<code>id</code>值全部是<code>1</code>，这就表明了查询优化器将子查询转换为了连接查询。</p><p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280321427-124e6217-466a-41c2-9363-d807856fadb7.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6436d0a7&margin=%5Bobject%20Object%5D&name=8.png&originHeight=176&originWidth=1360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14950&status=done&style=none&taskId=u50a3e117-c91d-420f-a8b4-31af4e2b3c2&title=" alt="8.png"></p><p>这个语句的执行计划的第三条记录是个什么？为什么<code>id</code>值是<code>NULL</code>，而且<code>table</code>名也不大对？<code>UNION</code>子句会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢？<code>MySQL</code>使用的是内部的临时表。正如上边的查询计划中所示，<code>UNION</code>子句是为了把<code>id</code>为<code>1</code>的查询和<code>id</code>为<code>2</code>的查询的结果集合并起来并去重，所以在内部创建了一个临时表（就是执行计划第三条记录的<code>table</code>列的名称），<code>id</code>为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p><p>跟<code>UNION</code>对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个<code>id</code>为<code>NULL</code>的记录，如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280329103-1d10728f-1cb6-424c-afc2-a6998f2ba02d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9423ac3e&margin=%5Bobject%20Object%5D&name=9.png&originHeight=146&originWidth=1176&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10897&status=done&style=none&taskId=u493e7dd0-542c-4a70-9c7b-7298631abd7&title=" alt="9.png"></p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>通过上边的内容我们知道，一条大的查询语句里边可以包含若干个<code>SELECT</code>关键字，每个<code>SELECT</code>关键字代表着一个小的查询语句，而每个<code>SELECT</code>关键字的<code>FROM</code>子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个<code>SELECT</code>关键字中的表来说，它们的<code>id</code>值是相同的。</p><p><code>MySQL</code>为每一个<code>SELECT</code>关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中有什么作用。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td>Simple SELECT (not using UNION or subqueries)</td></tr><tr><td><code>PRIMARY</code></td><td>Outermost SELECT</td></tr><tr><td><code>UNION</code></td><td>Second or later SELECT statement in a UNION</td></tr><tr><td><code>UNION RESULT</code></td><td>Result of a UNION</td></tr><tr><td><code>SUBQUERY</code></td><td>First SELECT in subquery</td></tr><tr><td><code>DEPENDENT SUBQUERY</code></td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td><code>DEPENDENT UNION</code></td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td><code>DERIVED</code></td><td>Derived table</td></tr><tr><td><code>MATERIALIZED</code></td><td>Materialized subquery</td></tr><tr><td><code>UNCACHEABLE SUBQUERY</code></td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td><code>UNCACHEABLE UNION</code></td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><ul><li> <code>SIMPLE</code><br>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询的<code>select_type</code>的值就是<code>SIMPLE</code>：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280337218-078fa344-d1da-4a52-857b-352ecb12cddc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufffa3027&margin=%5Bobject%20Object%5D&name=10.png&originHeight=146&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9907&status=done&style=none&taskId=u2df9f156-ab20-4e89-8136-9585d85cba1&title=" alt="10.png"><br>当然，连接查询也算是<code>SIMPLE</code>类型，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280343184-8c2e7e4c-f85b-4bb0-b45f-4325497a7ebd.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u63b97864&margin=%5Bobject%20Object%5D&name=11.png&originHeight=158&originWidth=1512&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14164&status=done&style=none&taskId=ud077b5f1-886a-44b5-abcd-76bdbfe08d7&title=" alt="11.png"> </li><li> <code>PRIMARY</code><br>对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280350857-4dfa730e-2b7c-4e94-825e-742a49f2b9e3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3fe99956&margin=%5Bobject%20Object%5D&name=12.png&originHeight=173&originWidth=1331&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14928&status=done&style=none&taskId=u8c6000b8-3cf9-48d9-9447-09224347660&title=" alt="12.png"><br>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是<code>PRIMARY</code>。 </li><li> <code>UNION</code><br>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>，可以对比上一个例子的效果，这就不多举例子了。 </li><li> <code>UNION RESULT</code><br><code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上边有，就不赘述了。 </li><li> <code>SUBQUERY</code><br>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280358319-9d411906-99c1-4214-a731-b31a6fa6487b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udf5c0430&margin=%5Bobject%20Object%5D&name=13.png&originHeight=154&originWidth=1284&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14997&status=done&style=none&taskId=u59a4d22d-11c4-4b80-b1d8-042fb9c3db7&title=" alt="13.png"><br>可以看到，外层查询的<code>select_type</code>就是<code>PRIMARY</code>，子查询的<code>select_type</code>就是<code>SUBQUERY</code>。由于select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。 </li><li> <code>DEPENDENT SUBQUERY</code><br>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280367090-997cc1b5-ef45-43b8-a298-68a707d7fcac.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b271730&margin=%5Bobject%20Object%5D&name=14.png&originHeight=154&originWidth=1433&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15238&status=done&style=none&taskId=uc46092db-b61b-4abe-b1e5-fdd03ca496e&title=" alt="14.png"></li></ul><p><strong>select_type为DEPENDENT SUBQUERY的查询可能会被执行多次。</strong> </p><ul><li><p> <code>DEPENDENT UNION</code><br>在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。说的有些绕哈，比方说下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280375650-6efa28fa-5b07-4b2b-a936-51dc06e0687e.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub4c42a77&margin=%5Bobject%20Object%5D&name=15.png&originHeight=176&originWidth=1650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21604&status=done&style=none&taskId=u977e1294-949c-4a21-a61e-32deb74d580&title=" alt="15.png"><br>这个查询比较复杂，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = &#39;a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = &#39;b&#39;</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。 </p></li><li><p> <code>DERIVED</code><br>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280385622-887431a3-4aed-4d36-829d-508ee28a1baa.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua247020c&margin=%5Bobject%20Object%5D&name=16.png&originHeight=163&originWidth=1336&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15817&status=done&style=none&taskId=u8f8c12bc-ad97-4e22-aac9-53a038d858f&title=" alt="16.png"><br>从执行计划中可以看出，<code>id</code>为<code>2</code>的记录就代表子查询的执行方式，它的<code>select_type</code>是<code>DERIVED</code>，说明该子查询是以物化的方式执行的。<code>id</code>为<code>1</code>的记录代表外层查询，它的<code>table</code>列显示的是``，表示该查询是针对将派生表物化之后的表进行查询的。  </p><blockquote><p>如果派生表可以通过和外层查询合并的方式执行的话，执行计划又是另一番景象。</p></blockquote></li><li><p> <code>MATERIALIZED</code><br>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280393291-f5462583-d221-4f0e-962a-a44c8ce95477.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u38a01fd0&margin=%5Bobject%20Object%5D&name=17.png&originHeight=170&originWidth=1455&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17733&status=done&style=none&taskId=u66eebaeb-7470-4f0c-a238-d04e43892d3&title=" alt="17.png"><br>执行计划的第三条记录的<code>id</code>值为<code>2</code>，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为<code>MATERIALIZED</code>可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的<code>id</code>值都为<code>1</code>，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是``，说明该表其实就是<code>id</code>为<code>2</code>对应的子查询执行之后产生的物化表，然后将<code>s1</code>和该物化表进行连接查询。 </p></li><li><p> <code>UNCACHEABLE SUBQUERY</code><br>不常用 </p></li><li><p> <code>UNCACHEABLE UNION</code><br>不常用 </p></li></ul><h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><p>一般情况下我们的查询语句的执行计划的<code>partitions</code>列的值都是<code>NULL</code>。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>执行计划的一条记录就代表着<code>MySQL</code>对某个表的执行查询时的访问方法，其中的<code>type</code>列就表明了这个访问方法是什么，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280402792-2ed1ee54-de24-42de-8f8d-4ec2f861dcd5.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubaa6a847&margin=%5Bobject%20Object%5D&name=18.png&originHeight=141&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10843&status=done&style=none&taskId=u694e9953-97ca-4705-9136-ec6a7dc3196&title=" alt="18.png"></p><p>可以看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。但是我们之前只分析过对使用<code>InnoDB</code>存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。接下来我们详细看一下：</p><ul><li><p> <code>system</code><br>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：<br>然后我们看一下查询这个表的执行计划：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280410379-02b98490-4259-4af4-bd20-c465d0b6bebd.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u85f77e9b&margin=%5Bobject%20Object%5D&name=19.png&originHeight=130&originWidth=1179&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8957&status=done&style=none&taskId=u998b055a-ccec-41f7-8e2e-097010b188d&title=" alt="19.png"><br>可以看到<code>type</code>列的值就是<code>system</code>了。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>把表改成使用InnoDB存储引擎，执行计划的type列是ALL。</p></blockquote></li><li><p> <code>const</code><br>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280418708-2e9e505a-c985-45fa-8518-44c27fc83979.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7438f4f7&margin=%5Bobject%20Object%5D&name=20.png&originHeight=133&originWidth=1220&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10419&status=done&style=none&taskId=ubcd36136-b889-4eac-aefb-c68f5da874a&title=" alt="20.png"> </p></li><li><p> <code>eq_ref</code><br>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280456161-049d60a4-d6da-46b2-91fe-9b2661fa1d36.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0c6b2463&margin=%5Bobject%20Object%5D&name=21.png&originHeight=158&originWidth=1264&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13498&status=done&style=none&taskId=ue5cce22c-1ad7-46d1-82c7-559db693de7&title=" alt="21.png"><br>从执行计划的结果中可以看出，<code>MySQL</code>打算将<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表，重点关注<code>s2</code>的访问方法是<code>eq_ref</code>，表明在访问<code>s2</code>表的时候可以通过主键的等值匹配来进行访问。 </p></li><li><p> <code>ref</code><br>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>。 </p></li><li><p> <code>fulltext</code><br>全文索引,意义不大。 </p></li><li><p> <code>ref_or_null</code><br>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280463125-26170cb7-ba4b-4933-a004-8c346961b5da.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufa9a4774&margin=%5Bobject%20Object%5D&name=22.png&originHeight=141&originWidth=1422&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12130&status=done&style=none&taskId=u6b7b7747-acae-4a15-adf5-d446fbbb6c0&title=" alt="22.png"> </p></li><li><p> <code>index_merge</code><br>在某些场景下可以使用<code>Intersection</code>、<code>Union</code>、<code>Sort-Union</code>这三种索引合并的方式来执行查询，我们看一下执行计划中是怎么体现<code>MySQL</code>使用索引合并的方式来对某个表执行查询的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280470378-3882e0be-f91d-44c0-a7b9-a979adc93085.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue18487eb&margin=%5Bobject%20Object%5D&name=23.png&originHeight=130&originWidth=1806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18097&status=done&style=none&taskId=u3aaf69a0-df90-4b3e-a75d-7f161bc37f0&title=" alt="23.png"><br>从执行计划的<code>type</code>列的值是<code>index_merge</code>就可以看出，<code>MySQL</code>打算使用索引合并的方式来执行对<code>s1</code>表的查询。 </p></li><li><p> <code>unique_subquery</code><br>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280477014-ddc7ace3-5261-47a3-956c-3acce84f20dc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0d35569a&margin=%5Bobject%20Object%5D&name=24.png&originHeight=138&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15149&status=done&style=none&taskId=ub0da4c73-db17-427c-b87b-e059de96b1b&title=" alt="24.png"><br>可以看到执行计划的第二条记录的<code>type</code>值就是<code>unique_subquery</code>，说明在执行子查询时会使用到<code>id</code>列的索引。 </p></li><li><p> <code>index_subquery</code><br><code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280483868-ff7a1815-8c05-4a2f-94e7-79b880cea954.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue020d52f&margin=%5Bobject%20Object%5D&name=25.png&originHeight=148&originWidth=1457&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16363&status=done&style=none&taskId=u2782b719-e96b-4afa-bb75-8eb977622af&title=" alt="25.png"> </p></li><li><p> <code>range</code><br>如果使用索引获取某些<code>范围区间</code>的记录，那么就可能使用到<code>range</code>访问方法，比如下边的这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280490568-7cef7a7c-7acf-4be1-9c08-5b6da950acfc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08f05ea8&margin=%5Bobject%20Object%5D&name=26.png&originHeight=143&originWidth=1371&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11837&status=done&style=none&taskId=u99904bc8-68ad-4658-a5fc-b5851815429&title=" alt="26.png"><br>或者：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280496929-e1318302-934b-4bda-b7a4-8a858c278403.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u14fae300&margin=%5Bobject%20Object%5D&name=27.png&originHeight=117&originWidth=1355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10119&status=done&style=none&taskId=u13e335fa-04ea-4d0e-861b-045a44df8c6&title=" alt="27.png"> </p></li><li><p> <code>index</code><br>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280502811-c5c73a14-cb70-410e-9997-eb5296fe7ead.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9d0bfa53&margin=%5Bobject%20Object%5D&name=28.png&originHeight=129&originWidth=1445&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11338&status=done&style=none&taskId=u8ea5271b-21e8-4dfe-b21f-f9b7cce2e5a&title=" alt="28.png"><br>上述查询中的搜索列表中只有<code>key_part2</code>一个列，而且搜索条件中也只有<code>key_part3</code>一个列，这两个列又恰好包含在<code>idx_key_part</code>这个索引中，可是搜索条件<code>key_part3</code>不能直接使用该索引进行<code>ref</code>或者<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。  </p><blockquote><p>对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></blockquote></li><li><p> <code>ALL</code><br>最熟悉的全表扫描直接看例子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280509611-e1909546-52e6-44eb-a2ad-bc9422cf1521.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8e1ce447&margin=%5Bobject%20Object%5D&name=29.png&originHeight=136&originWidth=1172&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9873&status=done&style=none&taskId=ucadc9702-0049-4b37-bcc0-a6e180d38b3&title=" alt="29.png"> </p></li></ul><p>一般来说，这些访问方法按照我们介绍它们的顺序性能依次变差。其中除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引。</p><h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p>在<code>EXPLAIN</code>语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280516466-778cee1a-3912-45ce-b8b0-961fde6131b2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8c4c0e4c&margin=%5Bobject%20Object%5D&name=30.png&originHeight=135&originWidth=1311&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11553&status=done&style=none&taskId=u20dfc39d-6030-42fa-8480-2d27b8ab68a&title=" alt="30.png"></p><p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1,idx_key3</code>，表示该查询可能使用到<code>idx_key1,idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code>来执行查询比较划算。</p><p>不过有一点比较特别，就是在使用<code>index</code>访问方法来查询某个表时，<code>possible_keys</code>列是空的，而<code>key</code>列展示的是实际使用到的索引，比如这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280523465-50db2fcf-3aab-459d-bd56-9fe94cfef62d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u709cacbf&margin=%5Bobject%20Object%5D&name=31.png&originHeight=133&originWidth=1456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11806&status=done&style=none&taskId=u7d4f3316-a2df-450a-82f1-e9dc395c5d1&title=" alt="31.png"></p><p>另外需要注意的一点是，possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p><ol><li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</li><li>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</li><li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li></ol><p>比如下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280530011-7d5e65ca-3e73-4ce5-9cd7-30e30fca150d.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u37395cf6&margin=%5Bobject%20Object%5D&name=32.png&originHeight=126&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10064&status=done&style=none&taskId=u620f6e76-7540-4994-b49b-8ecb5d6c62a&title=" alt="32.png"></p><p>由于<code>id</code>列的类型是<code>INT</code>，并且不可以存储<code>NULL</code>值，所以在使用该列的索引时<code>key_len</code>大小就是<code>4</code>。当索引列可以存储<code>NULL</code>值时，比如：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280536833-34a98995-bbb1-4f5b-9c65-cd883418fbd2.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u91c8ee45&margin=%5Bobject%20Object%5D&name=33.png&originHeight=132&originWidth=1203&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10328&status=done&style=none&taskId=uf7c83065-c654-47e4-886d-3e1fc98b6e8&title=" alt="33.png"></p><p>可以看到<code>key_len</code>列就变成了<code>5</code>，比使用<code>id</code>列的索引时多了<code>1</code>。</p><p>对于可变长度的索引列来说，比如下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280547140-fea8d226-3465-4e13-b93d-0e74882cf422.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc8b9f40b&margin=%5Bobject%20Object%5D&name=34.png&originHeight=137&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10837&status=done&style=none&taskId=ubc579fb7-242e-4242-844b-50635088a6d&title=" alt="34.png"></p><p>由于<code>key1</code>列的类型是<code>VARCHAR(100)</code>，所以该列实际最多占用的存储空间就是<code>300</code>字节，又因为该列允许存储<code>NULL</code>值，所以<code>key_len</code>需要加<code>1</code>，又因为该列是可变长度列，所以<code>key_len</code>需要加<code>2</code>，所以最后<code>ken_len</code>的值就是<code>303</code>。</p><p>这里需要强调的一点是，执行计划的生成是在<code>MySQL server</code>层中的功能，并不是针对具体某个存储引擎的功能，<code>MySQL</code>在执行计划中输出<code>key_len</code>列主要是为了让我们区分某个使用联合索引的查询具体用了几个索引列，而不是为了准确的说明针对某个具体存储引擎存储变长字段的实际长度占用的空间到底是占用1个字节还是2个字节。比方说下边这个使用到联合索引<code>idx_key_part</code>的查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280574627-423abda2-7282-4686-850d-158ee23ceef0.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue80e815d&margin=%5Bobject%20Object%5D&name=35.png&originHeight=135&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11390&status=done&style=none&taskId=ua1103849-bb46-4d1e-bfe7-d43baa19357&title=" alt="35.png"></p><p>我们可以从执行计划的<code>key_len</code>列中看到值是<code>303</code>，这意味着<code>MySQL</code>在执行上述查询中只能用到<code>idx_key_part</code>索引的一个索引列，而下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280584178-4d046ed5-9399-46e8-acf8-c4dba1e88a44.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufe6bdb41&margin=%5Bobject%20Object%5D&name=36.png&originHeight=148&originWidth=1310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11956&status=done&style=none&taskId=u5a6a7a9e-56f9-4f90-b3e3-3ccce6aeeb1&title=" alt="36.png"></p><p>这个查询的执行计划的<code>ken_len</code>列的值是<code>606</code>，说明执行这个查询的时候可以用到联合索引<code>idx_key_part</code>的两个索引列。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280639189-65511db0-6781-43a2-a189-da56d4a39d06.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3e0a564f&margin=%5Bobject%20Object%5D&name=37.png&originHeight=137&originWidth=1205&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10813&status=done&style=none&taskId=ubf40913d-f7f9-48b6-a1bc-22be2439bce&title=" alt="37.png"></p><p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280647362-c56ac11e-c810-49b1-b6ef-74142632a2f3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2efc95bd&margin=%5Bobject%20Object%5D&name=38.png&originHeight=151&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13438&status=done&style=none&taskId=u78dba58c-d2a6-4a38-8342-d8829ff9213&title=" alt="38.png"></p><p>可以看到对被驱动表<code>s2</code>的访问方法是<code>eq_ref</code>，而对应的<code>ref</code>列的值是<code>yhd.s1.id</code>，这说明在对被驱动表进行访问时会用到<code>PRIMARY</code>索引，也就是聚簇索引与一个列进行等值匹配的条件，于<code>s2</code>表的<code>id</code>作等值匹配的对象就是<code>yhd.s1.id</code>列（注意这里把数据库名也写出来了）。</p><p>有的时候与索引列进行等值匹配的对象是一个函数，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280654511-c4a8f217-0578-4a32-b78c-1b61a2160364.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u11c13c47&margin=%5Bobject%20Object%5D&name=39.png&originHeight=152&originWidth=1372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14314&status=done&style=none&taskId=u9c0c9cba-8fec-41c7-82d0-9469e60fcc2&title=" alt="39.png"></p><p>我们看执行计划的第二条记录，可以看到对<code>s2</code>表采用<code>ref</code>访问方法执行查询，然后在查询计划的<code>ref</code>列里输出的是<code>func</code>，说明与<code>s2</code>表的<code>key1</code>列进行等值匹配的对象是一个函数。</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。比如下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280662371-b8621d39-7404-4335-8b6f-6ac3bf020927.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubdf57c66&margin=%5Bobject%20Object%5D&name=40.png&originHeight=144&originWidth=1362&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11525&status=done&style=none&taskId=u502bf400-c9d0-4d98-a90c-01d6e656856&title=" alt="40.png"></p><p>我们看到执行计划的<code>rows</code>列的值是<code>1</code>，这意味着查询优化器在经过分析使用<code>idx_key1</code>进行查询的成本之后，觉得满足<code>key1 &gt; &#39;z&#39;</code>这个条件的记录只有<code>1</code>条。</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>之前在分析连接查询的成本时提出过一个<code>condition filtering</code>的概念，就是<code>MySQL</code>在计算驱动表扇出时采用的一个策略：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要估计出满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p>比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280695851-4f237801-1121-4cce-935d-8d124f691b30.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08ebf4a7&margin=%5Bobject%20Object%5D&name=41.png&originHeight=139&originWidth=1507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12747&status=done&style=none&taskId=uef9d60d8-c348-4d80-a2f2-29ebce41900&title=" alt="41.png"></p><p>从执行计划的<code>key</code>列中可以看出来，该查询使用<code>idx_key1</code>索引来执行查询，从<code>rows</code>列可以看出满足<code>key1 &gt; &#39;z&#39;</code>的记录有<code>1</code>条。执行计划的<code>filtered</code>列就代表查询优化器预测在这<code>1</code>条记录中，有多少条记录满足其余的搜索条件，也就是<code>common_field = &#39;a&#39;</code>这个条件的百分比。此处<code>filtered</code>列的值是<code>10.00</code>，说明查询优化器预测在<code>1</code>条记录中有<code>10.00%</code>的记录满足<code>common_field = &#39;a&#39;</code>这个条件。</p><p>对于单表查询来说，这个<code>filtered</code>列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的<code>filtered</code>值，比方说下边这个查询：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280702717-5e6276df-2775-4dd9-9068-168632a6e891.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua075a642&margin=%5Bobject%20Object%5D&name=42.png&originHeight=159&originWidth=1359&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15418&status=done&style=none&taskId=u2ce577e9-11ca-4213-8c24-e76cc816cc0&title=" alt="42.png"></p><p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>当作驱动表，<code>s2</code>当作被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>997219</code>， <code>filtered</code>列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>997219 × 10.00% = 99721.9</code>，这说明还要对被驱动表执行大约<code>99721.9</code>次查询。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解<code>MySQL</code>到底将如何执行给定的查询语句。</p><ul><li><p> <code>No tables used</code><br>当查询语句的没有<code>FROM</code>子句时将会提示该额外信息，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280709963-b0a3875e-f1e9-4112-928c-5a2509c69a1c.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0af38ec6&margin=%5Bobject%20Object%5D&name=43.png&originHeight=137&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8351&status=done&style=none&taskId=ub8c0c8c7-6dd1-436a-a457-2a8f3fd0a43&title=" alt="43.png"> </p></li><li><p> <code>Impossible WHERE</code><br>查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280716070-b375d8db-fab7-411f-b6c3-fdb1cb8a2b68.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u62a56c70&margin=%5Bobject%20Object%5D&name=44.png&originHeight=140&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10429&status=done&style=none&taskId=u3592d4c4-8b55-4c36-ab4c-19bfcb10f2a&title=" alt="44.png"> </p></li><li><p> <code>No matching min/max row</code><br>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚集函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息，比方说：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280722423-8f00c35d-e352-4e4f-9ad0-06344f87d7be.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uae911a2d&margin=%5Bobject%20Object%5D&name=45.png&originHeight=133&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10632&status=done&style=none&taskId=uc25dd0ec-cd40-4efa-b32b-289e0c6a293&title=" alt="45.png"> </p></li><li><p> <code>Using index</code><br>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用索引覆盖的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280729248-e8d19929-5057-4e2b-92b5-4f0815d42951.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uca03b967&margin=%5Bobject%20Object%5D&name=46.png&originHeight=137&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10748&status=done&style=none&taskId=u4ef056f1-92c6-4c14-8947-39aa551837d&title=" alt="46.png"> </p></li><li><p><code>Using index condition</code><br>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：<br>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的<code>MySQL</code>中，是按照下边步骤来执行这个查询的： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure><ul><li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</li><li>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</li></ul></li></ul><p>但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以<code>MySQL</code>把上边的步骤改进了一下： </p><ul><li>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</li><li>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</li><li>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</li></ul><p>我们说回表操作其实是一个随机<code>IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。<code>MySQL</code>把他们的这个改进称之为<code>索引条件下推</code>（英文名：<code>Index Condition Pushdown</code>）。<br>如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在<code>Extra</code>列中将会显示<code>Using index condition</code>，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280739039-b867ce7b-7772-4c60-ad85-de88f84dfc95.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5f7b5a5f&margin=%5Bobject%20Object%5D&name=47.png&originHeight=150&originWidth=1355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12096&status=done&style=none&taskId=u108c9eb7-bb19-4820-a2c3-34bdae80479&title=" alt="47.png"></p><ul><li><p> <code>Using where</code><br>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280745116-15cf2e92-4bc6-4896-a114-a08fd4f149f1.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue69355bd&margin=%5Bobject%20Object%5D&name=48.png&originHeight=142&originWidth=1251&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11283&status=done&style=none&taskId=u5bca1059-5304-4173-a759-fe3383de92f&title=" alt="48.png"><br>当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在<code>Extra</code>列中也会提示上述额外信息。比如下边这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1 = &#39;a&#39;</code>，还有包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280750980-0af4ffa5-7801-40ed-b434-60cf04e53c39.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6328631b&margin=%5Bobject%20Object%5D&name=49.png&originHeight=139&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11868&status=done&style=none&taskId=u78e29b4d-4d4a-49e1-85b3-0469f52cbfc&title=" alt="49.png"> </p></li><li><p><code>Using join buffer (Block Nested Loop)</code><br>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>，比如下边这个查询语句：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280756935-cbffc56a-f033-486c-bc9e-2a4b45faffc3.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u66ccbdd4&margin=%5Bobject%20Object%5D&name=50.png&originHeight=197&originWidth=1615&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16002&status=done&style=none&taskId=u33176016-e036-4aa1-a1e2-fb9469510e0&title=" alt="50.png"><br>可以在对<code>s2</code>表的执行计划的<code>Extra</code>列显示了两个提示： </p><ul><li><code>Using join buffer (Block Nested Loop)</code>：这是因为对表<code>s2</code>的访问不能有效利用索引，只好退而求其次，使用<code>join buffer</code>来减少对<code>s2</code>表的访问次数，从而提高性能。</li><li><code>Using where</code>：可以看到查询语句中有一个<code>s1.common_field = s2.common_field</code>条件，因为<code>s1</code>是驱动表，<code>s2</code>是被驱动表，所以在访问<code>s2</code>表时，<code>s1.common_field</code>的值已经确定下来了，所以实际上查询<code>s2</code>表的条件就是<code>s2.common_field = 一个常数</code>，所以提示了<code>Using where</code>额外信息。</li></ul></li><li><p> <code>Not exists</code><br>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的<code>Extra</code>列就会提示<code>Not exists</code>额外信息，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280765248-adc53a64-08e5-4047-9282-dedf49c0ba53.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud66d86bd&margin=%5Bobject%20Object%5D&name=51.png&originHeight=168&originWidth=1735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20626&status=done&style=none&taskId=ue194205d-192b-4293-96ba-cbbb11125a2&title=" alt="51.png"><br>上述查询中<code>s1</code>表是驱动表，<code>s2</code>表是被驱动表，<code>s2.id</code>列是不允许存储<code>NULL</code>值的，而<code>WHERE</code>子句中又包含<code>s2.id IS NULL</code>的搜索条件，这意味着必定是驱动表的记录在被驱动表中找不到匹配<code>ON</code>子句条件的记录才会把该驱动表的记录加入到最终的结果集，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合<code>ON</code>子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说我们没有必要到被驱动表中找到全部符合ON子句条件的记录，这样可以稍微节省一点性能。  </p><blockquote><p>右（外）连接可以被转换为左（外）连接，所以就不提右（外）连接的情况了。</p></blockquote></li><li><p> <code>Using intersect(...)</code>、<code>Using union(...)</code>和<code>Using sort_union(...)</code><br>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。比如这个查询的执行计划：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280772463-3a90c8d1-6545-4018-b8d7-5025f232d7ee.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ueda5799e&margin=%5Bobject%20Object%5D&name=52.png&originHeight=143&originWidth=1303&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11849&status=done&style=none&taskId=u894c398e-c275-41a7-8968-5e3e310bd43&title=" alt="52.png"><br>其中<code>Extra</code>列就显示了<code>Using intersect(idx_key3,idx_key1)</code>，表明<code>MySQL</code>即将使用<code>idx_key3</code>和<code>idx_key1</code>这两个索引进行<code>Intersect</code>索引合并的方式执行查询。 </p></li><li><p> <code>Zero limit</code><br>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示不打算从表中读出任何记录，将会提示该额外信息，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280778887-9254ccb9-15d2-4dca-ae74-454146fcd5bc.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u805e1066&margin=%5Bobject%20Object%5D&name=53.png&originHeight=153&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9929&status=done&style=none&taskId=ud78823f5-06ba-40ce-b3b7-d471c6eb90f&title=" alt="53.png"> </p></li><li><p> <code>Using filesort</code><br>有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280785452-754d9c90-0fa1-49ec-889c-dc8cf142399b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u231ab400&margin=%5Bobject%20Object%5D&name=54.png&originHeight=154&originWidth=1214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11063&status=done&style=none&taskId=u9983daa3-8d15-47c4-aeea-15b73d0dcc1&title=" alt="54.png"><br>这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，<code>MySQL</code>把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280791344-a71710e6-a915-4788-bc09-688eec1a399b.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7aa08f31&margin=%5Bobject%20Object%5D&name=55.png&originHeight=148&originWidth=1290&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11614&status=done&style=none&taskId=u5f2f6bce-bad5-4b54-8664-8d144260c1a&title=" alt="55.png"><br>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用<code>文件排序</code>的执行方式改为使用索引进行排序。 </p></li><li><p> <code>Using temporary</code><br>在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280797689-75d2cb3d-3866-480c-bf4e-8a69e479536f.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u286716ac&margin=%5Bobject%20Object%5D&name=56.png&originHeight=151&originWidth=1270&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11377&status=done&style=none&taskId=u4ce60cde-24ba-4663-aadd-a4e68b73f0d&title=" alt="56.png"><br>再比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280803837-7d795aa0-fd17-4d87-9ab0-07c295f5e7c9.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue7b2c60b&margin=%5Bobject%20Object%5D&name=57.png&originHeight=149&originWidth=1425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12625&status=done&style=none&taskId=ub9d1b398-3b4f-4f73-a1ee-342d85bf749&title=" alt="57.png"><br>不知道大家注意到没有，上述执行计划的<code>Extra</code>列不仅仅包含<code>Using temporary</code>提示，还包含<code>Using filesort</code>提示，可是我们的查询语句中明明没有写<code>ORDER BY</code>子句呀？这是因为<code>MySQL</code>会在包含<code>GROUP BY</code>子句的查询中默认添加上<code>ORDER BY</code>子句，也就是说上述查询其实和下边这个查询等价：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field ORDER BY common_field;</span><br></pre></td></tr></table></figure></li></ul><p>如果我们并不想为包含GROUP BY子句的查询进行排序，需要我们显式的写上ORDER BY NULL，就像这样：<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280846631-90d86605-c8b9-4548-b10d-b44be5d9335f.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u822663e5&margin=%5Bobject%20Object%5D&name=58.png&originHeight=150&originWidth=1271&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12514&status=done&style=none&taskId=u61a5fe59-aa4c-4df4-b86a-5d5c7d5c8fe&title=" alt="58.png"><br>​</p><p>这回执行计划中就没有Using filesort的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。<br>​</p><p>另外，执行计划中出现Using temporary并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含GROUP BY子句的查询就不需要使用临时表：<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280856295-6e72f854-6076-48fe-9766-4b8dd70a434c.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uaf5517ea&margin=%5Bobject%20Object%5D&name=59.png&originHeight=136&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11837&status=done&style=none&taskId=ucb545596-9525-4ce1-ab15-e96493d37f6&title=" alt="59.png"><br>​</p><p>从Extra的Using index的提示里我们可以看出，上述查询只需要扫描idx_key1索引就可以搞定了，不再需要临时表了。</p><ul><li> <code>Start temporary, End temporary</code><br>查询优化器会优先尝试将<code>IN</code>子查询转换成<code>semi-join</code>，而<code>semi-join</code>又有好多种执行策略，当执行策略为<code>DuplicateWeedout</code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的<code>Extra</code>列将显示<code>Start temporary</code>提示，被驱动表查询执行计划的<code>Extra</code>列将显示<code>End temporary</code>提示，就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280870260-d8109158-d388-4665-87a3-fbc3393cb1e6.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u40bf656b&margin=%5Bobject%20Object%5D&name=60.png&originHeight=180&originWidth=1443&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18905&status=done&style=none&taskId=u60106558-b64a-4cad-8c4c-7e89266b735&title=" alt="60.png"></li><li> <code>LooseScan</code><br>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>LooseScan</code>执行策略，则在驱动表执行计划的<code>Extra</code>列就是显示<code>LooseScan</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280878656-f9849a88-d738-4e61-92fe-71e8fb4b8097.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud020c3be&margin=%5Bobject%20Object%5D&name=61.png&originHeight=182&originWidth=1553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18884&status=done&style=none&taskId=u48e16db1-823b-481d-93b1-641580ba363&title=" alt="61.png"> </li><li> <code>FirstMatch(tbl_name)</code><br>在将<code>In</code>子查询转为<code>semi-join</code>时，如果采用的是<code>FirstMatch</code>执行策略，则在被驱动表执行计划的<code>Extra</code>列就是显示<code>FirstMatch(tbl_name)</code>提示，比如这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280886946-4cee061e-db5d-429b-9f77-887af2159190.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue6d1ea12&margin=%5Bobject%20Object%5D&name=62.png&originHeight=171&originWidth=1613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17585&status=done&style=none&taskId=ue1333208-0342-496e-bc90-8215638090b&title=" alt="62.png"> </li></ul><h2 id="2-Json格式的执行计划"><a href="#2-Json格式的执行计划" class="headerlink" title="2.Json格式的执行计划"></a>2.Json格式的执行计划</h2><p>我们上边介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行计划好坏的重要属性 —— 成本。不过<code>MySQL</code>贴心的为我们提供了一种查看某个执行计划花费的成本的方式：</p><ul><li>在<code>EXPLAIN</code>单词和真正的查询语句中间加上<code>FORMAT=JSON</code>。</li></ul><p>这样我们就可以得到一个<code>json</code>格式的执行计划，里边儿包含该计划花费的成本，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: 1,     # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;3197.16&quot;   # 整个查询的执行成本预计为3197.16</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [    # 几个表之间采用嵌套循环连接算法执行</span><br><span class="line">    </span><br><span class="line">    # 以下是参与嵌套循环连接算法的各个表的信息</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,   # s1表是驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,     # 访问方法为ALL，意味着使用全表扫描访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 9688,   # 查询一次s1表大致需要扫描9688条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 驱动表s1的扇出是968</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,  # condition filtering代表的百分比</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;1840.84&quot;,     # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;2034.60&quot;,   # 单次查询s1表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          </span><br><span class="line">          # 对s1表访问时针对单表查询的条件</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`xiaohaizi`.`s1`.`common_field` = &#x27;a&#x27;) and (`xiaohaizi`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,   # s2表是被驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ref&quot;,     # 访问方法为ref，意味着使用索引等值匹配的方式访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,    # 实际使用的索引</span><br><span class="line">          &quot;used_key_parts&quot;: [   # 使用到的索引列</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,    # key_len</span><br><span class="line">          &quot;ref&quot;: [      # 与key2列进行等值匹配的对象</span><br><span class="line">            &quot;xiaohaizi.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 1,  # 查询一次s2表大致需要扫描1条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,     # condition filtering代表的百分比</span><br><span class="line">          </span><br><span class="line">          # s2表使用索引进行查询的搜索条件</span><br><span class="line">          &quot;index_condition&quot;: &quot;(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;968.80&quot;,      # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;3197.16&quot;,   # 单次查询s1、多次查询s2表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>&quot;cost_info&quot;</code>里边的成本是怎么计算出来的？先看<code>s1</code>表的<code>&quot;cost_info&quot;</code>部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>read_cost</code>是由下边这两部分组成的： </p><ul><li><code>IO</code>成本</li><li>检测<code>rows × (1 - filter)</code>条记录的<code>CPU</code>成本<blockquote><p>rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</p></blockquote></li></ul></li><li><p> <code>eval_cost</code>是这样计算的：<br>检测 <code>rows × filter</code>条记录的成本。 </p></li><li><p> <code>prefix_cost</code>就是单独查询<code>s1</code>表的成本，也就是：<br><code>read_cost + eval_cost</code> </p></li><li><p> <code>data_read_per_join</code>表示在此次查询中需要读取的数据量，我们就不多唠叨这个了。 </p></li></ul><blockquote><p>其实没必要关注MySQL为啥使用这么古怪的方式计算出read_cost和eval_cost，关注prefix_cost是查询s1表的成本就好了。</p></blockquote><p>对于<code>s2</code>表的<code>&quot;cost_info&quot;</code>部分是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;968.80&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;3197.16&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>s2</code>表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code>和<code>eval_cost</code>是访问多次<code>s2</code>表后累加起来的值，主要关注里边儿的<code>prefix_cost</code>的值代表的是整个连接查询预计的成本，也就是单次查询<code>s1</code>表和多次查询<code>s2</code>表后的成本的和，也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">968.80 + 193.76 + 2034.60 = 3197.16</span><br></pre></td></tr></table></figure><h2 id="3-Extented-EXPLAIN"><a href="#3-Extented-EXPLAIN" class="headerlink" title="3.Extented EXPLAIN"></a>3.Extented EXPLAIN</h2><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280900493-ef323458-9ed7-4213-a1bd-1b1a606384aa.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf7584cec&margin=%5Bobject%20Object%5D&name=63.png&originHeight=308&originWidth=1560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27815&status=done&style=none&taskId=ub7ecd933-32ca-458a-8f52-efe2fb29519&title=" alt="63.png"></p><p>可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level</code>、<code>Code</code>、<code>Message</code>。我们最常见的就是<code>Code</code>为<code>1003</code>的信息，当<code>Code</code>值为<code>1003</code>时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左（外）连接查询，但是有一个<code>s2.common_field IS NOT NULL</code>的条件，着就会导致查询优化器把左（外）连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的<code>LEFT JOIN</code>已经变成了<code>JOIN</code>。</p><p>我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接运行，它只能作为帮助我们理解查<code>MySQL</code>将如何执行查询语句的一个参考依据而已。</p><h1 id="二，optimizer-trace"><a href="#二，optimizer-trace" class="headerlink" title="二，optimizer trace"></a>二，optimizer trace</h1><p>对于<code>MySQL 5.6</code>以及之前的版本来说，查询优化器就像是一个黑盒子一样，只能通过<code>EXPLAIN</code>语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。</p><p>在<code>MySQL 5.6</code>以及之后的版本中，<code>MySQL</code>提出了一个<code>optimizer trace</code>的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量<code>optimizer_trace</code>决定，我们看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;optimizer_trace&#x27;;</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name   | Value                    |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled=off,one_line=off |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>可以看到<code>enabled</code>值为<code>off</code>，表明这个功能默认是关闭的。</p><blockquote><p>one_line的值是控制输出格式的，如果为on那么所有输出都将在一行中展示，不适合人阅读，所以我们就保持其默认值为off吧。</p></blockquote><p>如果想打开这个功能，必须首先把<code>enabled</code>的值改为<code>on</code>，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>然后我们就可以输入我们想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。这个<code>OPTIMIZER_TRACE</code>表有4个列，分别是：</p><ul><li><code>QUERY</code>：表示我们的查询语句。</li><li><code>TRACE</code>：表示优化过程的JSON格式文本。</li><li><code>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</code>：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li><li><code>INSUFFICIENT_PRIVILEGES</code>：表示是否没有权限查看优化过程，默认值是0，只有某些特殊情况下才会是<code>1</code>，我们暂时不关心这个字段的值。</li></ul><p>完整的使用<code>optimizer trace</code>功能的步骤总结如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1. 打开optimizer trace功能 (默认情况下它是关闭的):</span><br><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line"># 2. 这里输入查询语句</span><br><span class="line">SELECT ...; </span><br><span class="line"></span><br><span class="line"># 3. 从OPTIMIZER_TRACE表中查看上一个查询的优化过程</span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE;</span><br><span class="line"></span><br><span class="line"># 4. 可能还要观察其他语句执行的优化过程，重复上边的第2、3步</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 5. 当停止查看语句的优化过程时，把optimizer trace功能关闭</span><br><span class="line">SET optimizer_trace=&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure><p>现在我们有一个搜索条件比较多的查询语句，它的执行计划如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640280913355-faf51846-5a6c-457f-8c09-ef9a61f1e7f0.png#clientId=udee86ba6-ae37-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua3d01893&margin=%5Bobject%20Object%5D&name=64.png&originHeight=133&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13872&status=done&style=none&taskId=u3f87397a-3e3c-45de-8b02-c7efbc04957&title=" alt="64.png"></p><p>可以看到该查询可能使用到的索引有3个，那么为什么优化器最终选择了<code>idx_key2</code>而不选择其他的索引或者直接全表扫描呢？这时候就可以通过<code>otpimzer trace</code>功能来查看优化器的具体工作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND </span><br><span class="line">    key2 &lt; 1000000 AND </span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    common_field = &#x27;abc&#x27;;</span><br><span class="line">    </span><br><span class="line">SELECT * FROM information_schema.OPTIMIZER_TRACE\G</span><br></pre></td></tr></table></figure><p>直接看一下通过查询<code>OPTIMIZER_TRACE</code>表得到的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line"># 分析的查询语句是什么</span><br><span class="line">QUERY: SELECT * FROM s1 WHERE</span><br><span class="line">    key1 &gt; &#x27;z&#x27; AND</span><br><span class="line">    key2 &lt; 1000000 AND</span><br><span class="line">    key3 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">    common_field = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line"># 优化的具体过程</span><br><span class="line">TRACE: &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123;     # prepare阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;IN_uses_bisection&quot;: true</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `s1`.`id` AS `id`,`s1`.`key1` AS `key1`,`s1`.`key2` AS `key2`,`s1`.`key3` AS `key3`,`s1`.`key_part1` AS `key_part1`,`s1`.`key_part2` AS `key_part2`,`s1`.`key_part3` AS `key_part3`,`s1`.`common_field` AS `common_field` from `s1` where ((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_preparation */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;    # optimize阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;   # 处理搜索条件</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              # 原始搜索条件</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  # 等值传递转换</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 常量传递转换    </span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  # 去除没用的条件</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* steps */</span><br><span class="line">            &#125; /* condition_processing */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 替换虚拟生成列</span><br><span class="line">            &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">            &#125; /* substitute_generated_columns */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 表的依赖信息</span><br><span class="line">            &quot;table_dependencies&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: false,</span><br><span class="line">                &quot;map_bit&quot;: 0,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ] /* depends_on_map_bits */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* table_dependencies */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">            ] /* ref_optimizer_key_uses */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">          </span><br><span class="line">            # 预估不同单表访问方法的访问成本</span><br><span class="line">            &quot;rows_estimation&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                  &quot;table_scan&quot;: &#123;   # 全表扫描的行数以及成本</span><br><span class="line">                    &quot;rows&quot;: 9688,</span><br><span class="line">                    &quot;cost&quot;: 2036.7</span><br><span class="line">                  &#125; /* table_scan */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析可能使用的索引</span><br><span class="line">                  &quot;potential_range_indexes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,   # 主键不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,  # idx_key2可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key2&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key1&quot;,  # idx_key1可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key1&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key3&quot;,  # idx_key3可能被使用</span><br><span class="line">                      &quot;usable&quot;: true,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;key3&quot;,</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] /* key_parts */</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key_part&quot;,  # idx_keypart不可用</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* potential_range_indexes */,</span><br><span class="line">                  &quot;setup_range_conditions&quot;: [</span><br><span class="line">                  ] /* setup_range_conditions */,</span><br><span class="line">                  &quot;group_index_range&quot;: &#123;</span><br><span class="line">                    &quot;chosen&quot;: false,</span><br><span class="line">                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                  &#125; /* group_index_range */,</span><br><span class="line">                  </span><br><span class="line">                  # 分析各种可能使用的索引的成本</span><br><span class="line">                  &quot;analyzing_range_alternatives&quot;: &#123;</span><br><span class="line">                    &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key2的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                        # 使用idx_key2的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 是否使用index dive</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,     # 使用该索引获取的记录是否按照主键排序</span><br><span class="line">                        &quot;using_mrr&quot;: false,     # 是否使用mrr</span><br><span class="line">                        &quot;index_only&quot;: false,    # 是否是索引覆盖访问</span><br><span class="line">                        &quot;rows&quot;: 12,     # 使用该索引获取的记录条数</span><br><span class="line">                        &quot;cost&quot;: 15.41,  # 使用该索引的成本</span><br><span class="line">                        &quot;chosen&quot;: true  # 是否选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key1的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key1&quot;,</span><br><span class="line">                        # 使用idx_key1的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;z &lt; key1&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 266,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 320.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 因为成本太大所以不选择该索引</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        # 使用idx_key3的成本分析</span><br><span class="line">                        &quot;index&quot;: &quot;idx_key3&quot;,</span><br><span class="line">                        # 使用idx_key3的范围区间</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;a &lt;= key3 &lt;= a&quot;,</span><br><span class="line">                          &quot;b &lt;= key3 &lt;= b&quot;,</span><br><span class="line">                          &quot;c &lt;= key3 &lt;= c&quot;</span><br><span class="line">                        ] /* ranges */,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: true,   # 同上</span><br><span class="line">                        &quot;rowid_ordered&quot;: false,   # 同上</span><br><span class="line">                        &quot;using_mrr&quot;: false,   # 同上</span><br><span class="line">                        &quot;index_only&quot;: false,   # 同上</span><br><span class="line">                        &quot;rows&quot;: 21,   # 同上</span><br><span class="line">                        &quot;cost&quot;: 28.21,   # 同上</span><br><span class="line">                        &quot;chosen&quot;: false,   # 同上</span><br><span class="line">                        &quot;cause&quot;: &quot;cost&quot;   # 同上</span><br><span class="line">                      &#125;</span><br><span class="line">                    ] /* range_scan_alternatives */,</span><br><span class="line">                    </span><br><span class="line">                    # 分析使用索引合并的成本</span><br><span class="line">                    &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">                      &quot;usable&quot;: false,</span><br><span class="line">                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                    &#125; /* analyzing_roworder_intersect */</span><br><span class="line">                  &#125; /* analyzing_range_alternatives */,</span><br><span class="line">                  </span><br><span class="line">                  # 对于上述单表查询s1最优的访问方法</span><br><span class="line">                  &quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">                    &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                      &quot;index&quot;: &quot;idx_key2&quot;,</span><br><span class="line">                      &quot;rows&quot;: 12,</span><br><span class="line">                      &quot;ranges&quot;: [</span><br><span class="line">                        &quot;NULL &lt; key2 &lt; 1000000&quot;</span><br><span class="line">                      ] /* ranges */</span><br><span class="line">                    &#125; /* range_access_plan */,</span><br><span class="line">                    &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                    &quot;cost_for_plan&quot;: 15.41,</span><br><span class="line">                    &quot;chosen&quot;: true</span><br><span class="line">                  &#125; /* chosen_range_access_summary */</span><br><span class="line">                &#125; /* range_analysis */</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* rows_estimation */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            </span><br><span class="line">            # 分析各种可能的执行计划</span><br><span class="line">            #（对多表查询这可能有很多种不同的方案，单表查询的方案上边已经分析过了，直接选取idx_key2就好）</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ] /* plan_prefix */,</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: 12,</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;range_details&quot;: &#123;</span><br><span class="line">                        &quot;used_index&quot;: &quot;idx_key2&quot;</span><br><span class="line">                      &#125; /* range_details */,</span><br><span class="line">                      &quot;resulting_rows&quot;: 12,</span><br><span class="line">                      &quot;cost&quot;: 17.81,</span><br><span class="line">                      &quot;chosen&quot;: true</span><br><span class="line">                    &#125;</span><br><span class="line">                  ] /* considered_access_paths */</span><br><span class="line">                &#125; /* best_access_path */,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: 100,</span><br><span class="line">                &quot;rows_for_plan&quot;: 12,</span><br><span class="line">                &quot;cost_for_plan&quot;: 17.81,</span><br><span class="line">                &quot;chosen&quot;: true</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* considered_execution_plans */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 尝试给查询添加一些其他的查询条件</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ] /* attached_conditions_computation */,</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key2` &lt; 1000000) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] /* attached_conditions_summary */</span><br><span class="line">            &#125; /* attaching_conditions_to_tables */</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            # 再稍稍的改进一下执行计划</span><br><span class="line">            &quot;refine_plan&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`s1`&quot;,</span><br><span class="line">                &quot;pushed_index_condition&quot;: &quot;(`s1`.`key2` &lt; 1000000)&quot;,</span><br><span class="line">                &quot;table_condition_attached&quot;: &quot;((`s1`.`key1` &gt; &#x27;z&#x27;) and (`s1`.`key3` in (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)) and (`s1`.`common_field` = &#x27;abc&#x27;))&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] /* refine_plan */</span><br><span class="line">          &#125;</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_optimization */</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123;    # execute阶段</span><br><span class="line">        &quot;select#&quot;: 1,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        ] /* steps */</span><br><span class="line">      &#125; /* join_execution */</span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 因优化过程文本太多而丢弃的文本字节大小，值为0时表示并没有丢弃</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0</span><br><span class="line"></span><br><span class="line"># 权限字段</span><br><span class="line">INSUFFICIENT_PRIVILEGES: 0</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这只是优化器执行过程中的一小部分，<code>MySQL</code>可能会在之后的版本中添加更多的优化过程信息。不过杂乱之中其实还是蛮有规律的，优化过程大致分为了三个阶段：</p><ul><li><code>prepare</code>阶段</li><li><code>optimize</code>阶段</li><li><code>execute</code>阶段</li></ul><p>我们所说的基于成本的优化主要集中在<code>optimize</code>阶段，对于单表查询来说，我们主要关注<code>optimize</code>阶段的<code>&quot;rows_estimation&quot;</code>这个过程，这个过程深入分析了对单表查询的各种执行方案的成本；对于多表连接查询来说，我们更多需要关注<code>&quot;considered_execution_plans&quot;</code>这个过程，这个过程里会写明各种不同的连接方式所对应的成本。反正优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用<code>EXPLAIN</code>语句所展现出的那种方案。</p><p>如果对使用<code>EXPLAIN</code>语句展示出的对某个查询的执行计划很不理解，可以尝试使用<code>optimizer trace</code>功能来详细了解每一种执行方案对应的成本。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[九]基于规则的优化&amp;子查询优化</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&amp;%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><code>MySQL</code>依据一些规则，把语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<code>查询重写</code>。</p><h1 id="1-条件化简"><a href="#1-条件化简" class="headerlink" title="1.条件化简"></a>1.条件化简</h1><p>我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行，<code>MySQL</code>的查询优化器会为我们简化这些表达式。</p><h2 id="1-1移除不必要的括号"><a href="#1-1移除不必要的括号" class="headerlink" title="1.1移除不必要的括号"></a>1.1移除不必要的括号</h2><p>有时候表达式里有许多无用的括号，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a = 5 AND b = c) OR ((a &gt; c) AND (c &lt; 5)))</span><br></pre></td></tr></table></figure><p>优化器会把那些用不到的括号给干掉，就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a = 5 and b = c) OR (a &gt; c AND c &lt; 5)</span><br></pre></td></tr></table></figure><h2 id="1-2常量传递"><a href="#1-2常量传递" class="headerlink" title="1.2常量传递"></a>1.2常量传递</h2><p>有时候某个表达式是某个列和某个常量做等值匹配，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br></pre></td></tr></table></figure><p>当这个表达式和其他涉及列<code>a</code>的表达式使用<code>AND</code>连接起来时，可以将其他表达式中的<code>a</code>的值替换为<code>5</code>，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 AND b &gt; a</span><br></pre></td></tr></table></figure><p>就可以被转换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 AND b &gt; 5</span><br></pre></td></tr></table></figure><blockquote><p>用OR的表达式不能进行能量传递是因为OR两边的条件是取并集的，或者说互不相关。</p></blockquote><h2 id="1-3-等值传递"><a href="#1-3-等值传递" class="headerlink" title="1.3 等值传递"></a>1.3 等值传递</h2><p>有时候多个列之间存在等值匹配的关系，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b and b = c and c = 5</span><br></pre></td></tr></table></figure><p>这个表达式可以被简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 and b = 5 and c = 5</span><br></pre></td></tr></table></figure><h2 id="1-4移除没用的条件"><a href="#1-4移除没用的条件" class="headerlink" title="1.4移除没用的条件"></a>1.4移除没用的条件</h2><p>对于一些明显永远为<code>TRUE</code>或者<code>FALSE</code>的表达式，优化器会移除掉它们，比如这个表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; 1 and b = b) OR (a = 6 OR 5 != 5)</span><br></pre></td></tr></table></figure><p>很明显，<code>b = b</code>这个表达式永远为<code>TRUE</code>，<code>5 != 5</code>这个表达式永远为<code>FALSE</code>，所以简化后的表达式就是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; 1 and TRUE) OR (a = 6 OR FALSE)</span><br></pre></td></tr></table></figure><p>可以继续被简化为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt; 1 OR a = 6</span><br></pre></td></tr></table></figure><h2 id="1-5表达式计算"><a href="#1-5表达式计算" class="headerlink" title="1.5表达式计算"></a>1.5表达式计算</h2><p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5 + 1</span><br></pre></td></tr></table></figure><p>因为<code>5 + 1</code>这个表达式只包含常量，所以就会被化简成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 6</span><br></pre></td></tr></table></figure><p>但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABS(a) &gt; 5</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a &lt; -8</span><br></pre></td></tr></table></figure><p>优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。</p><h2 id="1-6HAVING-amp-WHERE子句的合并"><a href="#1-6HAVING-amp-WHERE子句的合并" class="headerlink" title="1.6HAVING&amp;WHERE子句的合并"></a>1.6HAVING&amp;WHERE子句的合并</h2><p>如果查询语句中没有出现诸如<code>SUM</code>、<code>MAX</code>等等的聚集函数以及<code>GROUP BY</code>子句，优化器就把<code>HAVING</code>子句和<code>WHERE</code>子句合并起来。</p><h2 id="1-7常量表检测"><a href="#1-7常量表检测" class="headerlink" title="1.7常量表检测"></a>1.7常量表检测</h2><p><code>MySQL</code>觉得下边这两种查询运行的特别快：</p><ol><li>查询的表中一条记录没有，或者只有一条记录。</li><li>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</li></ol><p>MySQL觉得这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为<code>常量表</code>（英文名：<code>constant tables</code>）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本，比方说这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table1 INNER JOIN table2</span><br><span class="line">    ON table1.column1 = table2.column2 </span><br><span class="line">    WHERE table1.primary_key = 1;</span><br></pre></td></tr></table></figure><p>很明显，这个查询可以使用主键和常量值的等值匹配来查询<code>table1</code>表，也就是在这个查询中<code>table1</code>表相当于<code>常量表</code>，在分析对<code>table2</code>表的查询成本之前，就会执行对<code>table1</code>表的查询，并把查询中涉及<code>table1</code>表的条件都替换掉，也就是上边的语句会被转换成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT table1表记录的各个字段的常量值, table2.* FROM table1 INNER JOIN table2 </span><br><span class="line">    ON table1表column1列的常量值 = table2.column2;</span><br></pre></td></tr></table></figure><h1 id="2-外连接消除"><a href="#2-外连接消除" class="headerlink" title="2.外连接消除"></a>2.外连接消除</h1><p><code>内连接</code>的驱动表和被驱动表的位置可以相互转换，而<code>左（外）连接</code>和<code>右（外）连接</code>的驱动表和被驱动表是固定的。这就导致<code>内连接</code>可能通过优化表的连接顺序来降低整体的查询成本，而<code>外连接</code>却无法优化表的连接顺序。我在之前的文章创建了两个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (</span><br><span class="line">    m1 int, </span><br><span class="line">    n1 char(1)</span><br><span class="line">) Engine=InnoDB, CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE t2 (</span><br><span class="line">    m2 int, </span><br><span class="line">    n2 char(1)</span><br><span class="line">) Engine=InnoDB, CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>再看一下表的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2   | n2   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。查询效果就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">|    1 | a    | NULL | NULL |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于上边例子中的（左）外连接来说，由于驱动表<code>t1</code>中<code>m1=1, n1=&#39;a&#39;</code>的记录无法在被驱动表<code>t2</code>中找到符合<code>ON</code>子句条件<code>t1.m1 = t2.m2</code>的记录，所以就直接把这条记录加入到结果集，对应的<code>t2</code>表的<code>m2</code>和<code>n2</code>列的值都设置为<code>NULL</code>。</p><blockquote><p>右（外）连接和左（外）连接其实只在驱动表的选取方式上是不同的，其余方面都是一样的，所以优化器会首先把右（外）连接查询转换成左（外）连接查询。</p></blockquote><p>凡是不符合WHERE子句中条件的记录都不会参与连接。只要我们在搜索条件中指定关于被驱动表相关列的值不为<code>NULL</code>，那么外连接中在被驱动表中找不到符合<code>ON</code>子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.n2 IS NOT NULL;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>由于指定了被驱动表<code>t2</code>的<code>n2</code>列不允许为<code>NULL</code>，所以上边的<code>t1</code>和<code>t2</code>表的左（外）连接查询和内连接查询是一样一样的。当然，我们也可以不用显式的指定被驱动表的某个列<code>IS NOT NULL</code>，只要隐含的有这个意思就行了，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在<code>WHERE</code>子句中指定了被驱动表<code>t2</code>的<code>m2</code>列等于<code>2</code>，也就相当于间接的指定了<code>m2</code>列不为<code>NULL</code>值，所以上边的这个左（外）连接查询其实和下边这个内连接查询是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们把这种在外连接查询中，指定的<code>WHERE</code>子句中包含被驱动表中的列不为<code>NULL</code>值的条件称之为<code>空值拒绝</code>（英文名：<code>reject-NULL</code>）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p><h1 id="3-子查询优化"><a href="#3-子查询优化" class="headerlink" title="3.子查询优化"></a>3.子查询优化</h1><h2 id="3-1子查询语法"><a href="#3-1子查询语法" class="headerlink" title="3.1子查询语法"></a>3.1子查询语法</h2><h3 id="3-1-1按返回的结果集区分子查询"><a href="#3-1-1按返回的结果集区分子查询" class="headerlink" title="3.1.1按返回的结果集区分子查询"></a>3.1.1按返回的结果集区分子查询</h3><p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型：</p><ol><li><p> 标量子查询<br>那些只返回一个单一值的子查询称之为<code>标量子查询</code>，比如这样：<br>或者这样：<br>这两个查询语句中的子查询都返回一个单一的值，也就是一个<code>标量</code>。这些标量子查询可以作为一个单一值或者表达式的一部分出现在查询语句的各个地方。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (SELECT m1 FROM t1 LIMIT 1);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);</span><br></pre></td></tr></table></figure></li><li><p> 行子查询<br>顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：<br>其中的<code>(SELECT m2, n2 FROM t2 LIMIT 1)</code>就是一个行子查询，整条语句的含义就是要从<code>t1</code>表中找一些记录，这些记录的<code>m1</code>和<code>n1</code>列分别等于子查询结果中的<code>m2</code>和<code>n2</code>列。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);</span><br></pre></td></tr></table></figure></li><li><p> 列子查询<br>列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：<br>其中的<code>(SELECT m2 FROM t2)</code>就是一个列子查询，表明查询出<code>t2</code>表的<code>m2</code>列的值作为外层查询<code>IN</code>语句的参数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</span><br></pre></td></tr></table></figure></li><li><p> 表子查询<br>顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：<br>其中的<code>(SELECT m2, n2 FROM t2)</code>就是一个表子查询，这里需要和行子查询对比一下，行子查询中我们用了<code>LIMIT 1</code>来保证子查询的结果只有一条记录，表子查询中不需要这个限制。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-1-2按与外层查询关系来区分子查询"><a href="#3-1-2按与外层查询关系来区分子查询" class="headerlink" title="3.1.2按与外层查询关系来区分子查询"></a>3.1.2按与外层查询关系来区分子查询</h3><ol><li> 不相关子查询<br>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为<code>不相关子查询</code>。我们前边介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了哈。 </li><li> 相关子查询<br>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为<code>相关子查询</code>。比如：<br>例子中的子查询是<code>(SELECT m2 FROM t2 WHERE n1 = n2)</code>，可是这个查询中有一个搜索条件是<code>n1 = n2</code>，别忘了<code>n1</code>是表<code>t1</code>的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个<code>相关子查询</code>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-1-3-子查询语法注意事项"><a href="#3-1-3-子查询语法注意事项" class="headerlink" title="3.1.3 子查询语法注意事项"></a>3.1.3 子查询语法注意事项</h3><ol><li><p> 子查询必须用小括号扩起来。 </p></li><li><p> 在<code>SELECT</code>子句中的子查询必须是标量子查询。 </p></li><li><p> 在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用<code>LIMIT 1</code>语句来限制记录数量。 </p></li><li><p> 对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。<br>比如这样是非法的：<br>因为<code>[NOT] IN/ANY/SOME/ALL</code>子查询不支持<code>LIMIT</code>语句，所以子查询中的这些语句也就是多余的了： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 WHERE m1 IN (SELECT * FROM t2 LIMIT 2);</span><br></pre></td></tr></table></figure></li><li><p><code>ORDER BY</code>子句：子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要。</p></li><li><p><code>DISTINCT</code>语句：集合里的值去不去重也没啥意义。</p></li><li><p>没有聚集函数以及<code>HAVING</code>子句的<code>GROUP BY</code>子句。</p></li></ol><p>对于这些冗余的语句，查询优化器在一开始就把它们给干掉了。 </p><ol start="5"><li> 不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM t1 WHERE m1 &lt; (SELECT MAX(m1) FROM t1);</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-子查询的执行"><a href="#3-2-子查询的执行" class="headerlink" title="3.2 子查询的执行"></a>3.2 子查询的执行</h2><p>还是复用前面的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>我们假设有两个表<code>s1</code>、<code>s2</code>与这个<code>single_table</code>表的构造是相同的，而且这两个表里边儿有10000条记录。</p><h3 id="3-2-1-标量-行子查询的执行方式"><a href="#3-2-1-标量-行子查询的执行方式" class="headerlink" title="3.2.1 标量/行子查询的执行方式"></a>3.2.1 标量/行子查询的执行方式</h3><p>我们经常在下边两个场景中使用到标量子查询或者行子查询：</p><ul><li><code>SELECT</code>子句中，我们前边说过的在查询列表中的子查询必须是标量子查询。</li><li>子查询使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li></ul><p>对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下边这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27; LIMIT 1);</span><br></pre></td></tr></table></figure><ol><li>先单独执行<code>(SELECT common_field FROM s2 WHERE key3 = &#39;a&#39; LIMIT 1)</code>这个子查询。</li><li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 = ...</code>。</li></ol><p>也就是说，<strong>对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</strong></p><p>对于相关的标量子查询或者行子查询来说，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE </span><br><span class="line">    key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12610368/1641804199349-63a75016-de79-4c41-897b-b2add30ea245.jpeg#clientId=u08f6cf82-f067-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42a271a5&margin=%5Bobject%20Object%5D&name=%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg&originHeight=975&originWidth=3093&originalType=binary&ratio=1&rotation=0&showTitle=false&size=259239&status=done&style=none&taskId=u108f4af2-efce-47d1-bcce-7a62b84dd35&title=" alt="相关子查询执行流程.jpg"></p><h3 id="3-2-2-IN子查询优化"><a href="#3-2-2-IN子查询优化" class="headerlink" title="3.2.2 IN子查询优化"></a>3.2.2 IN子查询优化</h3><h4 id="①-物化表的提出"><a href="#①-物化表的提出" class="headerlink" title="① 物化表的提出"></a>① 物化表的提出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>对于不相关的<code>IN</code>子查询来说，如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还行，但是如果单独执行子查询后的结果集太多的话，就会导致这些问题：</p><ul><li>结果集太多，可能内存中都放不下。</li><li>对于外层查询来说，如果子查询的结果集太多，那就意味着<code>IN</code>子句中的参数特别多，这就导致： <ul><li>无法有效的使用索引，只能对外层查询进行全表扫描。</li><li>在对外层查询执行全表扫描时，由于<code>IN</code>子句中的参数太多，这会导致检测一条记录是否符合和<code>IN</code>子句中的参数匹配花费的时间太长。</li></ul></li></ul><p>所以MySQL并不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。</p><ol><li><p> 该临时表的列就是子查询结果集中的列。 </p></li><li><p> 写入临时表的记录会被去重。<br>我们说<code>IN</code>语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个<code>IN</code>语句的结果并没有影响，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小。  </p><blockquote><p>临时表如何对记录进行去重？只要为表中记录的所有列建立主键或者唯一索引就好了嘛～</p></blockquote></li><li><p> 一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用<code>Memory</code>存储引擎的临时表，而且会为该表建立哈希索引。<br>如果子查询的结果集非常大，超过了系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为<code>B+</code>树索引。 </p><blockquote><p>IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。</p></blockquote></li></ol><p><code>MySQL</code>把这个将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行<code>IN</code>语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p><h4 id="②-物化表转连接"><a href="#②-物化表转连接" class="headerlink" title="② 物化表转连接"></a>② 物化表转连接</h4><p>再看一下最开始的那个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>当我们把子查询进行物化之后，假设子查询物化表的名称为<code>materialized_table</code>，该物化表存储的子查询结果集的列为<code>m_val</code>，那么这个查询其实可以从下边两种角度来看待：</p><ul><li> 从表<code>s1</code>的角度来看待，整个查询的意思其实是：对于<code>s1</code>表中的每条记录来说，如果该记录的<code>key1</code>列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640267701713-1a419399-7381-4338-a04e-0af34b0555d8.png#clientId=u7473b4e3-8a45-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u981c0b64&margin=%5Bobject%20Object%5D&name=1.png&originHeight=519&originWidth=728&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126733&status=done&style=none&taskId=ube4d8262-3244-4e4c-9f1a-846f3f773dd&title=" alt="1.png"></li><li> 从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在<code>s1</code>表中找到对应的<code>key1</code>列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640267710960-6fc5e0b3-555b-4690-be6f-cef6913cb7e8.png#clientId=u7473b4e3-8a45-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1611c8f0&margin=%5Bobject%20Object%5D&name=2.png&originHeight=457&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103779&status=done&style=none&taskId=u1a52d8a1-26f9-4226-9340-d7cd29f77ac&title=" alt="2.png"></li></ul><p>也就是说其实上边的查询就相当于表<code>s1</code>和子查询物化表<code>materialized_table</code>进行内连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;</span><br></pre></td></tr></table></figure><p>转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表<code>s1</code>和物化表<code>materialized_table</code>进行内连接的成本都是由哪几部分组成的：</p><ul><li>如果使用<code>s1</code>表作为驱动表的话，总查询成本由下边几个部分组成： <ol><li>物化子查询时需要的成本</li><li>扫描<code>s1</code>表时的成本</li><li>s1表中的记录数量 × 通过<code>m_val = xxx</code>对<code>materialized_table</code>表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li></ol></li><li>如果使用<code>materialized_table</code>表作为驱动表的话，总查询成本由下边几个部分组成： <ol><li>物化子查询时需要的成本</li><li>扫描物化表时的成本</li><li>物化表中的记录数量 × 通过<code>key1 = xxx</code>对<code>s1</code>表进行单表访问的成本（非常庆幸<code>key1</code>列上建立了索引，所以这个步骤是非常快的）。</li></ol></li></ul><p><code>MySQL</code>查询优化器会通过运算来选择上述成本更低的方案来执行查询。</p><h4 id="③-将子查询转换为semi-join"><a href="#③-将子查询转换为semi-join" class="headerlink" title="③ 将子查询转换为semi-join"></a>③ 将子查询转换为semi-join</h4><p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用，能不能不进行物化操作直接把子查询转换为连接呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><p>我们可以把这个查询理解成：对于<code>s1</code>表中的某条记录，如果我们能在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中找到一条或多条记录，这些记录的<code>common_field</code>的值等于<code>s1</code>表记录的<code>key1</code>列的值，那么该条<code>s1</code>表的记录就会被加入到最终的结果集。这个过程其实和把<code>s1</code>和<code>s2</code>两个表连接起来的效果很像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s2.key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>只不过我们不能保证对于<code>s1</code>表的某条记录来说，在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中有多少条记录满足<code>s1.key1 = s2.common_field</code>这个条件，不过我们可以分三种情况讨论：</p><ul><li>情况一：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中没有任何记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录自然也不会加入到最后的结果集。</li><li>情况二：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中有且只有1条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被加入最终的结果集。</li><li>情况三：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中至少有2条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被多次加入最终的结果集。</li></ul><p>对于<code>s1</code>表的某条记录来说，由于我们只关心<code>s2</code>表中是否存在记录满足<code>s1.key1 = s2.common_field</code>这个条件，而不关心具体有多少条记录与之匹配，又因为有<code>情况三</code>的存在，我们上边所说的<code>IN</code>子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以<code>MySQL</code>在这里提出了一个新概念 — <code>半连接</code>。将<code>s1</code>表和<code>s2</code>表进行半连接的意思就是：对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录。我们假设MySQL内部是这么改写上边的子查询的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 SEMI JOIN s2</span><br><span class="line">    ON s1.key1 = s2.common_field</span><br><span class="line">    WHERE key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>semi-join只是在MySQL内部采用的一种执行子查询的方式，MySQL并没有提供面向用户的semi-join语法，所以我们不需要，也不能尝试把上边这个语句放到mysql客户端执行。</p></blockquote><p>怎么实现这种所谓的<code>半连接</code>呢？</p><ul><li><p> Table pullout （子查询中的表上拉）<br>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表<code>上拉</code>到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个<br>由于<code>key2</code>列是<code>s2</code>表的唯一二级索引列，所以我们可以直接把<code>s2</code>表上拉到外层查询的<code>FROM</code>子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：<br>为什么当子查询的查询列表处只有主键或者唯一索引列时，就可以直接将子查询转换为连接查询呢？主键或者唯一索引列中的数据本身就是不重复的，所以对于同一条<code>s1</code>表中的记录，不可能找到两条以上的符合<code>s1.key2 = s2.key2</code>的记录。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key2 = s2.key2 </span><br><span class="line">    WHERE s2.key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> DuplicateWeedout execution strategy （重复值消除）<br>对于这个查询来说：<br>转换为半连接查询后，<code>s1</code>表中的某条记录可能在<code>s2</code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：<br>这样在执行连接查询的过程中，每当某条<code>s1</code>表中的记录要加入结果集时，就首先把这条记录的<code>id</code>值加入到这个临时表里，如果添加成功，说明之前这条<code>s1</code>表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明之前这条<code>s1</code>表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code>。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp (</span><br><span class="line">    id PRIMARY KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p> LooseScan execution strategy （松散扫描）<br>大家看这个查询：<br>在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640267724986-725be8df-4e22-4b31-ad11-f1f3f52b05ba.png#clientId=u7473b4e3-8a45-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4f2fb7fe&margin=%5Bobject%20Object%5D&name=3.png&originHeight=335&originWidth=810&originalType=binary&ratio=1&rotation=0&showTitle=false&size=127580&status=done&style=none&taskId=u525e014a-627f-4977-a72b-fd728749105&title=" alt="3.png"><br>如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>&#39;aa&#39;</code>的二级索引记录一共有3条，那么只需要取第一条的值到<code>s1</code>表中查找<code>s1.key3 = &#39;aa&#39;</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到<code>s1</code>表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<code>松散扫描</code>。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;);</span><br></pre></td></tr></table></figure></li><li><p> Semi-join Materialization execution strategy<br>我们之前介绍的先把外层查询的<code>IN</code>子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种<code>semi-join</code>，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。 </p></li><li><p> FirstMatch execution strategy （首次匹配）<br><code>FirstMatch</code>是一种最原始的半连接执行方式，先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。 </p></li></ul><p>对于某些使用<code>IN</code>语句的相关子查询，比方这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3);</span><br></pre></td></tr></table></figure><p>它也可以很方便的转为半连接，转换后的语句类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.* FROM s1 SEMI JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.common_field AND s1.key3 = s2.key3;</span><br></pre></td></tr></table></figure><p>然后就可以使用我们上边介绍过的<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>FirstMatch</code>等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用<code>table pullout</code>的策略来执行查询，但是，由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询。</p><h4 id="④-semi-join的适用条件"><a href="#④-semi-join的适用条件" class="headerlink" title="④ semi-join的适用条件"></a>④ semi-join的适用条件</h4><p>当然，并不是所有包含<code>IN</code>子查询的查询语句都可以转换为<code>semi-join</code>，只有形如这样的查询才可以被转换为<code>semi-join</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM outer_tables </span><br><span class="line">    WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...</span><br></pre></td></tr></table></figure><p>或者这样的形式也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM outer_tables </span><br><span class="line">    WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...</span><br></pre></td></tr></table></figure><p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为<code>semi-join</code>：</p><ul><li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li><li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li><li>… 还有一些条件比较少见….</li></ul><h4 id="⑤-不适用于semi-join的情况"><a href="#⑤-不适用于semi-join的情况" class="headerlink" title="⑤ 不适用于semi-join的情况"></a>⑤ 不适用于semi-join的情况</h4><p>对于一些不能将子查询转位<code>semi-join</code>的情况，典型的比如下边这几种：</p><ul><li><p> 外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br><span class="line">        OR key2 &gt; 100;</span><br></pre></td></tr></table></figure></li><li><p> 使用<code>NOT IN</code>而不是<code>IN</code>的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br></pre></td></tr></table></figure></li><li><p> 在<code>SELECT</code>子句中的IN子查询的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;) FROM s1 ;</span><br></pre></td></tr></table></figure></li><li><p> 子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);</span><br></pre></td></tr></table></figure></li><li><p> 子查询中包含<code>UNION</code>的情况  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 IN (</span><br><span class="line">    SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27; </span><br><span class="line">    UNION</span><br><span class="line">    SELECT common_field FROM s2 WHERE key3 = &#x27;b&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p><code>MySQL</code>仍然会尝试优化不能转为<code>semi-join</code>查询的子查询，那就是：</p><ul><li><p> 对于不相关子查询来说，可以尝试把它们物化之后再参与查询<br>比如我们上边提到的这个查询：<br>先将子查询物化，然后再判断<code>key1</code>是否在物化表的结果集中可以加快查询执行的速度。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#x27;a&#x27;)</span><br></pre></td></tr></table></figure><blockquote><p>这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。</p></blockquote></li><li><p> 不管子查询是相关的还是不相关的，都可以把<code>IN</code>子查询尝试转为<code>EXISTS</code>子查询<br>其实对于任意一个IN子查询来说，都可以被转为<code>EXISTS</code>子查询，通用的例子如下：<br>可以被转换为：<br>当然这个过程中有一些特殊情况，比如在<code>outer_expr</code>或者<code>inner_expr</code>值为<code>NULL</code>的情况下就比较特殊。因为有<code>NULL</code>值作为操作数的表达式结果往往是<code>NULL</code>，比方说：<br>而<code>EXISTS</code>子查询的结果肯定是<code>TRUE</code>或者<code>FASLE</code>：<br>但是，我们大部分使用<code>IN</code>子查询的场景是把它放在<code>WHERE</code>或者<code>ON</code>子句中，而<code>WHERE</code>或者<code>ON</code>子句是不区分<code>NULL</code>和<code>FALSE</code>的，比方说：<br>所以只要我们的<code>IN</code>子查询是放在<code>WHERE</code>或者<code>ON</code>子句中的，那么<code>IN -&gt; EXISTS</code>的转换就是没问题的。说了这么多，为啥要转换呢？这是因为不转换的话可能用不到索引，比方说下边这个查询：<br>这个查询中的子查询是一个相关子查询，而且子查询执行的时候不能使用到索引，但是将它转为<code>EXISTS</code>子查询后却可以使用到索引：<br>转为<code>EXISTS</code>子查询时便可以使用到<code>s2</code>表的<code>idx_key3</code>索引了。<br>需要注意的是，如果<code>IN</code>子查询不满足转换为<code>semi-join</code>的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为<code>EXISTS</code>查询。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (SELECT inner_expr FROM ... WHERE subquery_where AND outer_expr=inner_expr)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IN (1, 2, 3);</span><br><span class="line">+-------------------+</span><br><span class="line">| NULL IN (1, 2, 3) |</span><br><span class="line">+-------------------+</span><br><span class="line">|              NULL |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 IN (1, 2, 3);</span><br><span class="line">+----------------+</span><br><span class="line">| 1 IN (1, 2, 3) |</span><br><span class="line">+----------------+</span><br><span class="line">|              1 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL IN (NULL);</span><br><span class="line">+----------------+</span><br><span class="line">| NULL IN (NULL) |</span><br><span class="line">+----------------+</span><br><span class="line">|           NULL |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = 1);</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE NULL = 1) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                                        0 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL);</span><br><span class="line">+------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE 1 = NULL) |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                                        0 |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL);</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">| EXISTS (SELECT 1 FROM s1 WHERE NULL = NULL) |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">|                                           0 |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 FROM s1 WHERE NULL;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 FROM s1 WHERE FALSE;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">    WHERE key1 IN (SELECT key3 FROM s2 where s1.common_field = s2.common_field) </span><br><span class="line">        OR key2 &gt; 1000;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1</span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 where s1.common_field = s2.common_field AND s2.key3 = s1.key1) </span><br><span class="line">        OR key2 &gt; 1000;</span><br></pre></td></tr></table></figure><blockquote><p>在MySQL5.5以及之前的版本没有引进semi-join和物化的方式优化子查询时，优化器都会把IN子查询转换为EXISTS子查询。</p></blockquote></li></ul><h4 id="⑥-阶段梳理"><a href="#⑥-阶段梳理" class="headerlink" title="⑥ 阶段梳理"></a>⑥ 阶段梳理</h4><ul><li>如果<code>IN</code>子查询符合转换为<code>semi-join</code>的条件，查询优化器会优先把该子查询转换为<code>semi-join</code>，然后再考虑下边5种执行半连接的策略中哪个成本最低： <ul><li>Table pullout</li><li>DuplicateWeedout</li><li>LooseScan</li><li>Materialization</li><li>FirstMatch</li></ul></li></ul><p>选择成本最低的那种执行策略来执行子查询。 </p><ul><li>如果<code>IN</code>子查询不符合转换为<code>semi-join</code>的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询： <ul><li>先将子查询物化之后再执行查询</li><li>执行<code>IN to EXISTS</code>转换。</li></ul></li></ul><h3 id="3-2-3-ANY-ALL子查询优化"><a href="#3-2-3-ANY-ALL子查询优化" class="headerlink" title="3.2.3 ANY/ALL子查询优化"></a>3.2.3 ANY/ALL子查询优化</h3><p>如果ANY/ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行，比方说：</p><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr …)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr …)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h3 id="3-2-4-NOT-EXISTS子查询的执行"><a href="#3-2-4-NOT-EXISTS子查询的执行" class="headerlink" title="3.2.4 [NOT] EXISTS子查询的执行"></a>3.2.4 [NOT] EXISTS子查询的执行</h3><p>如果<code>[NOT] EXISTS</code>子查询是不相关子查询，可以先执行子查询，得出该<code>[NOT] EXISTS</code>子查询的结果是<code>TRUE</code>还是<code>FALSE</code>，并重写原先的查询语句，比如对这个查询来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE key1 = &#x27;a&#x27;) </span><br><span class="line">        OR key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>因为这个语句里的子查询是不相关子查询，所以优化器会首先执行该子查询，假设该EXISTS子查询的结果为<code>TRUE</code>，那么接着优化器会重写查询为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE TRUE OR key2 &gt; 100;</span><br></pre></td></tr></table></figure><p>进一步简化后就变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE TRUE;</span><br></pre></td></tr></table></figure><p>对于相关的<code>[NOT] EXISTS</code>子查询来说，比如这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.common_field);</span><br></pre></td></tr></table></figure><p>这个查询只能按照普通的那种执行相关子查询的方式来执行。不过如果<code>[NOT] EXISTS</code>子查询中如果可以使用索引的话，那查询速度也会加快不少，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 </span><br><span class="line">    WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.key1);</span><br></pre></td></tr></table></figure><p>上边这个<code>EXISTS</code>子查询中可以使用<code>idx_key1</code>来加快查询速度。</p><h3 id="3-2-5-对于派生表的优化"><a href="#3-2-5-对于派生表的优化" class="headerlink" title="3.2.5 对于派生表的优化"></a>3.2.5 对于派生表的优化</h3><p>我们前边说过把子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code>，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM  (</span><br><span class="line">        SELECT id AS d_id,  key3 AS d_key3 FROM s2 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 WHERE d_key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>子查询<code>( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = &#39;a&#39;)</code>的结果就相当于一个派生表，这个表的名称是<code>derived_s1</code>，该表有两个列，分别是<code>d_id</code>和<code>d_key3</code>。</p><p>对于含有<code>派生表</code>的查询，<code>MySQL</code>提供了两种执行策略：</p><ul><li><p> 把派生表物化<br>我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当然，在对派生表进行物化时，<code>MySQL</code>使用了一种称为<code>延迟物化</code>的策略，也就是在查询中真正使用到派生表时才会去尝试物化派生表，而不是还没开始执行查询就把派生表物化掉。比方说对于下边这个含有派生表的查询来说：<br>如果采用物化派生表的方式来执行这个查询的话，那么执行时首先会到<code>s2</code>表中找出满足<code>s2.key2 = 1</code>的记录，如果找不到，说明参与连接的<code>s2</code>表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">        SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 INNER JOIN s2</span><br><span class="line">    ON derived_s1.key1 = s2.key1</span><br><span class="line">    WHERE s2.key2 = 1;</span><br></pre></td></tr></table></figure></li><li><p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式<br>我们来看这个包含派生表的查询：<br>这个查询本质上就是想查看<code>s1</code>表中满足<code>key1 = &#39;a&#39;</code>条件的的全部记录，所以和下边这个语句是等价的：<br>对于一些稍微复杂的包含派生表的语句，比如我们上边提到的那个：<br>我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：<br>这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;) AS derived_s1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">        SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;</span><br><span class="line">    ) AS derived_s1 INNER JOIN s2</span><br><span class="line">    ON derived_s1.key1 = s2.key1</span><br><span class="line">    WHERE s2.key2 = 1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 INNER JOIN s2 </span><br><span class="line">    ON s1.key1 = s2.key1</span><br><span class="line">    WHERE s1.key1 = &#x27;a&#x27; AND s2.key2 = 1;</span><br></pre></td></tr></table></figure><ul><li>聚集函数，比如MAX()、MIN()、SUM()…</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>LIMIT</li><li>UNION 或者 UNION ALL</li><li>派生表对应的子查询的<code>SELECT</code>子句中含有另一个子查询</li><li>… 还有些不常用的情况…</li></ul></li></ul><p>所以<code>MySQL</code>在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>MySQL会对用户编写的SQL语句进行重写操作，比如：</p><ol><li>移除不必要的括号</li><li>常量传递</li><li>移除没用的条件</li><li>表达式计算</li><li>HAVING&amp;WHERE子句的合并</li><li>常量表检测</li></ol><p>在被驱动表的WHERE子句符合空值拒绝条件的时候，外连接&amp;内连接可以相互转换。</p><p>子查询可以按照不同维度进行不同分类，比如按照子查询返回的结果集分类：</p><ol><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ol><p>按照与外层查询的关系来分类：</p><ol><li>不相关子查询</li><li>相关子查询</li></ol><p>MySQL对in查询进行了很多优化。如果in子查询符合转换为半连接的条件，查询优化器会优先把该子查询转换为半连接，然后再考虑下面五种执行半连接查询的策略中哪个成本最低，最后选择成本最低的执行策略来执行子查询。</p><ol><li>table pullout</li><li>duplicate weedout</li><li>looseScan</li><li>Semj-join Materialization</li><li>FirstMatch</li></ol><p>如果IN子查询不符合转换为半连接的条件，查询优化器会从下面的两种策略里面找出一种成本更低的方式去执行子查询：</p><ol><li>先将子查询物化，在执行子查询</li><li>执行in到exists的转换</li></ol><p>MySQL在处理带有派生表的语句的时候，优先尝试把派生表和外层查询进行合并；如果不行，再把派生表物化掉，然后执行查询。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[八]InnoDB统计数据收集原理</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇我们来分析下<code>InnoDB</code>存储引擎的统计数据收集策略。</p></blockquote><h1 id="1-统计数据的存储方式"><a href="#1-统计数据的存储方式" class="headerlink" title="1.统计数据的存储方式"></a>1.统计数据的存储方式</h1><p><code>InnoDB</code>提供了两种存储统计数据的方式：</p><ol><li> 永久性的统计数据<br>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。 </li><li> 非永久性的统计数据<br>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。 </li></ol><p><code>MySQL</code>提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在<code>MySQL 5.6.6</code>之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说<code>InnoDB</code>的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p><p>不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。</p><p>我们可以在创建和修改表的时候通过指定<code>STATS_PERSISTENT</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_PERSISTENT = (1|0);</span><br></pre></td></tr></table></figure><p>当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上，当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值。</p><h1 id="2-永久性统计数据"><a href="#2-永久性统计数据" class="headerlink" title="2.永久性统计数据"></a>2.永久性统计数据</h1><p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;innodb%&#x27;;</span><br><span class="line">+---------------------------+</span><br><span class="line">| Tables_in_mysql (innodb%) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| innodb_index_stats        |</span><br><span class="line">| innodb_table_stats        |</span><br><span class="line">+---------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>可以看到，这两个表都位于<code>mysql</code>系统数据库下边，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><p>看一下这两个表里边都有什么以及表里的数据是如何生成的。</p><h2 id="2-1-innodb-table-stats"><a href="#2-1-innodb-table-stats" class="headerlink" title="2.1 innodb_table_stats"></a>2.1 innodb_table_stats</h2><p>直接看一下这个<code>innodb_table_stats</code>表中的各个列都是干嘛的：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>database_name</code></td><td>数据库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>last_update</code></td><td>本条记录最后更新时间</td></tr><tr><td><code>n_rows</code></td><td>表中记录的条数</td></tr><tr><td><code>clustered_index_size</code></td><td>表的聚簇索引占用的页面数量</td></tr><tr><td><code>sum_of_other_index_sizes</code></td><td>表的其他索引占用的页面数量</td></tr></tbody></table><p>注意这个表的主键是<code>(database_name,table_name)</code>，也就是innodb_table_stats表的每条记录代表着一个表的统计信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_table_stats;</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">| database_name | table_name    | last_update         | n_rows | clustered_index_size | sum_of_other_index_sizes |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">| mysql         | gtid_executed | 2021-12-14 00:00:08 |      0 |                    1 |                        0 |</span><br><span class="line">| sys           | sys_config    | 2021-12-14 00:00:09 |      6 |                    1 |                        0 |</span><br><span class="line">| yhd           | person_info   | 2021-12-19 00:27:39 |      0 |                    1 |                        1 |</span><br><span class="line">| yhd           | single_table  | 2021-12-19 02:13:19 | 910545 |                 3109 |                     5836 |</span><br><span class="line">+---------------+---------------+---------------------+--------+----------------------+--------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到<code>single_table</code>表的统计信息就对应着<code>mysql.innodb_table_stats</code>的第三条记录。几个重要统计信息项的值如下：</p><ul><li><code>n_rows</code>的值是<code>9693</code>，表明<code>single_table</code>表中大约有<code>9693</code>条记录，注意这个数据是估计值。</li><li><code>clustered_index_size</code>的值是<code>97</code>，表明<code>single_table</code>表的聚簇索引占用97个页面，这个值是也是一个估计值。</li><li><code>sum_of_other_index_sizes</code>的值是<code>175</code>，表明<code>single_table</code>表的其他索引一共占用175个页面，这个值是也是一个估计值。</li></ul><h3 id="2-1-1-n-rows统计项的收集"><a href="#2-1-1-n-rows统计项的收集" class="headerlink" title="2.1.1 n_rows统计项的收集"></a>2.1.1 n_rows统计项的收集</h3><p>为啥<code>n_rows</code>这个统计项的值是估计值呢？InnoDB`统计一个表中有多少行记录的套路是这样的：</p><ul><li> 按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的<code>n_rows</code>值。  <blockquote><p>真实的计算过程比这个稍微复杂一些，不过大致上就是这样。</p></blockquote></li></ul><p>可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，<code>MySQL</code>为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。</p><p>我们前边说过，不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_SAMPLE_PAGES = 具体的采样页面数量;</span><br></pre></td></tr></table></figure><p>如果我们在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。</p><h3 id="2-1-2-clustered-index-size和sum-of-other-index-sizes统计项的收集"><a href="#2-1-2-clustered-index-size和sum-of-other-index-sizes统计项的收集" class="headerlink" title="2.1.2 clustered_index_size和sum_of_other_index_sizes统计项的收集"></a>2.1.2 clustered_index_size和sum_of_other_index_sizes统计项的收集</h3><p>这两个统计项的收集过程如下：</p><ul><li> 从数据字典里找到表的各个索引对应的根页面位置。<br>系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。 </li><li>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。<br>在每个索引的根页面的<code>Page Header</code>部分都有两个字段： <ul><li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li><li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li></ul></li><li> 从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。<br>这个是<code>Segment Header</code>结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640188725245-45998fe0-ca45-4a90-9fbb-85d0fa39744d.png#clientId=ucf54091a-1d82-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u664e06a0&margin=%5Bobject%20Object%5D&name=1.png&originHeight=261&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=87783&status=done&style=none&taskId=u43c2aedd-8d61-4203-85ad-6f9875928e5&title=" alt="1.png"></li><li> 从对应的<code>INODE Entry</code>结构中可以找到该段对应所有零散的页面地址以及<code>FREE</code>、<code>NOT_FULL</code>、<code>FULL</code>链表的基节点。<br>这个是<code>INODE Entry</code>结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640188857945-2f6e0703-1c75-4280-a7dd-5d30eabec059.png#clientId=ucf54091a-1d82-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=509&id=ue79edf9e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&size=187896&status=done&style=none&taskId=ub5bc9cbc-5d67-457c-ae3a-58017a6198d&title=&width=848" alt="image.png"></li><li> 直接统计零散的页面有多少个，然后从那三个链表的<code>List Length</code>字段中读出该段占用的区的大小，每个区占用<code>64</code>个页，所以就可以统计出整个段占用的页面。<br>这个是链表基节点的示意图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640188756249-938d7c13-7332-46d4-aeea-cebd520a8faf.png#clientId=ucf54091a-1d82-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=388&id=uf62cb732&margin=%5Bobject%20Object%5D&name=image.png&originHeight=388&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&size=134904&status=done&style=none&taskId=u8941ec55-2b91-454b-a3ff-4ad64206a27&title=&width=750" alt="image.png"></li><li> 分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是<code>clustered_index_size</code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是<code>sum_of_other_index_sizes</code>的值。 </li></ul><p>注意，我们说一个段的数据在非常多时（超过32个页面），会以<code>区</code>为单位来申请空间，这里头的问题是以区为单位申请空间中有一些页可能并没有使用，但是在统计<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code>时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p><h2 id="2-2-innodb-index-stats"><a href="#2-2-innodb-index-stats" class="headerlink" title="2.2 innodb_index_stats"></a>2.2 innodb_index_stats</h2><p>直接看一下这个<code>innodb_index_stats</code>表中的各个列：</p><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td><code>database_name</code></td><td>数据库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>index_name</code></td><td>索引名</td></tr><tr><td><code>last_update</code></td><td>本条记录最后更新时间</td></tr><tr><td><code>stat_name</code></td><td>统计项的名称</td></tr><tr><td><code>stat_value</code></td><td>对应的统计项的值</td></tr><tr><td><code>sample_size</code></td><td>为生成统计数据而采样的页面数量</td></tr><tr><td><code>stat_description</code></td><td>对应的统计项的描述</td></tr></tbody></table><p>注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。我们直接看一下关于<code>single_table</code>表的索引统计数据都有些什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.innodb_index_stats WHERE table_name = &#x27;single_table&#x27;;</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">| database_name | table_name   | index_name   | last_update         | stat_name    | stat_value | sample_size | stat_description                  |</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">| yhd           | single_table | PRIMARY      | 2021-12-19 02:13:19 | n_diff_pfx01 |     910518 |          20 | id                                |</span><br><span class="line">| yhd           | single_table | PRIMARY      | 2021-12-19 02:13:19 | n_leaf_pages |       3097 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | PRIMARY      | 2021-12-19 02:13:19 | size         |       3109 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | n_diff_pfx01 |          8 |          10 | key1                              |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | n_diff_pfx02 |     882192 |          20 | key1,id                           |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | n_leaf_pages |        828 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | idx_key1     | 2021-12-19 02:13:19 | size         |        993 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | n_diff_pfx01 |          8 |          10 | key3                              |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | n_diff_pfx02 |     910072 |          20 | key3,id                           |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | n_leaf_pages |        827 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | idx_key3     | 2021-12-19 02:13:19 | size         |        993 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx01 |          8 |          10 | key_part1                         |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx02 |         82 |          20 | key_part1,key_part2               |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx03 |        730 |          20 | key_part1,key_part2,key_part3     |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_diff_pfx04 |    1028534 |          20 | key_part1,key_part2,key_part3,id  |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | n_leaf_pages |       2556 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | idx_key_part | 2021-12-19 02:13:19 | size         |       2985 |        NULL | Number of pages in the index      |</span><br><span class="line">| yhd           | single_table | uk_key2      | 2021-12-19 02:13:19 | n_diff_pfx01 |     913104 |          20 | key2                              |</span><br><span class="line">| yhd           | single_table | uk_key2      | 2021-12-19 02:13:19 | n_leaf_pages |        816 |        NULL | Number of leaf pages in the index |</span><br><span class="line">| yhd           | single_table | uk_key2      | 2021-12-19 02:13:19 | size         |        865 |        NULL | Number of pages in the index      |</span><br><span class="line">+---------------+--------------+--------------+---------------------+--------------+------------+-------------+-----------------------------------+</span><br><span class="line">20 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>这个结果有点儿多，正确查看这个结果的方式是这样的：</p><ol><li><p> 先查看<code>index_name</code>列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来，<code>PRIMARY</code>索引（也就是主键）占了3条记录，<code>idx_key_part</code>索引占了6条记录。 </p></li><li><p> 针对<code>index_name</code>列相同的记录，<code>stat_name</code>表示针对该索引的统计项名称，<code>stat_value</code>展示的是该索引在该统计项上的值，<code>stat_description</code>指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项： </p></li><li><p> <code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。 </p></li><li><p> <code>size</code>：表示该索引共占用多少页面。 </p></li><li><p> <code>n_diff_pfx**NN**</code>：表示对应的索引列不重复的值有多少。<br>其实<code>NN</code>可以被替换为<code>01</code>、<code>02</code>、<code>03</code>… 这样的数字。比如对于<code>idx_key_part</code>来说：       1. <code>n_diff_pfx01</code>表示的是统计<code>key_part1</code>这单单一个列不重复的值有多少。      1. <code>n_diff_pfx02</code>表示的是统计<code>key_part1、key_part2</code>这两个列组合起来不重复的值有多少。      1. <code>n_diff_pfx03</code>表示的是统计<code>key_part1、key_part2、key_part3</code>这三个列组合起来不重复的值有多少。      1. <code>n_diff_pfx04</code>表示的是统计<code>key_part1、key_part2、key_part3、id</code>这四个列组合起来不重复的值有多少。</p><blockquote><p>注意：对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_key1来说，key1列就可能有很多值重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少。比如上边的idx_key1有n_diff_pfx01、n_diff_pfx02两个统计项，而idx_key2却只有n_diff_pfx01一个统计项。</p></blockquote></li><li><p> 在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，<code>sample_size</code>列就表明了采样的页面数量是多少。  </p><blockquote><p>注意：对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sample_pages × 索引列的个数。当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以在查询结果中看到不同索引对应的size列的值可能是不同的。</p></blockquote></li></ol><h2 id="2-3定期更新统计数据"><a href="#2-3定期更新统计数据" class="headerlink" title="2.3定期更新统计数据"></a>2.3定期更新统计数据</h2><p>随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是要变的，不变的话<code>MySQL</code>查询优化器计算的成本就会有问题。<code>MySQL</code>提供了如下两种更新统计数据的方式：</p><ul><li><p> 开启<code>innodb_stats_auto_recalc</code>。<br>系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。<br><code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：<br>当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_AUTO_RECALC=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (...) Engine=InnoDB, STATS_AUTO_RECALC = (1|0);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 Engine=InnoDB, STATS_AUTO_RECALC = (1|0);</span><br></pre></td></tr></table></figure></li><li><p> 手动调用<code>ANALYZE TABLE</code>语句来更新统计信息<br>如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：<br>需要注意的是，<strong>ANALYZE TABLE</strong>语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE single_table;</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| Table                  | Op      | Msg_type | Msg_text |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">| yhd.single_table | analyze | status   | OK       |</span><br><span class="line">+------------------------+---------+----------+----------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4手动更新统计数据"><a href="#2-4手动更新统计数据" class="headerlink" title="2.4手动更新统计数据"></a>2.4手动更新统计数据</h2><p>其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以手动更新某个表或者索引的统计数据。比如说我们想把<code>single_table</code>表关于行数的统计数据更改一下可以这么做：</p><ol><li><p> 步骤一：更新<code>innodb_table_stats</code>表。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE innodb_table_stats </span><br><span class="line">    SET n_rows = 1</span><br><span class="line">    WHERE table_name = &#x27;single_table&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 步骤二：让<code>MySQL</code>查询优化器重新加载我们更改过的数据。<br>更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下边的命令就可以了：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH TABLE single_table;</span><br></pre></td></tr></table></figure></li></ol><p>之后我们使用<code>SHOW TABLE STATUS</code>语句查看表的统计数据时就看到<code>Rows</code>行变为了<code>1</code>。</p><h1 id="3-非永久性统计数据"><a href="#3-非永久性统计数据" class="headerlink" title="3.非永久性统计数据"></a>3.非永久性统计数据</h1><p>当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p><p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><p>另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成经常变化的执行计划。</p><h1 id="4-innodb-stats-method"><a href="#4-innodb-stats-method" class="headerlink" title="4.innodb_stats_method"></a>4.innodb_stats_method</h1><p><code>索引列不重复的值的数量</code>这个统计数据对于<code>MySQL</code>查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p><ul><li><p> 单表查询中单点区间太多，比方说这样：<br>当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl_name WHERE key IN (&#x27;xx1&#x27;, &#x27;xx2&#x27;, ..., &#x27;xxn&#x27;);</span><br></pre></td></tr></table></figure></li><li><p> 连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询，比方说这样：<br>在真正执行对<code>t2</code>表的查询前，<code>t1.comumn</code>的值是不确定的，所以我们也不能通过<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 JOIN t2 ON t1.column = t2.key WHERE ...;</span><br></pre></td></tr></table></figure></li></ul><p>在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现<code>NULL</code>值怎么办，比方说某个索引列的内容是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+------+</span><br><span class="line">| col  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">| NULL |</span><br><span class="line">| NULL |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure><p>此时计算这个<code>col</code>列中不重复的值的数量就有下边的分歧：</p><ul><li><p> 有的人认为<code>NULL</code>值代表一个未确定的值，所以<code>MySQL</code>认为任何和<code>NULL</code>值做比较的表达式的值都为<code>NULL</code>，就是这样：<br>所以每一个<code>NULL</code>值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把<code>NULL</code>值当作一个独立的值，所以<code>col</code>列的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个值）。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = NULL;</span><br><span class="line">+----------+</span><br><span class="line">| 1 = NULL |</span><br><span class="line">+----------+</span><br><span class="line">|     NULL |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT 1 != NULL;</span><br><span class="line">+-----------+</span><br><span class="line">| 1 != NULL |</span><br><span class="line">+-----------+</span><br><span class="line">|      NULL |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL = NULL;</span><br><span class="line">+-------------+</span><br><span class="line">| NULL = NULL |</span><br><span class="line">+-------------+</span><br><span class="line">|        NULL |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT NULL != NULL;</span><br><span class="line">+--------------+</span><br><span class="line">| NULL != NULL |</span><br><span class="line">+--------------+</span><br><span class="line">|         NULL |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p> 有的人认为其实<code>NULL</code>值在业务上就是代表没有，所有的<code>NULL</code>值代表的意义是一样的，所以<code>col</code>列不重复的值的数量就是：<code>3</code>（分别是1、2、NULL这三个值）。 </p></li><li><p> 有的人认为这<code>NULL</code>完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以<code>col</code>列不重复的值的数量就是：<code>2</code>（分别是1、2这两个值）。 </p></li></ul><p><code>MySQL</code>提供了一个名为<code>innodb_stats_method</code>的系统变量，我们可以自己来设置，这个系统变量有三个候选值：</p><ol><li> <code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。这个值也是<code>innodb_stats_method</code>的默认值。<br>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。 </li><li> <code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。<br>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。 </li><li> <code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。 </li></ol><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><ol><li><code>InnoDB</code>以表为单位来收集统计数据，这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据。</li><li><code>innodb_stats_persistent</code>控制着使用永久性统计数据还是非永久性统计数据；<code>innodb_stats_persistent_sample_pages</code>控制着永久性统计数据的采样页面数量；<code>innodb_stats_transient_sample_pages</code>控制着非永久性统计数据的采样页面数量；<code>innodb_stats_auto_recalc</code>控制着是否自动重新计算统计数据。</li><li>我们可以针对某个具体的表，在创建和修改表时通过指定<code>STATS_PERSISTENT</code>、<code>STATS_AUTO_RECALC</code>、<code>STATS_SAMPLE_PAGES</code>的值来控制相关统计数据属性。</li><li><code>innodb_stats_method</code>决定着在统计某个索引列不重复值的数量时如何对待<code>NULL</code>值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[七]基于成本的优化</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是成本？"><a href="#1-什么是成本？" class="headerlink" title="1.什么是成本？"></a>1.什么是成本？</h1><p>在<code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p><ul><li> <code>I/O</code>成本<br>我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。 </li><li> <code>CPU</code>成本<br>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。 </li></ul><p>对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，<code>MySQL</code>规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>。</p><blockquote><p>不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p></blockquote><h1 id="2-单表查询的成本"><a href="#2-单表查询的成本" class="headerlink" title="2.单表查询的成本"></a>2.单表查询的成本</h1><h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><p>把之前用到的<code>single_table</code>表搬来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE single_table (</span><br><span class="line">    id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    UNIQUE KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="2-2-基于成本的优化步骤"><a href="#2-2-基于成本的优化步骤" class="headerlink" title="2.2 基于成本的优化步骤"></a>2.2 基于成本的优化步骤</h2><p>在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE </span><br><span class="line">    key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND </span><br><span class="line">    key2 &gt; 10 AND key2 &lt; 1000 AND </span><br><span class="line">    key3 &gt; key2 AND </span><br><span class="line">    key_part1 LIKE &#x27;%hello%&#x27; AND</span><br><span class="line">    common_field = &#x27;123&#x27;;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-根据搜索条件，找出所有可能使用的索引"><a href="#2-2-1-根据搜索条件，找出所有可能使用的索引" class="headerlink" title="2.2.1 根据搜索条件，找出所有可能使用的索引"></a>2.2.1 根据搜索条件，找出所有可能使用的索引</h3><p>对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，<code>MySQL</code>把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p><p>我们分析一下上边查询中涉及到的几个搜索条件：</p><ul><li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li><li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li><li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li><li><code>key_part1 LIKE &#39;%hello%&#39;</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li><li><code>common_field = &#39;123&#39;</code>，由于该列上压根儿没有索引，所以不会用到索引。</li></ul><p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p><h3 id="2-2-2-计算全表扫描的代价"><a href="#2-2-2-计算全表扫描的代价" class="headerlink" title="2.2.2 计算全表扫描的代价"></a>2.2.2 计算全表扫描的代价</h3><p>对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本=<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><p>这两个信息从哪来呢？<code>MySQL</code>为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的后面再谈，现在看看怎么查看这些统计信息。<code>MySQL</code>给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS LIKE &#x27;single_table&#x27;</span><br></pre></td></tr></table></figure><p>虽然出现了很多统计选项，但我们目前只关心两个：</p><ul><li> <code>Rows</code><br>本选项表示表中的记录条数。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。 </li><li> <code>Data_length</code><br>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：<br>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data_length = 聚簇索引的页面数量 x 每个页面的大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</span><br></pre></td></tr></table></figure></li></ul><p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是<code>MySQL</code>在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，这些微调的值十分的小，并不影响我们分析。现在可以看一下全表扫描成本的计算过程：</p><ul><li><p> <code>I/O</code>成本<br><code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">97 x 1.0 + 1.1 = 98.1</span><br></pre></td></tr></table></figure></li><li><p> <code>CPU</code>成本：<br><code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 x 0.2 + 1.0 = 1939.6</span><br></pre></td></tr></table></figure></li><li><p> 总成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">98.1 + 1939.6 = 2037.7</span><br></pre></td></tr></table></figure></li></ul><p>综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p><blockquote><p>表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是MySQL在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I/O成本的依据，是不区分内节点和叶子节点的。</p></blockquote><h3 id="2-2-3-计算使用不同索引执行查询的代价"><a href="#2-2-3-计算使用不同索引执行查询的代价" class="headerlink" title="2.2.3 计算使用不同索引执行查询的代价"></a>2.2.3 计算使用不同索引执行查询的代价</h3><p>从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p><h4 id="①使用idx-key2执行查询的成本分析"><a href="#①使用idx-key2执行查询的成本分析" class="headerlink" title="①使用idx_key2执行查询的成本分析"></a>①使用idx_key2执行查询的成本分析</h4><p><code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176350999-33e75909-f6cf-4f47-8a62-a2d8212eb876.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u71764c3f&margin=%5Bobject%20Object%5D&name=1.png&originHeight=1170&originWidth=1622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=575463&status=done&style=none&taskId=u1e906447-5f38-4b93-8674-a23e7572a47&title=" alt="1.png"></p><p>对于使用<code>二级索引 + 回表</code>方式的查询，<code>MySQL</code>计算这种查询的成本依赖两个方面的数据：</p><ul><li><p> 范围区间数量<br>不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 x 1.0 = 1.0</span><br></pre></td></tr></table></figure></li><li><p>需要回表的记录数<br>优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算<code>idx_key2</code>在<code>(10, 1000)</code>这个范围区间中包含多少二级索引记录，计算过程是这样的： </p><ul><li> 步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。 </li><li> 步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。 </li><li> 步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176366166-30415d07-4c40-4385-bf7e-e6f27ecd0b98.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9da06e48&margin=%5Bobject%20Object%5D&name=2.png&originHeight=972&originWidth=1890&originalType=binary&ratio=1&rotation=0&showTitle=false&size=419948&status=done&style=none&taskId=ue5d8028d-6b8b-462c-8ee2-a9ab5e558aa&title=" alt="2.png"></li></ul></li></ul><p>如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就贼小了。<br>如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中，继续递归，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。<br>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 = 19.01</span><br></pre></td></tr></table></figure><p>其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。<br>在通过二级索引获取到记录之后，还需要干两件事儿： </p><ul><li><p> 根据这些记录里的主键值到聚簇索引中做回表操作<br><code>MySQL</code>认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上边统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：<br>其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 1.0 = 95.0</span><br></pre></td></tr></table></figure></li><li><p> 回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立<br>回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：<br><code>MySQL</code>只计算这个查找过程所需的<code>I/O</code>成本，也就是我们上一步骤中得到的<code>95.0</code>，在内存中的定位完整用户记录的过程的成本是忽略不计的。在定位到这些完整的用户记录后，需要检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立，这个比较过程花费的<code>CPU</code>成本就是：<br>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 = 19.0</span><br></pre></td></tr></table></figure></li></ul><p>所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p><ul><li><p> <code>I/O</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0 + 95 x 1.0 = 96.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li><li><p> <code>CPU</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">95 x 0.2 + 0.01 + 95 x 0.2 = 38.01 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li></ul><p>综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96.0 + 38.01 = 134.01</span><br></pre></td></tr></table></figure><h4 id="②使用idx-key1执行查询的成本分析"><a href="#②使用idx-key1执行查询的成本分析" class="headerlink" title="②使用idx_key1执行查询的成本分析"></a>②使用idx_key1执行查询的成本分析</h4><p><code>idx_key1</code>对应的搜索条件是：<code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，也就是说相当于3个单点区间：</p><ul><li><code>[&#39;a&#39;, &#39;a&#39;]</code></li><li><code>[&#39;b&#39;, &#39;b&#39;]</code></li><li><code>[&#39;c&#39;, &#39;c&#39;]</code></li></ul><p>使用<code>idx_key1</code>搜索的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640176380041-9a9e19f0-8469-426c-a064-ec10b855b743.png#clientId=uaab9e50c-a679-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u920d7136&margin=%5Bobject%20Object%5D&name=3.png&originHeight=1144&originWidth=1524&originalType=binary&ratio=1&rotation=0&showTitle=false&size=621869&status=done&style=none&taskId=u47f178fc-4c5c-47b1-ae74-fcb0d934c72&title=" alt="3.png"></p><p>与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p><ul><li><p> 范围区间数量<br>使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I/O成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 x 1.0 = 3.0</span><br></pre></td></tr></table></figure></li><li><p>需要回表的记录数<br>由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数： </p><ul><li> 查找单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数<br>计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，最后计算得到单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数是：<code>35</code>。 </li><li> 查找单点区间<code>[&#39;b&#39;, &#39;b&#39;]</code>对应的二级索引记录数<br>与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。 </li><li> 查找单点区间<code>[&#39;c&#39;, &#39;c&#39;]</code>对应的二级索引记录数<br>与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。 </li></ul></li></ul><p>所以，这三个单点区间总共需要回表的记录数就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35 + 44 + 39 = 118</span><br></pre></td></tr></table></figure><p>读取这些二级索引记录的<code>CPU</code>成本就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 = 23.61</span><br></pre></td></tr></table></figure><p>得到总共需要回表的记录数之后，就要考虑： </p><ul><li><p> 根据这些记录里的主键值到聚簇索引中做回表操作<br>所需的<code>I/O</code>成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 1.0 = 118.0</span><br></pre></td></tr></table></figure></li><li><p> 回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立<br>此步骤对应的<code>CPU</code>成本就是：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 = 23.6</span><br></pre></td></tr></table></figure></li></ul><p>所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p><ul><li><p> <code>I/O</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0 + 118 x 1.0 = 121.0 (范围区间的数量 + 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure></li><li><p> <code>CPU</code>成本：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">118 x 0.2 + 0.01 + 118 x 0.2 = 47.21 （读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li></ul><p>综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.0 + 47.21 = 168.21</span><br></pre></td></tr></table></figure><h4 id="③是否有可能使用索引合并（Index-Merge）"><a href="#③是否有可能使用索引合并（Index-Merge）" class="headerlink" title="③是否有可能使用索引合并（Index Merge）"></a>③是否有可能使用索引合并（Index Merge）</h4><p>本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p><h3 id="2-2-4-对比各种执行方案的代价，找出成本最低的那一个"><a href="#2-2-4-对比各种执行方案的代价，找出成本最低的那一个" class="headerlink" title="2.2.4 对比各种执行方案的代价，找出成本最低的那一个"></a>2.2.4 对比各种执行方案的代价，找出成本最低的那一个</h3><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p><ul><li>全表扫描的成本：<code>2037.7</code></li><li>使用<code>idx_key2</code>的成本：<code>134.01</code></li><li>使用<code>idx_key1</code>的成本：<code>168.21</code></li></ul><p>很显然，使用<code>idx_key2</code>的成本最低，所以选择<code>idx_key2</code>来执行查询。</p><h2 id="2-3-基于索引统计数据的成本计算"><a href="#2-3-基于索引统计数据的成本计算" class="headerlink" title="2.3 基于索引统计数据的成本计算"></a>2.3 基于索引统计数据的成本计算</h2><p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下边这个查询（下边查询语句中的<code>...</code>表示还有很多参数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure><p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。<code>MySQL</code>把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p><blockquote><p>index dive就是直接利用索引对应的B+树来计算某个范围区间对应的记录条数。</p></blockquote><p>有几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是如果很多的话，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。<code>MySQL</code>提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%dive%&#x27;;</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| Variable_name             | Value |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">| eq_range_index_dive_limit | 200   |</span><br><span class="line">+---------------------------+-------+</span><br><span class="line">1 row in set (0.08 sec)</span><br></pre></td></tr></table></figure><p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。</p><p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM single_table;</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table        | Non_unique | Key_name     | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| single_table |          0 | PRIMARY      |            1 | id          | A         |       9693  |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| single_table |          0 | idx_key2     |            1 | key2        | A         |       9693  |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key1     |            1 | key1        | A         |        968 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key3     |            1 | key3        | A         |        799 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            1 | key_part1   | A         |        9673 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            2 | key_part2   | A         |        9999 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| single_table |          1 | idx_key_part |            3 | key_part3   | A         |       10000 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><code>Table</code></td><td>索引所属表的名称。</td></tr><tr><td><code>Non_unique</code></td><td>索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为<code>0</code></td></tr><tr><td>，普通二级索引该列值为<code>1</code></td><td></td></tr><tr><td>。</td><td></td></tr><tr><td><code>Key_name</code></td><td>索引的名称。</td></tr><tr><td><code>Seq_in_index</code></td><td>索引列在索引中的位置，从1开始计数。比如对于联合索引<code>idx_key_part</code></td></tr><tr><td>，来说，<code>key_part1</code></td><td></td></tr><tr><td>、<code>key_part2</code></td><td></td></tr><tr><td>和<code>key_part3</code></td><td></td></tr><tr><td>对应的位置分别是1、2、3。</td><td></td></tr><tr><td><code>Column_name</code></td><td>索引列的名称。</td></tr><tr><td><code>Collation</code></td><td>索引列中的值是按照何种排序方式存放的，值为<code>A</code></td></tr><tr><td>时代表升序存放，为<code>NULL</code></td><td></td></tr><tr><td>时代表降序存放。</td><td></td></tr><tr><td><code>Cardinality</code></td><td>索引列中不重复值的数量。后边我们会重点看这个属性的。</td></tr><tr><td><code>Sub_part</code></td><td>对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前<code>n</code></td></tr><tr><td>个字符或字节建立索引，这个属性表示的就是那个<code>n</code></td><td></td></tr><tr><td>值。如果对完整的列建立索引的话，该属性的值就是<code>NULL</code></td><td></td></tr><tr><td>。</td><td></td></tr><tr><td><code>Packed</code></td><td>索引列如何被压缩，<code>NULL</code></td></tr><tr><td>值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。</td><td></td></tr><tr><td><code>Null</code></td><td>该索引列是否允许存储<code>NULL</code></td></tr><tr><td>值。</td><td></td></tr><tr><td><code>Index_type</code></td><td>使用索引的类型，我们最常见的就是<code>BTREE</code></td></tr><tr><td>，其实也就是<code>B+</code></td><td></td></tr><tr><td>树索引。</td><td></td></tr><tr><td><code>Comment</code></td><td>索引列注释信息。</td></tr><tr><td><code>Index_comment</code></td><td>索引注释信息。</td></tr></tbody></table><p>上述属性其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。</p><p>前边说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p><ul><li> 使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。 </li><li> 使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。<br>结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个值的重复次数 ≈ Rows ÷ Cardinality</span><br></pre></td></tr></table></figure></li></ul><p>以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9693 ÷ 968 ≈ 10（条）</span><br></pre></td></tr></table></figure><p>此时再看上边那条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 IN (&#x27;aa1&#x27;, &#x27;aa2&#x27;, &#x27;aa3&#x27;, ... , &#x27;zzz&#x27;);</span><br></pre></td></tr></table></figure><p>假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20000 x 10 = 200000</span><br></pre></td></tr></table></figure><p>使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是不精确！。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p><blockquote><p>在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</p></blockquote><h1 id="3-连接查询的成本"><a href="#3-连接查询的成本" class="headerlink" title="3. 连接查询的成本"></a>3. 连接查询的成本</h1><p>我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p><h2 id="3-1-条件过滤"><a href="#3-1-条件过滤" class="headerlink" title="3.1 条件过滤"></a>3.1 条件过滤</h2><p>我们前边说过，<code>MySQL</code>中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：</p><ul><li><p> 查询一：<br>假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2;</span><br></pre></td></tr></table></figure></li><li><p> 查询二：<br>仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前边计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">WHERE s1.key2 &gt;10 AND s1.key2 &lt; 1000;</span><br></pre></td></tr></table></figure></li></ul><p>有的时候扇出值的计算就变得很棘手，比方说下边几个查询：</p><ul><li><p> 查询三：<br>本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; &#39;xyz&#39;</code>条件。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 查询四：<br>本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; &#39;xyz&#39;</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; &#39;xyz&#39;</code>条件。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>查询五：<br>本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND</span><br><span class="line">          s1.key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) AND</span><br><span class="line">          s1.common_field &gt; &#x27;xyz&#x27;;</span><br></pre></td></tr></table></figure><ul><li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></li><li><code>common_field &gt; &#39;xyz&#39;</code></li></ul></li></ul><p>也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。 </p><p>说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li><li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li></ul><p><code>MySQL</code>把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是<code>MySQL</code>单纯的瞎猜。</p><blockquote><p>在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。在MySQL 5.7中，MySQL引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。 MySQL称之为启发式规则（heuristic）。</p></blockquote><h2 id="3-2-两表连接成本分析"><a href="#3-2-两表连接成本分析" class="headerlink" title="3.2 两表连接成本分析"></a>3.2 两表连接成本分析</h2><p>连接查询的成本计算公式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure><p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p><ul><li>分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p><ul><li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li><li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li></ul><p>很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。</p><blockquote><p>左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询。</p></blockquote><p>比如对于下边这个查询来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 </span><br><span class="line">    ON s1.key1 = s2.common_field </span><br><span class="line">    WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND </span><br><span class="line">          s2.key2 &gt; 1000 AND s2.key2 &lt; 2000;</span><br></pre></td></tr></table></figure><p>可以选择的连接顺序有两种：</p><ul><li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li><li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li></ul><p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p><ul><li>使用<code>s1</code>作为驱动表的情况 <ul><li>分析对于驱动表的成本最低的执行方案<br>首先看一下涉及<code>s1</code>表单表的搜索条件有哪些： <ul><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li></ul></li></ul></li></ul><p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，很显然使用<code>idx_key2</code>执行查询的成本更低些。 </p><ul><li>然后分析对于被驱动表的成本最低的执行方案<br>此时涉及被驱动表<code>s2</code>的搜索条件就是： <ul><li><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</li><li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li></ul></li></ul><p>很显然，第一个条件由于<code>common_field</code>没有用到索引，此时访问<code>s2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，假设使用<code>idx_key2</code>的成本更小。<br>所以此时使用<code>s1</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</span><br></pre></td></tr></table></figure><ul><li>使用<code>s2</code>作为驱动表的情况 <ul><li>分析对于驱动表的成本最低的执行方案<br>首先看一下涉及<code>s2</code>表单表的搜索条件有哪些： <ul><li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li></ul></li></ul></li></ul><p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，假设使用<code>idx_key2</code>执行查询的成本更低些。 </p><ul><li>然后分析对于被驱动表的成本最低的执行方案<br>此时涉及被驱动表<code>s1</code>的搜索条件就是： <ul><li><code>s1.key1 = 常数</code></li><li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 2000</code></li></ul></li></ul><p>这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这时优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上边已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们并不知道，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本更低，这里假设使用<code>idx_key1</code>进行对<code>s1</code>的访问。<br>所以此时使用<code>s2</code>作为驱动表时的总成本就是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</span><br></pre></td></tr></table></figure><p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下边这两个部分：</p><ul><li> 尽量减少驱动表的扇出 </li><li> 对被驱动表的访问成本尽量低<br>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。 </li></ul><h2 id="3-3-多表连接的成本分析"><a href="#3-3-多表连接的成本分析" class="headerlink" title="3.3 多表连接的成本分析"></a>3.3 多表连接的成本分析</h2><p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p><ul><li> 对于两表连接，比如表A和表B连接<br>只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。 </li><li> 对于三表连接，比如表A、表B、表C进行连接<br>有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。 </li><li> 对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。 </li><li> 对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。 </li></ul><p>有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍，不过<code>MySQL</code>想了很多办法减少计算非常多种连接顺序的成本的方法：</p><ul><li> 提前结束某种顺序的成本评估<br><code>MySQL</code>在计算各种链接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。 </li><li> 系统变量<code>optimizer_search_depth</code><br>为了防止无穷无尽的分析各种连接顺序的成本，<code>MySQL</code>提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。 </li><li> 根据某些规则压根儿就不考虑某些连接顺序<br>即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以<code>MySQL</code>干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。 </li></ul><h1 id="4-调节成本常数"><a href="#4-调节成本常数" class="headerlink" title="4. 调节成本常数"></a>4. 调节成本常数</h1><p>我们前边已经介绍了两个<code>成本常数</code>：</p><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>其实除了这两个成本常数，<code>MySQL</code>还支持好多，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库）的两个表中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES FROM mysql LIKE &#x27;%cost%&#x27;;</span><br><span class="line">+--------------------------+</span><br><span class="line">| Tables_in_mysql (%cost%) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| engine_cost              |</span><br><span class="line">| server_cost              |</span><br><span class="line">+--------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>一条语句的执行其实是分为两层的：</p><ul><li><code>server</code>层</li><li>存储引擎层</li></ul><p>在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p><h2 id="4-1mysql-server-cost表"><a href="#4-1mysql-server-cost表" class="headerlink" title="4.1mysql.server_cost表"></a>4.1mysql.server_cost表</h2><p><code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.server_cost;</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| cost_name                    | cost_value | last_update         | comment |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">| disk_temptable_create_cost   |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| disk_temptable_row_cost      |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| key_compare_cost             |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_create_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| memory_temptable_row_cost    |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| row_evaluate_cost            |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+------------------------------+------------+---------------------+---------+</span><br><span class="line">6 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>我们先看一下<code>server_cost</code>各个列都分别是什么意思：</p><ul><li> <code>cost_name</code><br>表示成本常数的名称。 </li><li> <code>cost_value</code><br>表示成本常数对应的值。如果该列的值为<code>NULL</code>的话，意味着对应的成本常数会采用默认值。 </li><li> <code>last_update</code><br>表示最后更新记录的时间。 </li><li> <code>comment</code><br>注释。 </li></ul><p>从<code>server_cost</code>中的内容可以看出来，目前在<code>server</code>层的一些操作对应的<code>成本常数</code>有以下几种：</p><table><thead><tr><th>成本常数名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>disk_temptable_create_cost</code></td><td><code>40.0</code></td><td>创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td><code>disk_temptable_row_cost</code></td><td><code>1.0</code></td><td>向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td><code>key_compare_cost</code></td><td><code>0.1</code></td><td>两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升<code>filesort</code></td></tr><tr><td>的成本，让优化器可能更倾向于使用索引完成排序而不是<code>filesort</code></td><td></td><td></td></tr><tr><td>。</td><td></td><td></td></tr><tr><td><code>memory_temptable_create_cost</code></td><td><code>2.0</code></td><td>创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td><code>memory_temptable_row_cost</code></td><td><code>0.2</code></td><td>向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td><code>row_evaluate_cost</code></td><td><code>0.2</code></td><td>这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td></tr></tbody></table><blockquote><p>MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。<strong>创建临时表和对这个临时表进行写入和读取的操作代价还是很高的。</strong></p></blockquote><p>这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p><ul><li><p> 对我们感兴趣的成本常数做更新操作<br>比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.server_cost </span><br><span class="line">    SET cost_value = 0.4</span><br><span class="line">    WHERE cost_name = &#x27;row_evaluate_cost&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 让系统重新加载这个表的值。<br>使用下边语句即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li></ul><p>当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p><h2 id="4-2mysql-engine-cost表"><a href="#4-2mysql-engine-cost表" class="headerlink" title="4.2mysql.engine_cost表"></a>4.2mysql.engine_cost表</h2><p><code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.engine_cost;</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| engine_name | device_type | cost_name              | cost_value | last_update         | comment |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">| default     |           0 | io_block_read_cost     |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">| default     |           0 | memory_block_read_cost |       NULL | 2018-01-20 12:03:21 | NULL    |</span><br><span class="line">+-------------+-------------+------------------------+------------+---------------------+---------+</span><br><span class="line">2 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p><ul><li> <code>engine_name</code>列<br>指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。 </li><li> <code>device_type</code>列<br>指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。 </li></ul><p>我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p><table><thead><tr><th>成本常数名称</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>io_block_read_cost</code></td><td><code>1.0</code></td><td>从磁盘上读取一个块对应的成本。请注意我使用的是<code>块</code></td></tr><tr><td>，而不是<code>页</code></td><td></td><td></td></tr><tr><td>这个词儿。对于<code>InnoDB</code></td><td></td><td></td></tr><tr><td>存储引擎来说，一个<code>页</code></td><td></td><td></td></tr><tr><td>就是一个块，不过对于<code>MyISAM</code></td><td></td><td></td></tr><tr><td>存储引擎来说，默认是以<code>4096</code></td><td></td><td></td></tr><tr><td>字节作为一个块的。增大这个值会加重<code>I/O</code></td><td></td><td></td></tr><tr><td>成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td><td></td><td></td></tr><tr><td><code>memory_block_read_cost</code></td><td><code>1.0</code></td><td>与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td></tr></tbody></table><p>怎么从内存中和从磁盘上读取一个块的默认成本是一样的？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以<code>MySQL</code>认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改。</p><p>与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p><ul><li><p> 插入针对某个存储引擎的成本常数<br>比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO mysql.engine_cost</span><br><span class="line">    VALUES (&#x27;InnoDB&#x27;, 0, &#x27;io_block_read_cost&#x27;, 2.0,</span><br><span class="line">    CURRENT_TIMESTAMP, &#x27;increase Innodb I/O cost&#x27;);</span><br></pre></td></tr></table></figure></li><li><p> 让系统重新加载这个表的值。<br>使用下边语句即可：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>在MySQL中，一个查询的执行成本是由IO成本和CPU成本组成的。对于InnoDB存储引擎来说，读取一个页面的默认IO成本是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。</p><p>在单表查询中，优化器生成执行计划的步骤如下：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那个方案</li></ol><p>在优化器生成执行计划过程中，需要依赖一些数据。这些数据可能是使用下面两种方式得到的：</p><ol><li>index dive：通过直接访问索引对应的B+树来获取数据</li><li>索引统计数据：直接依赖对表或者索引的统计数据</li></ol><p>为了更准确的计算连接查询的成本，MySQL提出了条件过滤的概念，也就是采用了某些规则来预测驱动表的扇出值。</p><p>对于内连接来说，为了生成成本最低的执行计划，需要考虑两方面的事情：</p><ol><li>选择最优的表连接顺序</li><li>为驱动表和被驱动表选择成本最低的访问方法</li></ol><p>我们可以通过手动修改MySQL数据库下engine_cost &amp; server_cost表中的某些成本常数，更精确的控制在生成执行计划时的成本计算过程。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[六]单表查询&amp;连接查询原理</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&amp;%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一，单表查询"><a href="#一，单表查询" class="headerlink" title="一，单表查询"></a><strong>一</strong>，单表查询</h1><p>不会走之前不要跑，在学SQL优化之前，我们先来分析下SQL是怎么执行的。</p><p>前面说过，<code>MySQL Server</code>有一个称为<code>查询优化器</code>的模块，一条查询语句进行语法解析之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的<code>执行计划</code>，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p><p>如果觉得我这篇博客讲的看不懂，回头看看我前面的几篇，MySQL是一个很复杂的东西，尽量不要跳着学，要静下心系统的来学习，之前我都是四处看帖子看博客，一直觉得自己MySQL迷迷糊糊，甚至成了痛点，所以决心写个MySQL专栏，系统的学习下。</p><p>我们前面创建过一张表，现在拿来复用下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>我们为这个<code>single_table</code>表建立了1个聚簇索引和4个二级索引，分别是：</p><ul><li>为<code>id</code>列建立的聚簇索引。</li><li>为<code>key1</code>列建立的<code>idx_key1</code>二级索引。</li><li>为<code>key2</code>列建立的<code>idx_key2</code>二级索引，而且该索引是唯一二级索引。</li><li>为<code>key3</code>列建立的<code>idx_key3</code>二级索引。</li><li>为<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>列建立的<code>idx_key_part</code>二级索引，这也是一个联合索引。</li></ul><p>这张表我插入了一百万数据，用来做实验。</p><h2 id="1-访问方法"><a href="#1-访问方法" class="headerlink" title="1.访问方法"></a>1.访问方法</h2><p>对于单个表的查询来说，MySQL把查询的执行方式大致分为下边两种：</p><ul><li> 使用全表扫描进行查询<br>这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。不管是啥查询都可以使用这种方式执行，当然，这种也是最笨的执行方式。 </li><li>使用索引进行查询<br>因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类： <ul><li>针对主键或唯一二级索引的等值查询</li><li>针对普通二级索引的等值查询</li><li>针对索引列的范围查询</li><li>直接扫描整个索引</li></ul></li></ul><p><code>MySQL</code>把<code>MySQL</code>执行查询语句的方式称之为<code>访问方法</code>或者<code>访问类型</code>。同一个查询语句可能可以使用多种不同的访问方法来执行，虽然最后的查询结果都是一样的，但是执行的时间可能相差很多。</p><h2 id="2-const"><a href="#2-const" class="headerlink" title="2.const"></a>2.const</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id = 1438;</span><br></pre></td></tr></table></figure><p><code>MySQL</code>会直接利用主键值在聚簇索引中定位对应的用户记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103085231-5c954328-c25e-401a-81eb-4339b0fcb577.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7458340a&margin=%5Bobject%20Object%5D&name=1.png&originHeight=440&originWidth=573&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50562&status=done&style=none&taskId=u7102ad8d-f063-4069-aa27-905850afdc8&title=" alt="1.png"></p><p><code>**B+**</code><strong>树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的</strong><code>**B+**</code><strong>树叶子节点中的记录就是按照</strong><code>**id**</code><strong>列排序的。</strong>所以这样根据主键值定位一条记录的速度贼快。类似的，我们根据唯一二级索引列来定位一条记录的速度也是贼快的，比如下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 = 3841;</span><br></pre></td></tr></table></figure><p>这个查询的执行过程的示意图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103092812-dc9c5731-27e4-47df-983d-759d09654719.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1166289d&margin=%5Bobject%20Object%5D&name=2.png&originHeight=596&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=159765&status=done&style=none&taskId=u57c775c3-45a1-43e1-a318-25b1b176f70&title=" alt="2.png"></p><p>这个查询的执行分两步：</p><ol><li>先从<code>idx_key2</code>对应的<code>B+</code>树索引中根据<code>key2</code>列与常数的等值比较条件定位到一条二级索引记录</li><li>再根据该记录的<code>id</code>值到聚簇索引中获取到完整的用户记录</li></ol><p><code>MySQL</code>认为通过主键或者唯一二级索引列与常数的等值比较来定位一条记录非常快，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：<code>const</code>，意思是常数级别的，代价是可以忽略不计的。不过这种<code>const</code>访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个<code>const</code>访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。</p><p>对于唯一二级索引来说，查询该列为<code>NULL</code>值的情况比较特殊，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IS NULL;</span><br></pre></td></tr></table></figure><p>因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用<code>const</code>访问方法来执行。</p><h2 id="3-ref"><a href="#3-ref" class="headerlink" title="3.ref"></a>3.ref</h2><p>有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的<code>id</code>值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以<code>MySQL</code>可能选择使用索引而不是全表扫描的方式来执行查询。MySQL把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：<code>ref</code>。我们看一下采用<code>ref</code>访问方法执行查询的图示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103103047-d3232525-adc5-43e0-920c-a21da1bcf02f.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7fd346ba&margin=%5Bobject%20Object%5D&name=3.png&originHeight=571&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157444&status=done&style=none&taskId=ub0bb4412-15a5-46c2-9696-9e0cf98d47b&title=" alt="3.png"></p><p>对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像主键或者唯一二级索引那样最多只能匹配1条记录，所以这种<code>ref</code>访问方法比<code>const</code>差了那么一点，但是在二级索引等值比较时匹配的记录数较少时的效率还是很高的（如果匹配的二级索引记录太多那么回表的成本就太大了）。</p><p>有两种特殊情况：</p><ul><li> 二级索引列值为<code>NULL</code>的情况<br>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含<code>NULL</code>值的数量并不限制，所以我们采用<code>key IS NULL</code>这种形式的搜索条件最多只能使用<code>ref</code>的访问方法，而不是<code>const</code>的访问方法。 </li><li> 对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用<code>ref</code>的访问方法，比方说下边这几个查询： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 = &#x27;legendary&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 = &#x27;legendary&#x27; AND key_part3 = &#x27;penta kill&#x27;;</span><br></pre></td></tr></table></figure><p>但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为<code>ref</code>了，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;god like&#x27; AND key_part2 &gt; &#x27;legendary&#x27;;</span><br></pre></td></tr></table></figure><h2 id="4-ref-or-null"><a href="#4-ref-or-null" class="headerlink" title="4.ref_or_null"></a>4.ref_or_null</h2><p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为<code>NULL</code>的记录也找出来，就像下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure><p>当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为<code>ref_or_null</code>，这个<code>ref_or_null</code>访问方法的执行过程如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103112647-02b81ae3-23ba-4eac-adcd-1699c6b384de.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua961cb22&margin=%5Bobject%20Object%5D&name=4.png&originHeight=581&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175770&status=done&style=none&taskId=uc5f31edd-d5d3-435c-baa7-c24c0d5d7d2&title=" alt="4.png"></p><p>上边的查询相当于先分别从<code>idx_key1</code>索引对应的<code>B+</code>树中找出<code>key1 IS NULL</code>和<code>key1 = &#39;abc&#39;</code>的两个连续的记录范围，然后根据这些二级索引记录中的<code>id</code>值再回表查找完整的用户记录。</p><h2 id="5-range"><a href="#5-range" class="headerlink" title="5.range"></a>5.range</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);</span><br></pre></td></tr></table></figure><p>如果采用<code>二级索引 + 回表</code>的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中<code>key2</code>列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：</p><ul><li><code>key2</code>的值是<code>1438</code></li><li><code>key2</code>的值是<code>6328</code></li><li><code>key2</code>的值在<code>38</code>和<code>79</code>之间。</li></ul><p><code>MySQL</code>把这种利用索引进行范围匹配的访问方法称之为：<code>range</code>。</p><blockquote><p>此处所说的使用索引进行范围匹配中的 <code>索引</code> 可以是聚簇索引，也可以是二级索引。</p></blockquote><p>我们可以把那种索引列等值匹配的情况称之为<code>单点区间</code>，上边所说的<code>范围1</code>和<code>范围2</code>都可以被称为单点区间，像<code>范围3</code>这种的我们可以称为连续范围区间。</p><h2 id="6-index"><a href="#6-index" class="headerlink" title="6.index"></a>6.index</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>由于<code>key_part2</code>并不是联合索引<code>idx_key_part</code>最左索引列，所以我们无法使用<code>ref</code>或者<code>range</code>访问方法来执行这个语句。但是这个查询符合下边这两个条件：</p><ul><li>它的查询列表只有3个列：<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>，而索引<code>idx_key_part</code>又包含这三个列。</li><li>搜索条件中只有<code>key_part2</code>列。这个列也包含在索引<code>idx_key_part</code>中。</li></ul><p>也就是说我们可以直接通过遍历<code>idx_key_part</code>索引的叶子节点的记录来比较<code>key_part2 = &#39;abc&#39;</code>这个条件是否成立，把匹配成功的二级索引记录的<code>key_part1</code>, <code>key_part2</code>, <code>key_part3</code>列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，<code>MySQL</code>就把这种采用遍历二级索引记录的执行方式称之为：<code>index</code>。</p><h2 id="7-all"><a href="#7-all" class="headerlink" title="7.all"></a>7.all</h2><p>全表扫描</p><h2 id="8-注意"><a href="#8-注意" class="headerlink" title="8.注意"></a>8.注意</h2><h3 id="8-1-二级索引-回表"><a href="#8-1-二级索引-回表" class="headerlink" title="8.1  二级索引 + 回表"></a>8.1  二级索引 + 回表</h3><p>一般情况下只能利用单个二级索引执行查询，比方说下边的这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;abc&#x27; AND key2 &gt; 1000;</span><br></pre></td></tr></table></figure><p>查询优化器会识别到这个查询中的两个搜索条件：</p><ul><li><code>key1 = &#39;abc&#39;</code></li><li><code>key2 &gt; 1000</code></li></ul><p>优化器一般会根据<code>single_table</code>表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录后再根据其余的<code>WHERE</code>条件过滤记录。一般来说，等值查找比范围查找需要扫描的行数更少（也就是<code>ref</code>的访问方法一般比<code>range</code>好，但这也不总是一定的，也可能采用<code>ref</code>访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用<code>idx_key1</code>索引进行查询，那么整个查询过程可以分为两个步骤：</p><ol><li>使用二级索引定位记录的阶段，也就是根据条件<code>key1 = &#39;abc&#39;</code>从<code>idx_key1</code>索引代表的<code>B+</code>树中找到对应的二级索引记录。</li><li>回表阶段，也就是根据上一步骤中找到的记录的主键值进行<code>回表</code>操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件<code>key2 &gt; 1000</code>到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。</li></ol><p>注意，因为二级索引的节点中的记录只包含索引列和主键，所以在步骤1中使用<code>idx_key1</code>索引进行查询时只会用到与<code>key1</code>列有关的搜索条件，其余条件，比如<code>key2 &gt; 1000</code>这个条件在步骤1中是用不到的，只有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤。</p><blockquote><p>一般情况下执行一个查询只会用到单个二级索引，不过还是有特殊情况的。</p></blockquote><p>从上文可以看出，每次从二级索引中读取到一条记录后，就会根据该记录的主键值执行回表操作。而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的。每次执行回表操作时都相当于要随机读取一个聚簇索引页面，而这些随机I/O带来的性能开销比较大。于是MySQL提出了一个名为Disk-S weep Multi-Range Read(MRR，多范围读取)的优化措施，即先读取一部分二级索引记录，将它们的主键值排好序之后再统一执行回表操作。相对于每读取一条二级索引记录 就立即执行回表操作，这样会节省一些I/0开销。当然使用这个MRR优化措施的条件比较苛刻，我们之前的讨论中没有涉及MRR 之后的讨论中也将忽略这项优化措施，直接认为每读取一条二级索引记录就立即执行回表操作。</p><h3 id="8-2-range访问方法使用的范围区间"><a href="#8-2-range访问方法使用的范围区间" class="headerlink" title="8.2 range访问方法使用的范围区间"></a>8.2 range访问方法使用的范围区间</h3><p>其实对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>区间</code>。</p><blockquote><p>LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引。 IN操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key2 IN (1438, 6328);</span><br><span class="line">    </span><br><span class="line">SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328;</span><br></pre></td></tr></table></figure><p>在日常的工作中，一个查询的<code>WHERE</code>子句可能有很多个小的搜索条件，这些搜索条件需要使用<code>AND</code>或者<code>OR</code>操作符连接起来。当我们想使用<code>range</code>访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。</p><h2 id="9-索引合并"><a href="#9-索引合并" class="headerlink" title="9.索引合并"></a>9.索引合并</h2><p><code>MySQL</code>在一般情况下执行一个查询时最多只会用到单个二级索引，但是还有特殊情况，在这些特殊情况下也可能在一个查询中使用到多个二级索引，<code>MySQL</code>把这种使用到多个索引来完成一次查询的执行方法称之为：<code>index merge</code>，具体的索引合并算法有下边三种。</p><h3 id="9-1-Intersection合并"><a href="#9-1-Intersection合并" class="headerlink" title="9.1 Intersection合并"></a>9.1 Intersection合并</h3><p><code>Intersection</code>翻译过来的意思是<code>交集</code>。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>假设这个查询使用<code>Intersection</code>合并的方式执行的话，那这个过程就是这样的：</p><ul><li>从<code>idx_key1</code>二级索引对应的<code>B+</code>树中取出<code>key1 = &#39;a&#39;</code>的相关记录。</li><li>从<code>idx_key3</code>二级索引对应的<code>B+</code>树中取出<code>key3 = &#39;b&#39;</code>的相关记录。</li><li>二级索引的记录都是由<code>索引列 + 主键</code>构成的，所以我们可以计算出这两个结果集中<code>id</code>值的交集。</li><li>按照上一步生成的<code>id</code>值列表进行回表操作，也就是从聚簇索引中把指定<code>id</code>值的完整用户记录取出来，返回给用户。</li></ul><p>为啥不直接使用<code>idx_key1</code>或者<code>idx_key3</code>只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。</p><ol><li>只读取一个二级索引的成本：</li></ol><ul><li>按照某个搜索条件读取一个二级索引</li><li>根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</li></ul><ol start="2"><li>读取多个二级索引之后取交集成本：</li></ol><ul><li>按照不同的搜索条件分别读取不同的二级索引</li><li>将从多个二级索引得到的主键值取交集，然后进行回表操作</li></ul><p>虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是<code>顺序I/O</code>，而回表操作是<code>随机I/O</code>，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为<code>回表</code>而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p><p><code>MySQL</code>在某些特定的情况下才可能会使用到<code>Intersection</code>索引合并：</p><ul><li> 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。<br>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Intersection</code>索引合并的操作： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>而下边这两个查询就不能进行<code>Intersection</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#x27;a&#x27; AND key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Intersection</code>索引合并。</p><ul><li> 情况二：主键列可以是范围匹配<br>比方说下边这个查询可能用到主键和<code>idx_key1</code>进行<code>Intersection</code>索引合并的操作： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE id &gt; 100 AND key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>对于<code>InnoDB</code>的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由<code>索引列 + 主键</code>构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照<code>主键</code>的值进行排序的。所以在二级索引列都是等值匹配的情况下才可能使用<code>Intersection</code>索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。</p><p><strong>根据二级索引查询出的结果集是按照主键值排序的对使用</strong><code>**Intersection**</code><strong>索引合并的好处？</strong><code>Intersection</code>索引合并会把从多个二级索引中查询出的主键值求交集，如果从各个二级索引中查询的到的结果集本身就是已经按照主键排好序的，那么求交集的过程就很简单。假设某个查询使用<code>Intersection</code>索引合并的方式从<code>idx_key1</code>和<code>idx_key2</code>这两个二级索引中获取到的主键值分别是：</p><ul><li>从<code>idx_key1</code>中获取到已经排好序的主键值：1、3、5</li><li>从<code>idx_key2</code>中获取到已经排好序的主键值：2、3、4</li></ul><p>那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了：</p><ul><li>先取出这两个结果集中较小的主键值做比较，因为<code>1 &lt; 2</code>，所以把<code>idx_key1</code>的结果集的主键值<code>1</code>丢弃，取出后边的<code>3</code>来比较。</li><li>因为<code>3 &gt; 2</code>，所以把<code>idx_key2</code>的结果集的主键值<code>2</code>丢弃，取出后边的<code>3</code>来比较。</li><li>因为<code>3 = 3</code>，所以把<code>3</code>加入到最后的交集结果中，继续两个结果集后边的主键值来比较。</li><li>后边的主键值也不相等，所以最后的交集结果中只包含主键值<code>3</code>。</li></ul><p>这个过程其实很快，时间复杂度是<code>O(n)</code>，但是如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。</p><blockquote><p>按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR。</p></blockquote><p>另外，不仅是多个二级索引之间可以采用<code>Intersection</code>索引合并，索引合并也可以有聚簇索引参加，也就是我们上边写的<code>情况二</code>：在搜索条件中有主键的范围匹配的情况下也可以使用<code>Intersection</code>索引合并索引合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND id &gt; 100;</span><br></pre></td></tr></table></figure><p>假设这个查询可以采用<code>Intersection</code>索引合并，我们理所当然的以为这个查询会分别按照<code>id &gt; 100</code>这个条件从聚簇索引中获取一些记录，在通过<code>key1 = &#39;a&#39;</code>这个条件从<code>idx_key1</code>二级索引中获取一些记录，然后再求交集，其实这样就把问题复杂化了，没必要从聚簇索引中获取一次记录。二级索引的记录中都带有主键值的，所以可以在从<code>idx_key1</code>中获取到的主键值上直接运用条件<code>id &gt; 100</code>过滤就行了。所以涉及主键的搜索条件只不过是为了从别的二级索引得到的结果集中过滤记录罢了，是不是等值匹配不重要。</p><p>当然，上边说的<code>情况一</code>和<code>情况二</code>只是发生<code>Intersection</code>索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生<code>Intersection</code>索引合并，这得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过<code>Intersection</code>索引合并后需要回表的记录数大大减少时才会使用<code>Intersection</code>索引合并。</p><h3 id="9-2-Union合并"><a href="#9-2-Union合并" class="headerlink" title="9.2 Union合并"></a>9.2 Union合并</h3><p>有时候<code>OR</code>关系的不同搜索条件会使用到不同的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p><code>Intersection</code>是交集的意思，这适用于使用不同索引的搜索条件之间使用<code>AND</code>连接起来的情况；<code>Union</code>是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。与<code>Intersection</code>索引合并类似，<code>MySQL</code>在某些特定的情况下才可能会使用到<code>Union</code>索引合并：</p><ul><li> 情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。<br>比方说下边这个查询可能用到<code>idx_key1</code>和<code>idx_key_part</code>这两个二级索引进行<code>Union</code>索引合并的操作： </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR ( key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;);</span><br></pre></td></tr></table></figure><p>而下边这两个查询就不能进行<code>Union</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &gt; &#x27;a&#x27; OR (key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; OR key_part1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>第一个查询是因为对<code>key1</code>进行了范围匹配，第二个查询是因为联合索引<code>idx_key_part</code>中的<code>key_part2</code>和<code>key_part3</code>列并没有出现在搜索条件中，所以这两个查询不能进行<code>Union</code>索引合并。</p><ul><li>情况二：主键列可以是范围匹配</li><li>情况三：使用<code>Intersection</code>索引合并的搜索条件</li></ul><p>这种情况其实就是搜索条件的某些部分使用<code>Intersection</code>索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27; AND key_part3 = &#x27;c&#x27; OR (key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>优化器可能采用这样的方式来执行这个查询：</p><ul><li>先按照搜索条件<code>key1 = &#39;a&#39; AND key3 = &#39;b&#39;</code>从索引<code>idx_key1</code>和<code>idx_key3</code>中使用<code>Intersection</code>索引合并的方式得到一个主键集合。</li><li>再按照搜索条件<code>key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39; AND key_part3 = &#39;c&#39;</code>从联合索引<code>idx_key_part</code>中得到另一个主键集合。</li><li>采用<code>Union</code>索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li></ul><p>当然，查询条件符合了这些情况也不一定就会采用<code>Union</code>索引合并，也得看优化器的心情。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过<code>Union</code>索引合并后进行访问的代价比全表扫描更小时才会使用<code>Union</code>索引合并。</p><h3 id="9-3-Sort-Union合并"><a href="#9-3-Sort-Union合并" class="headerlink" title="9.3 Sort-Union合并"></a>9.3 Sort-Union合并</h3><p><code>Union</code>索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到<code>Union</code>索引合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 &lt; &#x27;a&#x27; OR key3 &gt; &#x27;z&#x27;</span><br></pre></td></tr></table></figure><p>这是因为根据<code>key1 &lt; &#39;a&#39;</code>从<code>idx_key1</code>索引中获取的二级索引记录的主键值不是排好序的，根据<code>key3 &gt; &#39;z&#39;</code>从<code>idx_key3</code>索引中获取的二级索引记录的主键值也不是排好序的，但是<code>key1 &lt; &#39;a&#39;</code>和<code>key3 &gt; &#39;z&#39;</code>这两个条件又特别让我们动心，所以我们可以这样：</p><ul><li>先根据<code>key1 &lt; &#39;a&#39;</code>条件从<code>idx_key1</code>二级索引中获取记录，并按照记录的主键值进行排序</li><li>再根据<code>key3 &gt; &#39;z&#39;</code>条件从<code>idx_key3</code>二级索引中获取记录，并按照记录的主键值进行排序</li><li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和<code>Union</code>索引合并方式就一样了。</li></ul><p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p><blockquote><p>为啥有Sort-Union索引合并，就没有Sort-Intersection索引合并么？是的，的确没有Sort-Intersection索引合并这么一说， Sort-Union的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高 而Intersection索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，但是如果加入Sort-Intersection后，就需要为大量的二级索引记录按照主键值进行排序，这个成本可能比回表查询都高了，所以也就没有引入Sort-Intersection。</p></blockquote><h3 id="9-4-索引合并注意事项"><a href="#9-4-索引合并注意事项" class="headerlink" title="9.4 索引合并注意事项"></a>9.4 索引合并注意事项</h3><h4 id="联合索引替代Intersection索引合并"><a href="#联合索引替代Intersection索引合并" class="headerlink" title="联合索引替代Intersection索引合并"></a>联合索引替代Intersection索引合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key1 = &#x27;a&#x27; AND key3 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>这个查询之所以可能使用<code>Intersection</code>索引合并的方式执行，还不是因为<code>idx_key1</code>和<code>idx_key3</code>是两个单独的<code>B+</code>树索引，要是把这两个列搞一个联合索引，那直接使用这个联合索引就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE single_table drop index idx_key1, idx_key3, add index idx_key1_key3(key1, key3);</span><br></pre></td></tr></table></figure><p>这样我们把没用的<code>idx_key1</code>、<code>idx_key3</code>都干掉，再添加一个联合索引<code>idx_key1_key3</code>，使用这个联合索引进行查询效果更好，既不用多读一棵<code>B+</code>树，也不用合并结果。</p><blockquote><p>不过如果有单独对key3列进行查询的业务场景，这样子不得不再把key3列的单独索引给加上。具体还得以业务为准。</p></blockquote><h1 id="二，连接查询原理"><a href="#二，连接查询原理" class="headerlink" title="二，连接查询原理"></a>二，连接查询原理</h1><h2 id="1-连接简介"><a href="#1-连接简介" class="headerlink" title="1. 连接简介"></a>1. 连接简介</h2><h3 id="1-1-连接的本质"><a href="#1-1-连接的本质" class="headerlink" title="1.1 连接的本质"></a>1.1 连接的本质</h3><p>我们先建立两个简单的表并给它们填充一点数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1 (m1 int, n1 char(1));</span><br><span class="line"></span><br><span class="line">CREATE TABLE t2 (m2 int, n2 char(1));</span><br><span class="line"></span><br><span class="line">INSERT INTO t1 VALUES(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO t2 VALUES(2, &#x27;b&#x27;), (3, &#x27;c&#x27;), (4, &#x27;d&#x27;);</span><br></pre></td></tr></table></figure><p>我们成功建立了<code>t1</code>、<code>t2</code>两个表，这两个表都有两个列，一个是<code>INT</code>类型的，一个是<code>CHAR(1)</code>类型的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1;</span><br><span class="line">+------+------+</span><br><span class="line">| m1   | n1   |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t2;</span><br><span class="line">+------+------+</span><br><span class="line">| m2   | n2   |</span><br><span class="line">+------+------+</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | d    |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把<code>t1</code>和<code>t2</code>两个表连接起来的过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103128021-169724be-ad76-430d-88d4-27b8c7ef3b05.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud419858f&margin=%5Bobject%20Object%5D&name=5.png&originHeight=386&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132855&status=done&style=none&taskId=u39b88778-304b-4c35-b4f3-2f176449c1b&title=" alt="5.png"></p><p>这个过程看起来就是把<code>t1</code>表的记录和<code>t2</code>的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为<code>笛卡尔积</code>。因为表<code>t1</code>中有3条记录，表<code>t2</code>中也有3条记录，所以这两个表连接之后的笛卡尔积就有<code>3×3=9</code>行记录。在<code>MySQL</code>中，连接查询的语法很简单，只要在<code>FROM</code>语句后边跟多个表名就好了，比如我们把<code>t1</code>表和<code>t2</code>表连接起来的查询语句可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2;</span><br></pre></td></tr></table></figure><h3 id="1-2-连接过程简介"><a href="#1-2-连接过程简介" class="headerlink" title="1.2 连接过程简介"></a>1.2 连接过程简介</h3><p>在连接查询中的过滤条件可以分成两种：</p><ul><li> 涉及单表的条件<br>这种只涉及单表的过滤条件我们之前都提到过一万遍了，我们之前也一直称为<code>搜索条件</code>，比如<code>t1.m1 &gt; 1</code>是只针对<code>t1</code>表的过滤条件，<code>t2.n2 &lt; &#39;d&#39;</code>是只针对<code>t2</code>表的过滤条件。 </li><li> 涉及两表的条件<br>这种过滤条件我们之前没见过，比如<code>t1.m1 = t2.m2</code>、<code>t1.n1 &gt; t2.n2</code>等，这些条件中涉及到了两个表。 </li></ul><p>我们看一下携带过滤条件的连接查询的大致执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure><p>在这个查询中我们指明了这三个过滤条件：</p><ul><li><code>t1.m1 &gt; 1</code></li><li><code>t1.m1 = t2.m2</code></li><li><code>t2.n2 &lt; &#39;d&#39;</code></li></ul><p>这个连接查询的大致执行过程如下：</p><ol><li> 首先确定第一个需要查询的表，这个表称之为<code>驱动表</code>。此处假设使用<code>t1</code>作为驱动表，那么就需要到<code>t1</code>表中找满足<code>t1.m1 &gt; 1</code>的记录，因为表中的数据太少，我们也没在表上建立二级索引，所以此处查询<code>t1</code>表的访问方法就设定为<code>all</code>吧，也就是采用全表扫描的方式执行单表查询，所以查询过程就如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103137241-5f6ca008-f17b-44e8-b9a2-848e217eb287.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubff6b2a5&margin=%5Bobject%20Object%5D&name=6.png&originHeight=228&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45158&status=done&style=none&taskId=u2ab46c4d-01ec-4c86-a78b-46fd6bb81f6&title=" alt="6.png"><br>我们可以看到，<code>t1</code>表中符合<code>t1.m1 &gt; 1</code>的记录有两条。 </li><li> 针对上一步骤中从驱动表产生的结果集中的每一条记录，分别需要到<code>t2</code>表中查找匹配的记录，所谓<code>匹配的记录</code>，指的是符合过滤条件的记录。因为是根据<code>t1</code>表中的记录去找<code>t2</code>表中的记录，所以<code>t2</code>表也可以被称之为<code>被驱动表</code>。上一步骤从驱动表中得到了2条记录，所以需要查询2次<code>t2</code>表。此时涉及两个表的列的过滤条件<code>t1.m1 = t2.m2</code>就派上用场了： </li></ol><ul><li>当<code>t1.m1 = 2</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 2</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 2</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li><li>当<code>t1.m1 = 3</code>时，过滤条件<code>t1.m1 = t2.m2</code>就相当于<code>t2.m2 = 3</code>，所以此时<code>t2</code>表相当于有了<code>t2.m2 = 3</code>、<code>t2.n2 &lt; &#39;d&#39;</code>这两个过滤条件，然后到<code>t2</code>表中执行单表查询。</li></ul><p>所以整个连接查询的执行过程就如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103145039-c650a6a9-c051-481b-937c-b1e332d6bf9e.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc1ba2202&margin=%5Bobject%20Object%5D&name=7.png&originHeight=386&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92768&status=done&style=none&taskId=u98e6d49c-aa2e-4c67-a098-9ea24815ff5&title=" alt="7.png"></p><p>也就是说整个连接查询最后的结果只有两条符合过滤条件的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------+------+------+------+</span><br><span class="line">| m1   | n1   | m2   | n2   |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|    2 | b    |    2 | b    |</span><br><span class="line">|    3 | c    |    3 | c    |</span><br><span class="line">+------+------+------+------+</span><br></pre></td></tr></table></figure><p>这个两表连接查询共需要查询1次<code>t1</code>表，2次<code>t2</code>表。当然这是在特定的过滤条件下的结果，如果我们把<code>t1.m1 &gt; 1</code>这个条件去掉，那么从<code>t1</code>表中查出的记录就有3条，就需要查询3次<code>t2</code>表了。也就是说在两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p><h3 id="1-3-内连接和外连接"><a href="#1-3-内连接和外连接" class="headerlink" title="1.3 内连接和外连接"></a>1.3 内连接和外连接</h3><p>我们先创建两个有现实意义的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">    number INT NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,</span><br><span class="line">    name VARCHAR(5) COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    major VARCHAR(30) COMMENT &#x27;专业&#x27;,</span><br><span class="line">    PRIMARY KEY (number)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE score (</span><br><span class="line">    number INT COMMENT &#x27;学号&#x27;,</span><br><span class="line">    subject VARCHAR(30) COMMENT &#x27;科目&#x27;,</span><br><span class="line">    score TINYINT COMMENT &#x27;成绩&#x27;,</span><br><span class="line">    PRIMARY KEY (number, subject)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生成绩表&#x27;;</span><br></pre></td></tr></table></figure><p>我们新建了一个学生信息表，一个学生成绩表，然后我们向上述两个表中插入一些数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student;</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">| number   | name      | major                    |</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">| 20180101 | 杜子腾    | 软件学院                 |</span><br><span class="line">| 20180102 | 范统      | 计算机科学与工程         |</span><br><span class="line">| 20180103 | 史珍香    | 计算机科学与工程         |</span><br><span class="line">+----------+-----------+--------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM score;</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">| number   | subject                     | score |</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">| 20180101 | 母猪的产后护理              |    78 |</span><br><span class="line">| 20180101 | 论萨达姆的战争准备          |    88 |</span><br><span class="line">| 20180102 | 论萨达姆的战争准备          |    98 |</span><br><span class="line">| 20180102 | 母猪的产后护理              |   100 |</span><br><span class="line">+----------+-----------------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>现在我们想把每个学生的考试成绩都查询出来就需要进行两表连接了（因为<code>score</code>中没有姓名信息，所以不能单纯只查询<code>score</code>表）。连接过程就是从<code>student</code>表中取出记录，在<code>score</code>表中查找<code>number</code>相同的成绩记录，所以过滤条件就是<code>student.number = socre.number</code>，整个查询语句就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student, score WHERE student.number = score.number;</span><br></pre></td></tr></table></figure><p>从上述查询结果中我们可以看到，各个同学对应的各科成绩就都被查出来了，可是有个问题，<code>史珍香</code>同学，也就是学号为<code>20180103</code>的同学因为某些原因没有参加考试，所以在<code>score</code>表中没有对应的成绩记录。那如果老师想查看所有同学的考试成绩，即使是缺考的同学也应该展示出来，但是到目前为止我们介绍的<code>连接查询</code>是无法完成这样的需求的。</p><p>这个需求的本质是：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。为了解决这个问题，就有了<code>内连接</code>和<code>外连接</code>的概念。</p><ul><li> 对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，我们上边提到的连接都是所谓的<code>内连接</code>。 </li><li>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。<br>在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种： <ul><li>左外连接：选取左侧的表为驱动表。</li><li>右外连接：选取右侧的表为驱动表。</li></ul></li></ul><p>对于外连接来说，有时候我们也并不想把驱动表的全部记录都加入到最后的结果集。把过滤条件分为两种就可以了，所以放在不同地方的过滤条件是有不同语义的：</p><ul><li> <code>WHERE</code>子句中的过滤条件<br><code>WHERE</code>子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合<code>WHERE</code>子句中的过滤条件的记录都不会被加入最后的结果集。 </li><li> <code>ON</code>子句中的过滤条件<br>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用<code>NULL</code>值填充。 </li></ul><p>需要注意的是，这个<code>ON</code>子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把<code>ON</code>子句放到内连接中，<code>MySQL</code>会把它和<code>WHERE</code>子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。</p><p>一般情况下，我们都把只涉及单表的过滤条件放到<code>WHERE</code>子句中，把涉及两表的过滤条件都放到<code>ON</code>子句中，我们也一般把放到<code>ON</code>子句中的过滤条件也称之为<code>连接条件</code>。</p><h4 id="1-3-1-左（外）连接的语法"><a href="#1-3-1-左（外）连接的语法" class="headerlink" title="1.3.1 左（外）连接的语法"></a>1.3.1 左（外）连接的语法</h4><p>比如我们要把<code>t1</code>表和<code>t2</code>表进行左外连接查询可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>其中中括号里的<code>OUTER</code>单词是可以省略的。对于<code>LEFT JOIN</code>类型的连接来说，我们把放在左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。所以上述例子中<code>t1</code>就是外表或者驱动表，<code>t2</code>就是内表或者被驱动表。需要注意的是，对于左（外）连接和右（外）连接来说，必须使用<code>ON</code>子句来指出连接条件。</p><p>回到我们上边那个现实问题中来，看看怎样写查询语句才能把所有的学生的成绩信息都查询出来，即使是缺考的考生也应该被放到结果集中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score AS s2 ON s1.number = s2.number;</span><br></pre></td></tr></table></figure><p>从结果集中可以看出来，虽然<code>史珍香</code>并没有对应的成绩记录，但是由于采用的是连接类型为左（外）连接，所以仍然把她放到了结果集中，只不过在对应的成绩记录的各列使用<code>NULL</code>值填充而已。</p><h4 id="1-3-2-右（外）连接的语法"><a href="#1-3-2-右（外）连接的语法" class="headerlink" title="1.3.2 右（外）连接的语法"></a>1.3.2 右（外）连接的语法</h4><p>右（外）连接和左（外）连接的原理是一样一样的，语法也只是把<code>LEFT</code>换成<code>RIGHT</code>而已：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>只不过驱动表是右边的表，被驱动表是左边的表。</p><h4 id="1-3-3-内连接的语法"><a href="#1-3-3-内连接的语法" class="headerlink" title="1.3.3 内连接的语法"></a>1.3.3 内连接的语法</h4><p>内连接和外连接的根本区别就是在驱动表中的记录不符合<code>ON</code>子句中的连接条件时不会把该记录加入到最后的结果集。</p><p>一种最简单的内连接语法，就是直接把需要连接的多个表都放到<code>FROM</code>子句后边。其实针对内连接，MySQL提供了好多不同的语法，我们以<code>t1</code>和<code>t2</code>表为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];</span><br></pre></td></tr></table></figure><p>也就是说在<code>MySQL</code>中，下边这几种内连接的写法都是等价的：</p><ul><li>SELECT * FROM t1 JOIN t2;</li><li>SELECT * FROM t1 INNER JOIN t2;</li><li>SELECT * FROM t1 CROSS JOIN t2;</li></ul><p>上边的这些写法和直接把需要连接的表名放到<code>FROM</code>语句之后，用逗号<code>,</code>分隔开的写法是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2;</span><br></pre></td></tr></table></figure><p>在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。</p><p>前边说过，连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。不论哪个表作为驱动表，两表连接产生的笛卡尔积肯定是一样的。而对于内连接来说，由于凡是不符合<code>ON</code>子句或<code>WHERE</code>子句中的条件的记录都会被过滤掉，其实也就相当于从两表连接的笛卡尔积中把不符合过滤条件的记录给踢出去，所以对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果。但是对于外连接来说，由于驱动表中的记录即使在被驱动表中找不到符合ON子句条件的记录时也要将其加入到结果集，所以此时驱动表和被驱动表的关系就很重要了，也就是说左外连接和右外连接的驱动表和被驱动表不能轻易互换。</p><h2 id="2-连接的原理"><a href="#2-连接的原理" class="headerlink" title="2.连接的原理"></a>2.连接的原理</h2><p>接下来看一下MySQL采用了什么样的算法来进行表与表之间的连接。</p><h3 id="2-1-嵌套循环连接"><a href="#2-1-嵌套循环连接" class="headerlink" title="2.1 嵌套循环连接"></a>2.1 嵌套循环连接</h3><p>对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。</p><p>再来看一下<code>t1</code>表和<code>t2</code>表执行内连接查询的大致过程：</p><ul><li>步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。</li><li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li></ul><p>通用的两表连接过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640103159882-9771a923-7a5e-4d93-9d96-8ba02b9c732a.png#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udb034861&margin=%5Bobject%20Object%5D&name=8.png&originHeight=397&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93464&status=done&style=none&taskId=u1de44252-9bc7-44ee-bc05-48a7d9b564b&title=" alt="8.png"></p><p>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程，也就是<code>步骤2</code>中得到的结果集中的每一条记录都需要到<code>t3</code>表中找一找有没有匹配的记录，用伪代码表示一下这个过程就是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 &#123;   #此处表示遍历满足对t1单表查询结果集中的每一条记录</span><br><span class="line">    </span><br><span class="line">    for each row in t2 &#123;   #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的每一条记录</span><br><span class="line">    </span><br><span class="line">        for each row in t3 &#123;   #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询</span><br><span class="line">            if row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为<code>嵌套循环连接</code>（<code>Nested-Loop Join</code>），这是最简单，也是最笨拙的一种连接查询算法。</p><h3 id="2-2-使用索引加快连接速度"><a href="#2-2-使用索引加快连接速度" class="headerlink" title="2.2 使用索引加快连接速度"></a>2.2 使用索引加快连接速度</h3><p>在<code>嵌套循环连接</code>的<code>步骤2</code>中可能需要访问多次被驱动表，如果访问被驱动表的方式都是全表扫描的话，要查很多次。但是查询<code>t2</code>表其实就相当于一次单表扫描，我们可以利用索引来加快查询速度。回到最开始的<code>t1</code>表和<code>t2</code>表进行内连接的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640103172521-d5df075b-57e4-47f9-87cf-0c120e1f5486.jpeg#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf6ae63ce&margin=%5Bobject%20Object%5D&name=%E9%80%9A%E7%94%A8%E4%B8%A4%E5%BC%A0%E8%A1%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg&originHeight=1214&originWidth=2550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=268198&status=done&style=shadow&taskId=u37a2eaa4-6f87-44ac-8fb2-05dd6470b20&title=" alt="通用两张表连接过程.jpg"></p><p>查询驱动表<code>t1</code>后的结果集中有两条记录，<code>嵌套循环连接</code>算法需要对被驱动表查询2次：</p><ul><li><p> 当<code>t1.m1 = 2</code>时，去查询一遍<code>t2</code>表，对<code>t2</code>表的查询语句相当于：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure></li><li><p> 当<code>t1.m1 = 3</code>时，再去查询一遍<code>t2</code>表，此时对<code>t2</code>表的查询语句相当于：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; &#x27;d&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，原来的<code>t1.m1 = t2.m2</code>这个涉及两个表的过滤条件在针对<code>t2</code>表做查询时关于<code>t1</code>表的条件就已经确定了，所以我们只需要单单优化对<code>t2</code>表的查询了，上述两个对<code>t2</code>表的查询语句中利用到的列是<code>m2</code>和<code>n2</code>列，我们可以：</p><ul><li> 在<code>m2</code>列上建立索引，因为对<code>m2</code>列的条件是等值查找，比如<code>t2.m2 = 2</code>、<code>t2.m2 = 3</code>等，所以可能使用到<code>ref</code>的访问方法，假设使用<code>ref</code>的访问方法去执行对<code>t2</code>表的查询的话，需要回表之后再判断<code>t2.n2 &lt; d</code>这个条件是否成立。<br>这里有一个比较特殊的情况，就是假设<code>m2</code>列是<code>t2</code>表的主键或者唯一二级索引列，那么使用<code>t2.m2 = 常数值</code>这样的条件从<code>t2</code>表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而<code>MySQL</code>把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。 </li><li> 在<code>n2</code>列上建立索引，涉及到的条件是<code>t2.n2 &lt; &#39;d&#39;</code>，可能用到<code>range</code>的访问方法，假设使用<code>range</code>的访问方法对<code>t2</code>表的查询的话，需要回表之后再判断在<code>m2</code>列上的条件是否成立。 </li></ul><p>假设<code>m2</code>和<code>n2</code>列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对<code>t2</code>表的查询。当然，建立了索引不一定使用索引，只有在<code>二级索引 + 回表</code>的代价比全表扫描的代价更低时才会使用索引。</p><p>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是<code>index</code>的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使用<code>*</code>作为查询列表，最好把真实用到的列作为查询列表。</p><h3 id="2-3-基于块的嵌套循环连接"><a href="#2-3-基于块的嵌套循环连接" class="headerlink" title="2.3 基于块的嵌套循环连接"></a>2.3 基于块的嵌套循环连接</h3><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中的表可不像<code>t1</code>、<code>t2</code>这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都是。内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用<code>嵌套循环连接</code>算法的两表连接过程中，被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个<code>I/O</code>代价就非常大了，所以我们得想办法：尽量减少访问被驱动表的次数。</p><p>当被驱动表中的数据非常多时，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。</p><p><strong>如果在把被驱动表的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载被驱动表的代价。</strong></p><p><code>MySQL</code>提出了一个<code>join buffer</code>的概念，<code>join buffer</code>就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。使用<code>join buffer</code>的过程如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640103192756-bf8742e1-011a-4c59-8287-1526091cc67d.jpeg#clientId=u83174e17-7e8f-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udffc465f&margin=%5Bobject%20Object%5D&name=%E9%80%9A%E7%94%A8%E4%B8%A4%E5%BC%A0%E8%A1%A8%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%26JOIN%20BUFFER.jpg&originHeight=1214&originWidth=3664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=353466&status=done&style=shadow&taskId=u48cf259d-db08-4290-ab9b-43a4c2f5c9a&title=" alt="通用两张表连接过程&amp;JOIN BUFFER.jpg"></p><p>最好的情况是<code>join buffer</code>足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。<code>MySQL</code>把这种加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><p>这个<code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。当然，对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p><p>另外需要注意的是，驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>中，所以再次提醒我们，最好不要把<code>*</code>作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在<code>join buffer</code>中放置更多的记录。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[五]InnoDb表空间</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%BA%94%5DInnoDb%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%BA%94%5DInnoDb%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在前面的两篇文章已经对InnoDB索引的结构，页存储结构，行格式做了十分细致的分析，也详细阐述了为什么你的SQL会慢，索引命中的原理，接下来我要继续深入学习MySQL。在此之前还要先来补充一下MySQL的一些基础知识。</p></blockquote><h1 id="一，MySQL的数据目录"><a href="#一，MySQL的数据目录" class="headerlink" title="一，MySQL的数据目录"></a>一，MySQL的数据目录</h1><h2 id="1-数据库和文件系统的关系"><a href="#1-数据库和文件系统的关系" class="headerlink" title="1. 数据库和文件系统的关系"></a>1. 数据库和文件系统的关系</h2><p>InnoDB,MyISAM这样的存储引擎都是把表存储在磁盘上，而操作系统是使用文件系统来管理磁盘的。【像InnoDB,MyISAM这样的存储引擎都是把数据存储在文件系统上的。】当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎又会把数据写回到文件系统。</p><p>本小节主要就是分析下InnoDB,MyISAM两个存储引擎的数据是如何在文件系统中存储的。</p><blockquote><p>我的MySQL版本是5.7.28，所以接下来的操作和分析都是基于这个小版本的。其他版本可能会有细微的差异。</p></blockquote><h2 id="2-MySQL数据目录"><a href="#2-MySQL数据目录" class="headerlink" title="2.MySQL数据目录"></a>2.MySQL数据目录</h2><p>MySQL服务器程序在启动时，会到文件系统的某个目录下加载一些数据，之后再运行过程中产生的数据也会存储到这个目录下的某些文件中。这个目录就是数据目录。</p><h3 id="2-1-数据目录和安装目录的区别"><a href="#2-1-数据目录和安装目录的区别" class="headerlink" title="2.1 数据目录和安装目录的区别"></a>2.1 数据目录和安装目录的区别</h3><p>MySQL的安装目录是在安装MySQL的时候指定的安装位置，下面有个很重要的bin目录，里面存储着控制客户端程序与服务器程序的命令。</p><p>MySQL的数据目录是用来存储MySQL在运行过程中产生的数据。</p><h3 id="2-2-MySQL的数据目录在哪里"><a href="#2-2-MySQL的数据目录在哪里" class="headerlink" title="2.2 MySQL的数据目录在哪里"></a>2.2 MySQL的数据目录在哪里</h3><p>数据目录对应着一个系统变量<code>datadir</code>，在使用客户端与服务器建立连接以后，查看这个系统变量的值就知道了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;datadir&#x27;;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;datadir&#x27;;</span><br><span class="line">+---------------+--------------------+</span><br><span class="line">| Variable_name | Value              |</span><br><span class="line">+---------------+--------------------+</span><br><span class="line">| datadir       | C:\yhd\mysql\Data\ |</span><br><span class="line">+---------------+--------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="3-数据目录的结构"><a href="#3-数据目录的结构" class="headerlink" title="3.数据目录的结构"></a>3.数据目录的结构</h2><h3 id="3-1-数据库在文件系统中的表示"><a href="#3-1-数据库在文件系统中的表示" class="headerlink" title="3.1 数据库在文件系统中的表示"></a>3.1 数据库在文件系统中的表示</h3><p>每个数据库都对应着数据目录下的一个子目录，或者说对应着一个文件夹。当我们创建一个新的数据库的时候，MySQL会帮助我们做两件事：</p><ol><li>在数据目录下创建一个与数据库同名的文件目录</li><li>在该子目录下创建一个<strong>db.opt</strong>文件。这个文件中包含了数据库的一些属性，比如该数据库的字符集和比较规则。</li></ol><p>下面来看一下我的MySQL中的数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| yhd                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>再从数据目录里看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">C:\yhd\mysql\Data&gt;dir</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 CA5F-90F5</span><br><span class="line"></span><br><span class="line"> C:\yhd\mysql\Data 的目录</span><br><span class="line"></span><br><span class="line">2021/12/19  00:27    &lt;DIR&gt;          .</span><br><span class="line">2021/12/19  00:27    &lt;DIR&gt;          ..</span><br><span class="line">2021/12/14  00:00                56 auto.cnf</span><br><span class="line">2021/12/14  00:00             1,703 ca-key.pem</span><br><span class="line">2021/12/14  00:00             1,131 ca.pem</span><br><span class="line">2021/12/14  00:00             1,131 client-cert.pem</span><br><span class="line">2021/12/14  00:00             1,707 client-key.pem</span><br><span class="line">2021/12/14  00:12               696 DESKTOP-NJIMTJP-slow.log</span><br><span class="line">2021/12/18  01:15            25,345 DESKTOP-NJIMTJP.err</span><br><span class="line">2021/12/18  01:15                 5 DESKTOP-NJIMTJP.pid</span><br><span class="line">2021/12/19  02:18        79,691,776 ibdata1</span><br><span class="line">2021/12/18  01:15        12,582,912 ibtmp1</span><br><span class="line">2021/12/18  01:15               356 ib_buffer_pool</span><br><span class="line">2021/12/19  02:18        50,331,648 ib_logfile0</span><br><span class="line">2021/12/19  02:18        50,331,648 ib_logfile1</span><br><span class="line">2021/12/14  00:00    &lt;DIR&gt;          mysql</span><br><span class="line">2021/12/14  00:00    &lt;DIR&gt;          performance_schema</span><br><span class="line">2021/12/14  00:00             1,707 private_key.pem</span><br><span class="line">2021/12/14  00:00               461 public_key.pem</span><br><span class="line">2021/12/14  00:00             1,131 server-cert.pem</span><br><span class="line">2021/12/14  00:00             1,707 server-key.pem</span><br><span class="line">2021/12/14  00:00    &lt;DIR&gt;          sys</span><br><span class="line">2021/12/19  00:56    &lt;DIR&gt;          yhd</span><br><span class="line">              17 个文件    192,975,120 字节</span><br><span class="line">               6 个目录 189,156,126,720 可用字节</span><br><span class="line"></span><br><span class="line">C:\yhd\mysql\Data&gt;</span><br></pre></td></tr></table></figure><p>仔细看会发现，除了<strong>information_schema</strong>这个数据库以外，其他的数据库都对应一个文件目录，这个数据库有点特殊，后面在具体分析。</p><h3 id="3-2-表在文件系统中的表示"><a href="#3-2-表在文件系统中的表示" class="headerlink" title="3.2 表在文件系统中的表示"></a>3.2 表在文件系统中的表示</h3><p>我们的数据其实是以记录的形式插入到表中的。每个表的信息其实可以分为两种。</p><ol><li>表结构信息</li><li>表数据信息</li></ol><p>为了保存表结构信息，InnoDB,MyISAM这两种存储引擎都会在数据目录下对应的数据库子目录中创建一个专门用于描述表结构的文件，文件名是<strong>表名.frm</strong>。这个文件是二进制格式的，直接打开会乱码。</p><p>我们知道不同的存储引擎对于表中的数据存储是不一样的，接下来我们分别来看一下InnoDB,MyISAM是如何存储表中的数据的。</p><h4 id="InnoDb是如何存储数据的"><a href="#InnoDb是如何存储数据的" class="headerlink" title="InnoDb是如何存储数据的"></a>InnoDb是如何存储数据的</h4><p>我们再来回顾下上一篇的知识：</p><ol><li>innoDB其实是使用页来作为基本单位管理存储空间的，默认大小16KB。</li><li>对于InnoDB存储引擎来说，每个索引都对应一颗B+树，该B+树的每个结点都是一个数据页。数据页之间没有必要是物理连续的，因为数据页之间有双向链表来维护这些页的顺序。</li><li>InnoDB的聚簇索引的叶子结点存储了完整的用户记录，也就是所谓的索引即数据，数据即索引。</li></ol><p>为了更好的管理这些页，InnoDB提出了表空间或者文件空间的概念。这个表空间是一个抽象的概念，他可以对应文件系统上一个或者多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间可以被划分为很多个页，表数据被存放在某个表空间下的某些页中。InnoDB将表空间划分几种不同的类型，我们一个个分析一下子。</p><ol><li>系统表空间</li></ol><p>这个系统表空间可以对应文件系统上一个或者多个实际的文件。在默认情况下，InnoDB会在数据目录下创建一个名为<strong>ibdata1</strong>，大小为12MB的文件，这个文件就是对应的系统表空间在文件系统上的表示。怎么才12MB？这是因为这个文件是自扩展文件，也就是当不够用的时候会自己增加文件大小。</p><p>当然，如果想让系统表空间对应文件系统上的多个实际文件，或者仅仅觉得原来的<strong>ibdata1</strong>这个文件名难听，那么可以在MySQL服务启动的时候，配置对应的文件路径以及他们的大小。比如像下面这样修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_data_file_path=data1:512M;data2:512M:autoextend</span><br></pre></td></tr></table></figure><p>这样，在MySQL启动之后会创建data1和data2这两个各自512MB大小的文件作为系统表空间。其中的autoextend表明，如果这两个文件不够用，则会自动扩展data2文件的大小。</p><p>我们也可以把<code>系统表空间</code>对应的文件路径不配置到<code>数据目录</code>下，甚至可以配置到单独的磁盘分区上，涉及到的启动参数就是<code>innodb_data_file_path</code>和<code>innodb_data_home_dir</code>。</p><p>需要注意的一点是，在一个MySQL服务器中，系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 **<em>系统表空间</em>**。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011685295-19dfeb6a-b276-4482-9655-817ed9fb066c.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2751d2c7&margin=%5Bobject%20Object%5D&name=ibdata1.png&originHeight=581&originWidth=959&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71436&status=done&style=none&taskId=u6729a863-9b30-44f3-b559-08d55e8b5d8&title=" alt="ibdata1.png"></p><ol start="2"><li>独立表空间</li></ol><p>在MySQL5.6.6以及以后的版本中，InnoDB不在默认把各个表的数据存储到系统表空间，而是为每一个表建立一个独立的表空间，也就是说，创建多少张表就会对应多少个表空间。在使用独立表空间来存储表数据的时候，会在该表所属的数据库对应的子目录下创建一个表示该独立表空间的文件，其文件名和表名相同，只不过添加了一个.ibd扩展名。所以完整的文件名称：<strong>表名.ibd</strong>。</p><p>假如我们使用独立表空间来存储yhd数据库下的person_info表，那么在该数据库所对应的yhd文件目录下会为person_info表创建下面两个文件：<strong>person_info.frm</strong>,<strong>person_info.ibd</strong>。</p><p>其中ibd文件用来存储表中的数据。当然也可以自己指定是使用系统表空间还是独立表空间来存储数据。</p><ol start="3"><li>其他类型表空间</li></ol><p>除了上述两种表空间之外，还有一些不同类型的表空间，比如通用表空间，undo表空间，临时表空间。</p><h4 id="MyISAM是如何存储数据的"><a href="#MyISAM是如何存储数据的" class="headerlink" title="MyISAM是如何存储数据的"></a>MyISAM是如何存储数据的</h4><p>索引和数据在InnoDB是一回事，但是MyISAM中的索引相当于全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，而且与InnoDB不同的是，MyISAM并没有什么表空间一说，表的数据和索引都存放到对应的数据库子目录下。</p><p>假设我们person_info表使用的是MyISAM存储引擎，那么在它所在数据库对应的yhd文件目录下会为person_info创建三个文件：<strong>person_info.frm</strong>,<strong>person_info.MYD</strong>,<strong>person_info.MYI</strong>。</p><p>其中<strong>person_info.MYD</strong>表示表的数据文件，也就是插入的用户记录，<strong>person_info.MYI</strong>表示表的索引文件，我们为该表创建的索引都会放到这个文件中。</p><h3 id="3-3-其他的文件"><a href="#3-3-其他的文件" class="headerlink" title="3.3 其他的文件"></a>3.3 其他的文件</h3><p>除了我们上边说的这些用户自己存储的数据以外，<code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li> 服务器进程文件。<br>我们知道每运行一个<code>MySQL</code>服务器程序，都意味着启动一个进程。<code>MySQL</code>服务器会把自己的进程ID写入到一个文件中。 </li><li> 服务器日志文件。<br>在服务器运行过程中，会产生各种各样的日志，比如常规的查询日志、错误日志、二进制日志、redo日志等各种日志，这些日志各有各的用途，现在先了解一下就可以了。 </li><li> 默认/自动生成的SSL和RSA证书和密钥文件。<br>主要是为了客户端和服务器安全通信而创建的一些文件 </li></ul><h2 id="4-文件系统对数据库的影响"><a href="#4-文件系统对数据库的影响" class="headerlink" title="4.文件系统对数据库的影响"></a>4.文件系统对数据库的影响</h2><p>因为<code>MySQL</code>的数据都是存在文件系统中的，就不得不受到文件系统的一些制约，这在数据库和表的命名、表的大小和性能方面体现的比较明显，比如下边这些方面：</p><ul><li> 数据库名称和表名称不得超过文件系统所允许的最大长度。<br>每个数据库都对应<code>数据目录</code>的一个子目录，数据库名称就是这个子目录的名称；每个表都会在数据库子目录下产生一个和表名同名的<code>.frm</code>文件，如果是<code>InnoDB</code>的独立表空间或者使用<code>MyISAM</code>引擎还会有别的文件的名称与表名一致。这些目录或文件名的长度都受限于文件系统所允许的长度～ </li><li> 特殊字符的问题<br>为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，<code>MySQL</code>会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 <code>@+编码值</code>的形式作为文件名。比方说我们创建的表的名称为<code>&#39;test?&#39;</code>，由于<code>?</code>不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应的<code>.frm</code>文件的名称就变成了<code>test@003f.frm</code>。 </li><li> 文件长度受文件系统最大长度限制<br>对于<code>InnoDB</code>的独立表空间来说，每个表的数据都会被存储到一个与表名同名的<code>.ibd</code>文件中；对于<code>MyISAM</code>存储引擎来说，数据和索引会分别存放到与表同名的<code>.MYD</code>和<code>.MYI</code>文件中。这些文件会随着表中记录的增加而增大，它们的大小受限于文件系统支持的最大文件大小。 </li></ul><h2 id="5-MySQL系统数据库简介"><a href="#5-MySQL系统数据库简介" class="headerlink" title="5.MySQL系统数据库简介"></a>5.MySQL系统数据库简介</h2><p>我们前边提到了MySQL的几个系统数据库，这几个数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息，我们现在稍微了解一下。</p><ul><li> <code>mysql</code><br>这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。 </li><li> <code>information_schema</code><br>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等等。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。 </li><li> <code>performance_schema</code><br>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。 </li><li> <code>sys</code><br>这个数据库主要是通过视图的形式把<code>information_schema</code>和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。 </li></ul><hr><h1 id="二，回顾前面"><a href="#二，回顾前面" class="headerlink" title="二，回顾前面"></a>二，回顾前面</h1><p>数据页（也就是Index类型的页）由7部分组成，其中有两个部分是所有类型的页面都通用的。</p><p>所有类型的页都会包含下面两个部分。</p><ol><li>File Header：记录页面的一些通用信息</li><li>File Trailer: 校验页是否完整，保证页面在从内存刷新到磁盘后内容是相同的</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011719008-1353f404-8f8c-4d81-9a6f-76f122d746e4.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua635e316&margin=%5Bobject%20Object%5D&name=%E9%80%9A%E7%94%A8%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=475&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14614&status=done&style=none&taskId=u82ecfbd8-f77e-45b2-8d2d-d644c13df24&title=" alt="通用页结构示意图.png"></p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li>表空间中的每一个页都对应着一个页号，也就是<code>FIL_PAGE_OFFSET</code>，这个页号由4个字节组成，也就是32个比特位，所以一个表空间最多可以拥有2³²个页，如果按照页的默认大小16KB来算，一个表空间最多支持64TB的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3…依此类推</li><li>某些类型的页可以组成链表，链表中的页可以不按照物理顺序存储，而是根据<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>来存储上一个页和下一个页的页号。需要注意的是，这两个字段主要是为了<code>INDEX</code>类型的页，也就是我们之前一直说的数据页建立<code>B+</code>树后，为每层节点建立双向链表用的，一般类型的页是不使用这两个字段的。</li><li>每个页的类型由<code>FIL_PAGE_TYPE</code>表示，比如像数据页的该字段的值就是<code>0x45BF</code>，不同类型的页在该字段上的值是不同的。</li></ul><blockquote><p>InnoDB支持许多种类型的表空间，我们暂时重点关注系统表空间和独立表空间的结构。他们结构比较相似，但是由于系统表空间中额外包含了一些关于整个系统的信息，所以我们先分析独立表空间，再说系统表空间。</p></blockquote><h1 id="三，独立表空间"><a href="#三，独立表空间" class="headerlink" title="三，独立表空间"></a>三，独立表空间</h1><h2 id="1-区的概念"><a href="#1-区的概念" class="headerlink" title="1.区的概念"></a>1.区的概念</h2><p>为了更好的管理表中的页，InnoDB提出了区的概念。对于16KB的页来说，<strong>连续的64个页就是一个区</strong>。也就是说一个区默认占用1M空间。不论是系统表空间还是独立表空间，都可以看成是由若干区组成的，<strong>每256个区划分为一个组</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011740953-f94184f0-9793-4ade-9c74-159b23ced818.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf93a16d1&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.png&originHeight=637&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9806&status=done&style=none&taskId=u05c54b28-435d-4e5e-ab48-bee5b80fcf1&title=" alt="表空间结构.png"></p><p>为什么要有区的概念？</p><p>从理论上来讲，不引入区的概念只使用页的概念对存储引擎的运行并没有任何影响，但是我们来分析下：</p><p>我们每向表中插入一条记录，本质上就是向该表的聚簇索引以及所有二级索引代表的<code>B+</code>树的节点中插入数据。而<code>B+</code>树的每一层中的页都会形成一个双向链表，如果是以<code>页</code>为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。</p><p>B+树的范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的<code>随机I/O</code>。磁盘的速度和内存的速度差了好几个数量级，<code>随机I/O</code>是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的<code>顺序I/O</code>。</p><p>所以才引入了<code>区</code>（<code>extent</code>）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照<code>区</code>为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机<code>I/O</code>。</p><h2 id="2-段的概念"><a href="#2-段的概念" class="headerlink" title="2.段的概念"></a>2.段的概念</h2><p>范围查询，其实是对<code>B+</code>树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。InnoDB对B+树的叶子节点和非叶子节点进行了区别对待：叶子节点有自己独有的<code>区</code>，非叶子节点也有自己独有的<code>区</code>。存放叶子节点的区的集合就算是一个<code>段</code>（<code>segment</code>），存放非叶子节点的区的集合也算是一个<code>段</code>。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><p>默认情况下一个使用<code>InnoDB</code>存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？</p><p>为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了碎片区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：</p><ol><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的</li><li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间</li></ol><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。除了索引的叶子节点段和非叶子节点段之外，<code>InnoDB</code>中还有为存储一些特殊的数据而定义的段，比如回滚段，当然我们现在并不关心别的类型的段，现在只需要知道段是一些零散的页面以及一些完整的区的集合就好了。</p><blockquote><p>有的时候处于不同的阶段，对于某个概念的定义或者理解是不同的，随着知识水平的提升后续再来逐渐完善，就像小学的时候老师会告诉你最小的数是0，中学又告诉你最小的数是负无穷一样。</p></blockquote><h2 id="3-区的分类"><a href="#3-区的分类" class="headerlink" title="3.区的分类"></a>3.区的分类</h2><p>每个区都对应一个XDES Entry结构，这个结构中存储了一些与这个区有关的属性。这些区可以被分为下面四种类型。</p><ol><li>空闲的区：现在还没有用到这个区中的任何页面，这些区会被加入到FREE链表。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面，这些区会被加入到FREE_FRAG链表。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面；这些区会被加入到FULL_FRAG链表。</li><li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位；每个段所属的区又会被组织成下面几种链表。 <ol><li>FREE链表：在同一个段中，所有页面都是空闲页面的区对应的XDES Entry结构会被加入到这个链表。</li><li>NOT_FULL链表：在同一个段中，仍有空闲页面的区对应的XDES Entry结构会被加入到这个链表。</li><li>FULL链表：在同一个段中，已经没有空闲页面的区对应的XDES Entry结构会被加入到这个链表。</li></ol></li></ol><p>这四种类型的区也被叫做区的四种状态。</p><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>FREE</td><td>空闲的区</td></tr><tr><td>FREE_FRAG</td><td>有剩余空间的碎片区</td></tr><tr><td>FULL_FRAG</td><td>没有剩余空间的碎片区</td></tr><tr><td>FSEG</td><td>附属于某个段的区</td></tr></tbody></table><p><strong>处于</strong><code>**FREE**</code><strong>、</strong><code>**FREE_FRAG**</code><strong>以及</strong><code>**FULL_FRAG**</code><strong>这三种状态的区都是独立的，算是直属于表空间；而处于</strong><code>**FSEG**</code><strong>状态的区是附属于某个段的。</strong></p><p>每个段都会对应一个<code>INODE Entry</code>结构，该结构中存储了一些与这个段有关的属性。</p><p>表空间中第一个页面的类型为<code>FSP_HDR</code>，它存储了表空间的一些整体属性以及第一个组内256个区对应的XDES Entry结构。</p><p>除了表空间的第一个组以外，其余组的第一个页面的类型为XDES，这种页面的结构和FSP_HDR类型的页面对比，除了少了File Space header（记录表空间整体属性的部分）部分之外，其余部分是一样的。</p><p>每个组的第二个页面类型为IBUF_BITMAP，存储了一些关于Change Buffer的信息。</p><p>表空间中第一个组的第三个页面的类型是INODE，他是为了存储INODE Entry结构而设计的，这种类型的页面会组织成下面两个链表。</p><ol><li>SEG_INODES_FULL链表：在该链表中，INODE类型的页面中已经没有空闲空间来存储额外的INODE Entry结构。</li><li>SEG_INODES_FREE链表：在该链表中，INODE类型的页面中还有空闲空间来存储额外的INODE Entry结构。</li></ol><h2 id="4-Segment-Header"><a href="#4-Segment-Header" class="headerlink" title="4. Segment Header"></a>4. Segment Header</h2><p>一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个<code>INODE Entry</code>结构，那我们怎么知道<strong>某个段对应哪个</strong><code>**INODE Entry**</code><strong>结构</strong>呢？所以得找个地方记下来这个对应关系。<code>INDEX</code>类型的页时有一个<code>Page Header</code>部分，其中的<code>PAGE_BTR_SEG_LEAF</code>和<code>PAGE_BTR_SEG_TOP</code>都占用10个字节，它们其实对应一个叫<code>Segment Header</code>的结构，该结构图示如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011755576-3ecd1252-2638-464f-889a-90c84eca4f86.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u31b4510f&margin=%5Bobject%20Object%5D&name=SegmentHeader%E7%BB%93%E6%9E%84.png&originHeight=265&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=101386&status=done&style=none&taskId=u2dd24fe8-19ea-4269-a879-36246a5de4c&title=" alt="SegmentHeader结构.png"></p><p>各个部分的具体释义如下：</p><table><thead><tr><th>名称</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td>Space ID of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的表空间ID</td></tr><tr><td>Page Number of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的页面页号</td></tr><tr><td>Byte Offset of the INODE Ent</td><td>2</td><td>INODE Entry结构在该页面中的偏移量</td></tr></tbody></table><p><code>PAGE_BTR_SEG_LEAF</code>记录着叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量，<code>PAGE_BTR_SEG_TOP</code>记录着非叶子节点段对应的<code>INODE Entry</code>结构的地址是哪个表空间的哪个页面的哪个偏移量。这样子索引和其对应的段的关系就建立起来了。不过需要注意的一点是，因为一个索引只对应两个段，所以只需要在索引的根页面中记录这两个结构即可。</p><blockquote><p>其实Segment Header的作用就是记录哪个段对应哪个<code>INODE Entry</code>结构的。</p></blockquote><h2 id="5-真实表空间对应的文件大小"><a href="#5-真实表空间对应的文件大小" class="headerlink" title="5. 真实表空间对应的文件大小"></a>5. 真实表空间对应的文件大小</h2><p>一个新建的表对应的.ibd文件只占用了96KB，才6个页的大小。刚开始的时候，表空间占用空间自然很小，因为表里面没有数据。不过，ibd文件是自扩展文件，随着数据的增多文件也在逐渐增大。</p><h1 id="四，系统表空间"><a href="#四，系统表空间" class="headerlink" title="四，系统表空间"></a>四，系统表空间</h1><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间相当于是表空间之首，所以它的<code>表空间 ID</code>（Space ID）是<code>0</code>。</p><h2 id="1-系统表空间的整体结构"><a href="#1-系统表空间的整体结构" class="headerlink" title="1.系统表空间的整体结构"></a>1.系统表空间的整体结构</h2><p>系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011778567-ae1cca61-ce14-451b-a49c-c3ee3f4ab70a.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub1395531&margin=%5Bobject%20Object%5D&name=%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.png&originHeight=703&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=253316&status=done&style=shadow&taskId=udc4507a5-9091-44cd-9517-bf96623000b&title=" alt="系统表空间结构.png"></p><p>可以看到，系统表空间和独立表空间的前三个页面（页号分别为<code>0</code>、<code>1</code>、<code>2</code>，类型分别是<code>FSP_HDR</code>、<code>IBUF_BITMAP</code>、<code>INODE</code>）的类型是一致的，只是页号为<code>3</code>～<code>7</code>的页面是系统表空间特有的，我们来看一下这些多出来的页面都是干啥使的：</p><table><thead><tr><th>页号</th><th>页面类型</th><th>英文描述</th><th>描述</th></tr></thead><tbody><tr><td>3</td><td>SYS</td><td>Insert Buffer Header</td><td>存储Insert Buffer的头部信息</td></tr><tr><td>4</td><td>INDEX</td><td>Insert Buffer Root</td><td>存储Insert Buffer的根页面</td></tr><tr><td>5</td><td>TRX_SYS</td><td>Transaction System</td><td>事务系统的相关信息</td></tr><tr><td>6</td><td>SYS</td><td>First Rollback Segment</td><td>第一个回滚段的页面</td></tr><tr><td>7</td><td>SYS</td><td>Data Dictionary Header</td><td>数据字典头部信息</td></tr></tbody></table><p>除了这几个记录系统属性的页面之外，系统表空间的<code>extent 1</code>和<code>extent 2</code>这两个区，也就是页号从<code>64</code>~`191<code>这128个页面被称为</code>Doublewrite buffer`，也就是双写缓冲区。不过上述的大部分知识都涉及到了事务和多版本控制的问题，现在我们只分析有关InnoDB数据字典的知识，其余的概念在后边再看。</p><h3 id="1-1-InnoDB数据字典"><a href="#1-1-InnoDB数据字典" class="headerlink" title="1.1 InnoDB数据字典"></a>1.1 InnoDB数据字典</h3><p>每当我们向一个表中插入一条记录的时候，MySQL先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的<code>B+</code>树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p><ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li></ul><p>上述这些数据并不是我们使用<code>INSERT</code>语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为<code>元数据</code>。InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIRTUAL</td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr></tbody></table><p>这些系统表也被称为<code>数据字典</code>，它们都是以<code>B+</code>树的形式保存在系统表空间的某些页面中，其中<code>SYS_TABLES</code>、<code>SYS_COLUMNS</code>、<code>SYS_INDEXES</code>、<code>SYS_FIELDS</code>这四个表尤其重要，称之为基本系统表（basic system tables），我们先看看这4个表的结构：</p><h3 id="1-2-SYS-TABLES表"><a href="#1-2-SYS-TABLES表" class="headerlink" title="1.2 SYS_TABLES表"></a>1.2 SYS_TABLES表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>表的名称</td></tr><tr><td>id</td><td>InnoDB存储引擎每一张表都有一个唯一的ID</td></tr><tr><td>n_cols</td><td>该表拥有的列的个数</td></tr><tr><td>type</td><td>表的类型，记录了一些文件格式，行格式，压缩等信息</td></tr><tr><td>Mix_id</td><td>已经过时，忽略</td></tr><tr><td>Mix_len</td><td>表的一些额外属性</td></tr><tr><td>Cluster_id</td><td>未使用，忽略</td></tr><tr><td>Space</td><td>该表所属空间的ID</td></tr></tbody></table><p>这个<code>SYS_TABLES</code>表有两个索引：</p><ul><li>以<code>NAME</code>列为主键的聚簇索引</li><li>以<code>ID</code>列建立的二级索引</li></ul><h3 id="1-3-SYS-COLUMNS表"><a href="#1-3-SYS-COLUMNS表" class="headerlink" title="1.3 SYS_COLUMNS表"></a>1.3 SYS_COLUMNS表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该列所属表对应的ID</td></tr><tr><td>POS</td><td>该列在表中是第几列</td></tr><tr><td>NAME</td><td>该列的名称</td></tr><tr><td>MTYPE</td><td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE等</td></tr><tr><td>PRTYPE</td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td></tr><tr><td>LEN</td><td>该列最多占用存储空间的字节数</td></tr><tr><td>PREC</td><td>该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><p>这个<code>SYS_COLUMNS</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, POS)</code>列为主键的聚簇索引</li></ul><h3 id="1-4-SYS-INDEXES表"><a href="#1-4-SYS-INDEXES表" class="headerlink" title="1.4 SYS_INDEXES表"></a>1.4 SYS_INDEXES表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该索引所属表对应的ID</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td>NAME</td><td>该索引的名称</td></tr><tr><td>N_FIELDS</td><td>该索引包含列的个数</td></tr><tr><td>TYPE</td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td>SPACE</td><td>该索引根页面所在的表空间ID</td></tr><tr><td>PAGE_NO</td><td>该索引根页面所在的页面号</td></tr><tr><td>MERGE_THRESHOLD</td><td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><p>这个<code>SYS_INDEXES</code>表只有一个聚集索引：</p><ul><li>以<code>(TABLE_ID, ID)</code>列为主键的聚簇索引</li></ul><h3 id="1-5-SYS-FIELDS表"><a href="#1-5-SYS-FIELDS表" class="headerlink" title="1.5 SYS_FIELDS表"></a>1.5 SYS_FIELDS表</h3><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>INDEX_ID</td><td>该索引列所属的索引的ID</td></tr><tr><td>POS</td><td>该索引列在某个索引中是第几列</td></tr><tr><td>COL_NAME</td><td>该索引列的名称</td></tr></tbody></table><p>这个<code>SYS_FIELDS</code>表只有一个聚集索引：</p><ul><li>以<code>(INDEX_ID, POS)</code>列为主键的聚簇索引</li></ul><h3 id="1-6-Data-Dictionary-Header页面"><a href="#1-6-Data-Dictionary-Header页面" class="headerlink" title="1.6 Data Dictionary Header页面"></a>1.6 Data Dictionary Header页面</h3><p>只要有了上述4个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比方说我们想看看<code>SYS_TABLESPACES</code>这个系统表里存储了哪些表空间以及表空间对应的属性，那就可以：</p><ul><li>到<code>SYS_TABLES</code>表中根据表名定位到具体的记录，就可以获取到<code>SYS_TABLESPACES</code>表的<code>TABLE_ID</code></li><li>使用这个<code>TABLE_ID</code>到<code>SYS_COLUMNS</code>表中就可以获取到属于该表的所有列的信息。</li><li>使用这个<code>TABLE_ID</code>还可以到<code>SYS_INDEXES</code>表中获取所有的索引的信息，索引的信息中包括对应的<code>INDEX_ID</code>，还记录着该索引对应的<code>B+</code>数根页面是哪个表空间的哪个页面。</li><li>使用<code>INDEX_ID</code>就可以到<code>SYS_FIELDS</code>表中获取所有索引列的信息。</li></ul><p>这4个表的元数据去哪里获取呢？这4个表的元数据，就是它们有哪些列、哪些索引等信息是硬编码到代码中的，InnoDB用一个固定的页面来记录这4个表的聚簇索引和二级索引对应的<code>B+树</code>位置，这个页面就是页号为<code>7</code>的页面，类型为<code>SYS</code>，记录了<code>Data Dictionary Header</code>，也就是数据字典的头部信息。除了这4个表的5个索引的根页面信息外，这个页号为<code>7</code>的页面还记录了整个InnoDB存储引擎的一些全局属性。</p><p>这个页面由下边几个部分组成：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Data Dictionary Header</td><td>数据字典头部信息</td><td>56</td><td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td>Segment Header</td><td>段头部信息</td><td>10</td><td>记录本页面所在段对应的INODE Entry位置信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>16272</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><p>这个页面里有<code>Segment Header</code>部分，意味着InnoDB把这些有关数据字典的信息当成一个段来分配存储空间，我们称之为<code>数据字典段</code>。由于目前我们需要记录的数据字典信息非常少（可以看到<code>Data Dictionary Header</code>部分仅占用了56字节），所以该段只有一个碎片页，也就是页号为<code>7</code>的这个页。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1640011825618-aa10d2ad-6eec-4c77-b50b-2fe1973e2182.png#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uca647b94&margin=%5Bobject%20Object%5D&name=%E9%A1%B5%E5%8F%B7%E4%B8%BA7%E7%9A%84%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=944&originWidth=1846&originalType=binary&ratio=1&rotation=0&showTitle=false&size=558893&status=done&style=shadow&taskId=u10130667-5bfc-434f-a8de-39540039538&title=" alt="页号为7的页结构示意图.png"></p><p>接下来我们需要看一下<code>Data Dictionary Header</code>部分的各个字段：</p><ul><li><code>Max Row ID</code>：如果我们不显式的为表定义主键，而且表中也没有<code>UNIQUE</code>索引，那么<code>InnoDB</code>存储引擎会默认为我们生成一个名为<code>row_id</code>的列作为主键。因为它是主键，所以每条记录的<code>row_id</code>列的值不能重复。原则上只要一个表中的<code>row_id</code>列不重复就可以了，也就是说表a和表b拥有一样的<code>row_id</code>列也没啥关系，不过InnoDB只提供了这个<code>Max Row ID</code>字段，不论哪个拥有<code>row_id</code>列的表插入一条记录时，该记录的<code>row_id</code>列的值就是<code>Max Row ID</code>对应的值，然后再把<code>Max Row ID</code>对应的值加1，也就是说这个<code>Max Row ID</code>是全局共享的。</li><li><code>Max Table ID</code>：InnoDB存储引擎中的所有的表都对应一个唯一的ID，每次新建一个表时，就会把本字段的值作为该表的ID，然后自增本字段的值。</li><li><code>Max Index ID</code>：InnoDB存储引擎中的所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把本字段的值作为该索引的ID，然后自增本字段的值。</li><li><code>Max Space ID</code>：InnoDB存储引擎中的所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把本字段的值作为该表空间的ID，然后自增本字段的值。</li><li><code>Mix ID Low(Unused)</code>：这个字段没啥用，跳过。</li><li><code>Root of SYS_TABLES clust index</code>：本字段代表<code>SYS_TABLES</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_TABLE_IDS sec index</code>：本字段代表<code>SYS_TABLES</code>表为<code>ID</code>列建立的二级索引的根页面的页号。</li><li><code>Root of SYS_COLUMNS clust index</code>：本字段代表<code>SYS_COLUMNS</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_INDEXES clust index</code>本字段代表<code>SYS_INDEXES</code>表聚簇索引的根页面的页号。</li><li><code>Root of SYS_FIELDS clust index</code>：本字段代表<code>SYS_FIELDS</code>表聚簇索引的根页面的页号。</li><li><code>Unused</code>：这4个字节没用，跳过。</li></ul><p>以上就是页号为<code>7</code>的页面的全部内容。</p><h3 id="1-7-information-schema系统数据库"><a href="#1-7-information-schema系统数据库" class="headerlink" title="1.7 information_schema系统数据库"></a>1.7 information_schema系统数据库</h3><p>用户是不能直接访问<code>InnoDB</code>的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。不过InnoDB考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库<code>information_schema</code>中提供了一些以<code>innodb_sys</code>开头的表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE information_schema;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| Tables_in_information_schema (innodb_sys%) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| INNODB_SYS_DATAFILES                       |</span><br><span class="line">| INNODB_SYS_VIRTUAL                         |</span><br><span class="line">| INNODB_SYS_INDEXES                         |</span><br><span class="line">| INNODB_SYS_TABLES                          |</span><br><span class="line">| INNODB_SYS_FIELDS                          |</span><br><span class="line">| INNODB_SYS_TABLESPACES                     |</span><br><span class="line">| INNODB_SYS_FOREIGN_COLS                    |</span><br><span class="line">| INNODB_SYS_COLUMNS                         |</span><br><span class="line">| INNODB_SYS_FOREIGN                         |</span><br><span class="line">| INNODB_SYS_TABLESTATS                      |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表，而是在存储引擎启动时读取这些以<code>SYS</code>开头的系统表，然后填充到这些以<code>INNODB_SYS</code>开头的表中。以<code>INNODB_SYS</code>开头的表和以<code>SYS</code>开头的表中的字段并不完全一样。<br>​</p><blockquote><p>补充一张表空间完整结构图</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1640011944905-2540c89c-22e0-4215-8e21-c15a2da2b621.jpeg#clientId=uf6d4afa7-d985-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u54935513&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84%E5%9B%BE.jpg&originHeight=3476&originWidth=6102&originalType=binary&ratio=1&rotation=0&showTitle=false&size=396886&status=done&style=shadow&taskId=u9cd36e06-bfc7-476f-96f8-800de759742&title=" alt="表空间完整结构图.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[四]索引命中原理</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E5%9B%9B%5D%E7%B4%A2%E5%BC%95%E5%91%BD%E4%B8%AD%E5%8E%9F%E7%90%86/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E5%9B%9B%5D%E7%B4%A2%E5%BC%95%E5%91%BD%E4%B8%AD%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇分析了InnoDB存储引擎的B+树索引，现在来进行一个简单的回顾。</p><ol><li>每个索引都对应一颗B+树，B+树分为好多层，最下边一层是叶子结点，其余的是内结点。所有的用户记录都存储在B+树的叶子结点，所有目录项记录都存储在内节点。</li><li>InnoDB存储引擎会自动为主键建立聚簇索引，聚簇索引的叶子结点包含完整的用户记录。</li><li>我们可以为指定的列建立二级索引，二级索引的叶子结点包含的用户记录由索引列+主键组成，所以如果项通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+树中每层结点都是按照索引列值从大到小的顺序排序而组成了双向链表，而且每个页内的记录(不论是用户记录还是目录项记录)都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，在按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+树的根节点开始，一层一层乡下搜索。由于每个页面都按照索引列的值建立了页目录，所以在这些页面中查找非常快。</li></ol></blockquote><h1 id="一，做一些前置的准备"><a href="#一，做一些前置的准备" class="headerlink" title="一，做一些前置的准备"></a>一，做一些前置的准备</h1><p>为了这篇文章的演示，需要先建立一张简单的表，用来演示索引执行过程中出现的一些情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> single_table</span><br><span class="line">(</span><br><span class="line">    # 主键索引</span><br><span class="line">    id           <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    key1         <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key2         <span class="type">int</span>,</span><br><span class="line">    key3         <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1    <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2    <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3    <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    # 索引列key1</span><br><span class="line">    key idx_key1 (key1),</span><br><span class="line">    # 唯一索引：索引列key2</span><br><span class="line">    <span class="keyword">unique</span> key uk_key2 (key2),</span><br><span class="line">    # 索引列key3</span><br><span class="line">    key idx_key3 (key3),</span><br><span class="line">    # 联合索引：索引列：key_part1, key_part2, key_part3</span><br><span class="line">    key idx_key_part (key_part1, key_part2, key_part3)</span><br><span class="line">) engine <span class="operator">=</span> innodb</span><br><span class="line">  charset <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure><p>再往表中插入100w条数据，具体的插入过程不在演示。</p><h1 id="二，索引的代价"><a href="#二，索引的代价" class="headerlink" title="二，索引的代价"></a>二，索引的代价</h1><p>凡事都是有利有弊的，索引可以加快查询的速度，但是同样的，他也有相应的缺点。</p><ol><li>空间上</li></ol><blockquote><p>一个索引对应一个B+树，每一个B+树的每一个节点都是一个数据页。一个数据页大小默认是16kb，所以一张表的索引越多，占用的空间其实越大，特别是在数据量大的时候，所以一般我们建立索引，默认每张表不要超过5个。</p></blockquote><ol start="2"><li>时间上</li></ol><blockquote><p>在对表进行增删改操作的时候，要对所有索引对应的B+树进行修改。而且上一篇分析过，B+树的每一层节点都按照索引列的值从小到大的顺序排序组成了双向链表。页中的记录都按照索引列的值从小到大的顺序形成了一个单向链表。而增删改操作可能会对结点和记录的排序造成破坏，所以存储引擎需要额外的时间进行页面分裂，页回收等操作，好维护结点和记录的排序。索引越多，维护的时间成本越高。</p><p>还有一点就是执行查询语句之前，会先生成执行计划。一般情况下一条语句再一次执行过程中只会使用一个二级索引(有特殊的，后面会分析)，在生成执行计划的时候需要计算使用不同索引执行查询时所需成本，最后选取成本最低的索引执行查询。如果索引太多，分析成本就会很高，耗时严重，从而影响查询语句的执行性能。</p></blockquote><p>为了合理的建立索引，一方面加快我们的查询速度，一方面又不会过分的占用我们的时间和空间，我们需要了解索引在查询执行期间到底是如何发挥作用的。</p><h1 id="三，使用B-树索引"><a href="#三，使用B-树索引" class="headerlink" title="三，使用B+树索引"></a>三，使用B+树索引</h1><h2 id="1-扫描区间和边界条件"><a href="#1-扫描区间和边界条件" class="headerlink" title="1.扫描区间和边界条件"></a>1.扫描区间和边界条件</h2><p>先说什么是全表扫描？就是从头到尾依次遍历所有结点，再依次遍历结点中的所有记录。全表扫描虽然效率很低，但是却是一种万能的解决方案，所有查询都可以使用这种方案兜底。</p><p>我们可以利用B+树查找索引列值等于某个值的记录，这样可以明显减少需要扫描的记录数量。由于B+树叶子节点中的记录是按照索引列值从小到大的顺序排序的，所以只扫描某个区间或某些区间中的记录也是很快的，比如下面这个查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from single_table where id&gt;=2 and id&lt;=100;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861046004-8c35f559-5650-44b9-b0a9-47b2334d60ad.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1c70cd2c&margin=%5Bobject%20Object%5D&name=1.png&originHeight=59&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12854&status=done&style=none&taskId=ucca74516-26f6-41af-88cb-3f76bafac9c&title=" alt="1.png"></p><p>这个时候其实是走了主键索引，这个语句其实是想查找id值在区间【2，100】内的所有聚簇索引记录，我们可以通过主键索引先定位到id=2的记录，然后顺着这条记录的单向链表往后找就行了。</p><p>与全表扫描的100w数据相比，扫描这个区间的成本简直太小了，所以提升了查询效率。我们把这个案例中待扫描的id值所在区间称为扫描区间，把形成这个扫描区间的搜索条件称为形成这个扫描区间的边界条件。</p><blockquote><p>其实对于全表扫描来讲，就是在【-∞，+∞】的区间进行扫描而已。</p></blockquote><p>再来看一条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 in (1438, 6328)</span><br><span class="line">   or (key2 &gt;= 38 and key2 &lt;= 79);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861062027-fb46777d-8f4a-4f15-a4cc-883c41c8ab95.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ubca1ca12&margin=%5Bobject%20Object%5D&name=2.png&originHeight=65&originWidth=1608&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12570&status=done&style=none&taskId=u37ac3391-1f3f-4801-9b06-5935cfb6508&title=" alt="2.png"></p><p>这个查询的搜索条件涉及到key2列，我们正好在key2列上建立了唯一索引。如果使用唯一索引执行这个查询，实际上相当于从三个区间获取二级索引的记录。</p><ol><li>【1438，1438】</li><li>【6328，6328】</li><li>【38，79】</li></ol><p>类似前面两个区间这种，只有一个值的区间，我们称为单点扫描区间，把类似第三个区间这样存在多个值的叫做范围扫描区间，另外，由于我们的查询列是*，导致从上述的区间每次获取到一条二级索引记录，就需要根据二级索引记录的id列的值取回表一次。</p><p>当然，并不是所有的条件都可以称为边界条件，比如下面的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key1 &gt; &#x27;aaa&#x27;</span><br><span class="line">  and key3 &lt; &#x27;zzz&#x27;</span><br><span class="line">  and common_field = &#x27;aaa&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861071980-6cffcbf1-a768-4767-86ec-0ae8355ba6ac.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud3dc6494&margin=%5Bobject%20Object%5D&name=3.png&originHeight=68&originWidth=1510&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13331&status=done&style=none&taskId=u3c8e91ca-b9ac-41fa-9588-9fead969b05&title=" alt="3.png"></p><ol><li>如果使用idx_key1执行查询，那么相应的扫描区间就变成了【’aaa’,+∞】，后面的条件就是普通搜索条件，这些普通的搜索条件需要在获取到idx_key1的二级索引记录后，在执行回表操作，在获取到完整的用户记录后才能去判断他们是否成立。</li><li>如果使用idx_key3执行查询，那么扫描区间就是【-∞,’zzz’】,其余的条件就是普通搜索条件，这些普通的搜索条件需要在获取到idx_key3的二级索引记录后，在执行回表操作，在获取到完整的用户记录后才能去判断他们是否成立。</li></ol><p>在使用某个索引执行查询的时候，关键的问题就是通过搜索条件找出合适的区间，然后再去对应的B+树中扫描索引列值在这些扫描区间的记录，对于每一个区间来说，只需要定位到第一条，就可以沿着单链表一直往后扫符合条件的记录。</p><p>其实对于B+树索引来说： <code>=     &lt;=&gt;    in    not in    is null    is not null    &gt;    &lt;    &gt;=    &lt;=    between    !=    like</code>    都会进行区间扫描，只不过区间扫描大小不同导致效率不同。</p><p>不过也有一些需要注意的点：</p><ol><li>in和多个 = 用or连接起来的效果其实是一样的，都会产生多个单点扫描区间</li><li>不等于 产生的区间比较操蛋：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> single_table <span class="keyword">where</span> key1 <span class="operator">!=</span> <span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure><p>这个时候idx_key1 执行查询的时候对应的扫描区间就是【-∞,’aaa’】和【’aaa’,+∞】。</p><ol start="3"><li>like操作比较特殊，只有在匹配完整的字符串或者匹配字符串前缀的时候才会产生合适的扫描区间</li></ol><blockquote><p>比较字符串的大小其实就是逐个比较每个字符的大小。字符串的比较过程如下：</p><ol><li>先比较字符串的第一个字符，第一个字符串小的字符就比较小</li><li>如果第一个字符一样的话就按照上面的规则比较第二个，以此类推。</li></ol></blockquote><p>对于某个索引列来说，字符串前缀相同的记录在由记录组成的单向链表中肯定是相邻的。比如我们有一个搜索条件是<code>key1 like &#39;a%&#39;</code>，对于二级索引idx_key1来说，所有字符串前缀为a的二级索引记录肯定是相邻的。这也就意味着我们只要定位到key1值得字符串前缀为a的第一条记录，就可以依次往后扫描，直到某条二级索引记录的字符串不是a为止。</p><p>很显然，<code>key1 like &#39;a%&#39;</code>形成的扫描区间相当于【’a’,’b’】。</p><p><strong>在执行一个查询语句的时候，首先需要找出所有可用的索引以及使用他们时对应的扫描区间。</strong>接下来我们分析下怎么从包含若干个and或者or的复杂搜索条件中提取出正确的扫描区间。</p><h3 id="1-1-所有搜索条件都可以生成合适的扫描区间的情况"><a href="#1-1-所有搜索条件都可以生成合适的扫描区间的情况" class="headerlink" title="1.1 所有搜索条件都可以生成合适的扫描区间的情况"></a>1.1 所有搜索条件都可以生成合适的扫描区间的情况</h3><p>在使用某个索引执行查询的时候，有时每个小的搜索条件都可以生成一个合适的扫描区间来减少需要扫描的记录数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  and key2 &gt; 200;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861084810-5b627d4c-74d1-4e3a-a9d5-d13604354033.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9bca9182&margin=%5Bobject%20Object%5D&name=4.png&originHeight=62&originWidth=1622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12578&status=done&style=none&taskId=u65c5ba29-1492-4691-bed1-6a04678fe0c&title=" alt="4.png"></p><p>在使用唯一索引进行查询的时候，这两个条件都可以形成一个扫描区间【100，+∞】，【200，+∞】。因为这两个条件是用and连接的，所以最终就是两个区间取交集【200，+∞】。</p><p>我们把sql改一改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  or key2 &gt; 200;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861091476-035c46dc-56b7-4098-9ed1-01d81c30a134.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u6338bb93&margin=%5Bobject%20Object%5D&name=5.png&originHeight=72&originWidth=1617&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12711&status=done&style=none&taskId=u635f5d16-7043-4177-8af3-8966d0f2426&title=" alt="5.png"></p><p>这个时候因为是使用or进行两个条件的连接，所以两个条件的区间应该取并集：【100，+∞】。</p><h3 id="1-2-有的搜索条件不能生成合适的扫描区间的情况"><a href="#1-2-有的搜索条件不能生成合适的扫描区间的情况" class="headerlink" title="1.2 有的搜索条件不能生成合适的扫描区间的情况"></a>1.2 有的搜索条件不能生成合适的扫描区间的情况</h3><p>在使用某个索引进行查询的时候，有些小的搜索条件并不能生成合适的扫描区间来减少需要扫描的行数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  and common_field =&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>在使用唯一索引进行查询的时候，第一个条件会定位出区间【100，+∞】，但是第二个条件是一个普通条件，相当于【-∞，+∞】，因为两个条件使用and连接的，所以最终取交集之后的区间就是【100，+∞】。</p><p>其实在使用唯一索引进行查询的时候，在寻找对应的扫描区间的过程中，搜索条件<code>common_field =&#39;abc&#39;</code>没有起到任何作用，我们可以直接把这个条件进行一个等价替换【TRUE】(true对应的扫描区间也是【-∞，+∞】)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  and true;</span><br></pre></td></tr></table></figure><p>在进行化简之后就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br></pre></td></tr></table></figure><p>也就是说上面的查询语句在使用唯一索引进行查询的时候对应的扫描区间就是【100，+∞】。</p><p>再来看一下使用OR的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  or common_field =&#x27;abc&#x27;;</span><br></pre></td></tr></table></figure><p>同样进行化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key2 &gt; 100</span><br><span class="line">  or true;</span><br></pre></td></tr></table></figure><p>继续化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain</span><br><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where true</span><br></pre></td></tr></table></figure><p>可见如果此时强制使用唯一索引进行查询，对应的扫描区间就是【-∞，+∞】，再加上这是二级索引，每次匹配到一条都要进行回表，所以这个查询的代价甚至比全表扫描还大，这个时候再使用唯一索引就没意义了。</p><h3 id="1-3从复杂的搜索条件中找出扫描区间"><a href="#1-3从复杂的搜索条件中找出扫描区间" class="headerlink" title="1.3从复杂的搜索条件中找出扫描区间"></a>1.3从复杂的搜索条件中找出扫描区间</h3><p>来一个复杂点的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> single_table</span><br><span class="line"><span class="keyword">where</span> (key1 <span class="operator">&gt;</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">and</span> key2 <span class="operator">&gt;</span> <span class="number">748</span>)</span><br><span class="line">   <span class="keyword">or</span> (key1 <span class="operator">&lt;</span> <span class="string">&#x27;eee&#x27;</span> <span class="keyword">and</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line">   <span class="keyword">or</span> (key1 <span class="keyword">like</span> <span class="string">&#x27;%f&#x27;</span> <span class="keyword">and</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">and</span> (key2 <span class="operator">&lt;</span> <span class="number">8000</span> <span class="keyword">or</span> common_field <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span>));</span><br></pre></td></tr></table></figure><p>这无语的SQL怎么搞？</p><ol><li>先看where子句里面都涉及到了哪些列，以及我们为哪些列建立了索引</li><li>对于可以用到的索引，我们来分析索引的扫描区间</li></ol><h4 id="1-3-1-使用idx-key1查询"><a href="#1-3-1-使用idx-key1查询" class="headerlink" title="1.3.1 使用idx_key1查询"></a>1.3.1 使用idx_key1查询</h4><p>先把不能形成合适扫描区间的搜索条件干掉，怎么干掉？直接把他们替换成TRUE。</p><p>替换之后的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where (key1 &gt; &#x27;aaa&#x27; and TRUE)</span><br><span class="line">   or (key1 &lt; &#x27;eee&#x27; and key1 &gt; &#x27;ccc&#x27;)</span><br><span class="line">   or (TRUE and key1 &gt; &#x27;aaa&#x27; and (TRUE or TRUE));</span><br></pre></td></tr></table></figure><p>化简之后的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where (key1 &gt; &#x27;aaa&#x27; ) -- 【aaa,+∞】</span><br><span class="line">   or (key1 &lt; &#x27;eee&#x27; and key1 &gt; &#x27;ccc&#x27;) -- 【&#x27;ccc&#x27;,&#x27;eee&#x27;】</span><br></pre></td></tr></table></figure><p>因为这两个条件之间是用OR连接起来的，所以我们应该取并集，最终：【aaa,+∞】。</p><p>也就是需要把所有key1在这个区间内的所有二级索引记录都取出来，针对获取到的每一条二级索引记录进行一次回表，在得到完整的用户记录之后在使用其他的搜索条件进行过滤。</p><h4 id="1-3-2-使用唯一二级索引查询"><a href="#1-3-2-使用唯一二级索引查询" class="headerlink" title="1.3.2 使用唯一二级索引查询"></a>1.3.2 使用唯一二级索引查询</h4><p>我们还是进行化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where (TRUE and key2 = 748)</span><br><span class="line">   or (TRUE and TRUE)</span><br><span class="line">   or (TRUE and TRUE and (key2 &lt; 8000 or common_field = &#x27;aaa&#x27;));</span><br></pre></td></tr></table></figure><p>再继续化简</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where  key2 = 748</span><br><span class="line">   or TRUE</span><br></pre></td></tr></table></figure><p>因为两个条件使用OR连接的，所以最终的结果就是【-∞，+∞】。</p><p>也就是需要把所有key2所有二级索引记录都取出来，针对获取到的每一条二级索引记录进行一次回表，在得到完整的用户记录之后在使用其他的搜索条件进行过滤，比全表扫描还耗时，所以这个时候我们是不会走唯一二级索引的。</p><blockquote><p>在使用idx_key1执行上述查询的时候，搜索条件 <code>key1 like &#39;%f&#39;</code> 比较特殊。虽然他不能作为形成扫描区间的边界条件，但是idx_key1的二级索引记录是包含key1列的。因此我们可以先判断获取到的二级索引记录是否符合这个条件。如果符合在执行回表操作，如果不符合就不用回表了。这样就可以较少因为回表带来的性能损耗，这就是<strong>索引下推</strong>。</p></blockquote><h3 id="1-4使用联合索引执行查询时对应的扫描区间"><a href="#1-4使用联合索引执行查询时对应的扫描区间" class="headerlink" title="1.4使用联合索引执行查询时对应的扫描区间"></a>1.4使用联合索引执行查询时对应的扫描区间</h3><p>联合索引的索引列包含多个列，B+树中的每一层页面以及每一个页中的记录采用的排序规则比较复杂。以上面的表为例，<code>idx_key_part (key_part1, key_part2, key_part3)</code> 采用的排序规则如下：</p><ol><li>先按照key_part1进行排序</li><li>key_part1相同按照key_part2进行排序，以此类推</li></ol><h4 id="1-4-1全值匹配原理"><a href="#1-4-1全值匹配原理" class="headerlink" title="1.4.1全值匹配原理"></a>1.4.1全值匹配原理</h4><p>对于下面这条查询语句来讲：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 =&#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>因为二级索引记录先按照key_part1进行值排序的，所以符合条件的所有记录肯定是相邻的。我们可以先定位到符合条件的第一条记录，沿着链表顺序往下扫描知道不符合条件为止（当然，对于获取到的每一条二级索引记录都需要进行回表）。此时的扫描区间【’a’,’a’】。</p><p>在看一条查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 = &#x27;a&#x27;</span><br><span class="line">  and key_part2 = &#x27;b&#x27;;</span><br></pre></td></tr></table></figure><p>按照联合索引的排序规则，最终的扫描区间其实就是【(‘a’,’b’),(‘a’,’b’)】。</p><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 &lt;&#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>因为二级索引记录先按照key_part1进行值排序的，所以符合条件的所有记录肯定是相邻的。我们可以先定位到符合条件的第一条记录，然后顺着单向链表继续往后扫描，直到遇到不符合规则的记录就停止。【-∞,’a’】</p><h4 id="1-4-2最佳左前缀匹配原理"><a href="#1-4-2最佳左前缀匹配原理" class="headerlink" title="1.4.2最佳左前缀匹配原理"></a>1.4.2最佳左前缀匹配原理</h4><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part2 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure><p>由于二级索引记录不是直接按照key_part2列的值进行排序的，所以符合条件的二级索引记录可能并不相邻，也就意味着我们不能通过搜索条件来减少需要扫描的行数，这种情况下，我们是不会使用这个索引的。</p><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 = &#x27;a&#x27;</span><br><span class="line">  and key_part3 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>这个时候，其实是可以按照key_part1进行过滤的，但是因为接下来是按照key_part2进行排序的，所以满足搜索条件 <code>key_part3 = &#39;c&#39;</code>的二级索引值记录可能并不相邻，这个时候扫描区间其实就是【’a’,’a’】。因为第二个条件走不了索引。</p><blockquote><p>针对获取到的每一条二级索引记录，如果没有开启索引条件下推的特性，则必须先回表获取完整的记录在来判断 <code>key_part3 = &#39;c&#39;</code>条件是否成立，如果开启了索引下推特性，可以判断完 <code>key_part3 = &#39;c&#39;</code>是否成立后在进行回表操作，索引下推是在MySQL5.6引入的，默认开启。</p></blockquote><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 &lt; &#x27;a&#x27;</span><br><span class="line">  and key_part2 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>因为二级索引记录先按照key_part1进行值排序的，所以符合条件的所有记录肯定是相邻的。但是对于<code>key_part1 &lt; &#39;a&#39;</code>条件的二级索引记录来说，并不是直接按照key_part2进行排序的，也就是说我们不能根据<code>key_part2 = &#39;c&#39;</code>来进一步减少扫描的行数。那么，如果使用当前索引执行查询，可以定位到符合<code>key_part1 &lt; &#39;a&#39;</code>的第一条记录，然后沿着单链表往后扫描，一直到不符合<code>key_part1 &lt; &#39;a&#39;</code>为止。</p><p>所以在使用当前索引执行SQL的时候，对应的扫描区间其实就是【-∞,’a’】。</p><p>在看一条SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from single_table</span><br><span class="line">where key_part1 &lt;= &#x27;a&#x27;</span><br><span class="line">  and key_part2 = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure><p>这条SQL和上一条SQL很像，唯一的区别就是从小于变成了小于等于。很显然符合<code>key_part1 &lt;= &#39;a&#39;</code>的索引值记录是连续的，但是对于符合<code>key_part1 &lt;= &#39;a&#39;</code>条件的二级索引记录来说，并不是直接按照key_part2列排序的。<strong>但是</strong>，对于符合<code>key_part1 = &#39;a&#39;</code>的二级索引记录来说，是按照key_part2的值进行排序的。那么再确定需要扫描的二级索引记录的范围时，当二级索引记录的<code>key_part1 = &#39;a&#39;</code>时，也可以通过<code>key_part2 = &#39;c&#39;</code>来减少扫描行数，也就是说，当扫描到不符合<code>key_part1 &lt;= &#39;a&#39; and key_part2 = &#39;c&#39;</code>的第一条记录的时候，就可以结束扫描，而不需要将所有的<code>key_part1 = &#39;a&#39;</code>的记录全部扫描完。</p><h2 id="2-索引用于排序"><a href="#2-索引用于排序" class="headerlink" title="2. 索引用于排序"></a>2. 索引用于排序</h2><p>我们在写查询语句的时候经常需要对查询出来的记录通过<code>ORDER BY</code>子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在<code>MySQL</code>中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>），跟<code>文件</code>这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果<code>ORDER BY</code>子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2, key_part3 LIMIT 10;</span><br></pre></td></tr></table></figure><p>这个查询的结果集需要先按照<code>key_part1</code>值排序，如果记录的<code>key_part1</code>值相同，则需要按照<code>key_part2</code>来排序，如果<code>key_part2</code>的值相同，则需要按照<code>key_part3</code>排序。因为这个<code>B+</code>树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行<code>回表</code>操作取出该索引中不包含的列就好了。</p><h3 id="2-1使用联合索引进行排序注意事项"><a href="#2-1使用联合索引进行排序注意事项" class="headerlink" title="2.1使用联合索引进行排序注意事项"></a>2.1使用联合索引进行排序注意事项</h3><p>对于<code>联合索引</code>有个问题需要注意，<code>ORDER BY</code>的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出<code>ORDER BY key_part1, key_part3, key_part2</code>的顺序，那也是用不了<code>B+</code>树索引，这种颠倒顺序就不能使用索引的原因我们上边详细说过了，这就不赘述了。</p><p>同理，<code>ORDER BY key_part1</code>、<code>ORDER BY key_part1, key_part2</code>这种匹配索引左边的列的形式可以使用部分的<code>B+</code>树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 = &#x27;A&#x27; ORDER BY key_part2, key_part3 LIMIT 10;</span><br></pre></td></tr></table></figure><p>这个查询能使用联合索引进行排序是因为<code>key_part1</code>列的值相同的记录是按照<code>key_part2</code>, <code>key_part3</code>排序的。</p><h3 id="2-2不可以使用索引进行排序的几种情况"><a href="#2-2不可以使用索引进行排序的几种情况" class="headerlink" title="2.2不可以使用索引进行排序的几种情况"></a>2.2不可以使用索引进行排序的几种情况</h3><h4 id="2-2-1ASC、DESC混用"><a href="#2-2-1ASC、DESC混用" class="headerlink" title="2.2.1ASC、DESC混用"></a>2.2.1ASC、DESC混用</h4><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序。</p><blockquote><p>ORDER BY子句后的列如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的。</p></blockquote><p>为啥会有这种规定呢？这个还得回头想想这个<code>idx_key_part</code>联合索引中记录的结构：</p><ul><li>先按照记录的<code>key_part1</code>列的值进行升序排列。</li><li>如果记录的<code>key_part1</code>列的值相同，再按照<code>key_part2</code>列的值进行升序排列。</li><li>如果记录的<code>key_part2</code>列的值相同，再按照<code>key_part3</code>列的值进行升序排列。</li></ul><p>如果查询中的各个排序列的排序顺序是一致的，比方说下边这两种情况：</p><ul><li> <code>ORDER BY key_part1, key_part2 LIMIT 10</code><br>这种情况直接从索引的最左边开始往右读10行记录就可以了。 </li><li> <code>ORDER BY key_part1 DESC, key_part2 DESC LIMIT 10</code>，<br>这种情况直接从索引的最右边开始往左读10行记录就可以了。 </li></ul><p>但是如果我们查询的需求是先按照<code>key_part1</code>列进行升序排列，再按照<code>key_part2</code>列进行降序排列的话，比如说这样的查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2 DESC LIMIT 10;</span><br></pre></td></tr></table></figure><p>这样如果使用索引排序的话过程就是这样的：</p><ul><li>先从索引的最左边确定<code>key_part1</code>列最小的值，然后找到<code>key_part1</code>列等于该值的所有记录，然后从<code>name</code>列等于该值的最右边的那条记录开始往左找10条记录。</li><li>如果<code>key_part1</code>列等于最小的值的记录不足10条，再继续往右找<code>key_part1</code>值第二小的记录，重复上边那个过程，直到找到10条记录为止。</li></ul><p>这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据，所以就规定<strong>使用联合索引的各个排序列的排序顺序必须是一致的</strong>。</p><h4 id="2-2-2排序列包含非同一个索引的列"><a href="#2-2-2排序列包含非同一个索引的列" class="headerlink" title="2.2.2排序列包含非同一个索引的列"></a>2.2.2排序列包含非同一个索引的列</h4><p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, common_field LIMIT 10;</span><br></pre></td></tr></table></figure><p><code>key_part1</code>和<code>common_field</code>并不属于一个联合索引中的列，所以无法使用索引进行排序。</p><h4 id="2-2-3排序列使用了复杂的表达式"><a href="#2-2-3排序列使用了复杂的表达式" class="headerlink" title="2.2.3排序列使用了复杂的表达式"></a>2.2.3排序列使用了复杂的表达式</h4><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY UPPER(key_part1) LIMIT 10;</span><br></pre></td></tr></table></figure><p>使用了<code>UPPER</code>函数修饰过的列就不是单独的列了，这样就无法使用索引进行排序了。</p><h2 id="3-索引用于分组"><a href="#3-索引用于分组" class="headerlink" title="3. 索引用于分组"></a>3. 索引用于分组</h2><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2, key_part3, COUNT(*) FROM single_table GROUP BY key_part1, key_part2, key_part3</span><br></pre></td></tr></table></figure><p>这个查询语句相当于做了3次分组操作：</p><ol><li>先把记录按照<code>key_part1</code>值进行分组，所有<code>key_part1</code>值相同的记录划分为一组。</li><li>将每个<code>key_part1</code>值相同的分组里的记录再按照<code>key_part2</code>的值进行分组，将<code>key_part3</code>值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li><li>再将上一步中产生的小分组按照<code>key_part3</code>的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把<code>大分组</code>分成若干个<code>小分组</code>，然后把若干个<code>小分组</code>再细分成更多的<code>小小分组</code>。</li></ol><p>然后针对那些<code>小小分组</code>进行统计，比如在我们这个查询语句中就是统计每个<code>小小分组</code>包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的<code>B+</code>树中的索引列的顺序是一致的，而我们的<code>B+</code>树索引又是按照索引列排好序的，这不正好么，所以可以直接使用<code>B+</code>树索引进行分组。</p><p>和使用<code>B+</code>树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p><h1 id="四，回表的代价"><a href="#四，回表的代价" class="headerlink" title="四，回表的代价"></a>四，回表的代价</h1><p>看下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 &gt; &#x27;aaa&#x27; AND key_part1 &lt; &#x27;zzz&#x27;;</span><br></pre></td></tr></table></figure><p>在使用<code>idx_key_part</code>索引进行查询时大致可以分为这两个步骤：</p><ol><li>从索引<code>idx_key_part</code>对应的<code>B+</code>树中取出<code>key_part1</code>值在<code>aaa</code>～<code>zzz</code>之间的用户记录。</li><li>由于索引idx_key_part对应的<code>B+</code>树用户记录中只包含<code>key_part1</code>、<code>key_part2</code>、<code>key_part3</code>、<code>id</code>这4个字段，而查询列表是<code>*</code>，意味着要查询表中所有字段，也就是还要包括其他字段。这时需要把从上一步中获取到的每一条记录的<code>id</code>字段都到聚簇索引对应的<code>B+</code>树中找到完整的用户记录，也就是我们通常所说的<code>回表</code>，然后把完整的用户记录返回给查询用户。</li></ol><p>由于索引<code>idx_key_part</code>对应的<code>B+</code>树中的记录首先会按照<code>key_part1</code>列的值进行排序，所以值在<code>aaa～zzz</code>之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为<code>顺序I/O</code>。根据第1步中获取到的记录的<code>id</code>字段的值可能并不相连，而在聚簇索引中记录是根据<code>id</code>（也就是主键）的顺序排列的，所以根据这些并不连续的<code>id</code>值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为<code>随机I/O</code>。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引<code>idx_key_part</code>的查询有这么两个特点：</p><ol><li> 会使用到两个<code>B+</code>树索引，一个二级索引，一个聚簇索引。 </li><li> 访问二级索引使用<code>顺序I/O</code>，访问聚簇索引使用<code>随机I/O</code>。 </li></ol><p>需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用<code>二级索引</code>。比方说<code>key_part1</code>值在<code>aaa</code>～<code>zzz</code>之间的用户记录数量占全部记录数量90%以上，那么如果使用<code>idx_key_part</code>索引的话，有90%多的<code>id</code>值需要回表，还不如直接去扫描聚簇索引（也就是全表扫描）。</p><p>那什么时候采用全表扫描的方式，什么时候使用采用<code>二级索引 + 回表</code>的方式去执行查询呢？这个就是查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用<code>二级索引 + 回表</code>的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用<code>二级索引 + 回表</code>的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table WHERE key_part1 &gt; &#x27;aaa&#x27; AND key_part1 &lt; &#x27;zzz&#x27; LIMIT 10;</span><br></pre></td></tr></table></figure><p>添加了<code>LIMIT 10</code>的查询更容易让优化器采用<code>二级索引 + 回表</code>的方式进行查询。</p><p>对于有排序需求的查询，上边讨论的采用<code>全表扫描</code>还是<code>二级索引 + 回表</code>的方式进行查询的条件也是成立的，比方说下边这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2, key_part3;</span><br></pre></td></tr></table></figure><p>由于查询列表是<code>*</code>，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（<code>filesort</code>）低，所以优化器会倾向于使用<code>全表扫描</code>的方式执行查询。如果我们加了<code>LIMIT</code>子句，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM single_table ORDER BY key_part1, key_part2, key_part3 LIMIT 10;</span><br></pre></td></tr></table></figure><p>这样需要回表的记录特别少，优化器就会倾向于使用<code>二级索引 + 回表</code>的方式执行查询。</p><h1 id="五，更好的创建和使用索引"><a href="#五，更好的创建和使用索引" class="headerlink" title="五，更好的创建和使用索引"></a>五，更好的创建和使用索引</h1><h2 id="1-只为了用于搜索，排序-amp-分组的列创建索引"><a href="#1-只为了用于搜索，排序-amp-分组的列创建索引" class="headerlink" title="1. 只为了用于搜索，排序&amp;分组的列创建索引"></a>1. 只为了用于搜索，排序&amp;分组的列创建索引</h2><p>也就是说，只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2 FROM single_table WHERE key_part3 = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>像查询列表中的key_part1、key_part2这两个列就不需要建立索引，我们只需要为出现在<code>WHERE</code>子句中的<code>key_part3</code>列创建索引就可以了。</p><h2 id="2-考虑列的基数"><a href="#2-考虑列的基数" class="headerlink" title="2. 考虑列的基数"></a>2. 考虑列的基数</h2><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是<code>3</code>。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。这个<code>列的基数</code>指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为<code>1</code>，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：<strong>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</strong></p><h2 id="3-索引列的类型尽量小"><a href="#3-索引列的类型尽量小" class="headerlink" title="3. 索引列的类型尽量小"></a>3. 索引列的类型尽量小</h2><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDIUMINT</code>、<code>INT</code>、<code>BIGINT</code>这么几种，它们占用的存储空间依次递增，我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>～ 这是因为：</p><ol><li>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东西）</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ol><p>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的<code>I/O</code>。</p><h2 id="4-为列前缀建立索引"><a href="#4-为列前缀建立索引" class="headerlink" title="4. 为列前缀建立索引"></a>4. 为列前缀建立索引</h2><p>一个字符串其实是由若干个字符组成，如果我们在<code>MySQL</code>中使用<code>utf8</code>字符集去存储字符串的话，编码一个字符需要占用<code>1~3</code>个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的<code>B+</code>树中有这么两个问题：</p><ol><li> <code>B+</code>树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。 </li><li> 如果<code>B+</code>树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。 </li></ol><p>索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 — 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在<code>B+</code>树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题。</p><h2 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h2><p>为了彻底告别<code>回表</code>操作带来的性能损耗，建议：最好在查询列表里只包含索引列，比如这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT key_part1, key_part2 FROM single_table WHERE key_part3 = &#x27;Ashburn&#x27;;</span><br></pre></td></tr></table></figure><p>因为我们只查询<code>key_part1</code>, <code>key_part2</code>, 这2个索引列的值，所以在通过<code>idx_key_part</code>索引得到结果后就不必到<code>聚簇索引</code>中再查找记录的剩余列，这样就省去了<code>回表</code>操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为<code>索引覆盖</code>。排序操作也优先使用<code>覆盖索引</code>的方式进行查询，比方说这个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  key_part1, key_part2, key_part3  FROM person_info ORDER BYkey_part1, key_part2, key_part3;</span><br></pre></td></tr></table></figure><p>虽然这个查询中没有<code>LIMIT</code>子句，但是采用了<code>覆盖索引</code>，所以查询优化器就会直接使用<code>idx_key_part</code>索引进行排序而不需要回表操作了。</p><p>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是尽量不要用用<code>*</code>号作为查询列表，最好把需要查询的列依次标明。</p><h2 id="6-不要乱动列名"><a href="#6-不要乱动列名" class="headerlink" title="6.不要乱动列名"></a>6.不要乱动列名</h2><p>假设表中有一个整数列<code>my_col</code>，我们为这个列建立了索引。下边的两个<code>WHERE</code>子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li><code>WHERE my_col * 2 &lt; 4</code></li><li><code>WHERE my_col &lt; 4/2</code></li></ol><p>第1个<code>WHERE</code>子句中<code>my_col</code>列并不是以单独列的形式出现的，而是以<code>my_col * 2</code>这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于<code>4</code>，所以这种情况下是使用不到为<code>my_col</code>列建立的<code>B+</code>树索引的。而第2个<code>WHERE</code>子句中<code>my_col</code>列并是以单独列的形式出现的，这样的情况可以直接使用<code>B+</code>树索引。</p><p>所以结论就是<strong>：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的</strong>。</p><h2 id="7-尽量维持有序插入"><a href="#7-尽量维持有序插入" class="headerlink" title="7. 尽量维持有序插入"></a>7. 尽量维持有序插入</h2><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在<code>1~100</code>之间：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861103166-845b6b09-0294-4027-ad5d-b5815df00793.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub7061039&margin=%5Bobject%20Object%5D&name=6.png&originHeight=248&originWidth=1118&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5278&status=done&style=none&taskId=u7c51a7b9-7e57-4ac1-9546-eb1849caa4f&title=" alt="6.png"></p><p>如果此时再插入一条主键值为<code>9</code>的记录，那它插入的位置就如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639861109717-cb54b239-fa3d-463d-b7bf-d5a71ab2d1ca.png#clientId=udf787159-51e7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0dbeca73&margin=%5Bobject%20Object%5D&name=7.png&originHeight=407&originWidth=1101&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8706&status=done&style=none&taskId=udac3d09f-d048-4f8a-a7bc-6dfdca9f91e&title=" alt="7.png"></p><p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：<strong>让主键具有</strong><code>**AUTO_INCREMENT**</code><strong>，让存储引擎自己为表生成主键，而不是我们手动插入</strong> 。</p><h2 id="8-冗余和重复索引"><a href="#8-冗余和重复索引" class="headerlink" title="8.冗余和重复索引"></a>8.冗余和重复索引</h2><p>我们知道，通过<code>idx_key_part</code>索引就可以对<code>key_part1</code>列进行快速搜索，再创建一个专门针对<code>key_part1</code>列的索引就算是一个<code>冗余</code>索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><blockquote><p>至此，索引命中的原理和我们在建立索引的时候应该注意什么就分析完了，好家伙，又是一个通宵。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[三]InnoDB索引结构</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>索引其实就是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】。<br>​</p><blockquote><p>为什么有页的概念？<br>​</p></blockquote><blockquote><p>查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p></blockquote><p>​</p><p>数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。<br>​</p><blockquote><p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796442070-30497473-d6d6-4848-9622-3ef7c4be8eab.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5dd411f3&margin=%5Bobject%20Object%5D&name=%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.jpg&originHeight=816&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24988&status=done&style=shadow&taskId=u7ea9c417-2241-4f50-b784-ce1b7ae3a67&title=" alt="索引的层级关系.jpg"></p><p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p><h1 id="一，行格式"><a href="#一，行格式" class="headerlink" title="一，行格式"></a>一，行格式</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p><h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><p>比如我们创建一张表来指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="keyword">VALUES</span>(<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="string">&#x27;eeee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>首先我们来看Compact行格式。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796457336-bb5e4bf7-0f44-4c11-9580-32077f221ac3.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u510eb047&margin=%5Bobject%20Object%5D&name=Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=513&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108011&status=done&style=shadow&taskId=u3c55f797-d70f-44c7-bc54-b58728aaeaf&title=" alt="Compact行格式示意图.png"></p><p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p><h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>额外的信息实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p><h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】。</p><blockquote><p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p></blockquote><p>在Compact行格式中，会把所有的变长字段占用的真实长度全部<strong>逆序</strong>存储在记录的开头位置，形成一个变长字段长度列表。</p><p>比如我们刚才创建的那张表，我们来分析一下：</p><p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p><table><thead><tr><th>列名</th><th>储存内容</th><th>内容长度(十进制表示)</th><th>内容长度(十六进制表示)</th></tr></thead><tbody><tr><td>C1</td><td>‘aaaa’</td><td>4</td><td>0x04</td></tr><tr><td>C2</td><td>‘bbb’</td><td>3</td><td>0x03</td></tr><tr><td>C4</td><td>‘d’</td><td>1</td><td>0x01</td></tr></tbody></table><p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796496893-933ea1aa-d845-4f94-9328-beff8d57dbc4.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8653fe78&margin=%5Bobject%20Object%5D&name=%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=471&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96980&status=done&style=shadow&taskId=u7e13eb1a-bbe3-4c44-8f4e-7237f99dd6f&title=" alt="第一条记录的存储格式.png"></p><p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p><p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p><p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p><p>【L】：真实占用的字节数</p><ol><li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li></ol><blockquote><p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p></blockquote><ol start="2"><li>如果M*W&gt;=255,这个时候再次分为两种情况： <ol><li>如果L&lt;=127，那就用1个字节表示</li><li>否则就用2个字节表示</li></ol></li></ol><blockquote><p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p><p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p><p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p></blockquote><p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p><p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p><h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p><p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p><p>看一下处理过程：</p><ol><li>首先统计出表中允许存储NULL的字段</li><li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li><li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li></ol><p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p><p>这个时候再来看我们上面创建的表中的记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796522793-2b2f0b54-2e1b-4534-97fc-ad5d2ae29267.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua59c3787&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=578&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116004&status=done&style=shadow&taskId=u474c254b-e5cb-420c-939e-50e0762c364&title=" alt="表中记录的存储格式.png"></p><h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651393775-13c8a071-3007-4743-98e6-6bfadf766833.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=nEsCg&originHeight=238&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>接下来来看记录的真实数据。</p><h3 id="2-2-真实数据"><a href="#2-2-真实数据" class="headerlink" title="2.2 真实数据"></a>2.2 真实数据</h3><p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p><p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p><p>在完善下我们开头创建的那张表的记录形象。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651419885-ccc53e84-579f-4e2b-aaa3-c2da800dcf5b.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=EzoHh&originHeight=480&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p><h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p><p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p><blockquote><p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p></blockquote><h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p><h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p><p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p><ol><li>真实数据</li><li>真实数据占用的字节长度</li><li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li></ol><p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p><p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p><p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p><blockquote><p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p></blockquote><h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p><p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651449173-c7c3df4a-7697-4e98-8461-0f4d8fa25acf.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=YE1nR&originHeight=698&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651459938-08f5b09b-16a1-4981-b0db-58ce8c2776fd.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=yQ6dC&originHeight=427&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p><h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p><p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p><p>分析一下页空间是如何利用的</p><ol><li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li><li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：<table><thead><tr><th>内容</th><th>大小(字节)</th></tr></thead><tbody><tr><td>真实数据的长度</td><td>2</td></tr><tr><td>列是否是NULL值</td><td>1</td></tr><tr><td>头信息</td><td>5</td></tr><tr><td>row_id</td><td>6</td></tr><tr><td>transaction_id</td><td>6</td></tr><tr><td>roll_pointer</td><td>7</td></tr></tbody></table></li></ol><p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p><h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651470552-ca5845c2-4a02-4778-8072-12e7cfc5e936.png#crop=0&crop=0&crop=1&crop=1&id=DwYBu&originHeight=456&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p><blockquote><p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p></blockquote><h1 id="二，页的存储结构"><a href="#二，页的存储结构" class="headerlink" title="二，页的存储结构"></a>二，页的存储结构</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p><p>本节分析存放表中记录的页，官方成为索引页，为了分析方便，我们暂且叫做数据页。</p><blockquote><p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p></blockquote><p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796599016-6db7f08f-012c-4991-beb7-f86a02b783e9.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u24a51a9d&margin=%5Bobject%20Object%5D&name=%E8%A1%8C%E6%A0%BC%E5%BC%8F%26%E9%A1%B5%E7%BB%93%E6%9E%84.png&originHeight=1924&originWidth=2164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=761701&status=done&style=shadow&taskId=ua68b2010-2f09-4933-82b5-8624ccfa018&title=" alt="行格式&amp;页结构.png"></p><p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小（字节）</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页专有的一些信息</td></tr><tr><td>Infifmum + Supremum</td><td>最小记录和最大记录</td><td>26</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658751624-f2ae040c-521a-4279-a33a-3d049076dbbb.png#crop=0&crop=0&crop=1&crop=1&id=rhsyy&originHeight=443&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>再次回顾下记录头中5个字节表示的数据。</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>针对当前这个表的行格式简化图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658929002-26d8d2aa-f31f-4424-9364-53bb1e935f02.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=JuPWk&originHeight=328&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>接下来我们往表中插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure><p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639659360000-9ea955da-a191-4149-a654-02130cd27262.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=IQRli&originHeight=511&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>分析一下头信息中的每个属性是什么意思。</p><h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p><p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p><blockquote><p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p></blockquote><h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p><h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p><p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p><p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p><p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660568126-eca45a45-699f-4c18-a914-9b0082e4409e.png#crop=0&crop=0&crop=1&crop=1&id=Qa0fp&originHeight=341&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660690280-f21f9cde-a88c-43b7-bed2-e61cdf99821c.png#crop=0&crop=0&crop=1&crop=1&id=yv4uT&originHeight=417&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p><h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p><p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p><h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661137395-fec2e2b7-c0d0-4ecd-8cf0-ff73e86cd98b.png#crop=0&crop=0&crop=1&crop=1&id=GEIoi&originHeight=509&originWidth=1025&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure><p>删除第二条记录以后：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661263287-6bf68c5d-2b08-49f7-9b64-91ff84f8c25f.png#crop=0&crop=0&crop=1&crop=1&id=ehUJN&originHeight=472&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>发生的变化：</p><ul><li>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</li><li>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</li><li>第一条记录的next record指向了第三条记录</li><li>最大记录的 n_owned 值从5 变成了4</li></ul><p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p><p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p><p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p><p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661938956-dbc09fae-e330-4b44-a97c-ad28500fb0c0.png#crop=0&crop=0&crop=1&crop=1&id=N59w2&originHeight=516&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p><h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol><li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li><li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li><li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li></ol><p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663655164-28caa8e4-aceb-4b4e-aaaf-75ab188453c9.png#crop=0&crop=0&crop=1&crop=1&id=xFmTO&originHeight=481&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p><p>注意最大和最小记录的头信息的n_owned属性：</p><ol><li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li><li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li></ol><p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663745413-7924a9ec-b680-4231-8686-eb99c41946df.png#crop=0&crop=0&crop=1&crop=1&id=k3iqz&originHeight=541&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。所以分组是按照下边的步骤进行的：</p><ul><li> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </li><li> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li><li> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </li></ul><p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663920121-ec3b0a9f-f512-432d-a584-fb3187b0a0bf.png#crop=0&crop=0&crop=1&crop=1&id=caRNN&originHeight=632&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p><p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li></ol><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p><ol><li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ol><h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p><table><thead><tr><th>名称</th><th>占用空间大小（字节）</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p><p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p><h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p><p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p><ol><li>前四个字节代表校验和</li><li>后四个字节代表页面被最后修改时对应的日志序列位置</li></ol><p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p><blockquote><p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p></blockquote><h1 id="三，索引"><a href="#三，索引" class="headerlink" title="三，索引"></a>三，索引</h1><h2 id="1-假如没有索引"><a href="#1-假如没有索引" class="headerlink" title="1.假如没有索引"></a>1.假如没有索引</h2><p>我们先来看看没有索引的情况下，我们进行数据的查找(毕竟没有对比就没有伤害)。</p><h3 id="1-1-在一个页中查找"><a href="#1-1-在一个页中查找" class="headerlink" title="1.1 在一个页中查找"></a>1.1 在一个页中查找</h3><p>假设表中的记录很少，所有的记录仅仅用一个页就存放下了，这个时候按照不同的搜索条件其实可以分为两种情况讨论：</p><p>【以主键为搜索的条件】：可以再页目录中根据二分查找快速定位到槽，在根据槽定位到该组的最小索引记录，然后进行遍历匹配查找。</p><p>【以其他列作为搜索条件】：在数据页中并没有为非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。在这种情况下，只能从最小记录开始依次往后遍历单链表中的每条记录，然后对比每条记录是否符合搜索条件，显然，效率很低。</p><h3 id="1-2-在很多页中查找"><a href="#1-2-在很多页中查找" class="headerlink" title="1.2 在很多页中查找"></a>1.2 在很多页中查找</h3><p>很多时候，表的记录一个页都是存储不下的，这个时候的查找其实分为两个步骤：</p><p>【定位到记录所在的页】</p><p>【从所在的页内查找相应的记录】</p><p>因为我们不能快速的定位到所在的页，所以只能从第一页开始沿着双链表往后遍历定位页，定位到页以后在根据在一个页中的查找方式进行匹配查找，显而易见，这个时候效率低的可怕。</p><blockquote><p>有了痛点，就会有大牛去思考整个生命周期，完善逻辑和资源倾斜，形成一套自己的方法论，想办法为快速查找赋能。</p></blockquote><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>我们先创建一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><h3 id="2-1-一个简单的索引方案"><a href="#2-1-一个简单的索引方案" class="headerlink" title="2.1 一个简单的索引方案"></a>2.1 一个简单的索引方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？</p><p>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <strong><em>不得不</em></strong> 依次遍历所有的数据页。</p><p>如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？</p><p>对比根据主键值快速定位一条记录从而在页中的位置建立页目录，我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录。</p><p>【<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。】</p><p>假设我们现在每一页只能放三条记录，现在已经放了主键为1,3,5的三条记录。这个时候我们再添加一条主键为4的记录，我们不得不为他分配一个新的页。</p><blockquote><p>注意：新分配的数据页编号可能和原来并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。他们只是通过维护着上一页和下一页的编号而建立了链表关系。</p></blockquote><p>原来页中主键最大的值为5，现在我们新插入一条记录，如果直接放在新页里面，那就会有问题，这不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值得要求，所以在插入主键值为4 的记录的时候需要伴随一次记录的移动，也就是把主键值为5 的记录移动到新分配的页中，然后把主键值为4 的记录插入到原来的页中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796706858-85d2f635-d8a4-40cf-96ad-d575a4929471.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua72ea1d2&margin=%5Bobject%20Object%5D&name=%E9%A1%B5%E5%88%86%E8%A3%82.png&originHeight=689&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27916&status=done&style=shadow&taskId=u163f5ce3-dbab-47a0-bad4-ed0af4cae2f&title=" alt="页分裂.png"></p><p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为<code>页分裂</code>。</p><p>【<strong>给所有的页建立一个目录项。</strong>】</p><p>由于数据页的编号可能并不是连续的，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796721543-59286c6b-be1f-4bf0-89c0-3c9d783caf2c.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7a2de81e&margin=%5Bobject%20Object%5D&name=%E6%8F%92%E5%85%A5%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E6%83%85%E6%99%AF.png&originHeight=206&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17346&status=done&style=shadow&taskId=ue4ddf3bb-d1ea-41aa-a3e4-48daab58dfa&title=" alt="插入多条记录后的情景.png"></p><p>因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p><ol><li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li><li>页号，我们用<code>page_no</code>表示。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796747935-7d4d34c8-1163-4cae-8461-f44007b8fc07.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uafd00c0b&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BB%BA%E7%AB%8B%E7%9B%AE%E5%BD%95.png&originHeight=537&originWidth=1081&originalType=binary&ratio=1&rotation=0&showTitle=false&size=211150&status=done&style=none&taskId=u664861d2-e96c-4b27-9d3e-0df0e0538f5&title=" alt="推理索引-建立目录.png"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</li><li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录其实就是【索引】。</p><h3 id="2-2-InnoDB中的索引方案"><a href="#2-2-InnoDB中的索引方案" class="headerlink" title="2.2 InnoDB中的索引方案"></a>2.2 InnoDB中的索引方案</h3><p>上面的方案存在什么样的问题？</p><ul><li><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下。</li></ul><p>InnoDB复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。</p><p>那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？通过记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p><ul><li><code>0</code>：普通的用户记录</li><li><code>**1**</code><strong>：目录项记录</strong></li><li><code>2</code>：最小记录</li><li><code>3</code>：最大记录</li></ul><p>把前边使用到的目录项放到数据页中的样子就是这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796769647-30add870-277e-46a6-b85f-eb81c9fffd78.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udd4ebea4&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BC%95%E5%87%BA%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=477&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245132&status=done&style=shadow&taskId=u5c27ff4c-5fe6-43bc-8fc3-5bbf4ebce0e&title=" alt="推理索引-引出目录项记录.png"></p><p>从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p><ul><li><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</li><li><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</li><li>头信息里面有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p>除此之外，两者就没有区别了，页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li><li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li></ol><blockquote><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p><p><strong>当然是再多整一个存储</strong><code>**目录项记录**</code><strong>的页。</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796794024-3c603a8c-379a-4741-b43f-0d09f823f3db.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u74247d36&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=423&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206755&status=done&style=shadow&taskId=uf9035595-4bd9-4c46-8e69-5fa3ae1bf3e&title=" alt="推理索引-多目录项记录.png"></p><p>从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了<code>页31</code>。</li><li>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前边假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li></ul><p>现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p><ol><li>确定<code>目录项记录</code>页</li></ol><blockquote><p>我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p></blockquote><ol start="2"><li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？</p><p>为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796830733-a6cde000-9332-4f5a-8a83-0f7e8303a427.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5af42117&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95.png&originHeight=565&originWidth=888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246476&status=done&style=shadow&taskId=ub41ee0ab-63de-4476-9f1f-a9ecedd9f1f&title=" alt="推理索引-多级目录.png"></p><p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796848198-e8ce79c1-5f89-473a-97bf-03b44b900c28.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b765b2b&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png&originHeight=483&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27024&status=done&style=shadow&taskId=u8446b051-6d0e-476f-acb2-2a089be6d78&title=" alt="多路平衡二叉树.png"></p><p>其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p><p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上边的那个节点也称为<code>根节点</code>。</p><p>从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，<code>InnoDB</code>规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的分析我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p><ul><li>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li><li>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</li><li>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</li><li>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。</li></ul><p>一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录。</p><h3 id="2-3-聚簇索引"><a href="#2-3-聚簇索引" class="headerlink" title="2.3 聚簇索引"></a>2.3 聚簇索引</h3><p>上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p><ol><li> 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </li></ol><ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul><ol start="2"><li> <code>B+</code>树的叶子节点存储的是完整的用户记录。<br>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </li></ol><p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建，<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的<strong>索引即数据，数据即索引</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796876199-b11195b7-5f43-49e4-95b4-9f16f805b7c2.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc673077f&margin=%5Bobject%20Object%5D&name=B%2B%E6%A0%91%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.jpg&originHeight=1878&originWidth=2947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=414971&status=done&style=shadow&taskId=ue286f0f6-c6f0-48b5-a853-ab5a88d3867&title=" alt="B+树主键索引.jpg"></p><h3 id="2-4-二级索引"><a href="#2-4-二级索引" class="headerlink" title="2.4 二级索引"></a>2.4 二级索引</h3><p><code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p><p>我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797313347-a44afddd-2c1b-4011-acc5-577ff4416285.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u807c5795&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png&originHeight=580&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=250264&status=done&style=shadow&taskId=uffdaff61-f70c-4ca9-b584-bb4c6ec8250&title=" alt="二级索引.png"></p><p>这个<code>B+</code>树与上边介绍的聚簇索引有几处不同：</p><ol><li> 使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义： </li><li>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</li><li> <code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。 </li><li> 目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。 </li></ol><p>所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li>确定<code>目录项记录</code>页</li></ol><blockquote><p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p></blockquote><ol start="2"><li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li></ol><blockquote><p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p></blockquote><ol start="3"><li>在真实存储用户记录的页中定位到具体的记录.</li></ol><blockquote><p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p></blockquote><ol start="4"><li>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li></ol><p><strong>我们根据这个以</strong><code>**c2**</code><strong>列大小排序的</strong><code>**B+**</code><strong>树只能确定我们要查找记录的主键值，所以如果我们想根据</strong><code>**c2**</code><strong>列的值查找到完整的用户记录的话，仍然需要到</strong><code>**聚簇索引**</code><strong>中再查一遍，这个过程也被称为</strong><code>**回表**</code><strong>。</strong>也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p><p>为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？</p><p>如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为为c2列建立的索引。</p><p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p><p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p><h3 id="2-5-联合索引"><a href="#2-5-联合索引" class="headerlink" title="2.5 联合索引"></a>2.5 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li></ul><p>为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797330214-15ee3ffb-1ebd-41aa-a48a-6c81ea92814d.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42fac64f&margin=%5Bobject%20Object%5D&name=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png&originHeight=599&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264505&status=done&style=shadow&taskId=uaa1c9645-b635-4e8f-a3d7-7942580366d&title=" alt="联合索引.png"></p><h2 id="3-InnoDB的B-树索引的注意事项"><a href="#3-InnoDB的B-树索引的注意事项" class="headerlink" title="3. InnoDB的B+树索引的注意事项"></a>3. InnoDB的B+树索引的注意事项</h2><h3 id="3-1-跟页面永远固定不动"><a href="#3-1-跟页面永远固定不动" class="headerlink" title="3.1 跟页面永远固定不动"></a>3.1 跟页面永远固定不动</h3><p>前边介绍<code>B+</code>树索引的时候，为了理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p><ul><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程需要特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p><h3 id="3-2-内节点中目录项记录的唯一性"><a href="#3-2-内节点中目录项记录的唯一性" class="headerlink" title="3.2 内节点中目录项记录的唯一性"></a>3.2 内节点中目录项记录的唯一性</h3><p>我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。假设表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797360116-ea5f9dc7-74cc-4191-ae4d-dd56cd80b6f5.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u817bb64e&margin=%5Bobject%20Object%5D&name=%E4%B8%BAc2%E5%BB%BA%E7%AB%8B%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%90%8E%E7%9A%84%E6%A0%91.png&originHeight=434&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77378&status=done&style=shadow&taskId=uc338898e-4933-47a8-9023-5f624b43729&title=" alt="为c2建立二级索引后的树.png"></p><p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中?</p><p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的。</p><p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p><h3 id="3-3-一个页面最少存储2条记录"><a href="#3-3-一个页面最少存储2条记录" class="headerlink" title="3.3 一个页面最少存储2条记录"></a>3.3 一个页面最少存储2条记录</h3><p>B+树只需要很少的层级就可以轻松存储数亿条记录，这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录会怎么样？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录，会导致效率很低。</p><blockquote><p>其实让B+数的叶子结点值存储一条记录，让内节点存储多条记录，也还是可以发挥B+数的作用的。但是InnoDB为了避免数的层级过高，要求所有的数据页都至少可以容纳两条记录。</p></blockquote><h2 id="4-MyISAM中的索引方案简单介绍"><a href="#4-MyISAM中的索引方案简单介绍" class="headerlink" title="4. MyISAM中的索引方案简单介绍"></a>4. MyISAM中的索引方案简单介绍</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p><ul><li> 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。 </li><li> 使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！<br>这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code>！ </li><li> 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。 </li></ul><blockquote><p>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在MyIsaM数据上使用二分法进行查找。</p></blockquote><h2 id="5-创建和删除索引的语句"><a href="#5-创建和删除索引的语句" class="headerlink" title="5. 创建和删除索引的语句"></a>5. 创建和删除索引的语句</h2><p><code>InnoDB</code>和<code>MyISAM</code>会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。</p><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY<span class="operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们也可以在修改表结构的时候添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure><p>也可以在修改表结构的时候删除索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</span><br></pre></td></tr></table></figure><blockquote><p>至此，整个索引相关的结构我们就都分析完了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[一]入门</title>
      <link href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/"/>
      <url>/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一，MYSQL入门"><a href="#一，MYSQL入门" class="headerlink" title="一，MYSQL入门"></a>一，MYSQL入门</h3><h4 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1.数据库相关概念"></a>1.数据库相关概念</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DB：数据库：存储数据的仓库，保存了一系列有组织的数据。</span></span><br><span class="line"><span class="attr">DBMS：数据库管理系统：数据库是通过DBMS创建和操作的容器。</span></span><br><span class="line"><span class="attr">SQL：结构化查询语言：专门用来与数据库通信的语言。</span></span><br></pre></td></tr></table></figure><h4 id="2-数据库的好处"><a href="#2-数据库的好处" class="headerlink" title="2.数据库的好处"></a>2.数据库的好处</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.可以持久化数据到本地</span></span><br><span class="line"><span class="attr">2.可以实现结构化查询，方便管理</span></span><br></pre></td></tr></table></figure><h4 id="3-数据库存储数据特点"><a href="#3-数据库存储数据特点" class="headerlink" title="3.数据库存储数据特点"></a>3.数据库存储数据特点</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.将数据放到表中，表放到库中。</span></span><br><span class="line"><span class="attr">2.一个数据库有多张表，每个表都有一个名字，用来标识自己。</span></span><br><span class="line"><span class="attr">表名具有唯一性。</span></span><br><span class="line"><span class="attr">3.表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中类的设计。</span></span><br><span class="line"><span class="attr">4.表有列组成，我们也称为字段。所有表都是由一个列或多个列组成的，</span></span><br><span class="line"><span class="attr">每一列类似Java中的属性。</span></span><br><span class="line"><span class="attr">5.表中的数据按照行来存储，每一行类似于Java中的对象。</span></span><br></pre></td></tr></table></figure><h4 id="4-mysql的安装与使用"><a href="#4-mysql的安装与使用" class="headerlink" title="4.mysql的安装与使用"></a>4.mysql的安装与使用</h4><p><strong>参照mysql安装文档</strong></p><h4 id="5-Mysql常用命令"><a href="#5-Mysql常用命令" class="headerlink" title="5.Mysql常用命令"></a>5.Mysql常用命令</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">显示数据库-----&gt;show</span> <span class="string">Databases;</span></span><br><span class="line"><span class="meta">使用数据库-----&gt;use</span> <span class="string">数据库名；</span></span><br><span class="line"><span class="meta">显示表----&gt;show</span> <span class="string">tables;</span></span><br><span class="line"><span class="meta">显式指定数据库的表----&gt;show</span> <span class="string">tables from 数据库名；</span></span><br><span class="line"><span class="meta">查看位于那个数据库----&gt;select</span> <span class="string">database();</span></span><br><span class="line"><span class="meta">显示表结构---&gt;desc</span> <span class="string">表名；</span></span><br><span class="line"><span class="meta">查看数据库版本：---&gt;select</span> <span class="string">version();</span></span><br><span class="line"><span class="meta">查看数据库版本2</span>:<span class="string">-----&gt;Dos:mysql --version;</span></span><br><span class="line"><span class="meta">查看数据库信息-----&gt;show</span> <span class="string">CREATE DATABASE mydb1;</span></span><br><span class="line"><span class="meta">查看服务器中的数据库，并把mydb1的字符集修改为utf-8-----&gt;ALTER</span> <span class="string">DATABASE mydb1character set utf8;</span></span><br><span class="line"><span class="meta">删除数据库-----&gt;drop</span> <span class="string">database mydb1;</span></span><br><span class="line"><span class="meta">表中增加一栏信息-----&gt;alter</span> <span class="string">table student add image blob;</span></span><br><span class="line"><span class="meta">删除表-----&gt;drop</span> <span class="string">table student;</span></span><br><span class="line"><span class="meta">修改地址-----&gt;alter</span> <span class="string">table student modify address varchar(100);</span></span><br><span class="line"><span class="meta">删除一个属性-----&gt;</span> <span class="string">alter table student drop image;</span></span><br><span class="line"><span class="meta">修改表名-----&gt;rename</span> <span class="string">table student to students;</span></span><br><span class="line"><span class="meta">查看表的创建细节-----&gt;show</span> <span class="string">create table students;</span></span><br><span class="line"><span class="meta">修改表的字符集为</span> <span class="string">gbk-----&gt;alter table students character set gbk;</span></span><br><span class="line"><span class="meta">列名name修改为studentname-----&gt;alter</span> <span class="string">table students change name studentname varchar(100);</span></span><br></pre></td></tr></table></figure><h4 id="6-mysql语法规范"><a href="#6-mysql语法规范" class="headerlink" title="6.mysql语法规范"></a>6.mysql语法规范</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.不区分大小写，建议关键字大写，表名列名小写。</span></span><br><span class="line"><span class="attr">2.每条命令最好用分号结尾。</span></span><br><span class="line"><span class="attr">3.每条语句可以缩进，换行。</span></span><br><span class="line"><span class="attr">4.注释</span></span><br><span class="line"><span class="attr">单行注释：#注释文字</span></span><br><span class="line">          <span class="meta">--</span> <span class="string">注释文字</span></span><br><span class="line"><span class="meta">多行注释：/*</span> <span class="string">*/</span></span><br></pre></td></tr></table></figure><h3 id="二，DQL查询语言"><a href="#二，DQL查询语言" class="headerlink" title="二，DQL查询语言"></a>二，DQL查询语言</h3><h4 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">**语法：</span> <span class="string">select 查询列表 from 表名**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询列表：表中的字段，常量，表达式，函数**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">**查询的结果是张虚拟的表格**</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.查询表中的单个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.查询表中的多个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name,salary,email from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.查询表中的所有字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.查询常量值</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">&#x27;john&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.查询表达式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">100*98;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">6.查询函数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">version();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">7.起别名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name as name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">last_name name from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">8.去重</span></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工表中涉及到的所有的部门编号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">select</span> <span class="string">distinct department_id from employee;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">9.+的作用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#运算符：两个操作数都为数值型，则做加法运算；</span></span><br><span class="line"><span class="comment">#其中一方为字符型，试图将字符型数值转换成数值型，</span></span><br><span class="line"><span class="comment">#如果转换成功，继续做加法运算；否则，将字符型数值</span></span><br><span class="line"><span class="comment">#转换为0；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">10.使用concat实现连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名和性连接成一个字段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CONCAT(username,PASSWORD) FROM USER;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#任何数与null做运算结果都为null</span></span><br></pre></td></tr></table></figure><h4 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h4><p><strong>语法：</strong></p><p><strong>select 查询列表 from 表名 where 筛选条件</strong></p><p><strong>分类：</strong></p><h5 id="①按照条件表达式筛选"><a href="#①按照条件表达式筛选" class="headerlink" title="①按照条件表达式筛选"></a>①按照条件表达式筛选</h5><p>条件运算符：&gt;,&lt;,=,!=,&gt;=,&lt;=</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">查询员工工资&gt;1w2的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from employee where salary &gt;12000;</span></span><br><span class="line"><span class="meta">查询部门编号！</span>=<span class="string">90号的员工名和部门编号</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name, dep_id from employee where  dep_id 1=90；</span></span><br></pre></td></tr></table></figure><h5 id="②按照逻辑表达式筛选"><a href="#②按照逻辑表达式筛选" class="headerlink" title="②按照逻辑表达式筛选"></a>②按照逻辑表达式筛选</h5><p>逻辑运算符：&amp;&amp;,||,!,AND,OR,NOT</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询工资在一万到两万之见的员工名，工资以及奖金。</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name,salary ,jiangjin where salary between 10000 and 20000;</span></span><br><span class="line"><span class="attr">查询部门编号不在90-110之间，或者工资高于15000的员工信息。</span></span><br><span class="line"><span class="attr">select</span>  <span class="string">* from employee where department&lt;90||department&gt;110 ||salary &gt;15000;</span></span><br></pre></td></tr></table></figure><h5 id="③模糊查询"><a href="#③模糊查询" class="headerlink" title="③模糊查询"></a>③模糊查询</h5><p>like：一般和通配符搭配使用<br>通配符：<br>%任意多个字符，包含0个字符<br>_任意单个字符<br>BETWEEN AND:包含临界值<br>IN:判断某个字段的值是否属于in列表中的某一项<br>IS NULL,IS NOT NULL:=或者！=不能用来判断null<br>安全等于&lt;=&gt;可以判断null</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工名中包含a的员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where name like %a%;</span></span><br><span class="line"><span class="attr">查询员工名中第三个字符为e第五个字符为a的员工名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp where name like %__e_a%;</span></span><br><span class="line"><span class="attr">员工名中第二个字符为_的员工名</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name from emp where name like %_\_%;</span></span><br><span class="line"><span class="attr">查询员工编号在100到120之间的所有员工信息</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where id between 100 and 120;</span></span><br><span class="line"><span class="attr">查询员工的工种编号是IT_PRIG,AD_PRES,AD_VP中的一个员</span></span><br><span class="line"><span class="attr">工名和工种编号；</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name , id from emp where id in(IT_PRIG,AD_PRES,AD_VP);</span></span><br><span class="line"><span class="attr">查询没有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary , jjl from emp where salary is Null;</span></span><br><span class="line"><span class="attr">查询有奖金的员工名和奖金率</span></span><br><span class="line"><span class="attr">select</span> <span class="string">salary ,jjl from emp where salary is not null;</span></span><br></pre></td></tr></table></figure><h5 id="④IF-null的使用："><a href="#④IF-null的使用：" class="headerlink" title="④IF null的使用："></a>④IF null的使用：</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工号为176的员工的姓名和部门号和年薪</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name ,department_id , salary*(1+IFNULL(commission_pct,0))*12 &#x27;年薪&#x27;</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees WHERE employee_id =176;</span></span><br></pre></td></tr></table></figure><h4 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h4><p><strong>语法：</strong></p><p><strong>select   查询列表</strong></p><p><strong>from 表</strong></p><p><strong>where 筛选条件</strong></p><p><strong>order by 排序列表 asc 或desc （升序或者降序，默认为升序）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询员工信息，要求工资从高到低排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by salary desc;</span></span><br><span class="line"><span class="attr">查询部门编号大于等于90的员工信息，按照入职时间先后排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp where dep_id &gt;=90 order by createtime asc;</span></span><br><span class="line"><span class="attr">按照员工年薪的高低显示员工的信息和年薪</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* ,年薪 from emp  order by salary*(1+if null(jjl,0))*12 as 年薪 desc;</span></span><br><span class="line"><span class="attr">按姓名长度显示员工的姓名和工资</span></span><br><span class="line"><span class="attr">select</span> <span class="string">name ,salary from emp order by length(name) asc;</span></span><br><span class="line"><span class="attr">查询员工信息，先按照工资排序，再按照员工编号排序</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp  order by salary asc,id asc;</span></span><br></pre></td></tr></table></figure><h4 id="4-常见函数"><a href="#4-常见函数" class="headerlink" title="4.常见函数"></a>4.常见函数</h4><p><strong>功能：类似Java中的方法</strong><br><strong>分类：单行函数</strong><br><strong>分组函数</strong></p><h5 id="1-单行函数"><a href="#1-单行函数" class="headerlink" title="1.单行函数"></a>1.单行函数</h5><h6 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1.字符函数"></a>1.字符函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.length</span> <span class="string">获取参数值的字节个数</span></span><br><span class="line"><span class="attr">select</span> <span class="string">* from emp order by length(name);</span></span><br><span class="line"><span class="meta">2.concat</span> <span class="string">拼接字符串</span></span><br><span class="line"><span class="attr">select</span> <span class="string">concat(last_name,first_name) as 姓名 from emp;</span></span><br><span class="line"><span class="meta">3.upper，lower</span> <span class="string">大小写转换函数</span></span><br><span class="line"><span class="attr">案例：将姓变大写，名字变小写，然后拼接</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">CONCAT(UPPER(last_name),LOWER(first_name))</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.substr,SUBSTRING</span> <span class="string">截取字符串</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUBSTR(&#x27;李莫愁&#x27;,2,3);</span></span><br><span class="line"><span class="attr">案例：姓名中首字符大写，其他的小写然后用_拼接显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">CONCAT(</span></span><br><span class="line">    <span class="meta">UPPER(SUBSTR(last_name,</span> <span class="string">1, 1)),</span></span><br><span class="line">    <span class="attr">&#x27;_&#x27;,</span></span><br><span class="line">    <span class="meta">LOWER(SUBSTR(last_name,</span> <span class="string">2))</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">output </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">5.instr</span>:<span class="string">返回字串第一次出现的索引，如果找不到返回0</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">INSTR(&#x27;风急天高猿啸哀&#x27;,&#x27;天&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.trim</span> :<span class="string">去掉前后空格或前后指定字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LENGTH(TRIM(&#x27;   张三丰   &#x27;)) AS out_put;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRIM(&#x27;a&#x27; FROM &#x27;aaaa1aa2aaa3aaa&#x27;) AS out_put;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">7.lpad</span> :<span class="string">用指定字符填满指定长度（左填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">LPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">8.rpad</span>:<span class="string">用指定字符填满指定长度（右填充）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">RPAD(&#x27;苍老师&#x27;,10,&#x27;*&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">9.replace</span> <span class="string">替换</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">REPLACE(&#x27;千锋培训机构&#x27;,&#x27;千锋&#x27;,&#x27;尚硅谷&#x27;);</span></span><br></pre></td></tr></table></figure><h6 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2.数学函数"></a>2.数学函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.round</span>:<span class="string">四舍五入</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.666);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">ROUND(1.567,2);</span></span><br><span class="line"><span class="meta">2.ceil</span> <span class="string">向上取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CEIL(1.52);</span></span><br><span class="line"><span class="meta">3.floor</span> <span class="string">向下取整</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">FLOOR(1.52);</span></span><br><span class="line"><span class="meta">4.truncate</span>:<span class="string">截断（小数点后保留几位）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">TRUNCATE(1.65,2);</span></span><br><span class="line"><span class="meta">5.mod</span>:<span class="string">取余</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MOD(10,3);</span></span><br></pre></td></tr></table></figure><h6 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.now</span>:<span class="string">返回当前系统日期时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">NOW();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.curdate</span>:<span class="string">返回当前系统日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURDATE();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.curtime</span>:<span class="string">返回当前时间</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">CURTIME();</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.获取指定部分的年月日时分秒</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">YEAR(hiredate) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.str_to_date将字符通过指定的格式转化成日期</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">STR_TO_DATE(&#x27;1998-3-2&#x27;,&#x27;%Y-%c-%d&#x27;) AS out_put;</span></span><br><span class="line"><span class="attr">案例：查询入职时间为1992-4-3的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">hiredate=STR_TO_DATE(&#x27;2016-3-3&#x27;,&#x27;%Y-%c-%d&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">6.date_format</span> <span class="string">将日期转换成字符</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATE_FORMAT(NOW(),&#x27;%y年%m月%d日&#x27;) AS 日期;</span></span><br><span class="line"><span class="meta">案例：查询有奖金的员工名和入职日期（xx月/xx日</span> <span class="string">xx年）</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="meta">DATE_FORMAT(hiredate,</span> <span class="string">&#x27;%c月/%d日 %y&#x27;) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL ;</span></span><br></pre></td></tr></table></figure><h6 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SELECT</span> <span class="string">VERSION();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DATABASE();</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">USER();</span></span><br></pre></td></tr></table></figure><h6 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.if</span>:<span class="string">IF else效果</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">IF(10&gt;5,&#x27;true&#x27;,&#x27;false&#x27;);</span></span><br><span class="line"><span class="attr">案例：查询如果有奖金就备注有，没有就备注没有。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">commission_pct,</span></span><br><span class="line">  <span class="attr">IF(</span></span><br><span class="line">    <span class="attr">commission_pct</span> <span class="string">IS NULL,</span></span><br><span class="line">    <span class="attr">&#x27;没奖金&#x27;,</span></span><br><span class="line">    <span class="attr">&#x27;有奖金&#x27;</span></span><br><span class="line">  <span class="meta">)</span> <span class="string">AS 备注 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.case函数</span></span><br><span class="line"><span class="attr">1)switch-CASE</span></span><br><span class="line"><span class="meta">语法</span>:<span class="string"></span></span><br><span class="line"><span class="attr">CASE</span> <span class="string">要判断的字段或者表达式</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量1 THEN 要显示的值1或者语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">常量2 THEN 要显示的值2或者语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或者语句n；</span></span><br><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br><span class="line"><span class="meta">2)CASE</span> <span class="string">使用2：</span></span><br><span class="line"><span class="attr">语法：</span></span><br><span class="line"><span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件1 THEN 要显示的值1或语句1</span></span><br><span class="line"><span class="attr">WHEN</span> <span class="string">条件2 THEN 要显示的值2或语句2</span></span><br><span class="line"><span class="attr">...</span></span><br><span class="line"><span class="attr">ELSE</span> <span class="string">要显示的值n或语句n</span></span><br><span class="line"><span class="attr">END</span></span><br><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees ;</span></span><br></pre></td></tr></table></figure><h5 id="2-分组函数"><a href="#2-分组函数" class="headerlink" title="2.分组函数"></a>2.分组函数</h5><p><strong>功能：用作统计使用</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.sum</span> :<span class="string">求和</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2.avg：平均值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3.max：最大值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MAX(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.min：最小值</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.count：计算个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(salary) FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">总结</span></span><br><span class="line"><span class="attr">①.sum,avg一般用于处理数值类型</span></span><br><span class="line"><span class="attr">②.max，min，count用来处理任何类型</span></span><br><span class="line"><span class="attr">③.以上分组函数都忽略null值</span></span><br><span class="line"><span class="attr">④.可以和distinct搭配</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">SUM(DISTINCT salary) 纯净,SUM(salary) FROM employees;</span></span><br><span class="line"><span class="attr">6.count的详细介绍</span></span><br><span class="line"><span class="meta">①select</span> <span class="string">COUNT(*) FROM employees;</span></span><br><span class="line"><span class="meta">②select</span> <span class="string">COUNT(1) FROM employees;</span></span><br><span class="line"><span class="meta">③和分组函数一同查询的字段要求是group</span> <span class="string">by后的字段。</span></span><br></pre></td></tr></table></figure><h4 id="5-分组查询"><a href="#5-分组查询" class="headerlink" title="5.分组查询"></a>5.分组查询</h4><p><strong>GROUP BY 和分组函数对应</strong><br><strong>分组查询中分组条件分为两类</strong></p><table><thead><tr><th></th><th><strong>数据源</strong></th><th><strong>位置</strong></th><th><strong>关键字</strong></th></tr></thead><tbody><tr><td><strong>分组前筛选</strong></td><td>原始表</td><td>GROUP BY 子句的前面</td><td>WHERE</td></tr><tr><td><strong>分组后筛选</strong></td><td>分组后的结果集</td><td>GROUP BY 子句的后面</td><td>HAVING</td></tr></tbody></table><p><strong>分组函数做条件肯定是放在having子句中。</strong><br><strong>group BY 子句支持单个字段分组，多个字段分组</strong><br><strong>（多个字段之间用逗号隔开没有顺序要求），表达式或函数。</strong><br><strong>也可以添加排序，放在整个分组查询的最后。</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询每个工种的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY MAX(salary) ASC ;</span></span><br><span class="line"><span class="attr">案例：查询邮箱中包含a字符的，每个部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AVG(salary),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">email LIKE &#x27;%a%&#x27; </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id ;</span></span><br><span class="line"><span class="comment">#select Avg(salary),dep_id from employee where email like %a% group by dep_id ;</span></span><br><span class="line"><span class="attr">案例：查询有奖金的每个领导手下员工的最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">manager_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id ;</span></span><br><span class="line"><span class="comment">#select max(salary) ,manage_id from employees where commission_pct is not null group by manager_id;</span></span><br><span class="line"><span class="attr">案例：哪个部门的员工个数大于二？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 2 ;</span></span><br><span class="line"><span class="comment">#select dep_id from emp group by dep_id having count(*)&gt;2;</span></span><br><span class="line"><span class="attr">案例：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">MAX(salary),</span></span><br><span class="line">  <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MAX(salary) &gt; 12000 ;</span></span><br><span class="line"><span class="comment">#select job_id ,max(salary) from emp where commission_pct IS NOT NULL group by job_id having max(salary)&gt;12000;</span></span><br><span class="line"><span class="attr">案例：查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id ,MIN(salary)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">manager_id&gt;102</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY manager_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#select manager_id from emp where manager_id&gt;102 group by manager_id having min(salary)&gt;5000;</span></span><br><span class="line"><span class="comment">#按照员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些？</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">COUNT(*) AS c</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY LENGTH(last_name) </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">c&gt;5;</span></span><br><span class="line"><span class="comment"># select count(*) from emp group by length(name) having count(*)&gt;5;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id;</span></span><br><span class="line"><span class="comment">#查询每个部门每个工种的员工的平均工资并且按照平均工资的高低显示</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">AVG(salary),job_id</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id,job_id</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY AVG(salary) ASC;</span></span><br><span class="line"><span class="comment">#select avg(salary) from emp group by dep_id,job_id order by avg(salary) asc;</span></span><br></pre></td></tr></table></figure><h4 id="6-连接查询"><a href="#6-连接查询" class="headerlink" title="6.连接查询"></a>6.连接查询</h4><p><strong>又称为多表查询，当查询的字段来自多个表时，就会用到连接查询。</strong><br>**笛卡尔乘积现象：表1有m行，表2有n行，结果：m_n行_<br><strong>发生原因：没有有效的连接条件</strong></p><p><strong>分类</strong></p><p>①按年代分类<br>sql92:仅仅支持内连接<br>sql99：不支持全外连接</p><p>②按功能分类</p><table><thead><tr><th>内连接</th><th>外连接</th><th>交叉连接</th></tr></thead><tbody><tr><td>等值连接</td><td>左外连接</td><td></td></tr><tr><td>非等值连接</td><td>右外连接</td><td></td></tr><tr><td>自连接</td><td>全外连接</td><td></td></tr></tbody></table><h5 id="1-等值连接"><a href="#1-等值连接" class="headerlink" title="1.等值连接"></a>1.等值连接</h5><p>①多表等值连接的结果为多表的交集部分<br>②n表连接，至少需要n-1个连接条件<br>③多表的顺序没有要求<br>④一般需要为表起别名<br>⑤可以搭配前面介绍的所有子句使用，比如排序，分组，筛选</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例一：查询女优名对应的男优名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">NAME,</span></span><br><span class="line">  <span class="attr">boyName</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">beauty,</span></span><br><span class="line">  <span class="attr">boys</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">beauty.boyfriend_id = boys.`id` ;</span></span><br><span class="line"><span class="comment">#select name, boyname from girl ,boy where girl.boyfriend_id=boy.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名和对应的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employees.`department_id` = departments.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e,dep d where e.dep.id= d.id;</span></span><br><span class="line"><span class="comment">#案例：查询员工名，工种号，工种名。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">emp.`job_id`,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">job </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">emp.`job_id` = job.`job_id` ;</span></span><br><span class="line"><span class="comment">#select name , e.job_id,job_title from emp e,job j where e.job_id=j.id;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的员工名和部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">emp,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">dep </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL &amp;&amp; emp.`department_id` = dep.`department_id` ;</span></span><br><span class="line"><span class="comment">#select name ,dep_name from emp e ,dep d where e.dep_id =d.id &amp;&amp;e.salary_pct is not null;</span></span><br><span class="line"><span class="comment">#案例：查询城市名第二个字符为o的部门</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">l.`city` LIKE &#x27;_o%&#x27; ;</span></span><br><span class="line"><span class="comment">#select dep_name from location l , dep d where l.city like %_o% &amp;&amp; l.id =d.location_id;</span></span><br><span class="line"><span class="comment">#案例：查询每个城市的部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">COUNT(*),</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">l.`location_id` = d.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY l.`city` ;</span></span><br><span class="line"><span class="comment">#select count(*),city from loca l,dep d where l.loc_id=d.loc_id group by count(*) asc;</span></span><br><span class="line"><span class="comment">#案例：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.`department_name`,</span></span><br><span class="line">  <span class="attr">d.manager_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">e.`commission_pct` IS NOT NULL </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY d.`department_id`,</span></span><br><span class="line">  <span class="meta">d.`department_name`</span> <span class="string">;</span></span><br><span class="line"><span class="comment">#select dep_name ,d.manager_id ,min(salary) from emp e ,dep d where e.`department_id` = d.`department_id` AND e.`commission_pct` IS NOT NULL GROUP BY d.`department_id`,d.`department_name` ;</span></span><br><span class="line"><span class="comment">#案例：查询每个工种的工种名和员工的个数，并且按照员工个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">j.job_title,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">jobs</span> <span class="string">j,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">j.`job_id` = e.`job_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.`job_id`,</span></span><br><span class="line">  <span class="meta">j.`job_title`</span> <span class="string"></span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#案例：查询员工名，部门名和所在城市</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">city</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d,</span></span><br><span class="line">  <span class="attr">locations</span> <span class="string">l </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">d.`location_id` = l.`location_id` ;</span></span><br></pre></td></tr></table></figure><h5 id="2-非等值连接"><a href="#2-非等值连接" class="headerlink" title="2.非等值连接"></a>2.非等值连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工的工资和工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">DISTINCT </span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.salary &gt;= j.lowest_sal &amp;&amp; e.salary &lt;= j.highest_sal </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary ASC ;</span></span><br></pre></td></tr></table></figure><h5 id="3-自连接"><a href="#3-自连接" class="headerlink" title="3.自连接"></a>3.自连接</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#案例：查询员工名和上级的名称</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">e.last_name,</span></span><br><span class="line">  <span class="meta">m.last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e,</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">m </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e.manager_id = m.employee_id ;</span></span><br></pre></td></tr></table></figure><h5 id="4-内连接"><a href="#4-内连接" class="headerlink" title="4.内连接"></a>4.内连接</h5><p><strong>INNER 可以省略</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询员工名，部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.department_id = d.department_id ;</span></span><br><span class="line"><span class="comment">#查询名字中包含e的员工名和工种名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.job_id = j.job_id </span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">last_name LIKE &#x27;%e%&#x27; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询部门个数&gt;3的城市名和部门个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">city,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN locations l </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">d.`location_id` = l.`location_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY city</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按照个数降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY e.department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">COUNT(*) &gt; 3 </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询员工名，部门名，工种名，并按照部门名降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">department_name,</span></span><br><span class="line">  <span class="attr">job_title</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN departments d </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`department_id` = d.`department_id` </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN jobs j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`job_id` = j.`job_id` </span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY department_name DESC ;</span></span><br><span class="line"><span class="comment">#查询员工工资级别</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level,</span></span><br><span class="line">  <span class="attr">salary</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">job_grades</span> <span class="string">j </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN employees e </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` ;</span></span><br><span class="line"><span class="comment">#查询每个工资级别的个数，并且降序排序</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">grade_level,COUNT(*)</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN  job_grades j</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e.`salary` BETWEEN j.`lowest_sal` </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">j.`highest_sal` </span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY grade_level</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY COUNT(*) DESC;</span></span><br><span class="line"><span class="comment">#查询员工的名字和上级的名字</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">e1.last_name, e2.last_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">employees e1</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN employees e2</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">e1.`employee_id`=e2.`manager_id`;</span></span><br></pre></td></tr></table></figure><h5 id="5-左外连接"><a href="#5-左外连接" class="headerlink" title="5.左外连接"></a>5.左外连接</h5><p><strong>语法：</strong><br>SELECT 查询列表<br>FROM 表1 【连接类型】<br>JOIN 表2<br>ON 连接条件<br>WHERE 筛选条件<br>GROUP BY 分组<br>HAVING 筛选条件<br>ORDER BY 排序条件<br><strong>连接类型：</strong><br>内连接：inner<br>左外连接：left<br>右外连接：right<br>全外连接：full<br>交叉连接：cross<br><strong>外连接</strong><br>用于查询一个表中有，另一个表中没有的数据<br>左外连接，left左边是主表<br>右外连接，right右边是主表<br><em>Mysql不支持全外连接</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有男朋友的女生</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line"><span class="attr">g.`name`,b.`boyName`</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.`id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName` IS NULL;</span></span><br></pre></td></tr></table></figure><h5 id="6-交叉连接"><a href="#6-交叉连接" class="headerlink" title="6.交叉连接"></a>6.交叉连接</h5><p><strong>笛卡尔乘积</strong></p><h4 id="7-子查询"><a href="#7-子查询" class="headerlink" title="7.子查询"></a>7.子查询</h4><p><strong>出现在其它语句中的select语句，称为子查询或内查询</strong><br><strong>外部的查询语句，称为主查询或外查询</strong><br><strong>分类：</strong></p><p>①按照子查询出现的位置：</p><table><thead><tr><th>select后面</th><th>from后面</th><th>where或having后面</th><th>exists后面</th></tr></thead><tbody><tr><td>仅仅支持标量子查询</td><td>支持表子查询</td><td>标量子查询，列子查询</td><td>表子查询</td></tr></tbody></table><p>②按照结果集的行列数不同：</p><table><thead><tr><th>标量子查询</th><th>列子查询</th><th>行子查询</th><th>表子查询</th></tr></thead><tbody><tr><td>结果只有一行一列</td><td>结果一列多行</td><td>一行多列</td><td>多行多列</td></tr></tbody></table><h5 id="1）where或having后面"><a href="#1）where或having后面" class="headerlink" title="1）where或having后面"></a>1）where或having后面</h5><p><strong>特点：</strong><br>子查询一般放在小括号内<br>子查询一般放在条件的右边<br>标量子查询，一般搭配着单行操作符<br>列子查询：一般搭配多行操作符使用</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.标量子查询</span></span><br><span class="line"><span class="comment">#谁的工资比Abel高</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">last_name = &#x27;Abel&#x27;) ;</span></span><br><span class="line"><span class="comment">#返回job_id于141号员工相同，salary比143号员工多的员工 姓名，job_id和工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">job_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">job_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 141) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">salary</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 143)</span></span><br><span class="line"><span class="comment">#返回公司工资工资最少的员工的姓名，job_id,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees);</span></span><br><span class="line"><span class="comment">#查询最低工资大于50号部门最低工资的部门id和其最低工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_id,</span></span><br><span class="line">  <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY department_id </span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">MIN(salary) &gt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">department_id = 50) ;</span></span><br><span class="line"><span class="attr">2.列子查询</span></span><br><span class="line"><span class="attr">多行操作符：</span></span><br><span class="line"><span class="attr">IN</span> <span class="string">/ NOT in：等于列表中的任意一个</span></span><br><span class="line"><span class="attr">ANY</span> <span class="string">/ SOME ：和子查询返回的某一个值比较</span></span><br><span class="line"><span class="attr">ALL</span> <span class="string">：和子查询返回的所有值比较</span></span><br><span class="line"><span class="comment">#返回location_id是1400或者1700的部门中的所有员工姓名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">last_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id IN</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string">DISTINCT</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">departments</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">location_id IN (1400, 1700)) ;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门任意工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="comment">#返回其他工种中比job_id为IT_PROG部门所有工资低的员工</span></span><br><span class="line"><span class="comment">#工号，姓名，job_id以及salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">employee_id,</span></span><br><span class="line">  <span class="attr">last_name,</span></span><br><span class="line">  <span class="attr">job_id,</span></span><br><span class="line">  <span class="attr">salary</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">salary &lt; </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">job_id = &#x27;IT_PROG&#x27;) </span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">job_id !=&#x27;IT_PROG&#x27;;</span></span><br><span class="line"><span class="attr">*********************************</span></span><br><span class="line"><span class="attr">3.行子查询</span></span><br><span class="line"><span class="comment">#查询员工编号最小并且工资最高的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="meta">*</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MIN(employee_id)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="meta">employees)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">AND</span> <span class="string">salary = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">MAX(salary)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees)</span></span><br></pre></td></tr></table></figure><h5 id="2）SELECT-后面"><a href="#2）SELECT-后面" class="headerlink" title="2）SELECT 后面"></a>2）SELECT 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询每个部门的员工个数</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">d.*,</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">COUNT(*)</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string">e </span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">e.department_id = d.department_id) </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string">d ;</span></span><br><span class="line"><span class="comment">#查询员工号等于102的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">department_name</span> <span class="string"></span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">departments</span> <span class="string"></span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">department_id = </span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">WHERE</span> <span class="string">employee_id = 102) ;</span></span><br></pre></td></tr></table></figure><h5 id="3）FROM-后面"><a href="#3）FROM-后面" class="headerlink" title="3）FROM 后面"></a>3）FROM 后面</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#查询每个部门平均工资的工资等级</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">grade_level</span> <span class="string">,aa.department_id</span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="meta">(SELECT</span> <span class="string"></span></span><br><span class="line">    <span class="meta">AVG(salary)</span> <span class="string">ag,</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">  <span class="attr">FROM</span></span><br><span class="line">    <span class="attr">employees</span> <span class="string"></span></span><br><span class="line">  <span class="attr">GROUP</span> <span class="string">BY department_id) aa </span></span><br><span class="line">  <span class="attr">INNER</span> <span class="string">JOIN job_grades j </span></span><br><span class="line">    <span class="attr">ON</span> <span class="string">aa.ag BETWEEN lowest_sal </span></span><br><span class="line">    <span class="attr">AND</span> <span class="string">highest_sal ;</span></span><br></pre></td></tr></table></figure><h5 id="4）exists后面（相关子查询）"><a href="#4）exists后面（相关子查询）" class="headerlink" title="4）exists后面（相关子查询）"></a>4）exists后面（相关子查询）</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询有员工的部门名</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_name FROM departments d</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">EXISTS(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees  e WHERE d.department_id=e.department_id</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="comment">#查询没有女朋友的男生信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">bo.* FROM boys bo WHERE</span></span><br><span class="line"><span class="meta">bo.`id`</span> <span class="string">NOT IN(SELECT boyfriend_id FROM beauty);</span></span><br></pre></td></tr></table></figure><h5 id="5）子查询经典案例祥讲"><a href="#5）子查询经典案例祥讲" class="headerlink" title="5）子查询经典案例祥讲"></a>5）子查询经典案例祥讲</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1.查询工资最低的员工信息：last_name,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,salary FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span>  <span class="string">salary=(SELECT MIN(salary) FROM employees);</span></span><br><span class="line"><span class="attr">2.查询平均工资最低的部门信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM departments WHERE department_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">3.查询平均工资最低的部门信息和该部门的平均工资</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">d.*,a1.ag FROM departments  d JOIN </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">AVG(salary) ag,department_id  FROM employees GROUP BY department_id  ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1) a1</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">d.department_id=a1.department_id</span></span><br><span class="line"><span class="attr">4.查询平均工资最高的job信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">j.* FROM jobs j WHERE j.job_id=</span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">job_id FROM employees</span></span><br><span class="line"><span class="attr">GROUP</span> <span class="string">BY job_id ORDER BY AVG(salary) DESC LIMIT 1)</span></span><br><span class="line"><span class="attr">5.查询平均工资高于公司平均工资的部门有哪些</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM </span></span><br><span class="line"><span class="meta">(SELECT</span> <span class="string">department_id ,AVG(salary) AS avg1 FROM employees GROUP BY  department_id) e1</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">e1.avg1&gt;(SELECT AVG(salary)  AS avg2 FROM employees) </span></span><br><span class="line"><span class="attr">6.查询出公司中所有manager的详细信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">employee_id IN(SELECT DISTINCT manager_id FROM employees);</span></span><br><span class="line"><span class="attr">7.各个部门中，最高工资中最低的那个部门的最低工资是多少</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">MIN(salary) FROM employees GROUP BY department_id</span></span><br><span class="line"><span class="attr">HAVING</span> <span class="string">department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY MAX(salary)</span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">1)</span></span><br><span class="line"><span class="attr">8.查询平均工资最高的部门的manager的详细信息：last_name,department_id,email,salary</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">last_name,department_id,email,salary FROM employees WHERE employee_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">manager_id FROM departments WHERE department_id=(</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">department_id FROM employees GROUP BY department_id ORDER BY AVG(salary)</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">LIMIT 1))</span></span><br></pre></td></tr></table></figure><h4 id="8-分页查询"><a href="#8-分页查询" class="headerlink" title="8.分页查询"></a>8.分页查询</h4><p>**语法：limit(currentPage-1)<em>size,size</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询前五条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 0,5;</span></span><br><span class="line"><span class="comment">#查询第11-25条员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees LIMIT 10,15;</span></span><br><span class="line"><span class="comment">#查询有奖金的员工，并且工资最高的前十名显示出来</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">commission_pct IS NOT NULL</span></span><br><span class="line"><span class="attr">ORDER</span> <span class="string">BY salary DESC </span></span><br><span class="line"><span class="attr">LIMIT</span> <span class="string">0 ,10;</span></span><br></pre></td></tr></table></figure><h4 id="9-联合查询"><a href="#9-联合查询" class="headerlink" title="9.联合查询"></a>9.联合查询</h4><p><strong>要查询的结果来自于多个表，且多个表没有直接的连接关系，单查询的信息一致时</strong><br><strong>特点：</strong><br>1.要求多条查询语句的查询列数是一致的<br>2.要求多条查询语句的查询的每一列的类型和顺序最好一致<br>3.union关键字默认去重，如果使用union all 可以不去除重复项</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工部门编号大于90或邮箱包含a的员工信息</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE department_id&gt;90</span></span><br><span class="line"><span class="attr">UNION</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM employees WHERE email LIKE &#x27;%a%&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="三，DML数据操作语言"><a href="#三，DML数据操作语言" class="headerlink" title="三，DML数据操作语言"></a>三，DML数据操作语言</h3><p><strong>插入insert</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一：插入语句</span></span><br><span class="line"><span class="comment">#插入beauty一行数据</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;波多野吉依&#x27;,&#x27;女&#x27;,&#x27;1998-11-11&#x27;,&#x27;13342969497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,10)</span></span><br><span class="line"><span class="comment">#可以为null的列如何不插入值</span></span><br><span class="line"><span class="attr">直接写null，或列名少写一列</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty(NAME,sex,borndate,phone,photo,boyfriend_id)</span></span><br><span class="line"><span class="attr">VALUES(&#x27;小泽玛利亚&#x27;,&#x27;女&#x27;,&#x27;1999-11-11&#x27;,&#x27;13342456497&#x27;,</span></span><br><span class="line"><span class="attr">NULL,11)</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty VALUES(15,&#x27;马蓉&#x27;,&#x27;女&#x27;,&#x27;1989-11-11&#x27;,&#x27;13342456123&#x27;,</span></span><br><span class="line"><span class="attr">NULL,12);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty SET id=16,NAME=&#x27;刘亦菲&#x27;, sex=&#x27;女&#x27;,borndate=&#x27;1989-10-01&#x27;,</span></span><br><span class="line"><span class="attr">phone</span>=<span class="string">&#x27;15945231056&#x27;,boyfriend_id=16;</span></span><br><span class="line"><span class="comment">#insert 嵌套子查询，将一个表的数据插入另一张表</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO beauty (NAME,sex,borndate,phone,boyfriend_id)</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">&#x27;妲己&#x27;,&#x27;女&#x27;,&#x27;1111-11-11&#x27;,&#x27;13146587954&#x27;,0;</span></span><br></pre></td></tr></table></figure><p><strong>修改update</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">二，修改</span></span><br><span class="line"> <span class="attr">UPDATE</span> <span class="string">beauty SET phone=&#x27;110&#x27; WHERE id=16;</span></span><br><span class="line"><span class="attr">多表修改：sql99</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">表1 别名</span></span><br><span class="line"><span class="meta">INNER|LEFT|RIGHT</span> <span class="string">JOIN 表2 别名</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">连接条件</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">列=值</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">筛选条件</span></span><br><span class="line"><span class="comment">#修改张无忌的女朋友手机号为114</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.phone=&#x27;114&#x27;</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.boyName=&#x27;张无忌&#x27;;</span></span><br><span class="line"><span class="comment">#修改没有男朋友的女生的男朋友编号都为4号</span></span><br><span class="line"><span class="attr">UPDATE</span> <span class="string">beauty g</span></span><br><span class="line"><span class="attr">LEFT</span> <span class="string">JOIN  boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.`boyfriend_id`=b.id</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">g.`boyfriend_id`=4</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=NULL;</span></span><br></pre></td></tr></table></figure><p><strong>删除delete</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">三，删除</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">和 TRUNCATE 的区别：</span></span><br><span class="line"><span class="attr">1.delete可以加where条件，truncate不行</span></span><br><span class="line"><span class="attr">2.truncate删除效率高</span></span><br><span class="line"><span class="attr">3.加入要删除的表中有自增列，</span></span><br><span class="line"><span class="attr">用delete删除整个表后在插入数据，从断点处开始插入</span></span><br><span class="line"><span class="attr">用truncate删除后在插入数据，从1开始。</span></span><br><span class="line"><span class="attr">4.truncate删除没有返回值，delete有返回值</span></span><br><span class="line"><span class="attr">5.truncate删除不能回滚，delete删除可以回滚</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM beauty WHERE id=17;</span></span><br><span class="line"><span class="meta">语法：truncate</span> <span class="string">TABLE 表名;</span></span><br><span class="line"><span class="comment">#删除张无忌的女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">g.boyfriend_id=b.id</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.id=1;</span></span><br><span class="line"><span class="comment">#删除黄晓明以及他女朋友的信息</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">b,g FROM beauty g</span></span><br><span class="line"><span class="attr">INNER</span> <span class="string">JOIN boys b</span></span><br><span class="line"><span class="attr">ON</span> <span class="string">b.`id`=g.`boyfriend_id`</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">b.`boyName`=&#x27;黄晓明&#x27;;</span></span><br><span class="line"><span class="meta">多表删除</span> :<span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">TRUNCATE</span> <span class="string">TABLE boys</span></span><br></pre></td></tr></table></figure><h3 id="四，DDL数据定义语言"><a href="#四，DDL数据定义语言" class="headerlink" title="四，DDL数据定义语言"></a>四，DDL数据定义语言</h3><h4 id="1-库和表的管理"><a href="#1-库和表的管理" class="headerlink" title="1.库和表的管理"></a>1.库和表的管理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一，库的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">DATABASE IF NOT EXISTS mydb1 ;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.更改字符集</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">DATABASE mydb1 CHARACTER SET utf8;</span></span><br><span class="line"><span class="meta">删除</span> <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">DATABASE IF EXISTS school;</span></span><br><span class="line"><span class="attr">二，表的管理</span></span><br><span class="line"><span class="meta">创建</span> <span class="string">CREATE</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE book(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">b_name</span> <span class="string">VARCHAR(30),</span></span><br><span class="line"><span class="attr">price</span> <span class="string">DOUBLE,</span></span><br><span class="line"><span class="attr">author_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">publishDate</span> <span class="string">DATE</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">book ;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE author(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">au_name</span> <span class="string">VARCHAR(20),</span></span><br><span class="line"><span class="attr">nation</span> <span class="string">VARCHAR(10)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">author;</span></span><br><span class="line"><span class="meta">修改</span> <span class="string">ALTER</span></span><br><span class="line"><span class="attr">1.修改列名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book CHANGE COLUMN publishDate pub_date DATETIME;</span></span><br><span class="line"><span class="attr">2.修改列的类型或约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE book MODIFY COLUMN pub_date DATE;</span></span><br><span class="line"><span class="attr">3.添加新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author ADD COLUMN annual DOUBLE;</span></span><br><span class="line"><span class="attr">4.删除新列</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author DROP COLUMN annual;</span></span><br><span class="line"><span class="attr">5.修改表名</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE author RENAME TO book_author;</span></span><br><span class="line"><span class="meta">删除</span>  <span class="string">DROP</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE IF EXISTS my_employee;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">TABLES;</span></span><br><span class="line"><span class="attr">复制</span></span><br><span class="line"><span class="attr">1.仅仅复制表的结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy LIKE book_author;</span></span><br><span class="line"><span class="attr">2.复制表的结构加数据</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy2</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM book_author;</span></span><br><span class="line"><span class="attr">3.复制部分结构</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE copy3 </span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">id,au_name</span></span><br><span class="line"><span class="attr">FROM</span> <span class="string">book_author</span></span><br><span class="line"><span class="attr">WHERE</span> <span class="string">id=0;</span></span><br></pre></td></tr></table></figure><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p><strong>数值型</strong><br><strong>1.整型</strong></p><table><thead><tr><th>TINYINT</th><th>SMALLINT</th><th>MEDIUMINT</th><th>INT/INTEGER</th><th>BIGINT</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>8</td></tr></tbody></table><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如何设置无符号和有符号(默认有符号)</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_int;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_int(t1 INT,t2 INT UNSIGNED);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_int(t1,t2) VALUES(-1,1);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_int;</span></span><br></pre></td></tr></table></figure><p>1）如果插入的数值超出了整形的范围，会报out of range异常，并且插入<br>临界值。<br>2）如果不设置长度，会有默认的长度。<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配<br>zerofill使用。<br><strong>2.小数</strong><br>①定点数<br>dec（M,D）<br>②浮点数<br>float（4） ，double（8）<br>M，D的意思：M指定一共多少位，D指定小数几位，超出会四舍五入。<br>MD都可以省略，<br>如果是dec，则M默认为10，D默认为0<br>如果是浮点数，则会根据插入数值的精度改变精度<br>定点型精度相对较高。<br><strong>3.字符型</strong><br>①较短的文本<br>CHAR(M)默认为1,VARCHAR(M)<br>M:字符数<br>char：固定长度字符，比较耗费空间，但是效率高。<br>varchar：可变长度字符</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ENUM</span> <span class="string">枚举类</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_char(</span></span><br><span class="line">   <span class="attr">t1</span> <span class="string">ENUM(&#x27;a&#x27;,&#x27;c&#x27;,&#x27;b&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">集合</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_set(</span></span><br><span class="line"><span class="attr">s1</span> <span class="string">SET(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_set(s1) VALUES(&#x27;a,b&#x27;);</span></span><br></pre></td></tr></table></figure><p>BINARY:保存较短的二进制。<br>②较长的文本<br>text（文本）,BLOB(较大的二进制)<br><strong>4.日期型</strong><br>DATE:日期<br>DATETIME:日期加时间，8字节<br>timestamp：跟时区有关系，建议使用，4字节<br>time：时间<br>year：年</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_date(</span></span><br><span class="line"><span class="attr">t1</span> <span class="string">DATETIME,</span></span><br><span class="line"><span class="attr">t2</span> <span class="string">TIMESTAMP</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO tab_date(t1,t2)</span></span><br><span class="line"><span class="attr">VALUES(NOW(),NOW());</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM tab_date;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">time_zone=&#x27;+9:00&#x27;;</span></span><br><span class="line"><span class="comment">#设置时区为东9区</span></span><br></pre></td></tr></table></figure><h4 id="3-常见约束"><a href="#3-常见约束" class="headerlink" title="3.常见约束"></a>3.常见约束</h4><p><strong>含义：一种限制，用于限制表中的数据，保证数据的一致性。</strong></p><ol><li> NOT NULL </li><li> DEFAULT </li><li> PRIMARY KEY  唯一，且不为空 </li><li> UNIQUE  唯一，可以为空 </li><li> CHECK Mysql不支持 </li><li> FOREIGN KEY 外键约束，用于限制两个表的关系，<br>用于保证该字段的值必须来自于主表的关联列的值。<br>约束的分类：<br>列级约束：除外键约束<br>表级约束：除了非空，默认。<br>CREATE TABLE 表名(<br>字段1 字段类型 列级约束,<br>字段2 字段类型 列级约束,<br>表级约束<br>); </li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建表时添加列级约束</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">TABLE tab_test;</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_major(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY ,</span></span><br><span class="line"><span class="attr">major_name</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">DESC</span> <span class="string">tab_test;</span></span><br><span class="line"><span class="attr">SHOW</span> <span class="string">INDEX FROM tab_test;</span></span><br><span class="line"><span class="comment">#查看索引信息</span></span><br><span class="line"><span class="comment">#添加表级约束</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) NOT NULL,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR DEFAULT &#x27;男&#x27;,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT UNIQUE, </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id FOREIGN KEY(major_id) REFERENCES tab_major(id) </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">CONSTRAINT</span> <span class="string">m_id 可以省略</span></span><br></pre></td></tr></table></figure><p>面试题：主键约束和唯一约束的区别：<br>都可以保证唯一性，<br>主键不能为空 ，unique 能为空，但是只能有一个null。<br>主键只能有1个，unique可以有多个。<br>都允许两个列组合成一个约束。<br>面试题：外键：<br>要求在从表设置外键关系<br>从表的外键列类型和主表的关联列类型一致，名称无要求<br>要求主表的关联列必须是主键或者唯一键<br>插入数据应该先插入主表再插入从表<br>删除数据应该先删除从表，在删除主表<br>二，修改表时添加约束</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE tab_test2(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT ,</span></span><br><span class="line"><span class="attr">stu_name</span> <span class="string">VARCHAR(20) ,</span></span><br><span class="line"><span class="attr">gender</span> <span class="string">CHAR ,</span></span><br><span class="line"><span class="attr">seat_id</span> <span class="string">INT , </span></span><br><span class="line"><span class="attr">major_id</span> <span class="string">INT  </span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN stu_name  VARCHAR(20) NOT NULL ;</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;</span></span><br><span class="line"><span class="comment">#添加外键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE tab_test2 ADD FOREIGN KEY(major_id) REFERENCES tab_major(id);</span></span><br></pre></td></tr></table></figure><h4 id="4-标识列"><a href="#4-标识列" class="headerlink" title="4.标识列"></a>4.标识列</h4><p>自增长列 AUTO_INCREMENT<br>特点：<br>1.表示必须和一个key搭配<br>2.一个表最多一个标识列<br>3.标识列类型只能是数值型<br>4.标识列可以通过set auto_increment_increment=3;设置步长</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CREATE</span> <span class="string">tab_auto(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT PRIMARY KEY AUTO_INCREMENT,</span></span><br><span class="line"><span class="attr">NAME</span> <span class="string">VARCHAR(20) NOT NULL</span></span><br><span class="line"><span class="attr">);</span></span><br></pre></td></tr></table></figure><h3 id="五，TCL语言：事务控制语言"><a href="#五，TCL语言：事务控制语言" class="headerlink" title="五，TCL语言：事务控制语言"></a>五，TCL语言：事务控制语言</h3><p>事务：一个或一组sql语句组成的执行单元，</p><p>要么全部执行,要么都不执行。<br>存储引擎:在MySQL中的数据用各种不同的技术存储在文件中。<br>通过show ENGINES;来查看mysql支持的存储引擎。<br>innodb引擎支持事务。<br>事务的ACID属性：<br>1.原子性:事务是一个不可分割的工作单位，要么都发生，要么都不发生。<br>2.一致性：事务必须使数据库从一个一致性状态变为另一个一致性状态。<br>3.隔离性：一个事务的执行不能被另一个事务干扰。<br>4.持久性：事务一旦被提交，对数据库事务的改变就是永久性的。</p><p>DELETE 和 TRUNCATE 在事务中的区别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">演示delete</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">FROM tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="meta">演示</span> <span class="string">TRUNCATE</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">autocommit=0;</span></span><br><span class="line"><span class="attr">START</span> <span class="string">TRANSACTION;</span></span><br><span class="line"><span class="attr">TRUNCATE</span>  <span class="string">TABLE tab_teacher;</span></span><br><span class="line"><span class="attr">ROLLBACK;</span></span><br><span class="line"><span class="attr">DELETE</span> <span class="string">是直接删除表中数据，truncate是江表删除，创建一张与原来一样的空表。</span></span><br></pre></td></tr></table></figure><h3 id="六，视图"><a href="#六，视图" class="headerlink" title="六，视图"></a>六，视图</h3><p><strong>含义：虚拟表，和普通表格一样使用</strong><br><strong>通过表动态生成的数据</strong></p><h4 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1.创建视图"></a>1.创建视图</h4><p><strong>语法：</strong><br><strong>CREATE VIEW 视图名</strong><br><strong>AS</strong><br><strong>查询语句 ;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询姓名中包含a字符的员工名，部门名和工种信息</span><br><span class="line">create view view1 as</span><br><span class="line">    select e.last_name,d.department_name ,j.job_title from employees e</span><br><span class="line">inner join departments d on e.department_id = d.department_id</span><br><span class="line">    inner join jobs j on e.job_id = j.job_id</span><br><span class="line">where e.last_name like &#x27;%a%&#x27;;</span><br><span class="line">select * from view1;</span><br><span class="line"># 案例：查询各个部门的平均工资级别</span><br><span class="line">create view view2 as</span><br><span class="line">select j.grade_level ,aa.department_id</span><br><span class="line">    from job_grades j</span><br><span class="line">inner join (select avg(salary) avg_s,department_id from employees  group by department_id) aa</span><br><span class="line">    on aa.avg_s between j.lowest_sal and j.highest_sal;</span><br><span class="line">select * from view2;</span><br><span class="line"># 案例：查询平均工资最低的部门信息</span><br><span class="line">create view view3 as</span><br><span class="line">select avg(salary) avg_s ,department_id</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">order by avg_s asc</span><br><span class="line">limit 1;</span><br><span class="line">select * from view3;</span><br></pre></td></tr></table></figure><h4 id="2-视图修改"><a href="#2-视图修改" class="headerlink" title="2.视图修改"></a>2.视图修改</h4><p><strong>①create OR REPLACE VIEW 视图名 AS 查询语句;</strong><br><strong>②alter VIEW 视图名 AS 查询语句;</strong></p><h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3.删除视图"></a>3.删除视图</h4><p><strong>DROP VIEW v1,v2;</strong></p><h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4.查看视图"></a><strong>4.查看视图</strong></h4><p><strong>DESC v1;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资，邮箱</span><br><span class="line">CREATE VIEW emp_v1 AS</span><br><span class="line">SELECT last_name ,salary,email FROM employees WHERE</span><br><span class="line">phone_number LIKE &#x27;%011&#x27;;</span><br><span class="line">#创建视图emp_v2,要求查询部门的最高工资高于12000的部门信息</span><br><span class="line">CREATE VIEW v4 AS</span><br><span class="line">SELECT department_id FROM employees GROUP BY department_id</span><br><span class="line">HAVING MAX(salary)&gt; 12000;</span><br><span class="line">CREATE VIEW emp_v2 AS</span><br><span class="line">SELECT * FROM departments WHERE department_id IN(SELECT * FROM v4);</span><br></pre></td></tr></table></figure><h4 id="5-视图的更新"><a href="#5-视图的更新" class="headerlink" title="5.视图的更新"></a>5.视图的更新</h4><p><strong>视图的可更新性和视图中查询的定义有关，以下类型的视图是不能更新的。</strong><br><strong>1.包含以下关键字的sql语句：分组函数，distinct，group by，having，union</strong><br><strong>2.常量视图</strong><br><strong>3.select中包含子查询的</strong><br><strong>4.join</strong><br><strong>5.from 一个不能更新的视图</strong><br><strong>6.where子句的子查询引用了from子句的表</strong></p><h4 id="6-视图和表的对比："><a href="#6-视图和表的对比：" class="headerlink" title="6.视图和表的对比："></a>6.视图和表的对比：</h4><table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td><strong>视图</strong></td><td>CREATE VIEW</td><td>只是保存了sql逻辑</td><td>增删改查，一般不能增删改</td></tr><tr><td><strong>表</strong></td><td>CREATE TABLE</td><td>占用</td><td>增删改查</td></tr></tbody></table><h3 id="七，变量"><a href="#七，变量" class="headerlink" title="七，变量"></a>七，变量</h3><p><strong>系统变量</strong>   ：变量由系统提供，不是用户自定义，属于服务器层面。<br>查看系统所有变量：show GLOBAL VARIABLES;<br>查看满足条件的部分系统变量： SHOW GLOBAL VARIABLES LIKE ‘%char%’;<br>查看指定的某个系统变量的值： SELECT  @@global.autocommit;<br>为某个系统变量赋值：set @@global.系统变量名=值;<br><strong>全局变量:GLOBAL</strong><br>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话有效，但不能<br>跨重启。<br><strong>会话变量:SESSION</strong><br>作用域：针对当前的会话有效。<br>用户自定义变量<br><strong>用户变量</strong><br>声明： SET/SELECT  @用户变量名 :=值;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @用户变量名 :=值;<br>使用：select @用户变量名;<br>应用在任何地方。<br>作用域：针对当前会话和连接有效。<br><strong>局部变量</strong><br>作用域：作用在定义它的begin END 块中。<br>声明： DECLARE 变量名 类型  （default 值）;<br>赋值：通过 SELECT 字段  INTO 变量名;或 SET/SELECT  @变量名 :=值;<br>使用：select @变量名;<br>只能放在begin END 中的第一句话</p><h3 id="八，存储过程和函数"><a href="#八，存储过程和函数" class="headerlink" title="八，存储过程和函数"></a>八，存储过程和函数</h3><h4 id="存储过程："><a href="#存储过程：" class="headerlink" title="存储过程："></a>存储过程：</h4><p><strong>一组预先定义好的sql语句集合，理解成批处理语句。</strong><br>1.提高代码的重用性<br>2.简化操作<br>3.减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率。</p><h5 id="1-创建语法："><a href="#1-创建语法：" class="headerlink" title="1.创建语法："></a>1.创建语法：</h5><p>CREATE PROCEDURE 存储过程名（参数列表）<br>BEGIN<br>一组合法的sql语句;<br>END<br>参数列表：参数模式 参数名 参数类型</p><p>参数模式：<br>in：该参数可以作为输入，也就是该参数需要调用方传入值<br>OUT  ：该参数可以作为输出，也就是该参数可以作为返回值<br>inout：该参数既可以作为输入又可以作为输出</p><p>如果存储过程只有一句话，begin END 可以省略</p><p>存储过程体中的每条sql语句的结尾需要必须加分号，<br>存储过程的结尾可以使用 DELIMITER 重新设置。</p><h5 id="2-调用"><a href="#2-调用" class="headerlink" title="2.调用"></a>2.调用</h5><p>CALL 存储过程名（实参列表）;</p><h5 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#插入到admin表中五条记录</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_a()</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;yin&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;aa&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;bb&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;cc&#x27;,&#x27;123&#x27;);</span></span><br><span class="line"><span class="attr">INSERT</span> <span class="string">INTO admin(username,PASSWORD) VALUES(&#x27;dd&#x27;,&#x27;666&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="comment">#创建存储过程实现 根据女生名查询对应的男生信息</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_b(IN beauty_name VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line">      <span class="attr">SELECT</span> <span class="string">bo.*</span></span><br><span class="line">      <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">      <span class="attr">RIGHT</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">      <span class="attr">WHERE</span> <span class="string">b.name=beauty_name;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_b(&#x27;热巴&#x27;);</span></span><br><span class="line"><span class="comment">#根据女生名返回他的男朋友名</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_d(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SELECT</span> <span class="string">bo.boyName INTO boyName</span></span><br><span class="line">        <span class="attr">FROM</span> <span class="string">boys bo</span></span><br><span class="line">        <span class="attr">INNER</span> <span class="string">JOIN beauty b ON bo.id=b.boyfriend_id</span></span><br><span class="line">        <span class="attr">WHERE</span> <span class="string">b.name=beautyName;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_d(&#x27;小昭&#x27;,@b_name);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@b_name;</span></span><br><span class="line"><span class="comment">#传入两个值a，b，最终翻倍返回a和b</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">PROCEDURE my_e(INOUT a INT ,INOUT b INT )</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">a=a*2;</span></span><br><span class="line">        <span class="attr">SET</span> <span class="string">b=b*2;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@m=10;</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@n=20;</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_e(@m,@n);</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">@m,@n;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除存储过程"><a href="#4-删除存储过程" class="headerlink" title="4.删除存储过程"></a>4.删除存储过程</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE 存储过程名</span></span><br><span class="line"><span class="attr">DROP</span> <span class="string">PROCEDURE my_a;</span></span><br></pre></td></tr></table></figure><h5 id="5-查看存储过程的信息"><a href="#5-查看存储过程的信息" class="headerlink" title="5.查看存储过程的信息"></a>5.查看存储过程的信息</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE PROCEDURE  my_b;</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>存储过程可以有0/n个返回值：适合批量增删改</strong><br><strong>函数有且仅有一个返回值：适合查询</strong></p><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION 函数名(参数列表) RETURNS 返回类型</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="attr">END</span></span><br></pre></td></tr></table></figure><p>注意：<br>参数列表：参数名，参数类型<br>一定会有return语句</p><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p><strong>SELECT 函数名(参数列表)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回公司员工个数</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f1() RETURNS INT</span></span><br><span class="line"><span class="attr">BEGIN</span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c INT DEFAULT 0 ;</span></span><br><span class="line">    <span class="attr">SELECT</span> <span class="string">COUNT(*) INTO c FROM employees;</span></span><br><span class="line">    <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f1();</span></span><br><span class="line"><span class="comment">#根据员工名返回他的工资</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">FUNCTION my_f2(NAME VARCHAR(20)) RETURNS DOUBLE</span></span><br><span class="line"><span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"><span class="attr">DECLARE</span> <span class="string">c DOUBLE;</span></span><br><span class="line">     <span class="attr">SELECT</span> <span class="string">salary INTO c FROM employees WHERE last_name=NAME;</span></span><br><span class="line">     <span class="attr">RETURN</span> <span class="string">c;</span></span><br><span class="line"><span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">SET</span> <span class="string">@a=&#x27;Hunold&#x27;;</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">my_f2(@a);</span></span><br></pre></td></tr></table></figure><h5 id="3-查看"><a href="#3-查看" class="headerlink" title="3.查看"></a>3.查看</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SHOW</span> <span class="string">CREATE FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h5 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DROP</span> <span class="string">FUNCTION my_f2;</span></span><br></pre></td></tr></table></figure><h3 id="九，流程控制"><a href="#九，流程控制" class="headerlink" title="九，流程控制"></a>九，流程控制</h3><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h5 id="1-if-（表达式1，表达式2，表达式3）"><a href="#1-if-（表达式1，表达式2，表达式3）" class="headerlink" title="1.if （表达式1，表达式2，表达式3）"></a>1.if （表达式1，表达式2，表达式3）</h5><p>如果表达式1成立，就返回表达式2的值，否则返回表达式3的值。<br>应用在任何地方</p><h5 id="2-case"><a href="#2-case" class="headerlink" title="2.case"></a>2.case</h5><h6 id="1-switch-CASE"><a href="#1-switch-CASE" class="headerlink" title="1)switch-CASE"></a>1)switch-CASE</h6><p><strong>语法:</strong><br><strong>CASE 要判断的字段或者表达式</strong><br><strong>WHEN 常量1 THEN 要显示的值1或者语句1</strong><br><strong>WHEN 常量2 THEN 要显示的值2或者语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或者语句n；</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资，要求</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=30，显示的工资为1.1倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=40，显示的工资为1.2倍，</span></span><br><span class="line"><span class="meta">部门号</span>=<span class="string">=50，显示的工资为1.3倍，</span></span><br><span class="line"><span class="attr">其他部门，显示原有工资。</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary</span> <span class="string">AS 原始工资,</span></span><br><span class="line">  <span class="attr">department_id</span> <span class="string">,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">department_id</span> <span class="string"></span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">30 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.1 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">40 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.2 </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">50 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">salary * 1.3 </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">salary </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 新工资 </span></span><br><span class="line"><span class="attr">FROM</span></span><br><span class="line">  <span class="attr">employees</span> <span class="string">;</span></span><br></pre></td></tr></table></figure><h6 id="2-CASE-使用2："><a href="#2-CASE-使用2：" class="headerlink" title="2)CASE 使用2："></a>2)CASE 使用2：</h6><p><strong>语法：</strong><br><strong>CASE</strong><br><strong>WHEN 条件1 THEN 要显示的值1或语句1</strong><br><strong>WHEN 条件2 THEN 要显示的值2或语句2</strong><br><strong>…</strong><br><strong>ELSE 要显示的值n或语句n</strong><br><strong>END</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">案例：查询员工的工资情况</span></span><br><span class="line"><span class="attr">如果&gt;2w，显示A</span></span><br><span class="line"><span class="attr">如果&gt;1.5w，显示B</span></span><br><span class="line"><span class="attr">如果&gt;1w，显示C</span></span><br><span class="line"><span class="attr">否则，显示D</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string"></span></span><br><span class="line">  <span class="attr">salary,</span></span><br><span class="line">  <span class="attr">CASE</span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 20000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;A&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 15000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;B&#x27; </span></span><br><span class="line">    <span class="attr">WHEN</span> <span class="string">salary &gt; 10000 </span></span><br><span class="line">    <span class="attr">THEN</span> <span class="string">&#x27;C&#x27; </span></span><br><span class="line">    <span class="attr">ELSE</span> <span class="string">&#x27;D&#x27; </span></span><br><span class="line">  <span class="attr">END</span> <span class="string">AS 工资等级 FROM employees </span></span><br><span class="line"> <span class="attr">可以放在任何地方</span></span><br><span class="line"><span class="comment"> #创建存储过程，根据传入的成绩，显示等级，90A,80B，70C，60D ，F</span></span><br><span class="line"> <span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">PROCEDURE my_1(IN score INT)</span></span><br><span class="line"> <span class="attr">BEGIN</span></span><br><span class="line"> <span class="attr">CASE</span> <span class="string"></span></span><br><span class="line"> <span class="attr">WHEN</span>  <span class="string">score BETWEEN 90 AND 100</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;A&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 80 AND 90</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;B&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 80</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;C&#x27;;</span></span><br><span class="line">  <span class="attr">WHEN</span>  <span class="string">score BETWEEN 70 AND 60</span></span><br><span class="line"> <span class="attr">THEN</span>  <span class="string">SELECT &#x27;D&#x27;;</span></span><br><span class="line"> <span class="attr">ELSE</span> <span class="string">SELECT &#x27;E&#x27;;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">CASE;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"><span class="attr">CALL</span> <span class="string">my_1(95);</span></span><br></pre></td></tr></table></figure><h5 id="3-if"><a href="#3-if" class="headerlink" title="3.if"></a>3.if</h5><p><strong>语法：</strong><br><strong>IF 条件1 THEN 语句1;</strong><br><strong>ELSEIF 条件2 THEN 语句2;</strong><br><strong>…</strong><br><strong>ELSE 语句n;</strong><br><strong>END IF;</strong><br>只能用在begin end中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建存储过程，根据传入的成绩，返回等级，90A,80B，70C，60D ，F</span></span><br><span class="line"><span class="attr">DELIMITER</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">CREATE</span> <span class="string">FUNCTION my_2( score INT) RETURNS CHAR</span></span><br><span class="line"> <span class="attr">BEGIN</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line">   <span class="attr">IF</span> <span class="string">score &gt;=90 THEN RETURN&#x27;A&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=80 THEN RETURN&#x27;B&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=70 THEN RETURN&#x27;C&#x27;;</span></span><br><span class="line">   <span class="attr">ELSEIF</span> <span class="string">score &gt;=60 THEN RETURN&#x27;D&#x27;;</span></span><br><span class="line">   <span class="attr">ELSE</span> <span class="string">RETURN&#x27;E&#x27;;</span></span><br><span class="line">   <span class="attr">END</span> <span class="string">IF;</span></span><br><span class="line"> <span class="attr">END</span> <span class="string">$</span></span><br><span class="line"> <span class="attr">SELECT</span>  <span class="string">my_2(85);</span></span><br></pre></td></tr></table></figure><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p><strong>在存储过程或函数里面使用</strong></p><h5 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h5><p><strong>语法：</strong><br><strong>标签:WHILE 循环条件 DO</strong><br><strong>循环体;</strong><br><strong>END WHILE 标签;</strong><br><strong>循环控制和标签搭配使用</strong></p><h5 id="2-loop"><a href="#2-loop" class="headerlink" title="2.loop"></a>2.loop</h5><p><strong>语法：</strong><br><strong>标签： LOOP</strong><br><strong>循环体;</strong><br><strong>END LOOP 标签;</strong></p><h5 id="3-repeat"><a href="#3-repeat" class="headerlink" title="3.repeat"></a>3.repeat</h5><p><strong>语法：</strong><br><strong>标签： REPEAT</strong><br><strong>循环体;</strong><br><strong>UNTIL 结束循环的条件</strong><br><strong>END REPEAT 标签;</strong></p><p>循环控制<br>ITERATE 类似continue<br>LEAVE   类似break</p><hr><p>left join==left outer join</p><p>a left join b 就是取a和b的交集加a剩下的部分</p><p>inner join</p><p>a inner join b就是取交集</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/12610368/1641814968278-9ad396b9-3c05-4a17-816c-26b50cd647c2.jpeg" alt="夜拍.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[二]概述</title>
      <link href="/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一，一条SQL的查询流程"><a href="#一，一条SQL的查询流程" class="headerlink" title="一，一条SQL的查询流程"></a>一，一条SQL的查询流程</h1><ol><li><p>去连接池获取连接</p></li><li><p>查询缓存，命中返回，否则继续向下</p></li><li><p>词法解析&amp;预处理</p><blockquote><p>词法解析拆分SQL，语法分析检查SQL的正确性生成一颗解析树，预处理检查表名，列名，生成一颗解析树。</p></blockquote></li><li><p>优化器优化，优化计划，查询计划</p></li><li><p>执行引擎生成执行计划</p></li><li><p>存储引擎查询SQL，加入缓存，返回结果。</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641449666256-21382ea1-bf47-4ce3-b1ea-5cb8e82965f1.png" alt="image.png"></p><h2 id="1-获取连接"><a href="#1-获取连接" class="headerlink" title="1.获取连接"></a>1.获取连接</h2><p>MySQL支持多种通信协议，可以使用同步/异步的方式，支持长连接，短连接。<br>​</p><h3 id="1-1-通信类型"><a href="#1-1-通信类型" class="headerlink" title="1.1 通信类型"></a>1.1 通信类型</h3><p>​</p><p>一般来说，<strong>连接数据库都是同步连接</strong>。<br>​</p><blockquote><ol><li>同步连接：依赖于被调用方，受限制于被调用方的性能；一般只能一对一。</li><li>异步连接：避免阻塞，但不能节省SQL的执行时间，并发情况下，每个SQL的执行都要单独建立连接，占用大量CPU资源；异步连接必须使用连接池减少线程创建销毁的开销。</li></ol></blockquote><h3 id="1-2-连接方式"><a href="#1-2-连接方式" class="headerlink" title="1.2 连接方式"></a>1.2 连接方式</h3><p>MySQL长短连接都支持，一般我们会在连接池中使用长连接。保持长连接会消耗内存，长时间不活动的连接，MySQL服务器会断开。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>; <span class="comment">-- 非交互式超时时间，如 JDBC 程序</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;interactive_timeout&#x27;</span>; <span class="comment">-- 交互式超时时间，如数据库工具</span></span><br></pre></td></tr></table></figure><blockquote><p>默认长连接断开时间是8小时。</p></blockquote><p>可以使用 <code>show status;</code>查看当前MySQL有多少个连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Threads_cached</th><th>缓存中的线程连接数</th></tr></thead><tbody><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>为处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>每产生一个连接或者会话，服务端就会创建一个线程来处理。杀死会话本质就是kill 线程。<br>​</p><blockquote><p>可以使用<code>SHOW PROCESSLIST; </code>（root 用户）查看 SQL 的执行状态。<br>​</p></blockquote><blockquote><p>+—-+——+———–+——+———+——+———-+<br>| Id | User | Host      | db   | Command | Time | State    | Info             |<br>+—-+——+———–+——+———+——+———-+<br>| 11 | root | localhost | NULL | Query   |    0 | starting | show processlist |<br>+—-+——+———–+——+———+——+———-+</p></blockquote><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>Sleep</td><td>线程正在等待客户端，以向它发送一个新语句</td></tr><tr><td>Query</td><td>线程正在执行查询或往客户端发送数据</td></tr><tr><td>Locked</td><td>该查询被其它查询锁定</td></tr><tr><td>Copying to tmp table on disk</td><td>临时结果集合大于 tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器</td></tr><tr><td>Sending data</td><td>线程正在为 SELECT 语句处理行，同时正在向客户端发送数据</td></tr><tr><td>Sorting for group</td><td>线程正在进行分类，以满足 GROUP BY 要求</td></tr><tr><td>Sorting for order</td><td>线程正在进行分类，以满足 ORDER BY 要求</td></tr></tbody></table><p>在5.7版本，MySQL的默认连接数是151个，我们最大可以修改为16384个 （214）。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> [<span class="keyword">global</span> <span class="operator">|</span> session] max_connections <span class="operator">=</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-3-通信协议"><a href="#1-3-通信协议" class="headerlink" title="1.3 通信协议"></a>1.3 通信协议</h3><p>​</p><ol><li>编程语言的连接模块都是用 TCP 协议连接到 MySQL 服务器的，比如mysql-connector-java-x.x.xx.jar。</li><li>类unix系统上，支持 Socket套接字文件进行进程间通信。<code>/tmp/mysql.sock</code></li><li>windows系统上还支持命名管道和共享内存。</li></ol><p>​</p><h3 id="1-4-通信方式"><a href="#1-4-通信方式" class="headerlink" title="1.4 通信方式"></a>1.4 通信方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641431698698-e3b38143-26dc-439d-8a75-feff85dbc973.png" alt="image.png"><br>MySQL使用了半双工通信，所以客户端发送SQL语句给服务端的时候，不管SQL有多大，都是一次发过去的。<br>​</p><blockquote><p>比如我们用MyBatis动态SQL生成了一个批量插入的语句，插入10万条数据，values后面跟了一长串的内容，或者 where 条件 in 里面的值太多，会出现问题。这个时候我们必须要调整 MySQL 服务器配置 max_allowed_packet 参数的值（默认是 4M），把它调大，否则就会报错。</p></blockquote><p>对于服务端来说，也是一次性发送所有的数据，不能因为你已经取到了想要的数据就中断操作，这个时候会对网络和内存产生大量消耗。在程序里面避免不带 limit 的这种操作，比如一次把所有满足条件的数据全部查出来，一定要先 count 一下。如果数据量的话，可以分批查询。</p><hr><h2 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h2><p>MySQL 的缓存默认是关闭的。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;query_cache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL不推荐使用自带的缓存，命中条件过于苛刻。且表里数据发生变化，整张表的缓存全部失效，MySQL8移除掉了缓存。</p><hr><h2 id="3-语法解析-amp-预处理"><a href="#3-语法解析-amp-预处理" class="headerlink" title="3.语法解析&amp;预处理"></a>3.语法解析&amp;预处理</h2><h3 id="3-1-词法解析"><a href="#3-1-词法解析" class="headerlink" title="3.1 词法解析"></a>3.1 词法解析</h3><p>词法分析就是把一个完整的 SQL 语句打碎成一个个的单词。<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>它会打碎成 8 个符号，每个符号是什么类型，从哪里开始到哪里结束。<br>​</p><h3 id="3-2-语法解析"><a href="#3-2-语法解析" class="headerlink" title="3.2 语法解析"></a>3.2 语法解析</h3><p>语法分析会对 SQL 做一些语法检查，比如单引号有没有闭合，然后根据 MySQL 定义的语法规则，根据 SQL 语句生成一个数据结构。这个数据结构我们把它叫做解析树（select_lex）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641432113376-2499bc3f-6277-49aa-8a99-eb135ce35507.png" alt="image.png"></p><blockquote><p>任何数据库的中间件，比如 Mycat，Sharding-JDBC（用到了 Druid Parser），都必须要有词法和语法分析功能。</p></blockquote><h3 id="3-3-预处理"><a href="#3-3-预处理" class="headerlink" title="3.3 预处理"></a>3.3 预处理</h3><p>​</p><p>如果写了一个词法和语法都正确的 SQL，但是表名或者字段不存在，会在哪里报错？是在数据库的执行层还是解析器？<br>​</p><p>实际上还是在解析的时候报错，解析 SQL 的环节里面有个预处理器。它会检查生成的解析树，解决解析器无法解析的语义。比如，它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理之后得到一个新的解析树。<br>​</p><hr><h2 id="4-查询优化-amp-查询执行计划"><a href="#4-查询优化-amp-查询执行计划" class="headerlink" title="4.查询优化&amp;查询执行计划"></a>4.查询优化&amp;查询执行计划</h2><p>一条SQL语句的执行方式有很多种，但是最终返回的结果都是相同的。查询优化器的目的就是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL 里面使用的是基于开销（cost）的优化器，那种执行计划开销最小，就用哪种。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看查询的开销</span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Last_query_cost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-优化器的作用"><a href="#4-1-优化器的作用" class="headerlink" title="4.1 优化器的作用"></a>4.1 优化器的作用</h3><ol><li>多表联查，以哪张表为基准表</li><li>用不用索引，用哪个索引</li><li>。。。。</li></ol><p>​</p><h3 id="4-2-优化器是怎么得到执行计划的"><a href="#4-2-优化器是怎么得到执行计划的" class="headerlink" title="4.2 优化器是怎么得到执行计划的"></a>4.2 优化器是怎么得到执行计划的</h3><ol><li>首先我们要启用优化器的追踪（默认是关闭的）。</li></ol><blockquote><p>开启这开关是会消耗性能的，因为它要把优化分析的结果写到表里面，所以不要轻易开启，或者查看完之后关闭它（改成 off）。</p></blockquote><ol start="2"><li>接着执行一个 SQL 语句，优化器会生成执行计划：</li></ol><ol start="3"><li>这个时候优化器分析的过程已经记录到系统表里面了，我们可以查询：</li></ol><blockquote><p>它是一个 JSON 类型的数据，主要分成三部分，准备阶段、优化阶段和执行阶段。</p></blockquote><blockquote><p>expanded_query 是优化后的 SQL 语句。</p></blockquote><blockquote><p>considered_execution_plans 里面列出了所有的执行计划。</p></blockquote><ol start="4"><li>分析完记得关掉它</li></ol><blockquote><p>通过追踪优化器，可以看到优化器对sql的初始优化，表的读取顺序，为什么采用了这种读取顺序。为什么采用了某个索引或者采用了全表查询。</p></blockquote><h3 id="4-3-优化器得到的结果"><a href="#4-3-优化器得到的结果" class="headerlink" title="4.3 优化器得到的结果"></a>4.3 优化器得到的结果</h3><p>​</p><p>优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。</p><p>当然，这个执行计划是不是一定是最优的执行计划呢？不一定，因为 MySQL 也有可能覆盖不到所有的执行计划。<br>​</p><p>MySQL 提供了一个执行计划的工具。我们在 SQL 语句前面加上 EXPLAIN，就可以看到执行计划的信息。<br>​</p><p><strong>Explain 的结果也不一定最终执行的方式。</strong><br><strong>​</strong></p><h3 id="4-4-选错索引"><a href="#4-4-选错索引" class="headerlink" title="4.4 选错索引"></a>4.4 选错索引</h3><p>这里错误决定分两类，第一，彻底错误。第二，基于成本最低，但执行速度不是最快。</p><ol><li><p>由于InnoDB的 MVCC 功能和随机采样方式，默认随机采取几个数据页，当做总体数据。以部分代表整体，本来就有错误的风险。加上数据不断地添加过程中，索引树可能会分裂，结果更加不准确。 </p><blockquote><ol><li>执行 ANALYZE TABLE ,可以重新构建索引，使索引树不过于分裂。</li><li>调整参数，加大InnoDB采样的页数，页数越大越精确，但性能消耗更高。一般不建议这么干。</li></ol></blockquote></li><li><p>在优化阶段，会对表中所有索引进行对比，优化器基于成本的原因，选择成本最低的索引，所以会错过最佳索引。带来的问题便是，执行速度很慢。 </p><blockquote><ol><li>通过explain查看执行计划，结合sql条件查看可以利用哪些索引。</li><li>使用 <code>force index(indexName)</code>强制走指定索引。弊端就是后期若索引名发生改变，或索引被删除，该sql语句需要调整。 </li></ol></blockquote></li></ol><hr><h2 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5. 存储引擎"></a>5. 存储引擎</h2><p>得到执行计划以后，SQL 语句是不是终于可以执行了？</p><ol><li>从逻辑的角度来说，我们的数据是放在哪里的，或者说放在一个什么结构里面？</li></ol><ol start="2"><li>执行计划在哪里执行？是谁去执行？</li></ol><p>表在存储数据的同时，还要组织数据的存储结构，这个存储结构就是由存储引擎决定的，所以也可以把存储引擎叫做表类型。</p><p>在 MySQL 里面，支持多种存储引擎，他们是可以替换的，所以叫做插件式的存储引擎。<br>​</p><h3 id="5-1-查看存储引擎"><a href="#5-1-查看存储引擎" class="headerlink" title="5.1 查看存储引擎"></a>5.1 查看存储引擎</h3><p>我们数据库里面已经存在的表，我们怎么查看它们的存储引擎呢？<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">from</span> `数据库名`;</span><br></pre></td></tr></table></figure><p>或者通过 DDL 建表语句来查看。<br>​</p><p>在 MySQL 里面，我们创建的每一张表都可以指定它的存储引擎，而不是一个数据库只能使用一个存储引擎。存储引擎的使用是以表为单位的。而且，创建表之后还可以修改存储引擎。<br>​</p><p>一张表使用的存储引擎决定存储数据的结构，那在服务器上它们是怎么存储的呢？先要找到数据库存放数据的路径：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434256832-de450340-7be5-41be-845e-61c79f6b4f82.png" alt="image.png"><br>默认情况下，每个数据库有一个自己文件夹，以 yhd数据库为例。任何一个存储引擎都有一个 frm 文件，这个是表结构定义文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641434747584-0e54ae84-325f-48ba-9586-59d5b480aa92.png" alt="image.png"><br>不同的存储引擎存放数据的方式不一样，产生的文件也不一样，innodb 是 1 个，memory 没有，myisam 是两个。</p><h3 id="5-2-存储引擎比较"><a href="#5-2-存储引擎比较" class="headerlink" title="5.2 存储引擎比较"></a>5.2 存储引擎比较</h3><h4 id="①常见存储引擎"><a href="#①常见存储引擎" class="headerlink" title="①常见存储引擎"></a>①常见存储引擎</h4><p>MyISAM 和 InnoDB 是我们用得最多的两个存储引擎，在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，它是 MySQL 自带的。</p><p>5.5 版本之后默认的存储引擎改成了 InnoDB，最主要的原因还是 InnoDB 支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。</p><h4 id="②数据库支持的存储引擎"><a href="#②数据库支持的存储引擎" class="headerlink" title="②数据库支持的存储引擎"></a>②数据库支持的存储引擎</h4><p>可以用这个命令查看数据库对存储引擎的支持情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines ;</span><br></pre></td></tr></table></figure><p>其中有存储引擎的描述和对事务、XA 协议和 Savepoints 的支持。</p><p>XA 协议用来实现分布式事务（分为本地资源管理器，事务管理器）。</p><p>Savepoints 用来实现子事务（嵌套事务）。创建了一个 Savepoints 之后，事务就可以回滚到这个点，不会影响到创建 Savepoints 之前的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641435383199-5ae5e040-4df5-4a35-94ba-e8e13b19fe54.png" alt="image.png"></p><h4 id="③MyISAM（3-个文件）"><a href="#③MyISAM（3-个文件）" class="headerlink" title="③MyISAM（3  个文件）"></a>③MyISAM（3  个文件）</h4><p>应用范围比较小。表级锁定限制了读/写的性能，因此在 Web 和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p><strong>特点</strong></p><ol><li>支持表级别的锁（插入和更新会锁表）。不支持事务。</li></ol><ol start="2"><li>拥有较高的插入（insert）和查询（select）速度。</li></ol><ol start="3"><li>存储了表的行数（count 速度更快）。</li></ol><p>适合：只读之类的数据分析的项目。</p><h4 id="④InnoDB（2个文件）"><a href="#④InnoDB（2个文件）" class="headerlink" title="④InnoDB（2个文件）"></a>④InnoDB（2个文件）</h4><p>mysql 5.7 中的默认存储引擎。InnoDB 是一个事务安全（与 ACID 兼容）的 MySQL存储引擎，它具有提交、回滚和崩溃恢复功能来保护用户数据。InnoDB 行级锁（不升级为更粗粒度的锁）和 Oracle 风格的一致非锁读提高了多用户并发性和性能。InnoDB 将用户数据存储在聚集索引中，以减少基于主键的常见查询的 I/O。为了保持数据完整性，InnoDB 还支持外键引用完整性约束。</p><p><strong>特点</strong></p><ol><li>支持事务，支持外键，因此数据的完整性、一致性更高。</li></ol><ol start="2"><li>支持行级别的锁和表级别的锁。</li></ol><ol start="3"><li>支持读写并发，写不阻塞读（MVCC）。</li></ol><ol start="4"><li>特殊的索引存放方式，可以减少 IO，提升查询效率。</li></ol><p>适合：经常更新的表，存在并发读写或者有事务处理的业务系统。</p><h4 id="⑤Memory-1个文件"><a href="#⑤Memory-1个文件" class="headerlink" title="⑤Memory(1个文件)"></a>⑤Memory(1个文件)</h4><p>基于内存的存储引擎。</p><p>特征：</p><ul><li>基于内存的表，服务器重启后，表结构会被保留，但表中的数据会被清空。</li><li>不需要进行磁盘IO，比 MYISAM 快了一个数量级。</li><li>表级锁，故并发插入性能较低。</li><li>每一行是固定的，VARCHAR 列在 memory 存储引擎中会变成 CHAR，可能导致内存浪费。</li><li>不支持 BLOB 或 TEXT 列，如果sql返回的结果列中包含 BLOB 或 TEXT，就直接采用 MYISAM 存储引擎，在磁盘上建临时表</li><li>支持哈希索引，B+树索引</li></ul><p>MEMORY 存储引擎在很多地方可以发挥很好的作用：</p><ul><li>用于查找或映射表，例如邮编和州名的映射表</li><li>用于缓存周期性聚合数据的结果</li><li>用于保存数据分析中产生的中间结果。即SQL执行过程中用到的临时表</li><li>监控MySQL内存中的执行情况，例如：information_schema 库下的表基本都是 memory 存储引擎，监控InnoDB缓冲池中page(INNODB_BUFFER_PAGE表)，InnoDB缓冲池状态(INNODB_BUFFER_POOL_STATS表)、InnoDB缓存页淘汰记录(INNODB_BUFFER_PAGE_LRU表)、InnoDB锁等待(INNODB_LOCK_WAITS表)、InnoDB锁信息(INNODB_LOCKS表)、InnoDB中正在执行的事务(INNODB_TRX表)等。</li></ul><p><strong>MEMORY 存储引擎默认 hash 索引，故等值查询特别快。同时也支持B+树索引。虽然查询速度特别快，但依旧无法取代传统的磁盘建表。</strong></p><h4 id="⑥CSV-3个文件"><a href="#⑥CSV-3个文件" class="headerlink" title="⑥CSV(3个文件)"></a>⑥CSV(3个文件)</h4><p>它的表实际上是带有逗号分隔值的文本文件。csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据。因为 csv 表没有索引，所以通常在正常操作期间将数据保存在 innodb 表中，并且只在导入或导出阶段使用 csv 表。</p><p><strong>特点</strong></p><p>不允许空行，不支持索引。格式通用，可以直接编辑，适合在不同数据库之间导入导出。<br>​</p><h3 id="5-3-如何选择存储引擎"><a href="#5-3-如何选择存储引擎" class="headerlink" title="5.3 如何选择存储引擎"></a>5.3 如何选择存储引擎</h3><ol><li>如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。</li></ol><ol start="2"><li>如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。</li></ol><ol start="3"><li>如果需要一个用于查询的临时表，可以选择 Memory。</li></ol><p>​</p><hr><h2 id="6-执行引擎"><a href="#6-执行引擎" class="headerlink" title="6.执行引擎"></a>6.执行引擎</h2><p>执行引擎，它利用存储引擎提供的相应的 API 来完成操作。</p><p>为什么我们修改了表的存储引擎，操作方式不需要做任何改变？因为不同功能的存储引擎实现的 API 是相同的。</p><p>最后把数据返回给客户端，即使没有结果也要返回。<br>​</p><hr><h1 id="二，一条SQL的更新流程"><a href="#二，一条SQL的更新流程" class="headerlink" title="二，一条SQL的更新流程"></a>二，一条SQL的更新流程</h1><p>更新和查询很多地方并没有区别，仅仅在于拿到数据之后的操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641458151710-45fe3a24-a127-401d-abec-75f52f953f3d.png" alt="image.png"></p><h2 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1.内存结构"></a>1.内存结构</h2><p>InnnoDB 的数据都是放在磁盘上的，InnoDB 操作数据有一个最小的逻辑单位，叫做页（索引页和数据页）。我们对于数据的操作，不是每次都直接操作磁盘，因为磁盘的速度太慢了。InnoDB 使用了一种缓冲池的技术，也就是把磁盘读到的页放到一块内存区域里面。这个内存区域就叫 Buffer Pool。<br>​</p><p>下一次读取相同的页，先判断是不是在缓冲池里面，如果是，就直接读取，不用再次访问磁盘。</p><p>修改数据的时候，先修改缓冲池里面的页。内存的数据页和磁盘数据不一致的时候，我们把它叫做脏页。InnoDB 里面有专门的后台线程把 Buffer Pool 的数据写入到磁盘，每隔一段时间就一次性地把多个修改写入磁盘，这个动作就叫做刷脏。</p><p>Buffer Pool 是 InnoDB 里面非常重要的一个结构，主要分为 3 个部分： Buffer Pool、Change Buffer、Adaptive HashIndex，另外还有一个（redo）log buffer。<br>​</p><h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>Buffer Pool 缓存的是页信息，包括数据页、索引页，默认大小是 128M（134217728 字节），可以调整。</p><p>查看服务器状态，里面有很多跟 Buffer Pool 相关的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>查看参数（系统变量）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES like &#x27;%innodb_buffer_pool%&#x27;;</span><br></pre></td></tr></table></figure><p>内存的缓冲池写满了怎么办？（Redis 设置的内存满了怎么办？）InnoDB 用 LRU算法来管理缓冲池（链表实现，不是传统的 LRU，分成了 young 和 old），经过淘汰的数据就是热点数据。</p><p>内存缓冲区对于提升读写性能有很大的作用。当需要更新一个数据页时，如果数据页在 Buffer Pool 中存在，那么就直接更新好了。否则的话就需要从磁盘加载到内存，再对内存的数据页进行操作。也就是说，如果没有命中缓冲池，至少要产生一次磁盘 IO。<br>​</p><h3 id="1-2-ChangeBuffer写缓冲"><a href="#1-2-ChangeBuffer写缓冲" class="headerlink" title="1.2 ChangeBuffer写缓冲"></a>1.2 ChangeBuffer写缓冲</h3><p>如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓冲池中，从而提升更新语句（Insert、Delete、Update）的执行速度。</p><p>这一块区域就是 Change Buffer。5.5 之前叫 Insert Buffer 插入缓冲，现在也能支持 delete 和 update。</p><p>最后把 Change Buffer 记录到数据页的操作叫做 merge。什么时候发生 merge？有几种情况：在访问这个数据页的时候，或者通过后台线程、或者数据库 shut down、redo log 写满时触发。</p><p>如果数据库大部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以使用 Change Buffer（写缓冲）。写多读少的业务，调大这个值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_change_buffer_max_size&#x27;;</span><br></pre></td></tr></table></figure><p>代表 Change Buffer 占 Buffer Pool 的比例，默认 25%。<br>​</p><h3 id="1-3-Adaptive-Hash-Index"><a href="#1-3-Adaptive-Hash-Index" class="headerlink" title="1.3 Adaptive Hash Index"></a>1.3 Adaptive Hash Index</h3><p>当我们需要访问某个页中的数据时，就会把该页从磁盘加载到<code>Buffer Pool</code>中，如果该页已经在<code>Buffer Pool</code>中的话直接使用就可以了。那么问题也就来了，我们怎么知道该页在不在<code>Buffer Pool</code>中呢？</p><p>我们其实是根据<code>表空间号 + 页号</code>来定位一个页的，也就相当于<code>表空间号 + 页号</code>是一个<code>key</code>，<code>缓存页</code>就是对应的<code>value</code>，怎么通过一个<code>key</code>来快速找着一个<code>value</code>呢？那肯定是哈希表。</p><p>所以我们可以用<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据<code>表空间号 + 页号</code>看看有没有对应的缓存页，如果有，直接使用该缓存页就好，如果没有，那就从<code>free链表</code>中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。<br>​</p><h3 id="1-4-（redo）Log-Buffer"><a href="#1-4-（redo）Log-Buffer" class="headerlink" title="1.4 （redo）Log Buffer"></a>1.4 （redo）Log Buffer</h3><p>​</p><p>如果 Buffer Pool 里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据丢失。如果写操作写到一半，甚至可能会破坏数据文件导致数据库不可用。为了避免这个问题，InnoDB 把所有对页面的修改操作专门写入一个日志文件，并且在数据库启动时从这个文件进行恢复操作（实现 crash-safe）——用它来实现事务的持久性。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478367975-c4e017fe-92ed-440a-8fb3-3efc4c310546.png" alt="image.png"><br>这个文件就是磁盘的 redo log（叫做重做日志），对应于/var/lib/mysql/目录下的ib_logfile0 和 ib_logfile1，每个 48M。这 种 日 志 和 磁 盘 配 合 的 整 个 过 程 ， 其 实 就 是 MySQL 里 的 WAL 技 术（Write-Ahead Logging），它的关键点就是先写日志，再写磁盘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_log%&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认 48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为 2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir 路径。</td></tr></tbody></table><p><strong>同样是写磁盘，为什么不直接写到 db file 里面去？为什么先写日志再写磁盘？</strong></p><p>磁盘的最小组成单元是扇区，通常是 512 个字节。操作系统和内存打交道，最小的单位是页 Page。操作系统和磁盘打交道，读写磁盘，最小的单位是块 Block。<br>​</p><p>如果我们所需要的数据是随机分散在不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们所需要的一块数据，依次进行此过程直到找完所有数据，这个就是随机 IO，读取数据速度较慢。</p><p>假设我们已经找到了第一块数据，并且其他所需的数据就在这一块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序 IO。</p><p>刷盘是随机 I/O，而记录日志是顺序 I/O，顺序 I/O 效率更高。因此先把修改写入日志，可以延迟刷盘时机，进而提升系统吞吐。</p><p>当然 redo log 也不是每一次都直接写入磁盘，在 Buffer Pool 里面有一块内存区域（Log Buffer）专门用来保存即将要写入日志文件的数据，默认 16M，它一样可以节省磁盘 IO。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478572344-fc83dc25-3a96-42fd-8017-03423f4d9f49.png" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_log_buffer_size&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>redo log 的内容主要是用于崩溃恢复。磁盘的数据文件，数据来自 buffer pool。redo log 写入磁盘，不是写入数据文件。</p></blockquote><p>那么，Log Buffer 什么时候写入 log file？</p><p>在我们写入数据到磁盘的时候，操作系统本身是有缓存的。flush 就是把操作系统缓冲区写入到磁盘。</p><p>log buffer 写入磁盘的时机，由一个参数控制，默认是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_flush_log_at_trx_commit&#x27;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0（延迟写）</td><td>log buffer 将每秒一次地写入 log file 中，并且 log file 的 flush 操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。</td></tr><tr><td>1（默认，实时写，实时刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file，并且刷到磁盘中去。</td></tr><tr><td>2（实时写，延迟刷）</td><td>每次事务提交时 MySQL 都会把 log buffer 的数据写入 log file。但是 flush 操作并不会同时进行。该模式下，MySQL 会每秒执行一次 flush 操作。</td></tr></tbody></table><p>redo log，它又分成内存和磁盘两部分。redo log 有什么特点？</p><ol><li>redo log 是 InnoDB 存储引擎实现的，并不是所有存储引擎都有。</li></ol><ol start="2"><li>不是记录数据页更新之后的状态，而是记录这个页做了什么改动，属于物理日志。（redo log 记录的是执行的结果）</li></ol><ol start="3"><li>redo log 的大小是固定的，前面的内容会被覆盖。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641478994184-25e740bb-80a0-48fe-9327-bc4bb7da7192.png" alt="image.png"><br>check point 是当前要覆盖的位置。如果 write pos 跟 check point 重叠，说明 redolog 已经写满，这时候需要同步 redo log 到磁盘中。</p><p>这是 MySQL 的内存结构，总结一下，分为：Buffer pool、change buffer、Adaptive Hash Index、 log buffer。</p><blockquote><p>磁盘结构里面主要是各种各样的表空间，叫做 Table space。</p></blockquote><h3 id="1-5-缓存的疑问"><a href="#1-5-缓存的疑问" class="headerlink" title="1.5 缓存的疑问"></a>1.5 缓存的疑问</h3><p><strong>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</strong></p><p>然后，InnoDB架构中，有非常重要的一个部分——<strong>缓冲池</strong>。该缓冲池需要占用服务器内存，且<strong>专用于MySQL的服务器，建议把80%的内存交给MySQL。</strong></p><p>缓冲池有一个缓存的功能。这个缓存，是InnoDB自带的，而且经常会用到。该缓存功能并不是MySQL架构中的缓存组件。这是两者最大的区别。</p><ul><li>MySQL组件中的缓存 <ol><li>所处位置：MySQL架构中的缓存组件</li><li>缓存内容：缓存的是SQL 和 该SQL的查询结果。如果SQL的大小写，格式，注释不一致，则被认为是不同的SQL，重新查询数据库，并缓存一份数据。</li><li>可否关闭：是可以手动关闭，并卸载该组件的。</li></ol></li><li>InnoDB中的缓存 <ol><li>所处位置：InnoDB架构中的缓冲池</li><li>缓存内容：缓存的是所有需要查找的数据，所在的数据页。</li><li>可否关闭：是InnoDB缓冲池自带的功能，<strong>无法关闭，无法卸载</strong>。如果InnoDB的缓冲池被关闭或卸载，则InnoDB直接瘫痪。所以说缓冲池是InnoDB的最重要的一部分。</li></ol></li></ul><p>不建议使用MySQL的缓存是指，不建议使用MySQL架构中的缓存组件，并不是同时否定了InnoDB中的缓存功能。<br>​</p><hr><h2 id="2-磁盘结构"><a href="#2-磁盘结构" class="headerlink" title="2.磁盘结构"></a>2.磁盘结构</h2><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB 的表空间分为 5 大类。<br>​</p><h3 id="2-1-系统表空间"><a href="#2-1-系统表空间" class="headerlink" title="2.1 系统表空间"></a>2.1 系统表空间</h3><p>在默认情况下 InnoDB 存储引擎有一个共享表空间（对应文件/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>InnoDB 系统表空间包含 InnoDB 数据字典和双写缓冲区，（Change Buffer 和 UndoLogs），如果没有指定 file-per-table，也包含用户创建的表和索引数据。</p><ol><li>undo 在后面介绍，因为有独立的表空间。</li></ol><ol start="2"><li>数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）。</li></ol><ol start="3"><li>双写缓冲（InnoDB 的一大特性）</li></ol><p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641479261038-52879c45-835e-4fae-abcd-1ca4ac1f9c66.png" alt="image.png"></p><p>如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_doublewrite&#x27;;</span><br></pre></td></tr></table></figure><p>如果这个页本身已经损坏了，用它来做崩溃恢复是没有意义的。所以在对于应用 redo log 之前，需要一个页的副本。如果出现了写入失效，就用页的副本来还原这个页，然后再应用 redo log。这个页的副本就是 double write，InnoDB 的双写技术。通过它实现了数据页的可靠性。</p><p>跟 redo log 一样，double write 由两部分组成，一部分是内存的 double write，一个部分是磁盘上的 double write。因为 double write 是顺序写入的，不会带来很大的开销。</p><p>在MySQL5.7之前，所有的表共享一个系统表空间，这个文件会越来越大，而且它的空间不会收缩。<br>​</p><h3 id="2-2-独占表空间"><a href="#2-2-独占表空间" class="headerlink" title="2.2 独占表空间"></a>2.2 独占表空间</h3><p>我们可以让每张表独占一个表空间。这个开关通过 innodb_file_per_table 设置，默认开启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br></pre></td></tr></table></figure><p>开启后，则每张表会开辟一个表空间，这个文件就是数据目录下的 ibd 文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页、系统事务信息，二次写缓冲（Double write buffer）等还是存放在原来的共享表空间内。<br>​</p><h3 id="2-3-通用表空间"><a href="#2-3-通用表空间" class="headerlink" title="2.3 通用表空间"></a>2.3 通用表空间</h3><p>通用表空间也是一种共享的表空间，跟 ibdata1 类似。</p><p>可以创建一个通用的表空间，用来存储不同数据库的表，数据路径和文件可以自定义。语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create tablespace ts2673 add datafile &#x27;/var/lib/mysql/ts2673.ibd&#x27; file_block_size=16K engine=innodb;</span><br></pre></td></tr></table></figure><p>在创建表的时候可以指定表空间，用 ALTER 修改表空间可以转移表空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t2673(id integer) tablespace ts2673;</span><br></pre></td></tr></table></figure><p>不同表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop table t2673;</span><br><span class="line">drop tablespace ts2673;</span><br></pre></td></tr></table></figure><h3 id="2-4-临时表空间"><a href="#2-4-临时表空间" class="headerlink" title="2.4 临时表空间"></a>2.4 临时表空间</h3><p>存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的 ibtmp1 文件。当数据服务器正常关闭时，该表空间被删除，下次重新产生。</p><p><strong>memory向template的过渡，还有磁盘上简历临时表用的什么存储引擎？</strong></p><p>8.0之前，内存临时表用Memory引擎创建，但假如字段中有BLOB或TEXT,或结果太大，就会转用MYISM在磁盘上建表，8.0之后内存临时表由MEMORY引擎更改为TempTable引擎，相比于前者，后者支持以变长方式存储VARCHAR，VARBINARY等变长字段。从MySQL 8.0.13开始，TempTable引擎支持BLOB字段。如果超过内存表大小，则用InnoDB建表。</p><h3 id="2-5-redo-log"><a href="#2-5-redo-log" class="headerlink" title="2.5 redo log"></a>2.5 redo log</h3><h3 id="2-6-undo-log-表空间"><a href="#2-6-undo-log-表空间" class="headerlink" title="2.6 undo log 表空间"></a>2.6 undo log 表空间</h3><p>undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态（不包括 select）。</p><p>如果修改数据时出现异常，可以用 undo log 来实现回滚操作（保持原子性）。</p><p>在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，属于逻辑格式的日志(记录操作)。</p><p>redo Log 和 undo Log 与事务密切相关，统称为事务日志。</p><p>undo Log 的数据默认在系统表空间 ibdata1 文件中，因为共享表空间不会自动收缩，也可以单独创建一个 undo 表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%undo%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-7-一条SQL的更新流程"><a href="#2-7-一条SQL的更新流程" class="headerlink" title="2.7 一条SQL的更新流程"></a>2.7 一条SQL的更新流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>事务开始，从内存或者磁盘取到这条数据，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>记录name = 二十 到redo log</li><li>调用存储引擎接口，在buffer pool 中修改 name =二十</li><li>事务提交</li></ol><p>​</p><blockquote><p>内存和磁盘之间，工作着很多后台线程。</p></blockquote><hr><h2 id="3-后台线程"><a href="#3-后台线程" class="headerlink" title="3.后台线程"></a>3.后台线程</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641480352645-ff2557dd-b622-49e2-829c-d058bbe6d559.png" alt="image.png"><br>后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master线程，IO 线程，purge 线程，page cleaner 线程。<br>​</p><h3 id="3-1-Master-线程"><a href="#3-1-Master-线程" class="headerlink" title="3.1 Master 线程"></a>3.1 Master 线程</h3><p>Master Thread是InnoDB存储引擎非常核心的一个后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收等。<br>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">master_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">    thread_sleep(<span class="number">1</span>);<span class="comment">// sleep 1秒</span></span><br><span class="line">        <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">        <span class="keyword">if</span>(last_one_second_ios &lt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer;</span><br><span class="line">        <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">          <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct(默认是75时)</span></span><br><span class="line">            <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;<span class="comment">// 刷新100脏页到磁盘</span></span><br><span class="line">        <span class="keyword">if</span>(no user activity)</span><br><span class="line">            <span class="keyword">goto</span> backgroud loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(last_ten_second_ios &lt; <span class="number">200</span>) <span class="comment">// 如果过去10内磁盘IO次数小于设置的innodb_io_capacity的值（默认是200）</span></span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> merge at most <span class="number">5</span> insert buffer; <span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">do</span> <span class="built_in">log</span> buffer flush to disk;</span><br><span class="line">    <span class="keyword">do</span> full purge;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; <span class="number">70</span>%)</span><br><span class="line">        <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buffer pool flush <span class="number">10</span> dirty page;</span><br><span class="line"></span><br><span class="line">    backgroud loop：<span class="comment">// 后台循环</span></span><br><span class="line">    <span class="keyword">do</span> full purge<span class="comment">// 删除无用的undo页 （总是）</span></span><br><span class="line">    <span class="keyword">do</span> merge <span class="number">20</span> insert buffer;<span class="comment">// 合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> idle<span class="comment">// 如果不空闲，就跳回主循环，如果空闲就跳入flush loop</span></span><br><span class="line">        <span class="keyword">goto</span> loop:<span class="comment">// 跳到主循环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop</span><br><span class="line"></span><br><span class="line">    flush loop:<span class="comment">// 刷新循环</span></span><br><span class="line">    <span class="keyword">do</span> buffer pool flush <span class="number">100</span> dirty page;</span><br><span class="line">    <span class="keyword">if</span>(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)</span><br><span class="line">    <span class="comment">// 如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct的值（默认75%）</span></span><br><span class="line">        <span class="keyword">goto</span> flush loop;<span class="comment">// 跳到刷新循环，不断刷新脏页，直到符合条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> suspend loop;<span class="comment">// 完成刷新脏页的任务后，跳入suspend loop</span></span><br><span class="line"></span><br><span class="line">    suspend loop:</span><br><span class="line">    suspend_thread();<span class="comment">//master线程挂起，等待事件发生</span></span><br><span class="line">    waiting event;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Master Thread具有<strong>最高的线程优先级别</strong>。内部由多个循环组成：<strong>主循环（loop）</strong>、<strong>后台循环</strong>（backgroup loop）、<strong>刷新循环</strong>（flush loop）、<strong>暂停循环</strong>（suspend loop）。Master Thread会<strong>根据数据库运行的状态</strong>在loop、backgroup loop、flush loop和suspend loop中<strong>进行切换</strong>。loop是主循环，大多数的操作都在这个循环中，主要有两大部分的操作——每秒钟的操作和每10秒钟的操作。<br>​</p><h4 id="①每秒钟的操作"><a href="#①每秒钟的操作" class="headerlink" title="①每秒钟的操作"></a>①每秒钟的操作</h4><p>​</p><ol><li>​<strong>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）</strong>；<br>即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这也解释了为什么再大的事务提交的时间也是很短的。 </li><li> <strong>合并插入缓冲（可能）</strong>；<br>合并插入缓冲并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB存储引擎认为当前的IO压力很小，可以执行合并插入缓冲的操作； </li><li> <strong>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）</strong>； 刷新100个脏页也不是每秒都会发生的，InnoDB存储引擎通过判断当前缓冲池中脏页的比例(buf_get_modified_ratio_pct)是否超过了配置文件中 innodb_max_dirty_pages_pct这个参数（默认是75，代表75%），如果超过了这个值，InnoDB存储引擎则认为需要做磁盘同步的操作，将100个脏页写入磁盘中。 </li><li> <strong>如果当前没有用户活动，则切换到background loop(可能)。</strong></li></ol><p><strong>​</strong></p><h4 id="②每十秒的操作"><a href="#②每十秒的操作" class="headerlink" title="②每十秒的操作"></a>②每十秒的操作</h4><ol><li> <strong>刷新100个脏页到磁盘（可能）</strong> InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO能力，因此将100个脏页刷新到磁盘。 </li><li> <strong>合并至多5个插入缓冲（总是）</strong> </li><li> <strong>将日志缓冲刷新到磁盘（总是）</strong> </li><li> <strong>删除无用的Undo页（总是）</strong> </li><li> <strong>刷新100个或者10个脏页到磁盘（总是）</strong> InnoDB存储引擎会执行full purge操作，即删除无用的Undo页。对表进行update，delete这类的操作时，原先的行被标记为删除，但是因为一致性读的关系，需要保留这些行版本的信息。但是在full purge过程中，InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB存储引擎会立即将其删除。从源代码中可以看出，InnoDB存储引擎在执行full purge 操作时，每次最多尝试回收20个undo页。<br>然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf_get_modified_ratio_pct）,如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%,则只需刷新10%的脏页到磁盘。</li></ol><p>​</p><hr><p>如果当前没有用户活动（数据库空闲）或者数据库关系，就会切换到backgroud loop这个循环。 backgroud loop会执行以下操作：</p><ol><li><strong>删除无用的Undo页（总是）</strong></li><li><strong>合并20个插入缓冲（总是）</strong></li><li><strong>跳回到主循环（总是）</strong></li><li><strong>不断刷新100个页直到符合条件（可能，需要跳转到flush loop中完成）</strong></li></ol><p>如果flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将Master Thread挂起，等待事件的发生。若用户启用了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。<br>​</p><p>1.0.x版本中，InnoDB存储引擎最多只会刷新100个脏页到磁盘，合并20个插入缓冲。如果是在写入密集的应用程序中，每秒可能会产生大于100个的脏页，如果是产生大于20个插入缓冲的情况，那么可能会来不及刷新所有的脏页以及合并插入缓冲。后来，InnoDB存储引擎提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。<br>​</p><p>对于刷新到磁盘的页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p><ol><li>在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%;</li><li>在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity;</li></ol><p>如果用户使用的是SSD类的磁盘，可以将innodb_io_capacity的值调高，直到符合磁盘IO的吞吐量为止；</p><p>另一个问题是参数innodb_max_dirty_pages_pct的默认值，在1.0.x版本之前，该值的默认值是90，意味着脏页占缓冲池的90%。InnoDB存储引擎在每秒刷新缓冲池和flush loop时会判断这个值，如果该值大于innodb_max_dirty_pages_pct,才会刷新100个脏页，如果有很大的内存，或者数据库服务器的压力很大，这时刷新脏页的速度反而会降低。 后来将innodb_max_dirty_pages_pct的默认值改为了75。这样既可以加快刷新脏页的频率，又能够保证磁盘IO的负载。<br>​</p><p>还有一个新的参数是innodb_adaptive_flushing(自适应地刷新)，该值影响每秒刷新脏页的数量。原来的刷新规则是：脏页在缓冲池所占的比例小于innodb_max_dirty_pages_pct时，不刷新脏页；大于innodb_max_dirty_pages_pct时，刷新100个脏页。随着innodb_adaptive_flushing参数的引入，InnoDB通过一个名为buf_flush_get_desired_flush_rate的函数来判断需要刷新脏页最合适的数量。buf_flush_get_desired_flush_rate函数通过判断产生重做日志的速率来决定最合适的刷新脏页数量。</p><p>之前每次进行full purge 操作时，最多回收20个Undo页，从InnoDB 1.0.x版本开始引入了参数innodb_purge_batch_size,该参数可以控制每次full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改。<br>​</p><p>1.2.x版本中再次对Master Thread进行了优化，对于刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。<br><strong>​</strong></p><h3 id="3-2-IO-线程"><a href="#3-2-IO-线程" class="headerlink" title="3.2 IO 线程"></a>3.2 IO 线程</h3><p>InnoDB中大量使用<strong>AIO (Async IO)</strong> 来处理IO请求。IO Thread的作用，是负责这些 IO 请求的回调（call back）。<br>​</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641481073193-6d2bbd4e-ffaa-49b5-9c2e-c591b8690872." alt="image.png"></p><h3 id="3-3-Purge-线程"><a href="#3-3-Purge-线程" class="headerlink" title="3.3 Purge 线程"></a>3.3 Purge 线程</h3><p>事务被提交后，其所使用的undo log可能不在需要。因此，需要purge thread来回收已经使用并分配的undo页。以前Master Thread来完成释放undo log，InnoDB1.1独立出来，分担主线程压力。<br>​</p><h3 id="3-4-Page-Cleaner-线程"><a href="#3-4-Page-Cleaner-线程" class="headerlink" title="3.4 Page Cleaner 线程"></a>3.4 Page Cleaner 线程</h3><p><strong>​</strong></p><p>负责将脏页刷新到磁盘。以前Master Thread来刷新脏页，InnoDB1.2独立出来，分担主线程压力。<br>​</p><blockquote><p>除了 InnoDB 架构中的日志文件，MySQL 的 Server 层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p></blockquote><hr><h2 id="4-binlog"><a href="#4-binlog" class="headerlink" title="4.binlog"></a>4.binlog</h2><p>binlog 以事件的形式记录了所有的DDL 和DML 语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不一样，它的文件内容是可以追加的，没有固定大小限制。在开启了 binlog 功能的情况下，我们可以把 binlog 导出成 SQL 语句，把所有的操作重放一遍，来实现数据的恢复。binlog 的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的 binlog，然后执行一遍。<br>​</p><p>有了这两个日志之后，来看一下一条更新语句是怎么执行的：<br>​</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># id <span class="operator">=</span><span class="number">1</span> 的记录原 name <span class="operator">=</span> <span class="string">&#x27;yhd&#x27;</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;二十&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​</p><ol><li>事务开始，从内存或者磁盘取到这条数据所在的数据页，返回给server的执行器</li><li>执行器修改这一行数据的值为二十</li><li>记录name =yhd 到undo log</li><li>在buffer pool 中修改 name =二十，此时该页变成脏页</li><li>记录name = 二十 到redo log buffer，redo log buffer每秒刷盘。</li><li>redo log 进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</li><li>写入binlog</li><li>事务提交，并回写最终状态到redo log里，代表该事务已经提交</li></ol><p>​</p><blockquote><p>事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便不断写入redo log文件中。一般情况下，每次事务commit时，必须调用 fsync 操作，将redo日志缓冲同步写到磁盘。另外，每次事务提交时同步写到磁盘bin log中。</p></blockquote><blockquote><p>那么就有了一个谁先谁后的问题：redo log 先，bin log 后。</p></blockquote><blockquote><p>两阶段提交的内容：**事务提交时，redo log处于 pre状态 -&gt; 写入bin log -&gt; 事务真正提交。 **</p></blockquote><blockquote><p>当发生崩溃恢复时，查看的是bin log是否完整，如果bin log完整，则代表事务已经提交。</p></blockquote><blockquote><p>如果在两阶段提交过程中，bin log写入失败，则事务无法终止提交，崩溃恢复时就不需要重做。如果bin log写完的一瞬间，服务器宕机了，事务都来不及提交，此时bin log并不是完整的，缺少了最终的commit标记。因此也是提交失败。</p></blockquote><blockquote><p>简单说，redo log和bin log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1641482848254-19b6e1b2-0fa7-411d-924b-0c6cb48f511f.png" alt="1.png"></p><hr><h1 id="三，MySQL中支持的字符集和排序规则"><a href="#三，MySQL中支持的字符集和排序规则" class="headerlink" title="三，MySQL中支持的字符集和排序规则"></a>三，MySQL中支持的字符集和排序规则</h1><h2 id="1-MySQL中的utf8和utf8mb4"><a href="#1-MySQL中的utf8和utf8mb4" class="headerlink" title="1.MySQL中的utf8和utf8mb4"></a>1.MySQL中的utf8和utf8mb4</h2><p>utf8字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计MySQL的大叔偷偷的定义了两个概念：</p><ul><li>utf8mb3：阉割过的utf8字符集，只使用1～3个字节表示字符。</li><li>utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符。</li></ul><p>在MySQL中utf8是utf8mb3的别名，所以之后在MySQL中提到utf8就意味着使用1~3个字节来表示一个字符，如果有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4。</p><p>查看字符集：<code>SHOW (CHARACTER SET|CHARSET)</code>。</p><h2 id="2-字符集-amp-比较规则的应用"><a href="#2-字符集-amp-比较规则的应用" class="headerlink" title="2.字符集&amp;比较规则的应用"></a>2.字符集&amp;比较规则的应用</h2><h3 id="2-1-各级别的字符集和比较规则"><a href="#2-1-各级别的字符集和比较规则" class="headerlink" title="2.1 各级别的字符集和比较规则"></a>2.1 各级别的字符集和比较规则</h3><p>MySQL有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><p>接下来仔细看一下怎么设置和查看这几个级别的字符集和比较规则。</p><h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_server&#x27;</span>;</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| character_set_server | utf8  |</span><br><span class="line">+----------------------+-------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_server&#x27;</span>;</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| Variable_name    | Value           |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line">| collation_server | utf8_general_ci |</span><br><span class="line">+------------------+-----------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用SET语句修改这两个变量的值。比如我们可以在配置文件中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">collation_server=gbk_chinese_ci</span><br></pre></td></tr></table></figure><p>当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。</p><h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br><span class="line"></span><br><span class="line">ALTER DATABASE 数据库名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [[DEFAULT] COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>其中的DEFAULT可以省略，并不影响语句的语义。比方说我们新创建一个名叫charset_demo_db的数据库，在创建的时候指定它使用的字符集为gb2312，比较规则为gb2312_chinese_ci：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.01</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE charset_demo_db;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">&#x27;character_set_database&#x27;</span>;</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| Variable_name          | Value  |</span><br><span class="line">+------------------------+--------+</span><br><span class="line">| character_set_database | gb2312 |</span><br><span class="line">+------------------------+--------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt; SHOW VARIABLES LIKE &#x27;collation_database&#x27;</span>;</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| Variable_name      | Value             |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">| collation_database | gb2312_chinese_ci |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这个charset_demo_db数据库的字符集和比较规则就是我们在创建语句中指定的。需要注意的一点是： <em><strong>character_set_database</strong></em> 和 _<strong>collation_database</strong>_ 这两个系统变量是只读的，我们不能通过修改这两个变量的值而改变当前数据库的字符集和比较规则。</p><h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息)</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]]</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名</span><br><span class="line">    [[DEFAULT] CHARACTER SET 字符集名称]</span><br><span class="line">    [COLLATE 比较规则名称]</span><br></pre></td></tr></table></figure><p>比方说我们在刚刚创建的charset_demo_db数据库中创建一个名为t的表，并指定这个表的字符集和比较规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">CREATE TABLE <span class="title">t</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    -&gt;     col VARCHAR(<span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.03</span> sec)</span></span></span><br></pre></td></tr></table></figure><p>如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。</p><h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>需要注意的是，对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];</span><br></pre></td></tr></table></figure><p>比如我们修改一下表t中列col的字符集和比较规则可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="function">ALTER TABLE t MODIFY col <span class="title">VARCHAR</span><span class="params">(<span class="number">10</span>)</span> CHARACTER SET gbk COLLATE gbk_chinese_ci</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="function">rows <span class="title">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span></span><br><span class="line"><span class="function">Records: 0  Duplicates: 0  Warnings: 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">mysql&gt;</span></span><br></pre></td></tr></table></figure><p>对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规则作为该列的字符集和比较规则。</p><blockquote><p>在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。 </p></blockquote><h3 id="2-2-客户端和服务器通信中的字符集"><a href="#2-2-客户端和服务器通信中的字符集" class="headerlink" title="2.2 客户端和服务器通信中的字符集"></a>2.2 客户端和服务器通信中的字符集</h3><h4 id="编码和解码使用的字符集不一致的后果"><a href="#编码和解码使用的字符集不一致的后果" class="headerlink" title="编码和解码使用的字符集不一致的后果"></a>编码和解码使用的字符集不一致的后果</h4><p>如果对于同一个字符串编码和解码使用的字符集不一样，会产生意想不到的结果，作为人类的我们看上去就像是产生了乱码一样。</p><h4 id="从发送请求到接收结果过程中发生的字符集转换"><a href="#从发送请求到接收结果过程中发生的字符集转换" class="headerlink" title="从发送请求到接收结果过程中发生的字符集转换"></a>从发送请求到接收结果过程中发生的字符集转换</h4><ul><li>客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。</li><li>服务器将客户端发送来的字节串采用character_set_client代表的字符集进行解码，将解码后的字符串再按照character_set_connection代表的字符集进行编码。</li><li>如果character_set_connection代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从character_set_connection代表的字符集转换为具体操作的列使用的字符集之后再进行操作。</li><li>将从某个列获取到的字节串从该列使用的字符集转换为character_set_results代表的字符集后发送到客户端。</li><li>客户端使用操作系统的字符集解析收到的结果集字节串。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639999607440-c7181f59-0354-43bd-b896-d3bd722cadc4.png" alt="image.png"></p><p>在这个过程中各个系统变量的含义如下：</p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。</p><p><strong>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap源码解读</title>
      <link href="/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/"/>
      <url>/2022/01/05/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>#1.成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//散列表数组的最大限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并发级别：jdk7历史遗留问题，仅仅在初始化的时候使用到，并不是真正的代表并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，JDK1.8中 ConcurrentHashMap 是固定值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树化阈值，指定桶位 链表长度达到8的话，有可能发生树化操作。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树转化为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合TREEIFY_THRESHOLD控制桶位是否树化，只有当table数组长度达到64且 某个桶位 中的链表长度达到8，才会真正树化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程迁移数据最小步长，控制线程迁移任务最小区间一个值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算扩容时候生成的一个 标识戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是65535 表示并发扩容最多线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容相关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当node节点hash=-1 表示当前节点已经被迁移了  ，fwd节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//node hash=-2 表示当前节点已经树化 且 当前节点为treebin对象  ，代理操作红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="comment">//转化成二进制实际上是 31个 1  可以将一个负数通过位移运算得到一个正数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前系统的cpu数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了兼容7版本的chp保存的，核心代码并没有使用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segments&quot;</span>, Segment[].class),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField(<span class="string">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表，长度一定是2次方数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容过程中，会将扩容中的新table 赋值给nextTable 保持引用，扩容结束之后，这里会被设置为Null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LongAdder 中的 baseCount 未发生竞争时 或者 当前LongAdder处于加锁状态时，增量累到到baseCount中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment"> * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment"> * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment"> * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扩容过程中，记录当前进度。所有线程都需要从transferIndex中分配区间任务，去执行自己的任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cellsBuzy 0表示当前LongAdder对象无锁状态，1表示当前LongAdder对象加锁状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LongAdder中的cells数组，当baseCount发生竞争后，会创建cells数组，</span></span><br><span class="line"><span class="comment"> * 线程会通过计算hash值 取到 自己的cell ，将增量累加到指定cell中</span></span><br><span class="line"><span class="comment"> * 总数 = sum(cells) + baseCount</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line"><span class="comment">/**表示sizeCtl属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"><span class="comment">/**表示transferIndex属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TRANSFERINDEX;</span><br><span class="line"><span class="comment">/**表示baseCount属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BASECOUNT;</span><br><span class="line"><span class="comment">/**表示cellsBusy属性在ConcurrentHashMap中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLSBUSY;</span><br><span class="line"><span class="comment">/**表示cellValue属性在CounterCell中内存偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CELLVALUE;</span><br><span class="line"><span class="comment">/**表示数组第一个元素的偏移地址*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABASE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class="line">        SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br><span class="line">                TRANSFERINDEX = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;transferIndex&quot;</span>));</span><br><span class="line">                BASECOUNT = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;baseCount&quot;</span>));</span><br><span class="line">                CELLSBUSY = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;cellsBusy&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ck = CounterCell.class;</span><br><span class="line">        CELLVALUE = U.objectFieldOffset</span><br><span class="line">                (ck.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">                Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">        ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">                <span class="comment">//表示数组单元所占用空间大小,scale 表示Node[]数组中每一个单元所占用空间大小</span></span><br><span class="line">                <span class="keyword">int</span> scale = U.arrayIndexScale(ak);</span><br><span class="line">                <span class="comment">//1 0000 &amp; 0 1111 = 0</span></span><br><span class="line">                <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">                <span class="comment">//numberOfLeadingZeros() 这个方法是返回当前数值转换为二进制后，从高位到低位开始统计，看有多少个0连续在一块。</span></span><br><span class="line">                <span class="comment">//8 =&gt; 1000 numberOfLeadingZeros(8) = 28</span></span><br><span class="line">                <span class="comment">//4 =&gt; 100 numberOfLeadingZeros(4) = 29</span></span><br><span class="line">                <span class="comment">//ASHIFT = 31 - 29 = 2 ？？</span></span><br><span class="line">                <span class="comment">//ABASE + （5 &lt;&lt; ASHIFT）</span></span><br><span class="line">                ASHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>#2.基础方法<br>##2.1 spread<br>高位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.2 tabAt<br>该方法获取对象中offset偏移地址对应的对象field的值。实际上这段代码的含义等价于tab[i],但是为什么不直接使用 tab[i]来计算呢？</p><p>getObjectVolatile，一旦看到 volatile 关键字，就表示可见性。因为对 volatile 写操作 happen-before 于 volatile 读操作，因此其他线程对 table 的修改均对 get 读取可见；</p><p>虽然 table 数组本身是增加了 volatile 属性，但是“volatile 的数组只针对数组的引用具有volatile 的语义，而不是它的元素”。 所以如果有其他线程对这个数组的元素进行写操作，那么当前线程来读的时候不一定能读到最新的值。出于性能考虑，Doug Lea 直接通过 Unsafe 类来对 table 进行操作。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/tabAt.png" alt="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.3 casTabAt<br>cas设置当前节点为桶位的头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.4 setTabAt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2.5 resizeStamp<br>resizeStamp 用来生成一个和扩容有关的扩容戳，具体有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer.numberOfLeadingZeros 这个方法是返回无符号整数 n 最高位非 0 位前面的 0 的个数。</p><p>比如 10 的二进制是 0000 0000 0000 0000 0000 0000 0000 1010，那么这个方法返回的值就是 28。</p><p>根据 resizeStamp 的运算逻辑，我们来推演一下，假如 n=16，那么 resizeStamp(16)=32796转化为二进制是[0000 0000 0000 0000 1000 0000 0001 1100]</p><p>接着再来看,当第一个线程尝试进行扩容的时候，会执行下面这段代码：</p><p><code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code><br>rs 左移 16 位，相当于原本的二进制低位变成了高位 1000 0000 0001 1100 0000 0000 00000000</p><p>然后再+2 =1000 0000 0001 1100 0000 0000 0000 0000+10=1000 0000 0001 1100 0000 00000000 0010</p><p><strong>高 16 位代表扩容的标记、低 16 位代表并行扩容的线程数</strong></p><p>这样来存储有什么好处呢？</p><p>1，首先在 CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责</p><p>2，可以保证每次扩容都生成唯一的生成戳，每次新的扩容，都有一个不同的 n，这个生成戳就是根据 n 来计算出来的一个数字，n 不同，这个数字也不同</p><p>第一个线程尝试扩容的时候，为什么是+2</p><p>因为 1 表示初始化，2 表示一个线程在执行扩容，而且对 sizeCtl 的操作都是基于位运算的，所以不会关心它本身的数值是多少，只关心它在二进制上的数值，而 sc + 1 会在低 16 位上加 1。<br>##2.6 tableSizeFor<br>经过多次位移返回大于等于c的最小的二次方数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two table size for the given desired capacity.</span></span><br><span class="line"><span class="comment">     * See Hackers Delight, sec 3.2</span></span><br><span class="line"><span class="comment">     * 返回&gt;=c的最小的2的次方数</span></span><br><span class="line"><span class="comment">     * c=28</span></span><br><span class="line"><span class="comment">     * n=27 =&gt; 0b 11011</span></span><br><span class="line"><span class="comment">     * 11011 | 01101 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * 11111 | 00111 =&gt; 11111</span></span><br><span class="line"><span class="comment">     * ....</span></span><br><span class="line"><span class="comment">     * =&gt; 11111 + 1 =100000 = 32</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#3. 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果指定的容量超过允许的最大值，设置为最大值</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果初始容量小于并发级别，那就设置初始容量为并发级别</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   </span><br><span class="line">        initialCapacity = concurrencyLevel;   </span><br><span class="line">    <span class="comment">//16/0.75 +1 = 22</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 22 - &gt; 32</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">         * 当目前table未初始化时，sizeCtl表示初始化容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#4.put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果key已经存在，是否覆盖，默认是false</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#5 putVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制k 和 v 不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过spread方法，可以让高位也能参与进寻址运算。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//binCount表示当前k-v 封装成node后插入到指定桶位后，在桶位中的所属链表的下标位置</span></span><br><span class="line">    <span class="comment">//0 表示当前桶位为null，node可以直接放着</span></span><br><span class="line">    <span class="comment">//2 表示当前桶位已经可能是红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tab 引用map对象的table</span></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f 表示桶位的头结点</span></span><br><span class="line">        <span class="comment">//n 表示散列表数组的长度</span></span><br><span class="line">        <span class="comment">//i 表示key通过寻址计算后，得到的桶位下标</span></span><br><span class="line">        <span class="comment">//fh 表示桶位头结点的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：成立，表示当前map中的table尚未初始化..</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//最终当前线程都会获取到最新的map.table引用。</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//CASE2：i 表示key使用路由寻址算法得到 key对应 table数组的下标位置，tabAt 获取指定桶位的头结点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进入到CASE2代码块 前置条件 当前table数组i桶位是Null时。</span></span><br><span class="line">            <span class="comment">//使用CAS方式 设置 指定数组i桶位 为 new Node&lt;K,V&gt;(hash, key, value, null),并且期望值是null</span></span><br><span class="line">            <span class="comment">//cas操作成功 表示ok，直接break for循环即可</span></span><br><span class="line">            <span class="comment">//cas操作失败，表示在当前线程之前，有其它线程先你一步向指定i桶位设置值了。</span></span><br><span class="line">            <span class="comment">//当前线程只能再次自旋，去走其它逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3：前置条件，桶位的头结点一定不是null。</span></span><br><span class="line">        <span class="comment">//条件成立表示当前桶位的头结点 为 FWD结点，表示目前map正处于扩容过程中..</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//看到fwd节点后，当前节点有义务帮助当前map对象完成迁移数据的工作</span></span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE4：当前桶位 可能是 链表 也可能是 红黑树代理结点TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当插入key存在时，会将旧值赋值给oldVal，返回给put方法调用处..</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用sync 加锁“头节点”，理论上是“头结点”</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//为什么又要对比一下，看看当前桶位的头节点 是否为 之前获取的头结点？</span></span><br><span class="line">                <span class="comment">//为了避免其它线程将该桶位的头结点修改掉，导致当前线程从sync 加锁 就有问题了。之后所有操作都不用在做了。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;<span class="comment">//条件成立，说明咱们 加锁 的对象没有问题，可以进来造了！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立，说明当前桶位就是普通链表桶位。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//1.当前插入key与链表当中所有元素的key都不一致时，当前的插入操作是追加到链表的末尾，binCount表示链表长度</span></span><br><span class="line">                        <span class="comment">//2.当前插入key与链表当中的某个元素的key一致时，当前插入操作可能就是替换了。binCount表示冲突位置（binCount - 1）</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代循环当前桶位的链表，e是每次循环处理节点。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//当前循环节点 key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash 成立 表示循环的当前元素的hash值与插入节点的hash值一致，需要进一步判断</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key ||(ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//       成立：说明循环的当前节点与插入节点的key一致，发生冲突了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//将当前循环的元素的 值 赋值给oldVal</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前元素 与 插入元素的key不一致 时，会走下面程序。</span></span><br><span class="line">                            <span class="comment">//1.更新循环处理节点为 当前节点的下一个节点</span></span><br><span class="line">                            <span class="comment">//2.判断下一个节点是否为null，如果是null，说明当前节点已经是队尾了，插入数据需要追加到队尾节点的后面。</span></span><br><span class="line"></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//前置条件，该桶位一定不是链表</span></span><br><span class="line">                    <span class="comment">//条件成立，表示当前桶位是 红黑树代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//p 表示红黑树中如果与你插入节点的key 有冲突节点的话 ，则putTreeVal 方法 会返回冲突节点的引用。</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        <span class="comment">//强制设置binCount为2，因为binCount &lt;= 1 时有其它含义，所以这里设置为了2 </span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：成立，说明当前插入节点的key与红黑树中的某个节点的key一致，冲突了</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将冲突节点的值 赋值给 oldVal</span></span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明当前桶位不为null，可能是红黑树 也可能是链表</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果binCount&gt;=8 表示处理的桶位一定是链表</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//调用转化链表为红黑树的方法</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//说明当前线程插入的数据key，与原有k-v发生冲突，需要将原数据v返回给调用者。</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.统计当前table一共有多少数据</span></span><br><span class="line">    <span class="comment">//2.判断是否达到扩容阈值标准，触发扩容。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#6 initTable<br>数组初始化方法，这个方法比较简单，就是初始化一个合适大小的数组。</p><p>sizeCtl ：这个标志是在 Node 数组初始化或者扩容的时候的一个控制位标识，负数代表正在进行初始化或者扩容操作。</p><p>-1 代表正在初始化</p><p>-N 代表有 N-1 个线程正在进行扩容操作，这里不是简单的理解成 n 个线程，sizeCtl 就是-N</p><p>0 标识 Node 数组还没有被初始化，正数代表初始化或者下一次扩容的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">     *      * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">     *      * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">     *      *</span></span><br><span class="line"><span class="comment">     *      * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">     *      * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//sc sizeCtl的临时值</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//自旋 条件：map.table 尚未初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//大概率就是-1，表示其它线程正在进行创建table的过程，当前线程没有竞争到初始化table的锁。</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line">        <span class="comment">//2.如果table未初始化，表示初始化大小</span></span><br><span class="line">        <span class="comment">//3.如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里为什么又要判断呢？ 防止其它线程已经初始化完毕了，然后当前线程再次初始化..导致丢失数据。</span></span><br><span class="line">                <span class="comment">//条件成立，说明其它线程都没有进入过这个if块，当前线程就是具备初始化table权利了。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sc大于0 创建table时 使用 sc为指定大小，否则使用 16 默认值.</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//最终赋值给 map.table</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//n &gt;&gt;&gt; 2  =&gt; 等于 1/4 n     n - (1/4)n = 3/4 n =&gt; 0.75 * n</span></span><br><span class="line">                    <span class="comment">//sc 0.75 n 表示下一次扩容时的触发条件。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//1.如果当前线程是第一次创建map.table的线程话，sc表示的是 下一次扩容的阈值</span></span><br><span class="line">                <span class="comment">//2.表示当前线程 并不是第一次创建map.table的线程，当前线程进入到else if 块 时，将</span></span><br><span class="line">                <span class="comment">//sizeCtl 设置为了-1 ，那么这时需要将其修改为 进入时的值。</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#7 addCount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//as 表示 LongAdder.cells</span></span><br><span class="line">    <span class="comment">//b 表示LongAdder.base</span></span><br><span class="line">    <span class="comment">//s 表示当前map.table中元素的数量</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//条件一：true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">    <span class="comment">//       false-&gt;表示当前线程应该将数据累加到 base</span></span><br><span class="line">    <span class="comment">//条件二：false-&gt;表示写base成功，数据累加到base中了，当前竞争不激烈，不需要创建cells</span></span><br><span class="line">    <span class="comment">//       true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">//有几种情况进入到if块中？</span></span><br><span class="line">        <span class="comment">//1.true-&gt;表示cells已经初始化了，当前线程应该去使用hash寻址找到合适的cell 去累加数据</span></span><br><span class="line">        <span class="comment">//2.true-&gt;表示写base失败，与其他线程在base上发生了竞争，当前线程应该去尝试创建cells。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a 表示当前线程hash寻址命中的cell</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//v 表示当前线程写cell时的期望值</span></span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//m 表示当前cells数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//true -&gt; 未竞争  false-&gt;发生竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：as == null || (m = as.length - 1) &lt; 0</span></span><br><span class="line">        <span class="comment">//true-&gt; 表示当前线程是通过 写base竞争失败 然后进入的if块，就需要调用fullAddCount方法去扩容 或者 重试.. LongAdder.longAccumulate</span></span><br><span class="line">        <span class="comment">//条件二：a = as[ThreadLocalRandom.getProbe() &amp; m]) == null   前置条件：cells已经初始化了</span></span><br><span class="line">        <span class="comment">//true-&gt;表示当前线程命中的cell表格是个空，需要当前线程进入fullAddCount方法去初始化 cell，放入当前位置.</span></span><br><span class="line">        <span class="comment">//条件三：!(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)</span></span><br><span class="line">        <span class="comment">//      false-&gt;取反得到false，表示当前线程使用cas方式更新当前命中的cell成功</span></span><br><span class="line">        <span class="comment">//      true-&gt;取反得到true,表示当前线程使用cas方式更新当前命中的cell失败，需要进入fullAddCount进行重试 或者 扩容 cells。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">           ) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">//考虑到fullAddCount里面的事情比较累，就让当前线程 不参与到 扩容相关的逻辑了，直接返回到调用点。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前散列表元素个数，这是一个期望值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示一定是一个put操作调用的addCount</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//tab 表示map.table</span></span><br><span class="line">        <span class="comment">//nt 表示map.nextTable</span></span><br><span class="line">        <span class="comment">//n 表示map.table数组的长度</span></span><br><span class="line">        <span class="comment">//sc 表示sizeCtl的临时值</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * sizeCtl &lt; 0</span></span><br><span class="line"><span class="comment">             * 1. -1 表示当前table正在初始化（有线程在创建table数组），当前线程需要自旋等待..</span></span><br><span class="line"><span class="comment">             * 2.表示当前table数组正在进行扩容 ,高16位表示：扩容的标识戳   低16位表示：（1 + nThread） 当前参与并发扩容的线程数量</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl = 0，表示创建table数组时 使用DEFAULT_CAPACITY为大小</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * sizeCtl &gt; 0</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. 如果table未初始化，表示初始化大小</span></span><br><span class="line"><span class="comment">             * 2. 如果table已经初始化，表示下次扩容时的 触发条件（阈值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="comment">//条件一：s &gt;= (long)(sc = sizeCtl)</span></span><br><span class="line">        <span class="comment">//       true-&gt; 1.当前sizeCtl为一个负数 表示正在扩容中..</span></span><br><span class="line">        <span class="comment">//              2.当前sizeCtl是一个正数，表示扩容阈值</span></span><br><span class="line">        <span class="comment">//       false-&gt; 表示当前table尚未达到扩容条件</span></span><br><span class="line">        <span class="comment">//条件二：(tab = table) != null</span></span><br><span class="line">        <span class="comment">//       恒成立 true</span></span><br><span class="line">        <span class="comment">//条件三：(n = tab.length) &lt; MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="comment">//       true-&gt;当前table长度小于最大值限制，则可以进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//扩容批次唯一标识戳</span></span><br><span class="line">            <span class="comment">//16 -&gt; 32 扩容 标识为：1000 0000 0001 1011</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：表示当前table正在扩容</span></span><br><span class="line">            <span class="comment">//         当前线程理论上应该协助table完成扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">                <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">                <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">                <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">                <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">                <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">                <span class="comment">//条件四：(nt = nextTable) == null</span></span><br><span class="line">                <span class="comment">//        true-&gt;表示本次扩容结束</span></span><br><span class="line">                <span class="comment">//        false-&gt;扩容正在进行中</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//前置条件：当前table正在执行扩容中.. 当前线程有机会参与进扩容。</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程成功参与到扩容任务中，并且将sc低16位值加1，表示多了一个线程参与工作</span></span><br><span class="line">                <span class="comment">//条件失败：1.当前有很多线程都在此处尝试修改sizeCtl，有其它一个线程修改成功了，导致你的sc期望值与内存中的值不一致 修改失败</span></span><br><span class="line">                <span class="comment">//        2.transfer 任务内部的线程也修改了sizeCtl。</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//协助扩容线程，持有nextTable参数</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000 +2 =&gt; 1000 0000 0001 1011 0000 0000 0000 0010</span></span><br><span class="line">            <span class="comment">//条件成立，说明当前线程是触发扩容的第一个线程，在transfer方法需要做一些扩容准备工作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//触发扩容条件的线程 不持有nextTable</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#8. transfer<br>ConcurrentHashMap 支持并发扩容，实现方式是，把 Node 数组进行拆分，让每个线程处理自己的区域，假设 table 数组总长度是 64，默认情况下，那么每个线程可以分到 16 个 bucket。然后每个线程处理的范围，按照倒序来做迁移。</p><p>通过 for 自循环处理每个槽位中的链表元素，默认 advace 为真，通过 CAS 设置 transferIndex属性值，并初始化 i 和 bound 值，i 指当前处理的槽位序号，bound 指需要处理的槽位边界，先处理槽位 31 的节点； （bound,i） =(16,31) 从 31 的位置往前推动。</p><p>每存在一个线程执行完扩容操作，就通过 cas 执行 sc-1。</p><p>接着判断(sc-2) !=resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT ; 如果相等，表示当前为整个扩容操作的 最后一个线程，那么意味着整个扩容操作就结束了；如果不相等，说明还得继续。</p><p>这么做的目的，一方面是防止不同扩容之间出现相同的 sizeCtl，另外一方面，还可以避免sizeCtl 的 ABA 问题导致的扩容重叠的情况。</p><p><strong>扩容图解</strong><br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E6%89%A9%E5%AE%B9%E5%9B%BE%E8%A7%A3.png" alt="img.png"><br>判断是否需要扩容，也就是当更新后的键值对总数 baseCount &gt;= 阈值 sizeCtl 时，进行rehash，这里面会有两个逻辑。</p><ol><li>如果当前正在处于扩容阶段，则当前线程会加入并且协助扩容。</li><li>如果当前没有在扩容，则直接触发扩容操作。</li></ol><p>扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。</p><p>而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。</p><p>它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket会被替换为一个ForwardingNode节点，标记当前bucket已经被其他线程迁移完了。接下来分析一下它的源码实现。</p><p>fwd:这个类是个标识类，用于指向新表用的，其他线程遇到这个类会主动跳过这个类，因为这个类要么就是扩容迁移正在进行，要么就是已经完成扩容迁移，也就是这个类要保证线程安全，再进行操作。</p><p>advance:这个变量是用于提示代码是否进行推进处理，也就是当前桶处理完，处理下一个桶的标识。</p><p>finishing:这个变量用于提示扩容是否结束用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示扩容之前table数组的长度</span></span><br><span class="line">    <span class="comment">//stride 表示分配给线程任务的步长</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//  stride 固定为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件成立：表示当前线程为触发本次扩容的线程，需要做一些扩容准备工作</span></span><br><span class="line">    <span class="comment">//条件不成立：表示当前线程是协助扩容的线程..</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建了一个比扩容之前大一倍的table</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值给对象属性 nextTable ，方便协助扩容线程 拿到新表</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录迁移数据整体位置的一个标记。index计数是从1开始计算的。</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 节点，当某个桶位数据处理完毕后，将此桶位设置为fwd节点，其它写线程 或读线程看到后，会有不同逻辑。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//推进标记</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//完成标记</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//i 表示分配给当前线程任务，执行到的桶位</span></span><br><span class="line">    <span class="comment">//bound 表示分配给当前线程任务的下界限制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//f 桶位的头结点</span></span><br><span class="line">        <span class="comment">//fh 头结点的hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.给当前线程分配任务区间</span></span><br><span class="line"><span class="comment">             * 2.维护当前线程任务进度（i 表示当前处理的桶位）</span></span><br><span class="line"><span class="comment">             * 3.维护map对象全局范围内的进度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">//分配任务的开始下标</span></span><br><span class="line">            <span class="comment">//分配任务的结束下标</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//CASE1:</span></span><br><span class="line">            <span class="comment">//条件一：--i &gt;= bound</span></span><br><span class="line">            <span class="comment">//成立：表示当前线程的任务尚未完成，还有相应的区间的桶位要处理，--i 就让当前线程处理下一个 桶位.</span></span><br><span class="line">            <span class="comment">//不成立：表示当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CASE2:</span></span><br><span class="line">            <span class="comment">//前置条件：当前线程任务已完成 或 者未分配</span></span><br><span class="line">            <span class="comment">//条件成立：表示对象全局范围内的桶位都分配完毕了，没有区间可分配了，设置当前线程的i变量为-1 跳出循环后，执行退出迁移任务相关的程序</span></span><br><span class="line">            <span class="comment">//条件不成立：表示对象全局范围内的桶位尚未分配完毕，还有区间可分配</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//CASE3:</span></span><br><span class="line">            <span class="comment">//前置条件：1、当前线程需要分配任务区间  2.全局范围内还有桶位尚未迁移</span></span><br><span class="line">            <span class="comment">//条件成立：说明给当前线程分配任务成功</span></span><br><span class="line">            <span class="comment">//条件失败：说明分配给当前线程失败，应该是和其它线程发生了竞争吧</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：i &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：表示当前线程未分配到任务</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//保存sizeCtl 的变量</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明设置sizeCtl 低16位  -1 成功，当前线程可以正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//1000 0000 0001 1011 0000 0000 0000 0000</span></span><br><span class="line">                <span class="comment">//条件成立：说明当前线程不是最后一个退出transfer任务的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//正常退出</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前置条件：【CASE2~CASE4】 当前线程任务尚未处理完，正在进行中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位未存放数据，只需要将此处设置为fwd节点即可。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前桶位已经迁移过了，当前线程不用再处理了，直接再次更新当前线程任务索引，再次处理下一个桶位 或者 其它操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//CASE4:</span></span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据，而且node节点 不是 fwd节点，说明这些数据需要迁移。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//sync 加锁当前桶位的头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//防止在你加锁头对象之前，当前桶位的头对象被其它写线程修改过，导致你目前加锁对象错误...</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//ln 表示低位链表引用</span></span><br><span class="line">                    <span class="comment">//hn 表示高位链表引用</span></span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是链表桶位</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lastRun</span></span><br><span class="line">                        <span class="comment">//可以获取出 当前链表 末尾连续高位不变的 node</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件成立：说明lastRun引用的链表为 低位链表，那么就让 ln 指向 低位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//否则，说明lastRun引用的链表为 高位链表，就让 hn 指向 高位链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//条件成立：表示当前桶位是 红黑树 代理结点TreeBin</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//转换头结点为 treeBin引用 t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//低位双向链表 lo 指向低位链表的头  loTail 指向低位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//高位双向链表 lo 指向高位链表的头  loTail 指向高位链表的尾巴</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lc 表示低位链表元素数量</span></span><br><span class="line">                        <span class="comment">//hc 表示高位链表元素数量</span></span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//迭代TreeBin中的双向链表，从头结点 至 尾节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="comment">// h 表示循环处理当前元素的 hash</span></span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">//使用当前节点 构建出来的 新的 TreeNode</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件成立：表示当前循环节点 属于低位链 节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//条件成立：说明当前低位链表 还没有数据</span></span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="comment">//说明 低位链表已经有数据了，此时当前元素 追加到 低位链表的末尾就行了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                <span class="comment">//将低位链表尾指针指向 p 节点</span></span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//当前节点 属于 高位链 节点</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                        (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                        (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表迁移原理</p><p>1）高低位原理分析</p><p>ConcurrentHashMap 在做链表迁移时，会用高低位来实现，这里有两个问题要分析一下</p><p>1，如何实现高低位链表的区分</p><p>假如有这样一个队列<br><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/concurrenthashmap%E8%BF%81%E7%A7%BB%E9%AB%98%E4%BD%8E%E4%BD%8D%E5%8E%9F%E7%90%861.png" alt="img_1.png"><br>第 14 个槽位插入新节点之后，链表元素个数已经达到了 8，且数组长度为 16，优先通过扩容来缓解链表过长的问题</p><p>假如当前线程正在处理槽位为 14 的节点，它是一个链表结构，在代码中，首先定义两个变量节点 ln 和 hn，实际就是 lowNode 和 HighNode，分别保存 hash 值的第 x 位为 0 和不等于0 的节点</p><p>通过 fn&amp;n 可以把这个链表中的元素分为两类，A 类是 hash 值的第 X 位为 0，B 类是 hash 值的第 x 位为不等于 0（至于为什么要这么区分，稍后分析），并且通过 lastRun 记录最后要处理的节点。最终要达到的目的是，A 类的链表保持位置不动，B 类的链表为 14+16(扩容增加的长度)=30</p><p>把 14 槽位的链表单独伶出来，用蓝色表示 fn&amp;n=0 的节点，假如链表的分类是这样</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/ffb2efa924944e02b25e97a2b90bf6f5.png" alt="111"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line"><span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line"><span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">        runBit = b;</span><br><span class="line">        lastRun = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这段代码遍历，会记录 runBit 以及 lastRun，按照上面这个结构，那么 runBit 应该是蓝色节点，lastRun 应该是第 6 个节点接着，再通过这段代码进行遍历，生成 ln 链以及 hn 链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/3914c7b94d2843b985ea10e5c23a04b0.png" alt="111"><br>接着，通过 CAS 操作，把 hn 链放在 i+n 也就是 14+16 的位置，ln 链保持原来的位置不动。并且设置当前节点为 fwd，表示已经被当前线程迁移完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><p>迁移完成以后的数据分布如下</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/e7e01e24e3e844c7b31c4d73da2fffed.png" alt="111"><br>2）为什么要做高低位的划分</p><p>要想了解这么设计的目的，我们需要从 ConcurrentHashMap 的根据下标获取对象的算法来看，在 putVal 方法中 1018 行：</p><p><code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code></p><p>通过(n-1) &amp; hash 来获得在 table 中的数组下标来获取节点数据，【&amp;运算是二进制运算符，1&amp; 1=1，其他都为 0】。</p><p><img src="/images/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/db389ed8b874494ca1f5a8723e8a6973.png" alt="111"><br>#9.helpTransfer<br>如果对应的节点存在，判断这个节点的 hash 是不是等于 MOVED(-1)，说明当前节点是ForwardingNode 节点，意味着有其他线程正在进行扩容，那么当前现在直接帮助它进行扩容，因此调用 helpTransfer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    <span class="comment">//nextTab 引用的是 fwd.nextTable == map.nextTable 理论上是这样。</span></span><br><span class="line">    <span class="comment">//sc 保存map.sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：tab != null 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件二：(f instanceof ForwardingNode) 恒成立 true</span></span><br><span class="line">    <span class="comment">//条件三：((ForwardingNode&lt;K,V&gt;)f).nextTable) != null 恒成立 true</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿当前标的长度 获取 扩容标识戳   假设 16 -&gt; 32 扩容：1000 0000 0001 1011</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件一：nextTab == nextTable</span></span><br><span class="line">        <span class="comment">//成立：表示当前扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：1.nextTable被设置为Null 了，扩容完毕后，会被设为Null</span></span><br><span class="line">        <span class="comment">//       2.再次出发扩容了...咱们拿到的nextTab 也已经过期了...</span></span><br><span class="line">        <span class="comment">//条件二：table == tab</span></span><br><span class="line">        <span class="comment">//成立：说明 扩容正在进行中，还未完成</span></span><br><span class="line">        <span class="comment">//不成立：说明扩容已经结束了，扩容结束之后，最后退出的线程 会设置 nextTable 为 table</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件三：(sc = sizeCtl) &lt; 0</span></span><br><span class="line">        <span class="comment">//成立：说明扩容正在进行中</span></span><br><span class="line">        <span class="comment">//不成立：说明sizeCtl当前是一个大于0的数，此时代表下次扩容的阈值，当前扩容已经结束。</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件一：(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明当前线程获取到的扩容唯一标识戳 非 本批次扩容</span></span><br><span class="line">            <span class="comment">//      false-&gt;说明当前线程获取到的扩容唯一标识戳 是 本批次扩容</span></span><br><span class="line">            <span class="comment">//条件二： JDK1.8 中有bug jira已经提出来了 其实想表达的是 =  sc == (rs &lt;&lt; 16 ) + 1</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示扩容完毕，当前线程不需要再参与进来了</span></span><br><span class="line">            <span class="comment">//        false-&gt;扩容还在进行中，当前线程可以参与</span></span><br><span class="line">            <span class="comment">//条件三：JDK1.8 中有bug jira已经提出来了 其实想表达的是 = sc == (rs&lt;&lt;16) + MAX_RESIZERS</span></span><br><span class="line">            <span class="comment">//        true-&gt; 表示当前参与并发扩容的线程达到了最大值 65535 - 1</span></span><br><span class="line">            <span class="comment">//        false-&gt;表示当前线程可以参与进来</span></span><br><span class="line">            <span class="comment">//条件四：transferIndex &lt;= 0</span></span><br><span class="line">            <span class="comment">//      true-&gt;说明map对象全局范围内的任务已经分配完了，当前线程进去也没活干..</span></span><br><span class="line">            <span class="comment">//      false-&gt;还有任务可以分配。</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#10.get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab 引用map.table</span></span><br><span class="line">    <span class="comment">//e 当前元素</span></span><br><span class="line">    <span class="comment">//p 目标节点</span></span><br><span class="line">    <span class="comment">//n table数组长度</span></span><br><span class="line">    <span class="comment">//eh 当前元素hash</span></span><br><span class="line">    <span class="comment">//ek 当前元素key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//扰动运算后得到 更散列的hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件一：(tab = table) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;表示已经put过数据，并且map内部的table也已经初始化完毕</span></span><br><span class="line">    <span class="comment">//false-&gt;表示创建完map后，并没有put过数据，map内部的table是延迟初始化的，只有第一次写数据时会触发创建逻辑。</span></span><br><span class="line">    <span class="comment">//条件二：(n = tab.length) &gt; 0 true-&gt;表示table已经初始化</span></span><br><span class="line">    <span class="comment">//条件三：(e = tabAt(tab, (n - 1) &amp; h)) != null</span></span><br><span class="line">    <span class="comment">//true-&gt;当前key寻址的桶位 有值</span></span><br><span class="line">    <span class="comment">//false-&gt;当前key寻址的桶位中是null，是null直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//前置条件：当前桶位有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比头结点hash与查询key的hash是否一致</span></span><br><span class="line">        <span class="comment">//条件成立：说明头结点与查询Key的hash值 完全一致</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="comment">//完全比对 查询key 和 头结点的key</span></span><br><span class="line">            <span class="comment">//条件成立：说明头结点就是查询数据</span></span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件成立：</span></span><br><span class="line">        <span class="comment">//1.-1  fwd 说明当前table正在扩容，且当前查询的这个桶位的数据 已经被迁移走了</span></span><br><span class="line">        <span class="comment">//2.-2  TreeBin节点，需要使用TreeBin 提供的find 方法查询。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前桶位已经形成链表的这种情况</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#11.remove</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#12.replaceNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算key经过扰动运算后的hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//f表示桶位头结点</span></span><br><span class="line">        <span class="comment">//n表示当前table数组长度</span></span><br><span class="line">        <span class="comment">//i表示hash命中桶位下标</span></span><br><span class="line">        <span class="comment">//fh表示桶位头结点 hash</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE1：</span></span><br><span class="line">        <span class="comment">//条件一：tab == null  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件二：(n = tab.length) == 0  true-&gt;表示当前map.table尚未初始化..  false-&gt;已经初始化</span></span><br><span class="line">        <span class="comment">//条件三：(f = tabAt(tab, i = (n - 1) &amp; hash)) == null true -&gt; 表示命中桶位中为null，直接break， 会返回</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE2：</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//条件成立：说明当前table正在扩容中，当前是个写操作，所以当前线程需要协助table完成扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CASE3:</span></span><br><span class="line">        <span class="comment">//前置条件CASE2 ~ CASE3：当前桶位不是null</span></span><br><span class="line">        <span class="comment">//当前桶位 可能是 &quot;链表&quot; 也可能 是  &quot;红黑树&quot; TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//保留替换之前的数据引用</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//校验标记</span></span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//加锁当前桶位 头结点，加锁成功之后会进入 代码块。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//判断sync加锁是否为当前桶位 头节点，防止其它线程，在当前线程加锁成功之前，修改过 桶位 的头结点。</span></span><br><span class="line">                <span class="comment">//条件成立：当前桶位头结点 仍然为f，其它线程没修改过。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//条件成立：说明桶位 为 链表 或者 单个 node</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//e 表示当前循环处理元素</span></span><br><span class="line">                        <span class="comment">//pred 表示当前循环节点的上一个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                            <span class="comment">//当前节点key</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//条件一：e.hash == hash true-&gt;说明当前节点的hash与查找节点hash一致</span></span><br><span class="line">                            <span class="comment">//条件二：((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span></span><br><span class="line">                            <span class="comment">//if 条件成立，说明key 与查询的key完全一致。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//当前节点的value</span></span><br><span class="line">                                V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件一：cv == null true-&gt;替换的值为null 那么就是一个删除操作</span></span><br><span class="line">                                <span class="comment">//条件二：cv == ev || (ev != null &amp;&amp; cv.equals(ev))  那么是一个替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    <span class="comment">//删除 或者 替换</span></span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//将当前节点的值 赋值给 oldVal 后续返回会用到</span></span><br><span class="line">                                    oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">//条件成立：说明当前是一个替换操作</span></span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//直接替换</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="comment">//条件成立：说明当前节点非头结点</span></span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">//当前节点的上一个节点，指向当前节点的下一个节点。</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">//说明当前节点即为 头结点，只需要将 桶位设置为头结点的下一个节点。</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//条件成立：TreeBin节点。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//转换为实际类型 TreeBin t</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        <span class="comment">//r 表示 红黑树 根节点</span></span><br><span class="line">                        <span class="comment">//p 表示 红黑树中查找到对应key 一致的node</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//条件一：(r = t.root) != null 理论上是成立</span></span><br><span class="line">                        <span class="comment">//条件二：TreeNode.findTreeNode 以当前节点为入口，向下查找key（包括本身节点）</span></span><br><span class="line">                        <span class="comment">//      true-&gt;说明查找到相应key 对应的node节点。会赋值给p</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//保存p.val 到pv</span></span><br><span class="line">                            V pv = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//条件一：cv == null  成立：不必对value，就做替换或者删除操作</span></span><br><span class="line">                            <span class="comment">//条件二：cv == pv ||(pv != null &amp;&amp; cv.equals(pv)) 成立：说明“对比值”与当前p节点的值 一致</span></span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                <span class="comment">//替换或者删除操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                oldVal = pv;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//条件成立：替换操作</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                <span class="comment">//删除操作</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    <span class="comment">//这里没做判断，直接搞了...很疑惑</span></span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当其他线程修改过桶位 头结点时，当前线程 sync 头结点 锁错对象时，validated 为false，会进入下次for 自旋</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//替换的值 为null，说明当前是一次删除操作，oldVal ！=null 成立，说明删除成功，更新当前元素个数计数器。</span></span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#13.TreeBin<br>##13.1 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树 根节点 </span></span><br><span class="line">TreeNode&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//链表的头节点</span></span><br><span class="line"><span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line"><span class="comment">//等待者线程（当前lockState是读锁状态）</span></span><br><span class="line"><span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.写锁状态 写是独占状态，以散列表来看，真正进入到TreeBin中的写线程 同一时刻 只有一个线程。 1</span></span><br><span class="line"><span class="comment">         * 2.读锁状态 读锁是共享，同一时刻可以有多个线程 同时进入到 TreeBin对象中获取数据。 每一个线程 都会给 lockStat + 4</span></span><br><span class="line"><span class="comment">         * 3.等待者状态（写线程在等待），当TreeBin中有读线程目前正在读取数据时，写线程无法修改数据，那么就将lockState的最低2位 设置为 0b 10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// values for lockState</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br></pre></td></tr></table></figure><p>##13.2 构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">    <span class="comment">//设置节点hash为-2 表示此节点是TreeBin节点</span></span><br><span class="line">    <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//使用first 引用 treeNode链表</span></span><br><span class="line">    <span class="keyword">this</span>.first = b;</span><br><span class="line">    <span class="comment">//r 红黑树的根节点引用</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x表示遍历的当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//强制设置当前插入节点的左右子树为null</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//条件成立：说明当前红黑树 是一个空树，那么设置插入元素 为根节点</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点的父节点 一定为 null</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//颜色改为黑色</span></span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//让r引用x所指向的对象。</span></span><br><span class="line">            r = x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非第一次循环，都会来带else分支，此时红黑树已经有数据了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//k 表示 插入节点的key</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//h 表示 插入节点的hash</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//kc 表示 插入节点key的class类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//p 表示 为查找插入节点的父节点的一个临时节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//dir (-1, 1)</span></span><br><span class="line">                <span class="comment">//-1 表示插入节点的hash值大于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//1 表示插入节点的hash值 小于 当前p节点的hash</span></span><br><span class="line">                <span class="comment">//ph p表示 为查找插入节点的父节点的一个临时节点的hash</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//临时节点 key</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点的hash值 小于 当前节点</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的左子节点 或者 继续在左子树上查找</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//插入节点的hash值 大于 当前节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    <span class="comment">//插入节点可能需要插入到当前节点的右子节点 或者 继续在右子树上查找</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果执行到 CASE3，说明当前插入节点的hash 与 当前节点的hash一致，会在case3 做出最终排序。最终</span></span><br><span class="line">                <span class="comment">//拿到的dir 一定不是0，（-1， 1）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//xp 想要表示的是 插入节点的 父节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//条件成立：说明当前p节点 即为插入节点的父节点</span></span><br><span class="line">                <span class="comment">//条件不成立：说明p节点 底下还有层次，需要将p指向 p的左子节点 或者 右子节点，表示继续向下搜索。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置插入节点的父节点 为 当前节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//小于P节点，需要插入到P节点的左子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//大于P节点，需要插入到P节点的右子节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//插入节点后，红黑树性质 可能会被破坏，所以需要调用 平衡方法</span></span><br><span class="line">                    r = balanceInsertion(r, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将r 赋值给 TreeBin对象的 root引用。</span></span><br><span class="line">    <span class="keyword">this</span>.root = r;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.3 putTreeVal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = root = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.findTreeNode(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前循环节点xp 即为 x 节点的爸爸</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//x 表示插入节点</span></span><br><span class="line">            <span class="comment">//f 老的头结点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(h, k, v, f, xp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//条件成立：说明链表有数据</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//设置老的头结点的前置引用为 当前的头结点。</span></span><br><span class="line">                f.prev = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//表示 当前新插入节点后，新插入节点 与 父节点 形成 “红红相连”</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//平衡红黑树，使其再次符合规范。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##13.4 find</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//e 表示循环迭代的当前节点   迭代的是first引用的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="comment">//s 保存的是lock临时状态</span></span><br><span class="line">            <span class="comment">//ek 链表当前节点 的key</span></span><br><span class="line">            <span class="keyword">int</span> s; K ek;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//(WAITER|WRITER) =&gt; 0010 | 0001 =&gt; 0011</span></span><br><span class="line">            <span class="comment">//lockState &amp; 0011 != 0 条件成立：说明当前TreeBin 有等待者线程 或者 目前有写操作线程正在加锁</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER|WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前置条件：当前TreeBin中 等待者线程 或者 写线程 都没有</span></span><br><span class="line">            <span class="comment">//条件成立：说明添加读锁成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s,</span><br><span class="line">                                         s + READER)) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//查询操作</span></span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> :</span><br><span class="line">                         r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//w 表示等待者线程</span></span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">//U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER)</span></span><br><span class="line">                    <span class="comment">//1.当前线程查询红黑树结束，释放当前线程的读锁 就是让 lockstate 值 - 4</span></span><br><span class="line">                    <span class="comment">//(READER|WAITER) = 0110 =&gt; 表示当前只有一个线程在读，且“有一个线程在等待”</span></span><br><span class="line">                    <span class="comment">//当前读线程为 TreeBin中的最后一个读线程。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.(w = waiter) != null 说明有一个写线程在等待读操作全部结束。</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) ==</span><br><span class="line">                        (READER|WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用unpark 让 写线程 恢复运行状态。</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#总结<br>在java8中，ConcurrentHashMap使用数组+链表+红黑树的组合方式，利用cas和synchronized保证并发写的安全。</p><p>引入红黑树的原因：链表查询的时间复杂度为On，但是红黑树的查询时间复杂度为O(log(n)),所以在节点比较多的情况下，使用红黑树可以大大提升性能。</p><p>链式桶是一个由node节点组成的链表。树状桶是一颗由TreeNode节点组成的红黑树。输的根节点为TreeBin类型。</p><p>当链表长度大于8整个hash表长度大于64的时候，就会转化为TreeBin。TreeBin作为根节点，其实就是红黑树对象。在ConcurrentHashMap的table数组中，存放的就是TreeBin对象，而不是TreeNoe对象。</p><p>数组table是懒加载的，只有第一次添加元素的时候才会初始化，所以initTable()存在线程安全问题。</p><p>重要的属性就是sizeCtl，用来控制table的初始化和扩容操作的过程：</p><p>● -1代表table正在初始化，其他线程直接join等待。</p><p>● -N代表有N-1个线程正在进行扩容操作，严格来说，当其为负数的时候，只用到了低16位，如果低16位为M，此时有M-1个线程进行扩容。</p><p>● 大于0有两种情况：如果table没有初始化，她就表示table初始化的大小，如果table初始化完了，就表示table的容量，默认是table大小的四分之三。</p><p>Transfer()扩容</p><p>table数据转移到nextTable。扩容操作的核心在于数据的转移，把旧数组中的数据迁移到新的数组。ConcurrentHashMap精华的部分是它可以利用多线程来进行协同扩容，简单来说，它把table数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程所负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的 Bucket会被替换为一个Forwarding节点，标记当前Bucket已经被其他线程迁移完了。</p><p>helpTransfer()帮助扩容</p><p>ConcurrentHashMap并发添加元素时，如果正在扩容，其他线程会帮助扩容，也就是多线程扩容。</p><p>第一次添加元素时，默认初始长度为16，当往table中继续添加元素时，通过Hash值跟数组长度取余来决定放在数组的哪个Bucket位置，如果出现放在同一个位置，就优先以链表的形式存放，在同一个位置的个数达到了8个以上，如果数组的长度还小于64，就会扩容数组。如果数组的长度大于等于64，就会将该节点的链表转换成树。</p><p>通过扩容数组的方式来把这些节点分散开。然后将这些元素复制到扩容后的新数组中，同一个Bucket中的元素通过Hash值的数组长度位来重新确定位置，可能还是放在原来的位置，也可能放到新的位置。而且，在扩容完成之后，如果之前某个节点是树，但是现在该节点的“Key-Value对”数又小于等于6个，就会将该树转为链表。</p><p>put()</p><p>JDK1.8在使用CAS自旋完成桶的设置时，使用synchronized内置锁保证桶内并发操作的线程安全。尽管对同一个Map操作的线程争用会非常激烈，但是在同一个桶内的线程争用通常不会很激烈，所以使用CAS自旋、synchronized不会降低ConcurrentHashMap的性能。为什么不用ReentrantLock显式锁呢?如果为每 个桶都创建一个ReentrantLock实 例，就会带来大量的内存消耗，反过来，使用CAS自旋、synchronized，内存消耗的增加更小。</p><p>get()</p><p>get()通过UnSafe的getObjectVolatile()来读取数组中的元素。为什么要这样做?虽然HashEntry数组的引用是volatile类型，但是数组内元素的 用不是volatile类型，因此多线程对 数组元素的修改是不安全的，可能会在数组中读取到尚未构造完成的元素对象。get()方法通过UnSafe的getObjectVolatile方法来保证元素的读取安全，调用getObjectVolatile()去读取数组元素需要先获得元素在数组中的偏移量，在这里，get()方法根据哈希码计算出偏移量为u，然后通过偏移量u来尝试读取数值。</p>]]></content>
      
      
      <categories>
          
          <category> 1.基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
