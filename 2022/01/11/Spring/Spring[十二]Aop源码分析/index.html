<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring[十二]Aop源码分析 | 二十</title><meta name="keywords" content="Spring"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Aop源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring[十二]Aop源码分析">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/11/Spring/Spring[%E5%8D%81%E4%BA%8C]Aop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="Aop源码分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/spring.png">
<meta property="article:published_time" content="2022-01-11T06:10:47.608Z">
<meta property="article:modified_time" content="2022-01-11T06:17:03.028Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/spring.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/11/Spring/Spring[%E5%8D%81%E4%BA%8C]Aop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring[十二]Aop源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 14:17:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/spring.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring[十二]Aop源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-11T06:10:47.608Z" title="发表于 2022-01-11 14:10:47">2022-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T06:17:03.028Z" title="更新于 2022-01-11 14:17:03">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring[十二]Aop源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>上一篇通过简单的分析，我们大概清楚了整个AOP代码实现的大体流程。本篇我们将从代码入手，一点点分解AOP的实现代码。</p>
</blockquote>
<h2 id="1-使用AOP的代码"><a href="#1-使用AOP的代码" class="headerlink" title="1.使用AOP的代码"></a>1.使用AOP的代码</h2><p>先看一段代码，看看如何使用AOP的。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//默认代理所有方法</span></span><br><span class="line">		proxyAllMethods();</span><br><span class="line">		<span class="comment">//定制代理</span></span><br><span class="line">		<span class="comment">//proxyMethod();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 默认情况。代理所有方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyAllMethods</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//1.创建被代理对象</span></span><br><span class="line">		Tiger tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line">		<span class="comment">//2.创建spring代理工厂对象 ProxyFactory</span></span><br><span class="line">		<span class="comment">//proxyFactory 是 config + factory 的存在  持有 aop 操作 的 所有的生产资料</span></span><br><span class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(tiger);</span><br><span class="line">		<span class="comment">//3. 添加拦截器</span></span><br><span class="line">		proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor01());</span><br><span class="line">		proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor02());</span><br><span class="line">		<span class="comment">//4.获取代理对象，分析如何获取的代理对象？</span></span><br><span class="line">		Animals proxy = (Animals) proxyFactory.getProxy();</span><br><span class="line">		proxy.eat(<span class="string">&quot;人&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">		proxy.run();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 代理指定的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//1.创建被代理对象</span></span><br><span class="line">		Tiger tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line">		<span class="comment">//2.创建spring代理工厂对象 ProxyFactory</span></span><br><span class="line">		<span class="comment">//proxyFactory 是 config + factory 的存在  持有 aop 操作 的 所有的生产资料</span></span><br><span class="line">		ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(tiger);</span><br><span class="line">		<span class="comment">//3.添加方法拦截</span></span><br><span class="line">		MyPointCut pointCut = <span class="keyword">new</span> MyPointCut();</span><br><span class="line">		proxyFactory.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(pointCut,<span class="keyword">new</span> MethodInterceptor01()));</span><br><span class="line">		proxyFactory.addAdvisor(<span class="keyword">new</span> DefaultPointcutAdvisor(pointCut,<span class="keyword">new</span> MethodInterceptor02()));</span><br><span class="line">		<span class="comment">//4.获取代理对象 分析如何获得代理对象</span></span><br><span class="line">		Animals proxy = (Animals) proxyFactory.getProxy();</span><br><span class="line"></span><br><span class="line">		proxy.eat(<span class="string">&quot;人肉&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">		proxy.run();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 方法拦截器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptor01</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="meta">@NonNull</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;method interceptor begin!----1&quot;</span>);</span><br><span class="line">			Object result = invocation.proceed();</span><br><span class="line">			System.out.println(<span class="string">&quot;method interceptor end!---4&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptor02</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="meta">@NonNull</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;method interceptor begin!----2&quot;</span>);</span><br><span class="line">			Object result = invocation.proceed();</span><br><span class="line">			System.out.println(<span class="string">&quot;method interceptor end!----3&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">implements</span> <span class="title">Animals</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;老虎吃&quot;</span>+food);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;跑的贼快！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPointCut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> clazz -&gt; <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MethodMatcher() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> method.getName().equals(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是使用AOP的两种方式，默认是代理全部方法，另一个则是代理指定的方法。接下来，我们来对源码进行分析。<br>​</p>
<h2 id="2-抓手"><a href="#2-抓手" class="headerlink" title="2.抓手"></a>2.抓手</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">proxyAllMethods</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.创建被代理对象</span></span><br><span class="line">	Tiger tiger = <span class="keyword">new</span> Tiger();</span><br><span class="line">	<span class="comment">//2.创建spring代理工厂对象 ProxyFactory</span></span><br><span class="line">	<span class="comment">//proxyFactory 是 config + factory 的存在  持有 aop 操作 的 所有的生产资料</span></span><br><span class="line">	ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(tiger);</span><br><span class="line">	<span class="comment">//3. 添加拦截器</span></span><br><span class="line">	proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor01());</span><br><span class="line">	proxyFactory.addAdvice(<span class="keyword">new</span> MethodInterceptor02());</span><br><span class="line">	<span class="comment">//4.获取代理对象，分析如何获取的代理对象？</span></span><br><span class="line">	Animals proxy = (Animals) proxyFactory.getProxy();</span><br><span class="line">	proxy.eat(<span class="string">&quot;人&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">	proxy.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面首先首先是创建了一个代理工厂，然后给代理工厂添加拦截器，最后通过代理工厂来获取代理对象，最后通过代理对象执行目标方法。<br>​</p>
<p>接下来我们来看代理工厂。<br>​</p>
<h2 id="3-代理工厂"><a href="#3-代理工厂" class="headerlink" title="3.代理工厂"></a>3.代理工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将目标对象封装成为 SingletonTargetSource 保存到父类字段内</span></span><br><span class="line">	setTarget(target);</span><br><span class="line">	<span class="comment">//获取目标对象class 的所有接口 ，保存到父类字段内</span></span><br><span class="line">	setInterfaces(ClassUtils.getAllInterfaces(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639234501126-02594c19-dc91-4adf-b4d0-a13860a4a61b.png#clientId=u24ddacc8-01b2-4&from=paste&height=540&id=ud8b3ce3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1680&originalType=binary&ratio=1&size=217930&status=done&style=none&taskId=uc216fa2c-022e-4bf2-8b25-ffc65a15b16&width=840" alt="image.png"><br>在<code>**ProxyFactory**</code>的构造器内将目标对象和目标对象实现的接口封装到了父类的字段里面。<br>​</p>
<p>上图是<code>**ProxyFactory**</code>的继承关系，可以先简单过一下，有一个印象。<br>​</p>
<h2 id="4-添加切面"><a href="#4-添加切面" class="headerlink" title="4.添加切面"></a>4.添加切面</h2><p><code>**proxyFactory.addAdvice(new MethodInterceptor01())**</code><br> <br>这一行代码是往代理工厂添加拦截器/切面。<br>​</p>
<p>看一下添加的流程<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="keyword">this</span>.advisors.size();</span><br><span class="line">	addAdvice(pos, advice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是调用了<code>**AdvisedSupport**</code>类的添加切面方法。<br>​</p>
<p>在添加切面的方法里获取了当前类的增强器个数。然后和切面一起传递到重载的方法里。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(<span class="keyword">int</span> pos, Advice advice)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	Assert.notNull(advice, <span class="string">&quot;Advice must not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//不考虑，引介增强，很少用</span></span><br><span class="line">	<span class="keyword">if</span> (advice <span class="keyword">instanceof</span> IntroductionInfo) &#123;</span><br><span class="line">		<span class="comment">// We don&#x27;t need an IntroductionAdvisor for this kind of introduction:</span></span><br><span class="line">		<span class="comment">// It&#x27;s fully self-describing.</span></span><br><span class="line">		addAdvisor(pos, <span class="keyword">new</span> DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不考虑，引介增强，很少用</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> DynamicIntroductionAdvice) &#123;</span><br><span class="line">		<span class="comment">// We need an IntroductionAdvisor for this kind of introduction.</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//spring中Advice对应的接口就是Advisor，Spring使用Advisor包装着AOP的Advice实例</span></span><br><span class="line">		addAdvisor(pos, <span class="keyword">new</span> DefaultPointcutAdvisor(advice));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>然后调用了<code>**addAdvisor()**</code>，添加增强器。<br>​</p>
<p>因为我们没有指定切点，所以创建了一个默认的切点的增强器<code>**DefaultPointcutAdvisor**</code>。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvisor</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	<span class="comment">//引介相关的逻辑，不考虑</span></span><br><span class="line">	<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">		validateIntroductionAdvisor((IntroductionAdvisor) advisor);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//委派模式</span></span><br><span class="line">	addAdvisorInternal(pos, advisor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>这里面调用了<code>**addAdvisorInternal(pos, advisor)**</code>，继续往下看。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAdvisorInternal</span><span class="params">(<span class="keyword">int</span> pos, Advisor advisor)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	Assert.notNull(advisor, <span class="string">&quot;Advisor must not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//如果当前AOP配置已经冻结了，不能在添加切面了，添加的话会抛出异常。</span></span><br><span class="line">	<span class="keyword">if</span> (isFrozen()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;Cannot add advisor: Configuration is frozen.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果传入的切面的位置大于当前切面的个数，抛异常，因为位置下标默认从-1开始。</span></span><br><span class="line">	<span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>.advisors.size()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">				<span class="string">&quot;Illegal position &quot;</span> + pos + <span class="string">&quot; in advisor list with size &quot;</span> + <span class="keyword">this</span>.advisors.size());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加增强器</span></span><br><span class="line">	<span class="keyword">this</span>.advisors.add(pos, advisor);</span><br><span class="line">	<span class="comment">//清理缓存</span></span><br><span class="line">	adviceChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里进行一些校验逻辑，然后添加增强器，清理缓存。<br>​</p>
<h2 id="5-获取代理对象"><a href="#5-获取代理对象" class="headerlink" title="5.获取代理对象"></a>5.获取代理对象</h2><p><code>**proxyFactory.getProxy()**</code><br> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据工厂的设置创建代理对象</span></span><br><span class="line"><span class="comment"> * 可以反复的调用。</span></span><br><span class="line"><span class="comment"> * 如果我们添加或者删除接口，效果会有所不同，可以添加和删除拦截器。</span></span><br><span class="line"><span class="comment"> * 使用默认的类加载器：默认是线程上下文类加载器（如果需要创建代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建AOP 的 代理  ，那么  AOP 的代理是什么 ？</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * AopProxy</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * createAopProxy() ：去创建代理对象的逻辑</span></span><br><span class="line"><span class="comment">	 * getProxy()：获取创建好的代理对象，这里有两个实现分别是jdk的动态代理和cglib的动态代理。</span></span><br><span class="line"><span class="comment">	 * CglibAopProxy</span></span><br><span class="line"><span class="comment">	 * JdkDynamicAopProxy</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面先是利用<code>**createAopProxy()**</code>创建了一个代理对象，然后通过<code>**getProxy()**</code>来获取一个代理对象。<br>​</p>
<p>我们先来分析<code>**createAopProxy()**</code>，看一看代理对象是如何创建的？<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类应该调用它来获得一个新的 AOP 代理。 他们不应该创建一个AOP代理this作为参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * active属性实际上就是一个标记，在创建第一个代理对象的时候，会将他设置为true。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">		activate();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分析一下下面这行代码的流程：</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1. 获取aop的代理工厂  看一下AopProxyFactory</span></span><br><span class="line"><span class="comment">	 * 2. 使用工厂创建一个aop的代理  ,如何创建代理的？</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先是通过<code>**getAopProxyFactory()**</code>获取AOP的代理工厂，然后通过<code>**createAopProxy(this)**</code>传入当前类来获取一个代理对象。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类里面已经持有了一个默认的aop的代理工厂</span></span><br><span class="line"><span class="comment"> * ctrl + h 查看当前类的继承关系</span></span><br><span class="line"><span class="comment"> * 当前类是 ProxyFactory的父类，所以里面的代理工厂会被默认的初始化加载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下上图类的继承关系，其实在创建<code>**ProxyFactory**</code>的时候，隐式调用父类的构造器的时候，就已经在<code>**ProxyCreatorSupport**</code>里面创建了一个默认的AOP代理工厂<code>**DefaultAopProxyFactory**</code>。<br>​</p>
<p>接下来再来看如何创建一个AOP代理对象的。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config 就是我们的ProxyFactory对象，ProxyFactory他是一个配置管理对象</span></span><br><span class="line"><span class="comment"> *               保存着创建代理对象所有的生产资料。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个AOP的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AopConfigException 如果某些不期望我们修改的配置被修改，就会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 条件一：暂且不管</span></span><br><span class="line"><span class="comment">	 * 条件二：true 表示强制使用cglib代理，</span></span><br><span class="line"><span class="comment">	 * 条件三：true 表示被代理对象没有实现任何接口没有办法使用jdk的动态代理，只能使用cglib的动态代理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; <span class="comment">//该条件不需要考虑</span></span><br><span class="line"></span><br><span class="line">			(</span><br><span class="line">					config.isOptimize() ||  <span class="comment">//设置了这个属性，那么就是强制使用cglib的动态代理</span></span><br><span class="line">							config.isProxyTargetClass() ||  <span class="comment">//设置了这个属性，那么就是强制使用cglib的动态代理</span></span><br><span class="line">							hasNoUserSuppliedProxyInterfaces(config) <span class="comment">//判断被代理对象有没有实现接口，没有实现接口，那还用锤子jdk的动态代理</span></span><br><span class="line">			)</span><br><span class="line">	) &#123;</span><br><span class="line">		<span class="comment">//走到这里的话，很大程度上就已经会使用cglib的动态代理</span></span><br><span class="line">		<span class="comment">//获取目标对象的类型，为空的话肯定没法继续往下走了，直接异常中断</span></span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//目标对象是一个接口 或者 已经是一个被代理过得类型（此时是多重代理） ，只能使用jdk的动态代理</span></span><br><span class="line">		<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//走cglib的动态代理</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//执行到这里的情况 ： 实现了接口,大多数情况我们都是面向接口编程，走这里</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据条件判断我们到底是创建JDK的代理对象还是创建Cglib的代理对象，因为我们的案例代码的目标类是实现了接口的，所以默认会走jdk的动态代理。<br>​</p>
<h2 id="6-JdkDynamicAopProxy"><a href="#6-JdkDynamicAopProxy" class="headerlink" title="6.JdkDynamicAopProxy"></a>6.JdkDynamicAopProxy</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的配置，通过构造器创建aop 的动jdk态代理对象</span></span><br><span class="line"><span class="comment"> * 这里的config是啥？就是我们的代理工厂对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">	<span class="comment">//非空断言</span></span><br><span class="line">	Assert.notNull(config, <span class="string">&quot;AdvisedSupport must not be null&quot;</span>);</span><br><span class="line">	<span class="comment">//如果配置里面的切面数==0 &amp;&amp; 配置里面的目标对象是空对象，那么代理无法继续往下走了，直接抛异常中断</span></span><br><span class="line">	<span class="keyword">if</span> (config.getAdvisorCount() == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;No advisors and no TargetSource specified&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.advised = config;</span><br><span class="line">	<span class="comment">//获取当前被代理对象实现的接口数组 ,具体的实现逻辑？</span></span><br><span class="line">	<span class="keyword">this</span>.proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">	<span class="comment">//查找所有被代理的接口，如果有equals 和 hashcode就打个标</span></span><br><span class="line">	findDefinedEqualsAndHashCodeMethods(<span class="keyword">this</span>.proxiedInterfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>判断如果配置里面没有该被代理对象的切面，或者被代理对象是空，那就不能往下走了，抛出异常。<br>​</p>
<p>获取当前被代理对象实现的接口数组<code>**AopProxyUtils.completeProxiedInterfaces(this.advised, true)**</code>。<br>​</p>
<p>查找所有被代理的接口，如果有equals 和 hashcode就打个标。<br>​</p>
<p>看一下如何获取到当前被代理对象实现的接口数组的。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿到被代理对象的所有接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, <span class="keyword">boolean</span> decoratingProxy) &#123;</span><br><span class="line">	<span class="comment">/*从proxyFactory中获取所有的target提取出来的接口*/</span></span><br><span class="line">	Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">	<span class="comment">/*如果接口长度是0*/</span></span><br><span class="line">	<span class="keyword">if</span> (specifiedInterfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//拿到目标对象的类型</span></span><br><span class="line">		Class&lt;?&gt; targetClass = advised.getTargetClass();</span><br><span class="line">		<span class="comment">//如果目标对象的类型不为空</span></span><br><span class="line">		<span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果目标对象是一个接口，那么就将目标对象设置到接口列表里面</span></span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface()) &#123;</span><br><span class="line">				advised.setInterfaces(targetClass);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果目标对象是一个代理类，那么也将目标对象设置到接口列表</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				advised.setInterfaces(targetClass.getInterfaces());</span><br><span class="line">			&#125;</span><br><span class="line">			specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*创建一个新的接口数组，长度是原接口数量+spring追加的三个接口数量*/</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; proxiedInterfaces = <span class="keyword">new</span> ArrayList&lt;&gt;(specifiedInterfaces.length + <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; ifc : specifiedInterfaces) &#123;</span><br><span class="line">		<span class="comment">// 只有非密封接口实际上有资格进行JDK代理(在JDK 17上)</span></span><br><span class="line">		<span class="keyword">if</span> (!ifc.isSealed()) &#123;</span><br><span class="line">			proxiedInterfaces.add(ifc);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*如果这个接口里面没有SpringProxy这个接口，那么就需要添加一个，打标，标识这个代理对象是Spring创建的*/</span></span><br><span class="line">	<span class="keyword">if</span> (!advised.isInterfaceProxied(SpringProxy.class)) &#123;</span><br><span class="line">		proxiedInterfaces.add(SpringProxy.class);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*判断目标对象的所有接口是否有advice接口，没有就手动添加*/</span></span><br><span class="line">	<span class="keyword">if</span> (!advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class)) &#123;</span><br><span class="line">		proxiedInterfaces.add(Advised.class);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果目标对象的所有接口里面，没有DecoratingProxy的接口，那就添加一个</span></span><br><span class="line">	<span class="keyword">if</span> (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class)) &#123;</span><br><span class="line">		proxiedInterfaces.add(DecoratingProxy.class);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回接口类型数组</span></span><br><span class="line">	<span class="keyword">return</span> ClassUtils.toClassArray(proxiedInterfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们来看<code>**getProxy(**</code>)的逻辑。<br>​</p>
<h2 id="7-getProxy"><a href="#7-getProxy" class="headerlink" title="7.getProxy()"></a>7.getProxy()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里如果没有传类加载器，就使用默认的类加载器，默认是线程上下文类加载器</span></span><br><span class="line">	<span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法重载，继续往下走。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//打印日志的逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过jdk的动态代理来创建代理对象 this == this::invoke  该方法最终会返回一个代理类对象</span></span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, <span class="keyword">this</span>.proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过JDK的动态代理来创建代理对象，为啥会传入当前类<code>**JdkDynamicAopProxy**</code>，因为当前类实现了<code>**InvocationHandler**</code>接口。<br>​</p>
<p>因此，当代理对象调用目标方法的时候，就会执行该类的<code>**invoke()**</code>。<br>​</p>
<h2 id="8-代理对象执行目标方法"><a href="#8-代理对象执行目标方法" class="headerlink" title="8.代理对象执行目标方法"></a>8.代理对象执行目标方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy<span class="comment">/*代理对象*/</span>, Method method<span class="comment">/*目标方法*/</span>, Object[] args<span class="comment">/*目标方法对应的参数*/</span>)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">//advised 这里实际上就是proxyFactory的引用，targetSource 实际上就是上层传递封装的targetsource</span></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">/*如果代理类实现的接口里面有equals方法，就使用里面的，否则使用jdk提供的equals方法*/</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果代理类实现的接口里面提供了hashcode方法，就是用里面的，否则用jdk的</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*暂时尚未用到，TODO*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回值</span></span><br><span class="line">		Object retVal;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 是否需要将当前的代理对象设置在aop上下文中</span></span><br><span class="line"><span class="comment">		 * aop上下文对象实际上就是一个threadLocal</span></span><br><span class="line"><span class="comment">		 * 为什么要引入一个aop上下文？</span></span><br><span class="line"><span class="comment">		 * 目标对象A B</span></span><br><span class="line"><span class="comment">		 * 通过代理的方式调用A.eat()</span></span><br><span class="line"><span class="comment">		 * 这个eat方法里面有恰恰调用到了B的方法，这个时候B对象实际上并不是代理对象，所以</span></span><br><span class="line"><span class="comment">		 * b的方法执行前后并不会被增强，为了解决这个问题，就引入了aop的上下文</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			<span class="comment">// 将当前代理对象设置到aop上下文中，并返回老的代理对象</span></span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*根据targetSource拿到目标对象*/</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		<span class="comment">/*根据目标对象拿到目标对象的类型*/</span></span><br><span class="line">		Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里是最关键的地方，查找适合该方法的增强  具体是如何查找的？</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*查询出匹配当前方法拦截器的数量是0 说明当前方法不需要被增强，直接通过反射调用目标对象的目标方法。*/</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			<span class="comment">/*调用目标对象的目标方法*/</span></span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*说明有匹配当前method的方法拦截器，说明要做增强处理 */</span></span><br><span class="line">			MethodInvocation invocation =</span><br><span class="line">					<span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">/*核心驱动逻辑在ReflectiveMethodInvocation*/</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*获取方法的返回值类型*/</span></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="comment">/*如果目标方法返回目标对象 ，做一个替换  ，返回代理对象*/</span></span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">				returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//方法是void类型，但是返回值类型还不为空，说明有问题，抛异常</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">					<span class="string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			<span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			<span class="comment">// 将上次设置的proxy在此设置回去到aop上下文内</span></span><br><span class="line">			<span class="comment">//因为当前代理对象的目标方法已经完成了，需要回到上一层逻辑</span></span><br><span class="line">			<span class="comment">//属于恢复现场的逻辑</span></span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <br> 抛开一切不是很重要的逻辑<br>​</p>
<p>判断当前代理对象是否应该暴露出去，aop上下文<code>**AopContext**</code>实际上就是一个ThreadLocal。<br>​</p>
<p><strong>为什么要引入AOP的上下文？</strong><br>​</p>
<p>假设有目标对象A,B。<br>​</p>
<p>通过代理的方式调用A.eat()。<br>​</p>
<p>这个eat()方法里面恰恰调用了B的方法，这个时候对象实际上并不是代理对象，所以B的方法执行前后并不会被增强，为了解决这个问题，就引入了AOP上下文。<br>​</p>
<p>通过<code>**getInterceptorsAndDynamicInterceptionAdvice()**</code>查找到当前方法执行前后需要执行的增强器。<br> <br>如果当前方法匹配的增强器数量是0，那么直接通过反射调用目标方法。<br>​</p>
<p>否则说明有匹配的增强器，需要做增强处理。<code>**retVal=ReflectiveMethodInvocation.proceed(）**</code><br>​</p>
<p>retVal就是方法的返回值。<br>​</p>
<p>判断如果方法最终返回的目标对象，那就替换成代理对象。<br>​</p>
<p>判断如果方法是void类型，但是返回值类型还不为空，说明有问题，抛异常。<br>​</p>
<p>最终返回结果，并将AOP上下文的代理对象还原成里面原有的对象，因为当前代理对象的目标方法已经完成了，需要回到上一层逻辑。<br> <br> 至此，AOP整个流程就分析完了，剩下的一些核心的细节：<br>​</p>
<ol>
<li><code>**getInterceptorsAndDynamicInterceptionAdvice()**</code>查找到当前方法执行前后需要执行的增强器</li>
<li><code>**retVal=ReflectiveMethodInvocation.proceed(）**</code>执行增强器逻辑</li>
</ol>
<p>​</p>
<blockquote>
<p>通过前面的分析，我们大体上了解了Spring的Aop的执行流程。接下来我们在看一些核心的细节，如何查找目标方法的增强器。</p>
</blockquote>
<h2 id="9-查找增强器"><a href="#9-查找增强器" class="headerlink" title="9.查找增强器"></a>9.查找增强器</h2><p><code>**List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);**</code><br> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先尝试从缓存拿</span></span><br><span class="line">	MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">	List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">	<span class="comment">/*如果缓存为空*/</span></span><br><span class="line">	<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*那就走查找逻辑，并刷新缓存</span></span><br><span class="line"><span class="comment">		* advisorChainFactory什么时候创建的？</span></span><br><span class="line"><span class="comment">		* 这个是在proxyFactory里面的一个变量，代理工厂创建出来，他就创建出来了</span></span><br><span class="line"><span class="comment">		* */</span></span><br><span class="line">		cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">				<span class="keyword">this</span>, method, targetClass);</span><br><span class="line">		<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*最终返回查找到的值*/</span></span><br><span class="line">	<span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找缓存，如果没命中则去查找并放入缓存放回。我们继续往下看查找逻辑<code>**this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice()**</code>。<br>​</p>
<p>这个<code>**advisorChainFactory**</code>是什么？看当前类的属性<code>**AdvisorChainFactory advisorChainFactory = new DefaultAdvisorChainFactory();**</code></p>
<p>从这里我们就定位到了看哪个方法的逻辑<br> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		Advised config<span class="comment">/*代理工厂*/</span>, Method method<span class="comment">/*目标方法*/</span>, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass<span class="comment">/*目标对象类型*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这个接口是切面适配器的注册中心</span></span><br><span class="line"><span class="comment">	 * 1.可以注册AdvisorAdapter 适配器目的：将非advisor类型的增强包装成advisor  ，将advisor类型的增强提取出来对应的 方法拦截器</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取代理工厂内部持有的增强信息</span></span><br><span class="line"><span class="comment">	 * 1. addAdvice</span></span><br><span class="line"><span class="comment">	 * 2. addAdvisor</span></span><br><span class="line"><span class="comment">	 * 最终在代理工厂中都会包装成 advisor</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	Advisor[] advisors = config.getAdvisors();</span><br><span class="line">	<span class="comment">/*创建一个拦截器列表，长度就是advisor的长度*/</span></span><br><span class="line">	List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</span><br><span class="line">	<span class="comment">/*真实的目标对象类型*/</span></span><br><span class="line">	Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">	<span class="comment">/*引介增强相关*/</span></span><br><span class="line">	Boolean hasIntroductions = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">		<span class="comment">/*包含切点信息的增强，内部逻辑就是做匹配算法*/</span></span><br><span class="line">		<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">			<span class="comment">// 转换成 PointcutAdvisor 类型，可以获取到切点信息</span></span><br><span class="line">			PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">			<span class="comment">/*条件二成立，说明当前被代理对象的class匹配当前advisor成功，可能被advisor增强，具体还要看方法匹配。 这里可以看一下 Pointcut 源码*/</span></span><br><span class="line">			<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				<span class="comment">/*获取切点信息的方法匹配器，做方法级别的匹配*/</span></span><br><span class="line">				MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">				<span class="keyword">boolean</span> match;</span><br><span class="line">				<span class="comment">/*引介相关的，不需要考虑*/</span></span><br><span class="line">				<span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">					<span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</span><br><span class="line">						hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">					&#125;</span><br><span class="line">					match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*进行方法匹配 目标方法匹配成功 ， match = true，当前的增强器可以应用到method*/</span></span><br><span class="line">					match = mm.matches(method, actualClass);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*判断是否还需要运行时的匹配*/</span></span><br><span class="line">				<span class="keyword">if</span> (match) &#123;</span><br><span class="line">					<span class="comment">/*提取出advisor类持有的拦截器信息  registry里面包含三个默认的增强器*/</span></span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">						<span class="comment">/*如果是运行时匹配，那就走运行时匹配的逻辑*/</span></span><br><span class="line">						<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">							interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/*将方法拦截器追加到拦截器列表里面去*/</span></span><br><span class="line">						interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*不考虑引介，所以直接跳过*/</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">			IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">			<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*适配所有方法的*/</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">			interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*返回所有匹配当前方法的拦截器*/</span></span><br><span class="line">	<span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法有点长，我们挑重点慢慢分析。<br>​</p>
<p>首先获取到切面适配器的注册中心，切面适配器<code>**AdvisorAdapter**</code>是做什么的？<br>​</p>
<p>将非advisor类型的增强包装成advisor  ，将advisor类型的增强提取出来对应的 方法拦截器。<br>​</p>
<p>获取代理工厂内部持有的增强信息<br>​</p>
<ol>
<li>Advice</li>
<li>Advisor</li>
</ol>
<p>最终在代理工厂中都会被包装成Advisor。<br>​</p>
<p>遍历所有的拦截器：<br>​</p>
<ol>
<li><p>先是处理切点类型的增强器</p>
<blockquote>
<ol>
<li>先将增强器转化成<code>**PointcutAdvisor**</code>类型</li>
<li>判断如果当前被代理对象的class匹配增强器成功，说明可能增强成功，还要看具体的方法匹配，这里可以看一下<code>**PointCut**</code> 源码</li>
<li>获取切点信息的方法匹配器，准备做方法级别的匹配</li>
<li><code>**match = mm.matches(method, actualClass)**</code>进行具体的方法匹配</li>
<li>判断是否需要运行时匹配</li>
<li>如果需要，提取出增强器持有的拦截器信息(registry里面默认持有三个增强器)，走运行时匹配的逻辑 -&gt; 将<code>**InterceptorAndDynamicMethodMatcher**</code>加入到拦截器列表</li>
<li>如果不需要，将方法拦截器添加到拦截器列表</li>
</ol>
</blockquote>
</li>
<li><p>处理引介类型的增强器</p>
<blockquote>
<p>这里的逻辑我们不需要关注</p>
</blockquote>
</li>
<li><p>处理适配所有方法的增强器</p>
<blockquote>
<p>从增强器的适配中心获取所有的拦截器</p>
</blockquote>
</li>
</ol>
<p>最终返回匹配当前方法的所有拦截器<br>​</p>
<h2 id="10-方法匹配"><a href="#10-方法匹配" class="headerlink" title="10.方法匹配"></a>10.方法匹配</h2><p>这里我们再看一下具体的方法匹配逻辑。<br>​</p>
<p>看一下<code>**AbstractRegexpMethodPointcut**</code>，说实话，营养价值不大，有兴趣可以自行琢磨。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (matchesPattern(ClassUtils.getQualifiedMethodName(method, targetClass)) ||</span><br><span class="line">			(targetClass != method.getDeclaringClass() &amp;&amp;</span><br><span class="line">					matchesPattern(ClassUtils.getQualifiedMethodName(method, method.getDeclaringClass()))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Match the specified candidate against the configured patterns.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> signatureString &quot;java.lang.Object.hashCode&quot; style signature</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether the candidate matches at least one of the specified patterns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">matchesPattern</span><span class="params">(String signatureString)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.patterns.length; i++) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> matched = matches(signatureString, i);</span><br><span class="line">		<span class="keyword">if</span> (matched) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.excludedPatterns.length; j++) &#123;</span><br><span class="line">				<span class="keyword">boolean</span> excluded = matchesExclusion(signatureString, j);</span><br><span class="line">				<span class="keyword">if</span> (excluded) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-拦截器的核心驱动"><a href="#11-拦截器的核心驱动" class="headerlink" title="11.拦截器的核心驱动"></a>11.拦截器的核心驱动</h2><p>获取到所有的匹配当前方法的拦截器后，最终我们是要驱动所有的拦截器去执行，接下来分析下拦截器的核心驱动逻辑。<code>**invocation.proceed()**</code>，核心逻辑在<code>**ReflectiveMethodInvocation**</code>中。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">// 因为从-1开始，如果当前拦截器下标 == 拦截器数量-1 ，说明所有方法拦截器都执行过了，接下来需要执行目标对象的目标方法</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/*调用连接点*/</span></span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*获取下一个方法拦截器*/</span></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="comment">/*判断是否需要运行时匹配*/</span></span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"></span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*大部分情况下会走到else这里静态匹配*/</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 让当前方法拦截器执行invoke即可 ，并且将当前对象传递进去</span></span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是否所有拦截器都执行完了，如果是的话，执行目标方法<code>**invokeJoinpoint()**</code>。<br>​</p>
<p> 获取下一个拦截器，判断是否需要做运行时匹配，大部分情况下，我们都是走静态匹配的逻辑。<br>​</p>
<p>让当前方法拦截器执行<code>**invoke()**</code>。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>通过这样类似递归的链式调用，每一个拦截器等待下一个拦截器执行完成返回以后在执行，拦截器的机制保证了通知方法与目标方法的执行顺序。<br>​</p>
<p>再来看下如何调用目标方法。<code>**invokeJoinpoint()**</code><br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 继续往下追。<br>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(<span class="meta">@Nullable</span> Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use reflection to invoke the method.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ReflectionUtils.makeAccessible(method);</span><br><span class="line">		<span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">		<span class="comment">// Invoked method threw a checked exception.</span></span><br><span class="line">		<span class="comment">// We must rethrow it. The client won&#x27;t see the interceptor.</span></span><br><span class="line">		<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;AOP configuration seems to be invalid: tried calling method [&quot;</span> +</span><br><span class="line">				method + <span class="string">&quot;] on target [&quot;</span> + target + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">&quot;Could not access method [&quot;</span> + method + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终通过暴力反射来调用目标方法执行。<br>​</p>
<h2 id="12-切点表达式"><a href="#12-切点表达式" class="headerlink" title="12.切点表达式"></a>12.切点表达式</h2><p><code>**PointCut**</code><br><strong>​</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the ClassFilter for this pointcut.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the ClassFilter (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 类过滤器：判断某个类是否符合切点位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the MethodMatcher for this pointcut.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the MethodMatcher (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">	 * 方法匹配器：判断类中某个方法是否匹配条件，匹配条件的方法才会被增强</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>前面案例代码中，有一个我们自己实现的切点，可以回顾一下。</p>
</blockquote>
<p>最终回顾下开头的一张图，明确下<code>**Advised --持有--&gt; Advisor --持有--&gt; Advice --子类--&gt;Interceptor --子类--&gt;MethodInterceptor**</code>关系：<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639244740087-0aff2acc-6151-410c-8f49-5d93f59216ff.png#clientId=uedc3a3ab-2b31-4&from=paste&height=550&id=u3f8e64de&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1100&originWidth=1882&originalType=binary&ratio=1&size=788714&status=done&style=none&taskId=u59e1ae3f-dd3f-40ed-a493-8f672e8a65b&width=941" alt="image.png"></p>
<p>至此，整个AOP的全部流程已经梳理清晰。下一篇，我们将开始分析Spring的事务。<br>​</p>
<p>​</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/11/Spring/Spring[%E5%8D%81%E4%BA%8C]Aop%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">https://yinhuidong.github.io/2022/01/11/Spring/Spring[十二]Aop源码分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/spring.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/Spring/Spring%5B%E5%8D%81%E4%B8%89%5DIoc%E6%95%B4%E5%90%88Aop%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/"><img class="prev-cover" src="/images/cover/spring.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring[十三]Ioc整合Aop创建代理对象</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/11/Spring/Spring%5B%E5%8D%81%5DAop%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"><img class="next-cover" src="/images/cover/spring.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring[十]Aop的两种实现方式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/11/Spring/Spring%5B%E4%B8%83%5DinitializeBean()/" title="Spring[七]initializeBean()"><img class="cover" src="/images/cover/spring.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Spring[七]initializeBean()</div></div></a></div><div><a href="/2022/01/11/Spring/Spring%5B%E4%B8%80%5D%E5%88%9D%E5%A7%8B%E5%8C%96Web%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/" title="Spring[一]初始化WEB组件"><img class="cover" src="/images/cover/spring.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Spring[一]初始化WEB组件</div></div></a></div><div><a href="/2022/01/11/Spring/Spring%5B%E4%B9%9D%5D%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98&%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" title="Spring[九]三级缓存&循环依赖"><img class="cover" src="/images/cover/spring.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Spring[九]三级缓存&循环依赖</div></div></a></div><div><a href="/2022/01/11/Spring/Spring%5B%E5%85%AB%5D%E6%B3%A8%E8%A7%A3&%E7%BB%84%E4%BB%B6%E7%AF%87/" title="Spring[八]注解&组件篇"><img class="cover" src="/images/cover/spring.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Spring[八]注解&组件篇</div></div></a></div><div><a href="/2022/01/11/Spring/Spring%5B%E4%BA%94%5DcreateBean()/" title="Spring[五]createBean()"><img class="cover" src="/images/cover/spring.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Spring[五]createBean()</div></div></a></div><div><a href="/2022/01/11/Spring/Spring%5B%E5%85%AD%5DpopulateBean()/" title="Spring[六]populateBean()"><img class="cover" src="/images/cover/spring.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Spring[六]populateBean()</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">119</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8AOP%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">1.使用AOP的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8A%93%E6%89%8B"><span class="toc-text">2.抓手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82"><span class="toc-text">3.代理工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B7%BB%E5%8A%A0%E5%88%87%E9%9D%A2"><span class="toc-text">4.添加切面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">5.获取代理对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JdkDynamicAopProxy"><span class="toc-text">6.JdkDynamicAopProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-getProxy"><span class="toc-text">7.getProxy()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95"><span class="toc-text">8.代理对象执行目标方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9F%A5%E6%89%BE%E5%A2%9E%E5%BC%BA%E5%99%A8"><span class="toc-text">9.查找增强器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%96%B9%E6%B3%95%E5%8C%B9%E9%85%8D"><span class="toc-text">10.方法匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E9%A9%B1%E5%8A%A8"><span class="toc-text">11.拦截器的核心驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">12.切点表达式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十]海量数据处理"/></a><div class="content"><a class="title" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理">MySQL[二十]海量数据处理</a><time datetime="2022-01-19T16:00:00.000Z" title="发表于 2022-01-20 00:00:00">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/MySQL/MySQL%5B%E5%8D%81%E4%B8%83%5D%E9%94%81%E6%A6%82%E8%BF%B0/" title="MySQL[十七]锁概述"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十七]锁概述"/></a><div class="content"><a class="title" href="/2022/01/17/MySQL/MySQL%5B%E5%8D%81%E4%B8%83%5D%E9%94%81%E6%A6%82%E8%BF%B0/" title="MySQL[十七]锁概述">MySQL[十七]锁概述</a><time datetime="2022-01-16T16:00:00.000Z" title="发表于 2022-01-17 00:00:00">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/16/MySQL/MySQL%5B%E5%8D%81%E5%85%AD%5D%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-MVCC/" title="MySQL[十六]并发版本控制-MVCC"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十六]并发版本控制-MVCC"/></a><div class="content"><a class="title" href="/2022/01/16/MySQL/MySQL%5B%E5%8D%81%E5%85%AD%5D%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-MVCC/" title="MySQL[十六]并发版本控制-MVCC">MySQL[十六]并发版本控制-MVCC</a><time datetime="2022-01-15T16:00:00.000Z" title="发表于 2022-01-16 00:00:00">2022-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/MySQL/MySQL%5B%E5%8D%81%E4%BA%94%5Dundo%E6%97%A5%E5%BF%97/" title="MySQL[十五]undo日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十五]undo日志"/></a><div class="content"><a class="title" href="/2022/01/15/MySQL/MySQL%5B%E5%8D%81%E4%BA%94%5Dundo%E6%97%A5%E5%BF%97/" title="MySQL[十五]undo日志">MySQL[十五]undo日志</a><time datetime="2022-01-14T16:00:00.000Z" title="发表于 2022-01-15 00:00:00">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/" title="MySQL[十四]redo日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[十四]redo日志"/></a><div class="content"><a class="title" href="/2022/01/14/MySQL/MySQL%5B%E5%8D%81%E5%9B%9B%5Dredo%E6%97%A5%E5%BF%97/" title="MySQL[十四]redo日志">MySQL[十四]redo日志</a><time datetime="2022-01-13T16:00:00.000Z" title="发表于 2022-01-14 00:00:00">2022-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/spring.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>