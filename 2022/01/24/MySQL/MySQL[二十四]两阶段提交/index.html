<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL[二十四]两阶段提交 | 二十</title><meta name="keywords" content="MySQL"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="XA">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL[二十四]两阶段提交">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/24/MySQL/MySQL[%E4%BA%8C%E5%8D%81%E5%9B%9B]%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="XA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2022-01-23T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-13T09:12:33.227Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/24/MySQL/MySQL[%E4%BA%8C%E5%8D%81%E5%9B%9B]%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL[二十四]两阶段提交',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-13 17:12:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL[二十四]两阶段提交</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-23T16:00:00.000Z" title="发表于 2022-01-24 00:00:00">2022-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-13T09:12:33.227Z" title="更新于 2022-01-13 17:12:33">2022-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL[二十四]两阶段提交"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>一条DML语句从客户端发出后，服务器都做了哪些处理？</p>
<blockquote>
<p>虽然SELECT语句的处理也很复杂，但SELECT语句并不会修改数据库中的数据，也就不会记录诸如redo、undo、binlog这些日志，本文主要是想讨论redo、undo、binlog这些日志是在什么时候生成的，啥时候写到磁盘的。</p>
</blockquote>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>为了故事的顺利发展，我们先建立一个表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE hero (</span><br><span class="line">    number INT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    country varchar(100),</span><br><span class="line">    PRIMARY KEY (number),</span><br><span class="line">    KEY idx_name (name)</span><br><span class="line">) Engine=InnoDB CHARSET=utf8;</span><br></pre></td></tr></table></figure>


<p>然后向这个表里插入几条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO hero VALUES</span><br><span class="line">    (1, &#x27;l刘备&#x27;, &#x27;蜀&#x27;),</span><br><span class="line">    (3, &#x27;z诸葛亮&#x27;, &#x27;蜀&#x27;),</span><br><span class="line">    (8, &#x27;c曹操&#x27;, &#x27;魏&#x27;),</span><br><span class="line">    (15, &#x27;x荀彧&#x27;, &#x27;魏&#x27;),</span><br><span class="line">    (20, &#x27;s孙权&#x27;, &#x27;吴&#x27;);</span><br></pre></td></tr></table></figure>


<p>然后现在<code>hero</code>表就有了两个索引（一个二级索引，一个聚簇索引），示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064397135-e6eeda60-8b5f-4683-b475-735c7e0d5a7a.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufaa6e9b1&margin=%5Bobject%20Object%5D&name=1.png&originHeight=463&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16836&status=done&style=none&taskId=uc6aeea8c-e8f7-4b15-93dc-529b992d35a&title=" alt="1.png"></p>
<h2 id="2-执行计划的生成"><a href="#2-执行计划的生成" class="headerlink" title="2.执行计划的生成"></a>2.执行计划的生成</h2><p>假设我们想执行下边这条UPDATE语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE hero SET country = &#x27;汉&#x27; WHERE name &gt;= &#x27;x荀彧&#x27;;</span><br></pre></td></tr></table></figure>


<p>MySQL优化器首先会分析一下使用不同索引执行查询的成本，然后选取成本最低的那个索引去执行查询。</p>
<p>对于上述语句来说，可选的执行方案有2种：</p>
<ul>
<li>方案一：使用全表扫描执行查询，即扫描全部聚簇索引记录，我们可以认为此时的扫描区间就是<code>(-∞, +∞)</code>。</li>
<li>方案二：使用二级索引idx_name执行查询，此时的扫描区间就是<code>[&#39;x荀彧&#39;, +∞)</code>。</li>
</ul>
<p>优化器会计算上述两种方案的成本，选取成本最低的方案作为最终的执行计划。</p>
<p>我们可以通过EXPLAIN语句来看一下这个语句的执行计划（当然也可以通过MySQL提供的optimizer trace功能查看具体执行计划分析流程）：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064407157-9989d49e-7b19-4e25-88fd-23d6f1add91a.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u82d1da42&margin=%5Bobject%20Object%5D&name=2.png&originHeight=386&originWidth=2288&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197228&status=done&style=none&taskId=uf0fbd8f0-d400-4323-a612-0b94b849de9&title=" alt="2.png"></p>
<p>可以看到，MySQL优化器决定采用方案二，即扫描二级索引idx_name在<code>[&#39;x荀彧&#39;, +∞)</code>这个扫描区间种的记录。</p>
<h2 id="3-真正开始执行"><a href="#3-真正开始执行" class="headerlink" title="3.真正开始执行"></a>3.真正开始执行</h2><p>优化器的执行计划中得到了若干个扫描区间（本例中只有1个扫描区间<code>[&#39;x荀彧&#39;, +∞)</code>），针对每个扫描区间，都会执行下边的步骤：</p>
<h3 id="3-1处理扫描区间的第一条记录"><a href="#3-1处理扫描区间的第一条记录" class="headerlink" title="3.1处理扫描区间的第一条记录"></a>3.1处理扫描区间的第一条记录</h3><ul>
<li> 步骤1：首先server层根据执行计划，向InnoDB层索要二级索引idx_name的扫描区间<code>[&#39;x荀彧&#39;, +∞)</code>的第一条记录。 </li>
<li> 步骤2：Innodb存储引擎便会通过二级索引idx_name对应的B+树，从B+树根页面一层一层向下查找（在页面中查找是通过页目录的槽进行二分查找的，这个过程很快），快速在叶子节点中定位到扫描区间<code>[&#39;x荀彧&#39;, +∞)</code>的第一条二级索引记录。接着根据这条二级索引记录中的主键值执行回表操作（即通过聚簇索引的B+树根节点一层一层向下找，直到在叶子节点中找到相应记录），将获取到的聚簇索引记录返回给server层。 </li>
<li> 步骤3：server层得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样，如果一样的话就不更新了，如果不一样的话就把更新前的记录和更新后的记录都当作参数传给InnoDB层，让InnoDB真正的执行更新记录的操作。 </li>
<li> 步骤4：InnoDB收到更新请求后，先更新记录的聚簇索引记录，再更新记录的二级索引记录。最后将更新结果返回给server层。 </li>
</ul>
<h3 id="3-2处理扫描区间的第二条记录"><a href="#3-2处理扫描区间的第二条记录" class="headerlink" title="3.2处理扫描区间的第二条记录"></a>3.2处理扫描区间的第二条记录</h3><ul>
<li> 步骤1：server层继续向InnoDB索要下一条记录。 </li>
<li> 步骤2：此时由于已经通过B+树定位到二级索引扫描区间<code>[&#39;x荀彧&#39;, +∞)</code>的第一条二级索引记录，而记录又是被串联成单向链表，所以InnoDB直接通过记录头信息的<code>next_record</code>的属性即可获取到下一条二级索引记录。然后通过该二级索引的主键值进行回表操作，获取到完整的聚簇索引记录再返回给server层。 </li>
<li> 步骤3：server层得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样，如果一样的话就不更新了，如果不一样的话就把更新前的记录和更新后的记录都当作参数传给InnoDB层，让InnoDB真正的执行更新记录的操作。 </li>
<li> 步骤4：InnoDB收到更新请求后，先更新记录的聚簇索引记录，再更新记录的二级索引记录。最后将更新结果返回给server层。 </li>
</ul>
<h3 id="3-3处理扫描区间的剩余记录"><a href="#3-3处理扫描区间的剩余记录" class="headerlink" title="3.3处理扫描区间的剩余记录"></a>3.3处理扫描区间的剩余记录</h3><p>该扫描区间中的其他记录的处理就和第2条记录的处理过程是一样。</p>
<h2 id="4-详细的更新过程"><a href="#4-详细的更新过程" class="headerlink" title="4.详细的更新过程"></a>4.详细的更新过程</h2><p>MySQL使用<code>mysql_update</code>函数处理我们上述的更新语句：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064419268-8e07e7b3-7d2d-47e7-afa4-811b9eb0ce70.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u0ed6b4b0&margin=%5Bobject%20Object%5D&name=3.png&originHeight=413&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13012&status=done&style=none&taskId=ub8e7500a-fd53-4637-b58f-2c34c403ea9&title=" alt="3.png"></p>
<p>最主要的处理流程写在了一个循环里：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064428797-be77de93-fb1e-4944-b154-db30a4f917ef.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5a0986ec&margin=%5Bobject%20Object%5D&name=4.png&originHeight=393&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20490&status=done&style=none&taskId=u85461a6c-b70f-4a04-a401-a4222a5bd65&title=" alt="4.png"></p>
<p>上图所示的while循环就是依次处理各条记录的过程。</p>
<p>其中<code>info.read_record</code>是用于获取扫描区间的一条记录，读取到该记录后随后展开详细的更新操作。处理完了之后再回到这个while循环的起点，通过<code>info.read_record</code>获取下一条记录，然后进行详细的更新操作。</p>
<p>也就是说，其实处理每一条记录的过程都是类似的，只不过定位扫描区间的第一条记录会有点儿麻烦（需要从B+树根页面一层一层向下找）。</p>
<p>我们接下来聚焦于一条记录的更新过程，看看这个过程都发生了什么。</p>
<h3 id="4-1将记录所在的页面加载到buffer-pool"><a href="#4-1将记录所在的页面加载到buffer-pool" class="headerlink" title="4.1将记录所在的页面加载到buffer pool"></a>4.1将记录所在的页面加载到buffer pool</h3><p>我们想更新一条记录，首先就得在B+树中定位这条记录——即进行一次<code>加锁读</code>（上图中的<code>info.read_record</code>函数用于调用Innodb读取记录的接口）。</p>
<p>如果该记录所在的页面已经在内存的buffer pool中，那就可以直接读取，否则还需要将该记录所在的页面读取到内存中的buffer pool中。</p>
<blockquote>
<p>不论我们想读写任何页面，都需要先将该页面从硬盘加载到buffer pool中。在定位扫描区间的第一条记录时，我们首先要读取B+树根页面中的记录，所以首先需要先把B+树根页面加载到buffer pool中，然后再读取下一层的页面，然后再读取下下层的页面，直到叶子节点。每当要读取的页面不在buffer pool中，都得将其先加载到buffer pool后才能使用。</p>
</blockquote>
<p>Innodb使用<code>row_search_mvcc</code>处理读取一条记录的过程（不论是加锁读还是一致性读都调用这个函数），在该函数内<code>btr_pcur_open_with_no_init</code>用于从B+树定位记录：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064440801-a00a8f39-45f9-4986-a66e-0986f7310339.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1a3d29be&margin=%5Bobject%20Object%5D&name=5.png&originHeight=219&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8364&status=done&style=none&taskId=uff941f77-293d-432c-9d8e-dc9762f8e34&title=" alt="5.png"></p>
<p>在定位记录时就需要将记录所在的页面加载到buffer pool，完成这个过程的函数是：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064449085-55163889-4209-49ac-ba11-b46aa24540da.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5bc1285b&margin=%5Bobject%20Object%5D&name=6.png&originHeight=447&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25404&status=done&style=none&taskId=ud0390bb0-8505-4693-9d54-1dceb39761c&title=" alt="6.png"></p>
<h3 id="4-2检测更新前后记录是否一样"><a href="#4-2检测更新前后记录是否一样" class="headerlink" title="4.2检测更新前后记录是否一样"></a>4.2检测更新前后记录是否一样</h3><p>在<code>mysql_update</code>函数中，当通过<code>info.read_record</code>读取到一条记录之后，就要分析一下这条记录更新前后是否发生变化：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064457432-c606b775-1cd6-418d-a6d0-5873924ad1ac.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc0f351ee&margin=%5Bobject%20Object%5D&name=7.png&originHeight=253&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9100&status=done&style=none&taskId=u0e237963-ce89-4833-8fd2-3643cd26d30&title=" alt="7.png"></p>
<p>上图中的<code>compare_records</code>用于比较记录更新前后是否一样。</p>
<p>如果更新前和更新后的记录是一样的，那就直接跳过该记录，否则继续向下处理。</p>
<h3 id="4-3调用存储引擎接口进行更新"><a href="#4-3调用存储引擎接口进行更新" class="headerlink" title="4.3调用存储引擎接口进行更新"></a>4.3调用存储引擎接口进行更新</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064465088-09a2473d-99c6-408d-9e4d-b99f990e0975.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u27511522&margin=%5Bobject%20Object%5D&name=8.png&originHeight=86&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4012&status=done&style=none&taskId=u7502382c-31de-471b-964c-7c36a411c9f&title=" alt="8.png"></p>
<p>上图中的<code>ha_update_row</code>就是要存储引擎去更新记录，其中的<code>table-&gt;record[1]</code>代表旧记录，<code>table-&gt;record[0]</code>代表新记录。</p>
<h3 id="4-4更新聚簇索引记录"><a href="#4-4更新聚簇索引记录" class="headerlink" title="4.4更新聚簇索引记录"></a>4.4更新聚簇索引记录</h3><p>InnoDB会首先更新聚簇索引记录，然后再更新二级索引记录。</p>
<p>我们先看更新聚簇索引记录时都发生了什么。更新聚簇索引的函数如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064473432-21654382-e5fa-43f2-bf5e-0ba8bec0d037.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u84fad721&margin=%5Bobject%20Object%5D&name=9.png&originHeight=196&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14482&status=done&style=none&taskId=uc8824c30-dd20-42f9-a800-ee08923551b&title=" alt="9.png"></p>
<p>下边首先会尝试在同一个页面中更新记录，这被称作<code>乐观更新</code>，调用<code>btr_cur_optimistic_update</code>函数：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064483231-2c17e3ee-e420-416d-bc4b-0f8d4e7f3994.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u44b98235&margin=%5Bobject%20Object%5D&name=10.png&originHeight=552&originWidth=683&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47930&status=done&style=none&taskId=u1179f844-2109-4293-a5c8-f29cc546b08&title=" alt="10.png"></p>
<p>如果不能在本页面中完成更新（比方说更新后的记录非常大，本页面容纳不下），就会尝试<code>悲观更新</code>：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064491909-ca159954-175f-47e6-966a-741659550a7f.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue2a33d46&margin=%5Bobject%20Object%5D&name=11.png&originHeight=558&originWidth=668&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42562&status=done&style=none&taskId=uac2f0a01-daad-4b53-aeb8-6ae684f390d&title=" alt="11.png"></p>
<h3 id="4-5记录undo日志"><a href="#4-5记录undo日志" class="headerlink" title="4.5记录undo日志"></a>4.5记录undo日志</h3><p>更新记录前，首先要记录相应的undo日志，调用<code>trx_undo_report_row_operation</code>来记录undo日志：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064502431-0c4f7131-4a8b-425d-9757-2f672149a1c6.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u05b49748&margin=%5Bobject%20Object%5D&name=12.png&originHeight=109&originWidth=521&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6766&status=done&style=none&taskId=u2ea2869a-0f44-40c1-9491-5af9f7f93a0&title=" alt="12.png"></p>
<p>首先我们要知道，MySQL的undo日志是要写到一种专门存储undo日志的页面中的。如果一个事务写入的undo日志非常多，需要占用多个Undo页面，那这些页面会被串联成一个链表，称作<code>Undo页面链表</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064510479-2bff9b3f-26ce-4fb0-846f-bef98aebbfdc.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7dbdf6d5&margin=%5Bobject%20Object%5D&name=13.png&originHeight=449&originWidth=607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31612&status=done&style=none&taskId=uf9e5d3b6-fad2-461a-a878-1e74711e2be&title=" alt="13.png"></p>
<p><code>trx_undo_page_report_modify</code>函数用于真正的向Undo页面中写入undo日志。另外，由于我们这里是在修改页面，一个事务执行过程中凡是修改页面的地方，都需要记录相应的redo日志，所以在这个函数的末尾，有一个记录修改这个Undo页面的redo日志的函数<code>trx_undof_page_add_undo_rec_log</code>：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064521165-31f9b245-1152-47af-8b7e-20a980e1d184.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u28c1cd9e&margin=%5Bobject%20Object%5D&name=14.png&originHeight=119&originWidth=623&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6170&status=done&style=none&taskId=u01b8108d-b024-4c10-a30f-a6f7525f597&title=" alt="14.png"></p>
<p>是先将undo日志写入Undo页面，然后再记录修改该页面对应的redo日志吗？是的。</p>
<p>不过这里修改后的页面并没有加入buffer pool的flush链表，记录的redo日志也没有加入到redo log buffer。当这个函数执行完后，才会：</p>
<ul>
<li>先将这个过程产生的redo日志写入到redo log buffer。•再将这个过程修改的页面加入到buffer pool的flush链表中。</li>
</ul>
<p>上述过程是在<code>mtr_commit</code>中完成的：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064531599-13e91a8e-f655-4ef4-8192-989490f66514.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u33be8354&margin=%5Bobject%20Object%5D&name=15.png&originHeight=450&originWidth=482&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18258&status=done&style=none&taskId=uf029159c-8efc-4433-a8cd-e24ce830a6c&title=" alt="15.png"></p>
<blockquote>
<p>MySQL把对底层页面的一次原子修改称作一个Mini Trasaction，即MTR。一个MTR中包含若干条redo日志，在崩溃恢复时，要么全部恢复该MTR对应的redo日志，要么全部不恢复。</p>
</blockquote>
<p>也就是说实际上虽然先修改Undo页面，后写redo日志，但是此时InnoDB并不认为Undo页面是脏页，就不会将其刷新到硬盘，redo日志也没有写入到redo log buffer，这些redo日志也不会被刷新到redo日志文件。只有当MTR提交时，才先将redo日志复制到redo log buffer，再将修改的Undo页面加入到flush链表。</p>
<p>所以我们可以粗略的认为<strong>修改Undo页面的redo日志是先写的，而修改页面的过程是后发生的</strong>。</p>
<blockquote>
<p>有后台线程不断的将redo log buffer中的redo日志刷新到硬盘的redo日志文件，也有后台线程不断的将buffer pool里的脏页（只有加入到flush链表后的页面才能算作是脏页）刷新到硬盘中的表空间中。InnoDB规定，在刷新一个脏页到硬盘时，该脏页对应的redo日志应该被先刷新到redo日志文件。而redo日志是顺序刷新的，也就是说，在刷新redo log buffer的某条redo日志时，在它之前的redo日志也都应该被刷新到redo日志文件。</p>
</blockquote>
<h3 id="4-6修改页面内容"><a href="#4-6修改页面内容" class="headerlink" title="4.6修改页面内容"></a>4.6修改页面内容</h3><p>上一步骤是先把undo日志写到Undo页面中以及记录相应的redo日志，接下来该真正修改聚簇索引记录了。</p>
<p>首先更新系统字段trx_id以及roll_pointer：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064542139-441aea66-9cd1-45c5-9bc7-b74bc40927d6.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf8f43bec&margin=%5Bobject%20Object%5D&name=16.png&originHeight=111&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6622&status=done&style=none&taskId=u3f464cda-b548-42f5-a9ea-c54cc5ee6fd&title=" alt="16.png"></p>
<p>然后真正的修改记录内容：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064549916-ec80f982-11f3-4f80-a75f-fdadb77d2022.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1d179abc&margin=%5Bobject%20Object%5D&name=17.png&originHeight=114&originWidth=588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6736&status=done&style=none&taskId=u108f6c28-8e0e-4743-bbdc-1597af968dc&title=" alt="17.png"></p>
<blockquote>
<p>由于本例中的更新语句更新前后的各个字段占用的存储空间大小是不变的，所以可以直接就地（in place）更新。</p>
</blockquote>
<p>然后记录更新的redo日志：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064558278-55271491-1726-4457-a4b7-063b0f93deae.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5ecdc13c&margin=%5Bobject%20Object%5D&name=18.png&originHeight=68&originWidth=545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3096&status=done&style=none&taskId=u97f55b62-3c71-4ac7-9c85-02872ae9ae6&title=" alt="18.png"></p>
<p>像向Undo页面写入undo日志一样，InnoDB规定更新一个页面中的一条记录也属于一个MTR。在该MTR提交时，也是先将MTR中的redo日志复制到redo log buffer，然后再将修改的页面加入到flush链表。</p>
<p>所以我们也可以认为在这个过程中，<strong>先记录修改页面的redo日志，然后再真正的修改页面</strong>。</p>
<p>至此，一条聚簇索引记录就更新完毕了。</p>
<h3 id="4-7更新二级索引记录"><a href="#4-7更新二级索引记录" class="headerlink" title="4.7更新二级索引记录"></a>4.7更新二级索引记录</h3><p>更新二级索引记录的函数如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064568651-91239f36-3298-4373-a000-98eca6b8dd7c.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u79e4382e&margin=%5Bobject%20Object%5D&name=19.png&originHeight=300&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11508&status=done&style=none&taskId=udb011c18-f64b-47d5-b0cf-a572efba409&title=" alt="19.png"></p>
<p>更新二级索引记录时不会再记录undo日志，但由于是在修改页面内容，会先记录相应的redo日志。</p>
<p>由于本例子中并不会更新二级索引记录，所以就跳过本步骤了。</p>
<h2 id="5-记录binlog"><a href="#5-记录binlog" class="headerlink" title="5.记录binlog"></a>5.记录binlog</h2><p>在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就需要该语句对应的binlog日志了（下图中的<code>thd-&gt;binlog_query</code>函数）：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064683735-c227ffcd-b727-4a21-aa37-6586530769ec.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue3e42a44&margin=%5Bobject%20Object%5D&name=20.png&originHeight=365&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17192&status=done&style=none&taskId=ud5fc06ce-6583-42f0-bebc-96d1808287f&title=" alt="20.png"></p>
<p>不过值得注意的是，此时记录的binlog日志并不会被写到binlog日志文件中，而是被暂时保存到内存的某个地方，等之后事务提交的时候才会真正将该事物执行过程中产生的所有binlog统一写入binlog日志文件。</p>
<h2 id="6-提交事务的时候"><a href="#6-提交事务的时候" class="headerlink" title="6.提交事务的时候"></a>6.提交事务的时候</h2><p>在事务提交时，binlog才会被真正刷新到binlog日志文件中，redo日志也会被刷新到redo日志文件中。</p>
<h2 id="7-阶段梳理"><a href="#7-阶段梳理" class="headerlink" title="7.阶段梳理"></a>7.阶段梳理</h2><p>具体更新一条记录的流程如下：</p>
<ol>
<li> 先在B+树中定位到该记录（这个过程也被称作加锁读），如果该记录所在的页面不在buffer pool里，先将其加载到buffer pool里再读取。 </li>
<li> 读取到记录后判断记录更新前后是否一样，一样的话就跳过该记录，否则进行后续步骤。 </li>
<li> 首先更新聚簇索引记录。更新聚簇索引记录时： </li>
<li>先向Undo页面写undo日志。不过由于这是在更改页面，所以修改Undo页面前需要先记录一下相应的redo日志。</li>
<li>真正的更新记录。不过在真正更新记录前也需要记录相应的redo日志。</li>
<li> 更新其他的二级索引记录。 </li>
</ol>
<p>至此，一条记录就更新完了。</p>
<p>然后开始记录该语句对应的binlog日志，此时记录的binlog并没有刷新到硬盘上的binlog日志文件，在事务提交时才会统一将该事务运行过程中的所有binlog日志刷新到硬盘。</p>
<p>剩下的就是<code>两阶段提交</code>。</p>
<h2 id="8-XA规范"><a href="#8-XA规范" class="headerlink" title="8.XA规范"></a>8.XA规范</h2><p>有一个名叫<code>X/Open</code>的组织提出了一个名为<code>XA</code>的规范。</p>
<p>这个XA规范提出了2个角色：</p>
<ul>
<li> 一个全局事务由多个小的事务组成，所以我们得在某个地方找一个总揽全局的家伙，这个家伙用于和各个小事务进行沟通，指导它们是提交还是回滚。这个家伙被称作事务协调器（Transaction Coordinator）或者资源管理器（Resource Manager）。 </li>
<li> 管理一个小事务的家伙被称作事务管理器（Transaction Manager）。 </li>
</ul>
<p>要提交一个全局事务，那么属于该全局事务的若干个小事务就应该全部提交，只要有任何一个小事务无法提交，那么整个全局事务就应该全部回滚。所以此时<code>事务协调器</code>不能让各个<code>事务管理器</code>逐个提交，因为不能保证后面提交的<code>事务管理器</code>是否可能发生错误。此时XA规范中指出，要提交一个全局事务，必须分为2步：</p>
<ul>
<li> Prepare阶段：当<code>事务协调器</code>准备提交一个全局事务时，会依次通知各个<code>事务管理器</code>说：“现在事务中的语句都已经执行完了，我们准备提交了，你这里有没有什么问题？”。如果<code>事务管理器</code>觉得自己没有问题，就把在事务执行过程中所产生的redo日志都刷新到硬盘，然后对<code>事务协调器</code>说：“没有问题”。如果<code>事务管理器</code>遇到了啥突发情况不能提交（比方说磁盘满了，不能写redo了），就对事务协调器说：“不行，提交不了了”。 </li>
<li> Commit阶段：如果在Prepare阶段各个<code>事务管理器</code>给<code>事务协调器</code>的答复都是:“OK，木有问题”，那<code>事务协调器</code>就要真正通知各个事务管理器去提交事务了。如果在Prepare阶段某个<code>事务管理器</code>给<code>事务协调器</code>的回复是：“NO，做不了”，那<code>事务协调器</code>就得通知所有<code>事务管理器</code>：“遇到突发情况，所有人立即回滚”。<code>事务管理器</code>收到通知便都回滚了。<strong>不过在</strong><code>**事务协调器**</code><strong>通知各个</strong><code>**事务管理器**</code><strong>是要提交之前，都需在某个地方记录一下这个全局事务已经提交，以及各个事务管理器都是什么的信息。</strong> </li>
</ul>
<p>XA规范把上述全局事务提交时所经历的两个阶段称作<code>两阶段提交</code>。</p>
<blockquote>
<p>如果一个全局事务仅包含一个<code>事务管理器</code>的话，那两阶段提交可以退化成1阶段提交。</p>
</blockquote>
<p>XA规范引入了一个在事务提交时的<code>Prepare阶段</code>，这个阶段就是让各个事务做好提交前的准备，具体就是把语句执行过程中产生的redo日志都刷盘。如果语句执行过程中的redo日志都刷盘了，那么即使之后系统崩溃，那么在重启的时候还是可以恢复到该事务各个语句都执行完的样子。</p>
<p>这样的话，在Prepare阶段结束后，即使某个事务管理器因为某些原因而崩溃，在之后重启恢复时，也可以把自己再次恢复成<code>Prepare</code>状态。<strong>在崩溃恢复结束后，事务协调器可以继续让事务管理器提交或者回滚。</strong></p>
<p>以上就是XA规范的核心内容，下边可以来看一下MySQL对上述XA规范的实现。</p>
<h2 id="9-MySQL中的XA事务"><a href="#9-MySQL中的XA事务" class="headerlink" title="9.MySQL中的XA事务"></a>9.MySQL中的XA事务</h2><p>MySQL中的XA事务分为<code>外部XA</code>和<code>内部XA</code>。</p>
<h3 id="9-1外部XA"><a href="#9-1外部XA" class="headerlink" title="9.1外部XA"></a>9.1外部XA</h3><p>在MySQL的<code>外部XA</code>实现中，MySQL服务器充当<code>事务管理器</code>，而连接服务器的客户端程序充当<code>事务协调器</code>。</p>
<p>与使用<code>BEGIN</code>语句开启，使用<code>COMMIT</code>提交的常规事务不同，如果我们想在MySQL中使用XA事务，需要一些特殊的语句：</p>
<ul>
<li><code>XA &#123;START|BEGIN&#125; xid</code>：该语句用于开启一个XA事务，此时该XA事务处于<code>ACTIVE</code>状态。</li>
</ul>
<p>在一台MySQL服务器上，每个XA事务都必须有一个唯一的id，被称作<code>xid</code>。这个xid是由发起XA事务的应用程序（客户端）自己指定的，只要我们自己保证它唯一就好了。</p>
<p>这个<code>xid</code>其实是由<code>gtrid</code>、<code>bqual</code>、<code>formatID</code>三个部分组成的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xid: gtrid [, bqual [, formatID ]]</span><br></pre></td></tr></table></figure>


<p>其中<code>gtrid</code>（global transaction id）是指全局事务id，是一个<strong>字符串</strong>，<code>bqual</code>是指分支限定符，<code>formatID</code>是指gtrid和bqual所使用的格式。</p>
<p>MySQL会使用默认的值（<code>bqual</code>默认是空字符串’’，<code>formatID</code>默认是1）。也就是说我们后续内容指定<code>xid</code>时仅指定<code>gtrid</code>就好了，也就是指定一个<strong>字符串</strong>即可。</p>
<ul>
<li> <code>XA END xid</code>：在使用<code>XA START xid</code>开启了一个XA事务后，客户端就可以接着发送属于这个XA事务的各条语句，等所有语句都发送完毕后，就可以接着发送<code>XA END xid</code>来告知服务器由<code>xid</code>标识的XA事务的所有语句都输入完了。此时该XA事务处于<code>IDLE</code>状态。 </li>
<li> <code>XA PREPARE xid</code>：对于处于<code>IDLE</code>状态的XA事务，应用程序就可以询问MySQL服务器是否准备好提交这个XA事务了，此时就可以给服务器发送<code>XA PREPARE xid</code>语句。当MySQL服务器收到此语句后，就需要做准备提交前的工作了，比如把该事务执行过程中所产生的redo日志刷新到磁盘等。此时XA事务处于<code>PREPARE</code>状态。 </li>
<li> <code>XA COMMIT xid [ONE PHASE]</code>：对于处于<code>PREPARE</code>状态的XA事务，应用程序可以发送<code>XA COMMIT xid</code>来让MySQL服务器提交XA事务。如果此XA事务尚处于<code>IDEL</code>状态，那应用程序可以不发送<code>XA PREPARE xid</code>，而直接发送<code>XA COMMIT xid ONE PHASE</code>来让MySQL服务器直接提交事务即可。此XA事务处于<code>COMMITE</code>状态。 </li>
<li> <code>XA ROLLBACK xid</code>：应用程序通过发送此语句来让MySQL服务器回滚xid所标识的事务。此时XA事务处于<code>ABORT</code>状态。 </li>
<li> <code>XA RECOVER</code>：应用程序想看一下当前MySQL服务器上已经处于Prepare状态的XA事务有哪些，就可以发送该语句。 </li>
</ul>
<p>介绍了在MySQL中使用<code>外部XA</code>的一些语句，接下来可以画一个XA事务的状态转换图了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064742932-533a3e8d-f0e5-46ac-a563-c9c98bfbf919.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u73f06d50&margin=%5Bobject%20Object%5D&name=21.png&originHeight=571&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9992&status=done&style=none&taskId=u1b4ef2ab-2322-42c4-b312-6d69f67e464&title=" alt="21.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; XA START &#x27;a&#x27;;    //XA事务进入ACTIVE状态</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM x WHERE id = 1;  //XA事务中包含的语句</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; XA END &#x27;a&#x27;;      //XA事务进入IDEL状态</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; XA PREPARE &#x27;a&#x27;;  //XA事务进入PREPARE状态</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; XA COMMIT &#x27;a&#x27;;   //XA事务进入COMMIT状态</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>


<p>MySQL的外部XA除了被用于跨行转账这种经典的分布式事务应用场景，还被广泛应用于所谓的<code>数据库中间件</code>。</p>
<h3 id="9-2内部XA"><a href="#9-2内部XA" class="headerlink" title="9.2内部XA"></a>9.2内部XA</h3><p>对于一台服务器来说，即使客户端使用<code>BEGIN/START TRANSACTION</code>语句开启的普通事务，该事务所包含的语句也有可能涉及多个存储引擎。此时MySQL内部采用XA规范来保证所有支持事务的存储引擎要么全部提交，要么全部回滚，这也被称作MySQL的<code>内部XA</code>。</p>
<p><code>内部XA</code>除了解决这种设计多个存储引擎的事务之外，还解决保证binlog和存储引擎所做的修改是一致的问题。</p>
<p>在MySQL内部执行一个事务时，存储引擎会修改相应的数据，server层会记录语句对应的binlog。这是两个要么都完成，要么都不完成的事情。否则的话：</p>
<ul>
<li> 如果存储引擎修改了相应数据并且提交了事务，而server层却未写入binlog。在有主从复制的场景中，意味着这个事务不会在从库中得以执行，从而造成主从之间的数据不一致。 </li>
<li> 如果server层写入了binlog，但存储引擎却回滚了事务。在有主从复制的场景中，意味着这个事务会在从库中得以执行，从而造成主从之间的数据不一致。 </li>
</ul>
<p>那我们需要保证：<strong>如果存储引擎提交了事务，server层的binlog日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的binlog日志必须不能被写入到硬盘上</strong>。</p>
<p>MySQL采用<code>内部XA</code>来实现上述内容，下边以Innodb存储引擎为例，具体讨论一下Innodb事务的提交和binlog日志写入的过程。</p>
<h2 id="10-有binlog参与的内部XA事务"><a href="#10-有binlog参与的内部XA事务" class="headerlink" title="10.有binlog参与的内部XA事务"></a>10.有binlog参与的内部XA事务</h2><p>当客户端执行<code>COMMIT</code>语句或者在自动提交的情况下，MySQL内部开启一个XA事务，分两阶段来完成XA事务的提交：</p>
<ul>
<li>Prepare阶段：存储引擎将该事务执行过程中产生的redo日志刷盘，并且将本事务的状态设置为<code>PREPARE</code>。binlog啥也不干。</li>
</ul>
<p><code>binlog_prepare</code>是在PREPARE阶段对binlog所做的一些操作：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064760934-353179d0-cb75-4471-9607-0d41b180e2b8.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub5188c7e&margin=%5Bobject%20Object%5D&name=22.png&originHeight=237&originWidth=613&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11766&status=done&style=none&taskId=ueb837767-0ed5-4229-9c6f-ecb1f043e58&title=" alt="22.png"></p>
<p><code>binlog_prepare</code>函数基本啥也没干。</p>
<p><code>innobase_xa_prepare</code>是InnoDB存储引擎实现的XA规范的prepare接口：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064769010-c9841fde-c66d-4c0d-93a5-f2474849d1af.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u755e2532&margin=%5Bobject%20Object%5D&name=23.png&originHeight=260&originWidth=667&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15532&status=done&style=none&taskId=ucd40c539-1595-4183-88f7-46e4b82c3f2&title=" alt="23.png"></p>
<p>这个函数做了很多事情。首先我们知道事务执行过程中需要写undo日志，这些undo日志被写到若干个页面中，这些页面也被称作<code>Undo页面</code>，这些页面会串成一个链表，称作<code>Undo页面</code>链表。在一个事务对应的Undo页面链表的首个页面中，记录了一些关于这个事务的一些属性，我们贴个图看一下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064777262-81b03c04-e7a4-47b4-8563-9c958841f0a0.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u32f496bf&margin=%5Bobject%20Object%5D&name=24.png&originHeight=413&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15508&status=done&style=none&taskId=ubd1f644a-d778-4522-a2a0-feb74c15ed1&title=" alt="24.png"></p>
<p>我们先看一下其中的<code>Undo Log Segment Header</code>部分：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064789366-13314019-1a1f-483c-8752-3464d3de333f.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue27dbb6b&margin=%5Bobject%20Object%5D&name=25.png&originHeight=411&originWidth=505&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11084&status=done&style=none&taskId=uc81c7fe8-7ff3-4e86-8f32-224d12a929e&title=" alt="25.png"></p>
<p>其中的<code>TRX_UNDO_STATE</code>字段就表明该事务目前处于什么状态。当处于Prepare阶段时，调用<code>innobase_xa_prepare</code>函数会将<code>TRX_UNDO_STATE</code>字段的值设置为<code>TRX_UNDO_PREPARED</code>（整数5），表明当前事务处在Prepare阶段。</p>
<p>我们再看一下<code>Undo Log Header</code>部分：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064800895-52487e76-629d-4668-ba95-786d027feb4f.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u55b6165a&margin=%5Bobject%20Object%5D&name=26.png&originHeight=391&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16342&status=done&style=none&taskId=u647c3cdc-b4ee-458f-a1ff-e422f1609d6&title=" alt="26.png"></p>
<p>这个部分体现着这个<code>Undo页面链表</code>所属的事务的各种信息，包括事务id。其中两个属性：</p>
<ul>
<li><code>TRX_UNDO_XID_EXISTS</code>：表示有没有xid信息。</li>
<li><code>XID信息</code>：表示具体的xid是什么。</li>
</ul>
<p>当处于Prepare阶段时，调用<code>innobase_xa_prepare</code>函数会将<code>TRX_UNDO_XID_EXISTS</code>设置为TRUE，并将本次内部XA事务的<code>xid</code>（这个xid是MySQL自己生成的）写入<code>XID信息</code>处。</p>
<blockquote>
<p>修改Undo页面也是在修改页面，事务凡是修改页面就需要先记录相应的redo日志。</p>
</blockquote>
<p>记录了关于该事务的各种属性之后，接下来该将到现在为止所产生的所有redo日志进行刷盘，刷盘的函数如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064809305-48e6608f-53ed-41e8-8b20-9bbc1a106208.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u2ed9ef44&margin=%5Bobject%20Object%5D&name=27.png&originHeight=543&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35692&status=done&style=none&taskId=uaea26e40-57df-4269-a7dc-6350c6aebbe&title=" alt="27.png"></p>
<p>在将redo日志刷盘之后，即使之后系统崩溃，在重启恢复的时候也可以将处于Prepare状态的事务完全恢复。</p>
<blockquote>
<p>在MySQL 5.7中，有一个称之为<code>组提交</code>（group commit）的优化。InnoDB觉得各个事务分别刷自己的redo日志和binlog效率太低，他们把并发执行的多个事务所产生的redo日志和binlog在后续的Commit阶段集中起来统一刷新，这样可能提升效率，所以在MySQL 5.7以及之后的版本中，上述在Prepare阶段刷新redo日志的操作会被推迟到Commit阶段才真正执行。关于<code>组提交</code>的优化措施我们并不过多展开，这里就认为在Prepare阶段事务就已经将执行过程中产生的redo日志刷盘就OK。</p>
</blockquote>
<ul>
<li>Commit阶段：先将事务执行过程中产生的binlog刷新到硬盘，再执行存储引擎的提交工作。</li>
</ul>
<p>将binlog刷盘的函数如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064818003-7860c7c8-f399-4f07-90b6-168faa9ffdb2.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u68028b82&margin=%5Bobject%20Object%5D&name=28.png&originHeight=455&originWidth=693&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25594&status=done&style=none&taskId=u5146007d-ff15-4dae-b398-5c6a4c86d47&title=" alt="28.png"></p>
<p>InnoDB存储引擎提交事务使用<code>innobase_commit</code>函数完成存储引擎层面的事务提交：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064828060-cd3ae739-2133-4811-b30f-063bd0f8b296.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u507eefea&margin=%5Bobject%20Object%5D&name=29.png&originHeight=152&originWidth=642&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10074&status=done&style=none&taskId=u1111a9ab-7faf-4ff6-8f55-8734091da69&title=" alt="29.png"></p>
<p><code>innobase_commit</code>函数做了很多事情，我们挑一些重要的来说。</p>
<p>首先是更新<code>Undo页面链表</code>的状态，将我们上边说的<code>Undo Log Segment Header</code>部分的STATE字段更新一下。更新规则如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064835804-181769cb-2967-4797-b3c3-b82125590fea.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u348bd107&margin=%5Bobject%20Object%5D&name=30.png&originHeight=222&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9162&status=done&style=none&taskId=udbef64f8-7c64-4969-968b-93a025ce23c&title=" alt="30.png"></p>
<p>也就是说如果当前事务产生的undo日志比较少，那么就继续让别的事务复用该<code>Undo页面链表</code>，将STATE设置为<code>TRX_UNDO_CACHED</code>；如果<code>Undo页面链表</code>用于存储INSERT操作产生的undo日志，那么就将STATE设置为<code>TRX_UNDO_TO_FREE</code>，稍后会释放<code>Undo页面链表</code>占用的页面；如果<code>Undo页面链表</code>用于存储其他操作产生的undo日志，那么就将STATE设置为<code>TRX_UNDO_TO_PURGE</code>，等待purge线程后台回收该<code>Undo页面链表</code>。</p>
<blockquote>
<p>UPDATE、DELETE操作产生的undo日志可能会用于其他事务的MVCC操作，所以不能立即删除。</p>
</blockquote>
<p>对于存储UPDATE、DELETE操作产生的undo日志的<code>Undo页面链表</code>，还要将其加入所谓的History链表。</p>
<p>每个<code>Undo页面链表</code>的首个页面的页号会被存储在表空间的某个地方，以便崩溃恢复的时候可以根据该页来进行恢复。如果此时在事务提交时，<code>Undo页面链表</code>的状态被设置为<code>TRX_UNDO_CACHED</code>，那存储<code>Undo页面链表</code>的首个页面的页号的地方也就不需要做改动；如果此时在事务提交时，<code>Undo页面链表</code>的状态被设置为<code>TRX_UNDO_CACHED</code>，那存储<code>Undo页面链表</code>的首个页面的页号的地方就得被设置为空，这样这个地方就可以被其他事务使用了。</p>
<p>至此，这个事务就算是提交完了。</p>
<h2 id="11-崩溃恢复"><a href="#11-崩溃恢复" class="headerlink" title="11.崩溃恢复"></a>11.崩溃恢复</h2><p>每当系统重启时，都会先进入恢复过程。</p>
<p>此时首先按照已经刷新到磁盘的redo日志修改页面，把系统恢复到崩溃前的状态。</p>
<p>然后在表空间中找一下各个<code>Undo页面链表</code>的首个页面的页号，然后就可以读取该页面的各种信息。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/12610368/1642064846064-23aa334e-0253-41a9-9d6a-ee2376f4b719.png#clientId=u1ca64b84-5777-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u10b5f9ba&margin=%5Bobject%20Object%5D&name=31.png&originHeight=413&originWidth=796&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15508&status=done&style=none&taskId=uc72353d2-5577-4e8a-b0ff-5edca7ce9b2&title=" alt="31.png"></p>
<p>通过这个页面，我们可以知道该<code>Undo页面链表</code>对应的事务状态是什么：</p>
<ul>
<li> 如果是<code>TRX_UNDO_ACTIVE</code>状态，也就是活跃状态，直接按照undo日志里记载的内容将其回滚就好了。 </li>
<li> 如果是<code>TRX_UNDO_PREPARE</code>状态，那么是提交还是回滚就取决于binlog的状态了，我们稍后再说。 </li>
<li> 如果是其他状态，就将该事务提交即可。 </li>
</ul>
<p>对于处于PREPARE状态的事务，存储引擎既可以提交，也可以回滚，这取决于目前该事务对应的binlog是否已经写入硬盘。这时就会读取最后一个binlog日志文件，从日志文件中找一下有没有该PREPARE事务对应的xid记录，如果有的话，就将该事务提交，否则就回滚好了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/24/MySQL/MySQL[%E4%BA%8C%E5%8D%81%E5%9B%9B]%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/">https://yinhuidong.github.io/2022/01/24/MySQL/MySQL[二十四]两阶段提交/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/"><img class="next-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL[二十三]二进制日志</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/01/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/" title="MySQL[一]入门"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-01</div><div class="title">MySQL[一]入门</div></div></a></div><div><a href="/2021/12/01/MySQL/MySQL5.7%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/" title="MySQL[前置]Windows下安装MySQL57"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">MySQL[前置]Windows下安装MySQL57</div></div></a></div><div><a href="/2022/01/07/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/" title="MySQL[七]基于成本的优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-07</div><div class="title">MySQL[七]基于成本的优化</div></div></a></div><div><a href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-20</div><div class="title">MySQL[二十]海量数据处理</div></div></a></div><div><a href="/2022/01/09/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL[九]基于规则的优化&子查询优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-09</div><div class="title">MySQL[九]基于规则的优化&子查询优化</div></div></a></div><div><a href="/2022/01/03/MySQL/MySQL%5B%E4%B8%89%5DInnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/" title="MySQL[三]InnoDB索引结构"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-03</div><div class="title">MySQL[三]InnoDB索引结构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-text">1.准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-text">2.执行计划的生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C"><span class="toc-text">3.真正开始执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E5%A4%84%E7%90%86%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-text">3.1处理扫描区间的第一条记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%A4%84%E7%90%86%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-text">3.2处理扫描区间的第二条记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%A4%84%E7%90%86%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4%E7%9A%84%E5%89%A9%E4%BD%99%E8%AE%B0%E5%BD%95"><span class="toc-text">3.3处理扫描区间的剩余记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%A6%E7%BB%86%E7%9A%84%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">4.详细的更新过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E5%B0%86%E8%AE%B0%E5%BD%95%E6%89%80%E5%9C%A8%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%88%B0buffer-pool"><span class="toc-text">4.1将记录所在的页面加载到buffer pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E6%A3%80%E6%B5%8B%E6%9B%B4%E6%96%B0%E5%89%8D%E5%90%8E%E8%AE%B0%E5%BD%95%E6%98%AF%E5%90%A6%E4%B8%80%E6%A0%B7"><span class="toc-text">4.2检测更新前后记录是否一样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0"><span class="toc-text">4.3调用存储引擎接口进行更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E6%9B%B4%E6%96%B0%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E8%AE%B0%E5%BD%95"><span class="toc-text">4.4更新聚簇索引记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E8%AE%B0%E5%BD%95undo%E6%97%A5%E5%BF%97"><span class="toc-text">4.5记录undo日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9"><span class="toc-text">4.6修改页面内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7%E6%9B%B4%E6%96%B0%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E8%AE%B0%E5%BD%95"><span class="toc-text">4.7更新二级索引记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%B0%E5%BD%95binlog"><span class="toc-text">5.记录binlog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%97%B6%E5%80%99"><span class="toc-text">6.提交事务的时候</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%98%B6%E6%AE%B5%E6%A2%B3%E7%90%86"><span class="toc-text">7.阶段梳理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-XA%E8%A7%84%E8%8C%83"><span class="toc-text">8.XA规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MySQL%E4%B8%AD%E7%9A%84XA%E4%BA%8B%E5%8A%A1"><span class="toc-text">9.MySQL中的XA事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E5%A4%96%E9%83%A8XA"><span class="toc-text">9.1外部XA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E5%86%85%E9%83%A8XA"><span class="toc-text">9.2内部XA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%9C%89binlog%E5%8F%82%E4%B8%8E%E7%9A%84%E5%86%85%E9%83%A8XA%E4%BA%8B%E5%8A%A1"><span class="toc-text">10.有binlog参与的内部XA事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-text">11.崩溃恢复</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/24/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E5%9B%9B%5D%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL[二十四]两阶段提交"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十四]两阶段提交"/></a><div class="content"><a class="title" href="/2022/01/24/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E5%9B%9B%5D%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" title="MySQL[二十四]两阶段提交">MySQL[二十四]两阶段提交</a><time datetime="2022-01-23T16:00:00.000Z" title="发表于 2022-01-24 00:00:00">2022-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/" title="MySQL[二十三]二进制日志"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十三]二进制日志"/></a><div class="content"><a class="title" href="/2022/01/23/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%89%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97/" title="MySQL[二十三]二进制日志">MySQL[二十三]二进制日志</a><time datetime="2022-01-22T16:00:00.000Z" title="发表于 2022-01-23 00:00:00">2022-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/22/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%BA%8C%5DCOUNT/" title="MySQL[二十二]COUNT"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十二]COUNT"/></a><div class="content"><a class="title" href="/2022/01/22/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%BA%8C%5DCOUNT/" title="MySQL[二十二]COUNT">MySQL[二十二]COUNT</a><time datetime="2022-01-21T16:00:00.000Z" title="发表于 2022-01-22 00:00:00">2022-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/21/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%80%5DLIMIT/" title="MySQL[二十一]LIMIT"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十一]LIMIT"/></a><div class="content"><a class="title" href="/2022/01/21/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%E4%B8%80%5DLIMIT/" title="MySQL[二十一]LIMIT">MySQL[二十一]LIMIT</a><time datetime="2022-01-20T16:00:00.000Z" title="发表于 2022-01-21 00:00:00">2022-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理"><img src="/images/cover/mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL[二十]海量数据处理"/></a><div class="content"><a class="title" href="/2022/01/20/MySQL/MySQL%5B%E4%BA%8C%E5%8D%81%5D%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/" title="MySQL[二十]海量数据处理">MySQL[二十]海量数据处理</a><time datetime="2022-01-19T16:00:00.000Z" title="发表于 2022-01-20 00:00:00">2022-01-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>