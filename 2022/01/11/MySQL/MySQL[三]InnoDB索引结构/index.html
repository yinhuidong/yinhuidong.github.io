<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL[三]InnoDB索引结构 | 二十</title><meta name="keywords" content="MySQL"><meta name="author" content="二十"><meta name="copyright" content="二十"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="InnoDB索引结构">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL[三]InnoDB索引结构">
<meta property="og:url" content="https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[%E4%B8%89]InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="二十">
<meta property="og:description" content="InnoDB索引结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yinhuidong.github.io/images/cover/mysql.png">
<meta property="article:published_time" content="2022-01-11T03:08:18.570Z">
<meta property="article:modified_time" content="2022-01-11T03:14:40.784Z">
<meta property="article:author" content="二十">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yinhuidong.github.io/images/cover/mysql.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[%E4%B8%89]InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL[三]InnoDB索引结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-11 11:14:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="referrer" content="no-referrer" /><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cover/mysql.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">二十</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/%E5%85%B3%E4%BA%8E%E6%88%91/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL[三]InnoDB索引结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-11T03:08:18.570Z" title="发表于 2022-01-11 11:08:18">2022-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-11T03:14:40.784Z" title="更新于 2022-01-11 11:14:40">2022-01-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL[三]InnoDB索引结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>索引其实就是对数据按照某种格式进行存储的文件。就InnoDB来讲，索引文件里面会有很多的基本单元【页】。<br>​</p>
<blockquote>
<p>为什么有页的概念？<br>​</p>
</blockquote>
<blockquote>
<p>查询数据的时候直接交互磁盘，效率显然又会很慢，所以真正处理数据的过程其实是在内存中，这样就需要把磁盘的数据加载到内存，如果是写操作，可能还要将内存的数据再次刷新到磁盘。如果内存与磁盘的数据交互过程是基于一条条记录来进行的，显然又会很慢，所以InnoDB采取的方式是将数据划分为若干个页，以页来作为内存和磁盘交互的基本单位，默认大小为16KB。</p>
</blockquote>
<p>​</p>
<p>数据或者叫记录，其实是以【行】的格式存储在页里面的，可以简单的理解成页里面的一行对应一条记录。<br>​</p>
<blockquote>
<p>当然索引文件里面肯定不光只有页，还会有其余的东西，页里面也不光只有行格式，也会有额外的信息，这个下面我们会详细分析，至此我们仅仅需要明确一下索引的概念和层级关系。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796442070-30497473-d6d6-4848-9622-3ef7c4be8eab.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5dd411f3&margin=%5Bobject%20Object%5D&name=%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.jpg&originHeight=816&originWidth=678&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24988&status=done&style=shadow&taskId=u7ea9c417-2241-4f50-b784-ce1b7ae3a67&title=" alt="索引的层级关系.jpg"></p>
<p>明确了这个层级关系之后，接下来我们来从最基础的行格式来进行分析。</p>
<h1 id="一，行格式"><a href="#一，行格式" class="headerlink" title="一，行格式"></a>一，行格式</h1><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存储形式被称为行格式或者记录格式，截至目前，一共有4种行格式。分别是 <code>compact</code> <code>redundant</code> <code>dynamic</code> <code>compressed</code>，MySQL5.7默认的行格式为<code>dynamic</code>。</p>
<h2 id="1-如何指定行格式"><a href="#1-如何指定行格式" class="headerlink" title="1. 如何指定行格式"></a>1. 如何指定行格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line">    </span><br><span class="line">ALTER TABLE 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure>


<p>比如我们创建一张表来指定行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> record_format(</span><br><span class="line">  c1 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  c2 <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  c3 <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  c4 <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">)charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="keyword">VALUES</span>(<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="string">&#x27;eeee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>


<h2 id="2-compact-行格式"><a href="#2-compact-行格式" class="headerlink" title="2.compact 行格式"></a>2.compact 行格式</h2><p>首先我们来看Compact行格式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796457336-bb5e4bf7-0f44-4c11-9580-32077f221ac3.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u510eb047&margin=%5Bobject%20Object%5D&name=Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png&originHeight=513&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=108011&status=done&style=shadow&taskId=u3c55f797-d70f-44c7-bc54-b58728aaeaf&title=" alt="Compact行格式示意图.png"></p>
<p>一条完整的行格式可以被分为两个部分：记录额外信息的部分&amp;记录真实数据的部分。</p>
<h3 id="2-1-额外的信息"><a href="#2-1-额外的信息" class="headerlink" title="2.1 额外的信息"></a>2.1 额外的信息</h3><p>额外的信息实包含三部分：变长字段的长度列表，NULL值列表和记录头信息。</p>
<h4 id="2-1-1-变长字段长度列表"><a href="#2-1-1-变长字段长度列表" class="headerlink" title="2.1.1 变长字段长度列表"></a>2.1.1 变长字段长度列表</h4><p>MySQL支持很多的变长字段，我们就以最经典的varchar来进行举例，变长字段的数据存储多少字节其实是不固定的，所以在存储真实的数据的时候，要记录一下真实数据的字节数，这样的话，一个变长字段列实际上就占用了两部分的空间来存储：【真实数据】&amp;【真实数据占用字节数】。</p>
<blockquote>
<p>注意：对于一个列varchar(100)，我们实际上存储一个10字节的数据，当在内存中为这个列的数据分配内存空间的时候，实际上会分配100字节，但是这个列的数据在磁盘上，实际上只会分配10字节。</p>
</blockquote>
<p>在Compact行格式中，会把所有的变长字段占用的真实长度全部<strong>逆序</strong>存储在记录的开头位置，形成一个变长字段长度列表。</p>
<p>比如我们刚才创建的那张表，我们来分析一下：</p>
<p>c1,c2,c4三个列都是变长字段，所以这三个列的值的长度其实都需要保存到变长字段长度列表，因为这张表的字符集的ASCII，所以每个字符实际只占用1字节来进行编码：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>储存内容</th>
<th>内容长度(十进制表示)</th>
<th>内容长度(十六进制表示)</th>
</tr>
</thead>
<tbody><tr>
<td>C1</td>
<td>‘aaaa’</td>
<td>4</td>
<td>0x04</td>
</tr>
<tr>
<td>C2</td>
<td>‘bbb’</td>
<td>3</td>
<td>0x03</td>
</tr>
<tr>
<td>C4</td>
<td>‘d’</td>
<td>1</td>
<td>0x01</td>
</tr>
</tbody></table>
<p>因为这些长度是按照逆序来存放的，所以最终变长字段长度列表的字节串用十六进制表示的效果就是【010304】。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796496893-933ea1aa-d845-4f94-9328-beff8d57dbc4.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8653fe78&margin=%5Bobject%20Object%5D&name=%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=471&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96980&status=done&style=shadow&taskId=u7e13eb1a-bbe3-4c44-8f4e-7237f99dd6f&title=" alt="第一条记录的存储格式.png"></p>
<p>因为我们演示的这条记录中，c1,c2,c4列中的字符串都比较短，所以真实的数据占用的字节数就比较小，真实数据的长度用一个字节就可以表示，但是如果变长列的内容占用字节数比较多，可能就需要用2个字节来表示。对此InnoDB的规定是：</p>
<p>【W】：某个字符集中表示一个字符最多需要使用的字节数</p>
<p>【M】：当前列类型最多能存储的字符数(比如varchar(100),M=100),如果换算成字节数就是W*M</p>
<p>【L】：真实占用的字节数</p>
<ol>
<li>如果M*W&lt;=255,那么使用1字节来表示字符串实际用到的字节数。</li>
</ol>
<blockquote>
<p>InnoDB在读记录的变长字段长度列表的时候会先去查看表结构，判断用几个字节去存储的。</p>
</blockquote>
<ol start="2">
<li>如果M*W&gt;=255,这个时候再次分为两种情况： <ol>
<li>如果L&lt;=127，那就用1个字节表示</li>
<li>否则就用2个字节表示</li>
</ol>
</li>
</ol>
<blockquote>
<p>如果某个变长字段允许存储的最大字节数大于255的时候，怎么区分他正在读取的字节是一个单独的字段长度还是半个字段长度呢？</p>
<p>InnoDB用该字节的第一个二进制为作为标志位，0：单独的字段长度，1：半个字段长度。</p>
<p>对于一些占用字节数特别多的字段，单个页都无法存储的时候，InnoDB会把一部分数据放到所谓的溢出页，在变长字段长度列表中只会记录当前页的字段长度，所以用两个字节也可以存的下。</p>
</blockquote>
<p>此外，变长字段的长度列表中只存储真实数据值为非NULL的列占用的长度，真实数据为NULL的列的长度是不存储的。</p>
<p>也并不是所有的记录都会有变长字段长度列表，假如表中的列要是没有变长字段，或者记录中的变长字段值都是NULL，那就没有变长字段长度列表了。</p>
<h4 id="2-1-2-NULL值列表"><a href="#2-1-2-NULL值列表" class="headerlink" title="2.1.2 NULL值列表"></a>2.1.2 NULL值列表</h4><p>如果一条记录有多个字段的真实值为NULL，不统一管理的话就会比较占用空间，所以抽取出来了NULL值列表。</p>
<p>当然如果这个表的所有字段都是NOT NULL约束的，就不会有NULL值列表。</p>
<p>看一下处理过程：</p>
<ol>
<li>首先统计出表中允许存储NULL的字段</li>
<li>如果表中没有NULL字段的列，那就没必要再往下了，否则将每个允许存储NULL的列对应的一个二进制位按照列的顺序逆序排列。1：NULL，0：不是NULL。</li>
<li>MySQL规定NULL值必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</li>
</ol>
<p>以此类推，如果一个表中有9个字段允许为NULL，那么这个记录的NULL值列表部分就需要2个字节来表示。</p>
<p>这个时候再来看我们上面创建的表中的记录。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796522793-2b2f0b54-2e1b-4534-97fc-ad5d2ae29267.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua59c3787&margin=%5Bobject%20Object%5D&name=%E8%A1%A8%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F.png&originHeight=578&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116004&status=done&style=shadow&taskId=u474c254b-e5cb-420c-939e-50e0762c364&title=" alt="表中记录的存储格式.png"></p>
<h4 id="2-1-3-记录头信息"><a href="#2-1-3-记录头信息" class="headerlink" title="2.1.3 记录头信息"></a>2.1.3 记录头信息</h4><p>由五个固定的字节组成，换算成二进制就是40位，每一部分代表不同的信息。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651393775-13c8a071-3007-4743-98e6-6bfadf766833.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=nEsCg&originHeight=238&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>接下来来看记录的真实数据。</p>
<h3 id="2-2-真实数据"><a href="#2-2-真实数据" class="headerlink" title="2.2 真实数据"></a>2.2 真实数据</h3><p>除了表中显式定义的列，MySQL会往我们的表中放一些隐藏列。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>【row_id】：这个玩意，跟主键的选择有关，如果我们显式定义了表的主键，就不会有它，如果我们没显式定义主键，那么会去选择一个unique的列作为主键，如果unique的列也没有，那么就会生成一个row_id列作为隐藏的主键。</p>
<p>【transaction_id】&amp;【roll_pointer】和一致性非锁读(MVCC)有关,后面遇到的时候我会在分析介绍。</p>
<p>在完善下我们开头创建的那张表的记录形象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651419885-ccc53e84-579f-4e2b-aaa3-c2da800dcf5b.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=EzoHh&originHeight=480&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>至此，其实就剩下我们显式插入数据库的真实记录了，但是还有一个特殊的类型需要说明一下。</p>
<h4 id="2-2-1-CHAR-也是变长的？"><a href="#2-2-1-CHAR-也是变长的？" class="headerlink" title="2.2.1 CHAR 也是变长的？"></a>2.2.1 CHAR 也是变长的？</h4><p>在Compact行格式下只会把变长类型的列的长度逆序记录到变长字段长度列表，但是这其实和我们的字符集有关系，上面我们创建的表显式指定为ASCII字符集，这个时候一个字符只会用一个字节表示，但是假如我们指定的是其它字符集，比如utf8，这个时候一个字符用几个字节表示就不确定了，所以CHAR列的真实字节长度也会被记录到变长字段长度列表。</p>
<p>另外，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)就没有这个要求。</p>
<blockquote>
<p>对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。</p>
</blockquote>
<h2 id="3-行溢出"><a href="#3-行溢出" class="headerlink" title="3. 行溢出"></a>3. 行溢出</h2><p>上面提到了，如果一条记录的真实字节数太大，就会导致行溢出，把超出的一部分数据存储到其他行或者页。</p>
<h3 id="3-1-varchar-M-最多能存储的数据"><a href="#3-1-varchar-M-最多能存储的数据" class="headerlink" title="3.1 varchar(M)最多能存储的数据"></a>3.1 varchar(M)最多能存储的数据</h3><p>varchar(M)的列最多可以占用65535个字节。其中M代表该类型最多存储的字符数量。</p>
<p>实际上，MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB，TEXT类型的列之外，其他所有的列(不包含隐藏列和记录头信息)占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，比如说我们为了存储一个varchar列，其实还需要占用3部分空间。</p>
<ol>
<li>真实数据</li>
<li>真实数据占用的字节长度</li>
<li>NULL值标识，如果该列有NOT_NULL属性则可以没有这部分存储空间</li>
</ol>
<p>如果该varchar类型的列没有NOT NULL属性那最多只能存储65532个字节的数据，因为真实数据的长度可能占用2个字节，NULL值标识需要占用1个字节。</p>
<p>如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。</p>
<p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那会怎么样呢？</p>
<p>如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。</p>
<blockquote>
<p>上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！</p>
</blockquote>
<h3 id="3-2-记录中的数据太多产生溢出"><a href="#3-2-记录中的数据太多产生溢出" class="headerlink" title="3.2 记录中的数据太多产生溢出"></a>3.2 记录中的数据太多产生溢出</h3><p>MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65532个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。</p>
<p>在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651449173-c7c3df4a-7697-4e98-8461-0f4d8fa25acf.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=YE1nR&originHeight=698&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>从图中可以看出来，对于Compact和Redundant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651459938-08f5b09b-16a1-4981-b0db-58ce8c2776fd.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=yQ6dC&originHeight=427&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>不只是 VARCHAR(M)类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p>
<h3 id="3-3-行溢出的临界点"><a href="#3-3-行溢出的临界点" class="headerlink" title="3.3 行溢出的临界点"></a>3.3 行溢出的临界点</h3><p>发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？</p>
<p>MySQL中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。我们往表中插入亮条记录，每条记录最少插入多少字节的数据才会行溢出呢？</p>
<p>分析一下页空间是如何利用的</p>
<ol>
<li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要132个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。</li>
<li>每个记录需要的额外信息是27字节。这27个字节包括下边这些部分：<table>
<thead>
<tr>
<th>内容</th>
<th>大小(字节)</th>
</tr>
</thead>
<tbody><tr>
<td>真实数据的长度</td>
<td>2</td>
</tr>
<tr>
<td>列是否是NULL值</td>
<td>1</td>
</tr>
<tr>
<td>头信息</td>
<td>5</td>
</tr>
<tr>
<td>row_id</td>
<td>6</td>
</tr>
<tr>
<td>transaction_id</td>
<td>6</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>7</td>
</tr>
</tbody></table>
</li>
</ol>
<p>因为表中具体有多少列不确定，所以没法确定具体的临界点，只需要知道插入的字段数据长度很大就会导致行溢出的现象。</p>
<h2 id="4-Dynamic-amp-Compressed-行格式"><a href="#4-Dynamic-amp-Compressed-行格式" class="headerlink" title="4.Dynamic &amp; Compressed 行格式"></a>4.Dynamic &amp; Compressed 行格式</h2><p>这俩行格式和Compact行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639651470552-ca5845c2-4a02-4778-8072-12e7cfc5e936.png#crop=0&crop=0&crop=1&crop=1&id=DwYBu&originHeight=456&originWidth=1318&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>Compressed行格式和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p>
<blockquote>
<p>至此，行格式就分析的差不多了，接下来我们来看页的存储结构。</p>
</blockquote>
<h1 id="二，页的存储结构"><a href="#二，页的存储结构" class="headerlink" title="二，页的存储结构"></a>二，页的存储结构</h1><p>InnoDB为了不同的目的设计了许多种页，比如存放表空间头部信息的页，存放 Insert Buffer信息的页，存放Innode信息的页，存放undo日志信息的页等等。</p>
<p>本节分析存放表中记录的页，官方成为索引页，为了分析方便，我们暂且叫做数据页。</p>
<blockquote>
<p>系统变量innodb_page_size表明了InnoDB存储引擎中的页大小，默认值是16384字节，也就是16kb。 该变量只能在第一次初始化MySQL数据目录时指定，之后就再也不能更改了。</p>
</blockquote>
<p>数据页代表的这块16kb的存储空间被划分为多个部分，不同部分有不同的功能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796599016-6db7f08f-012c-4991-beb7-f86a02b783e9.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u24a51a9d&margin=%5Bobject%20Object%5D&name=%E8%A1%8C%E6%A0%BC%E5%BC%8F%26%E9%A1%B5%E7%BB%93%E6%9E%84.png&originHeight=1924&originWidth=2164&originalType=binary&ratio=1&rotation=0&showTitle=false&size=761701&status=done&style=shadow&taskId=ua68b2010-2f09-4933-82b5-8624ccfa018&title=" alt="行格式&amp;页结构.png"></p>
<p>从图中可以看出，一个InnoDB数据页的存储空间大致被划分为了7个部分，有的部分占用的字节数是确定的，有的占用的字节数不是确定的。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小（字节）</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infifmum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<h2 id="1-记录在页中的存储"><a href="#1-记录在页中的存储" class="headerlink" title="1. 记录在页中的存储"></a>1. 记录在页中的存储</h2><p>我们先来创建一张表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> page_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">int</span> ,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">varchar</span>(<span class="number">10000</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">primary</span> key(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) charset<span class="operator">=</span>ascii row_format<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>


<p>因为我们指定了主键，所以存储实际数据的列里面不会有隐藏的row_id,我们来看一下他的行格式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658751624-f2ae040c-521a-4279-a33a-3d049076dbbb.png#crop=0&crop=0&crop=1&crop=1&id=rhsyy&originHeight=443&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>再次回顾下记录头中5个字节表示的数据。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型  0 ：普通记录，1：B+树非页节点记录，2：最小记录，3：最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>针对当前这个表的行格式简化图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639658929002-26d8d2aa-f31f-4424-9364-53bb1e935f02.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=JuPWk&originHeight=328&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>接下来我们往表中插入几条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;aaaa&#x27;</span>), (<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>), (<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;cccc&#x27;</span>), (<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;dddd&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p>为了分析这些记录在页的User Records 部分中是怎么表示的，把记录头信息和实际的列数据都用十进制表示出来了（其实是一堆二进制位），所以这些记录的示意图就是：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639659360000-9ea955da-a191-4149-a654-02130cd27262.png?x-oss-process=image/resize,w_1500#crop=0&crop=0&crop=1&crop=1&id=IQRli&originHeight=511&originWidth=1500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>分析一下头信息中的每个属性是什么意思。</p>
<h3 id="1-1-delete-mask"><a href="#1-1-delete-mask" class="headerlink" title="1.1 delete_mask"></a>1.1 delete_mask</h3><p>标记当前记录是否被删除，占用1个二进制位，0：未删除，1：删除。</p>
<p>被删除的记录不会立即从磁盘上删除，因为删除他们之后吧其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记，所有被删掉的数据会组成一个垃圾链表，在这个链表中的记录占用的空间成为可重用空间，之后如果有新的记录插入到表中，可能会把这些删除的记录覆盖掉。</p>
<blockquote>
<p>将delete_mask 设置为1 和 将被删除的记录加入到垃圾链表中其实是两个阶段。</p>
</blockquote>
<h3 id="1-2-min-rec-mask"><a href="#1-2-min-rec-mask" class="headerlink" title="1.2 min_rec_mask"></a>1.2 min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记，如果这个字段的值是0，意味着不是B+树的非叶子节点中的最小记录。</p>
<h3 id="1-3-n-owned"><a href="#1-3-n-owned" class="headerlink" title="1.3 n_owned"></a>1.3 n_owned</h3><h3 id="1-4-heap-no"><a href="#1-4-heap-no" class="headerlink" title="1.4 heap_no"></a>1.4 heap_no</h3><p>这个属性表示当前记录在本页中的位置，我们插入的四条记录在本页中的位置分别是 2，3，4 ，5 。为什么不见 0 和 1 的记录呢？</p>
<p>这是因为InnoDB自动给每个页里边加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。</p>
<p>记录是如何比较大小的？对于一条完整的记录来说，比较记录大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别为1，2，3，4，这也就意味着这四条记录的大小从大到小递增。</p>
<p>但是不管我们往页中插入了多少自己的记录，InnoDB都规定他们定义的两条伪记录分别为最小记录和最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660568126-eca45a45-699f-4c18-a914-9b0082e4409e.png#crop=0&crop=0&crop=1&crop=1&id=Qa0fp&originHeight=341&originWidth=586&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>由于这两条记录不是我们自己定义的记录，所以他们并不存放在页的User Records部分，他们被单独放在一个称为Infimum+Supremum的部分。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639660690280-f21f9cde-a88c-43b7-bed2-e61cdf99821c.png#crop=0&crop=0&crop=1&crop=1&id=yv4uT&originHeight=417&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>从图中我们可以看出来，最小记录和最大记录的heap_no值分别是0 和 1 ， 也就是说他们的位置最靠前。</p>
<h3 id="1-5-record-type"><a href="#1-5-record-type" class="headerlink" title="1.5 record_type"></a>1.5 record_type</h3><p>这个属性表示当前记录的类型。0：普通记录，1：B+树非叶子节点记录，2：最小记录，3：最大记录。</p>
<p>我们自己插入的记录是普通记录 0 ， 而最大记录和最小记录record_type 分别为 2 和 3。</p>
<h3 id="1-6-next-record"><a href="#1-6-next-record" class="headerlink" title="1.6 next_record"></a>1.6 next_record</h3><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一条链表，可以通过一条记录找到他的下一条记录，但是下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 infimum记录 的下一条记录就是本页主键值最小的用户记录，而本页中主键最大的用户记录的下一条记录就是supremum记录。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661137395-fec2e2b7-c0d0-4ecd-8cf0-ff73e86cd98b.png#crop=0&crop=0&crop=1&crop=1&id=GEIoi&originHeight=509&originWidth=1025&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>如果从中删除一条记录，这个链表也是会跟着变化的，假如现在删除第二条记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span><span class="number">2</span> ;</span><br></pre></td></tr></table></figure>


<p>删除第二条记录以后：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661263287-6bf68c5d-2b08-49f7-9b64-91ff84f8c25f.png#crop=0&crop=0&crop=1&crop=1&id=ehUJN&originHeight=472&originWidth=994&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>发生的变化：</p>
<ul>
<li>第二条记录并没有从存储空间中移除，而是把该记录的delete_mask设置为1</li>
<li>第二条记录的next_records值变成了0，意味着该记录没有下一条记录了</li>
<li>第一条记录的next record指向了第三条记录</li>
<li>最大记录的 n_owned 值从5 变成了4</li>
</ul>
<p>所以，不论我们怎么对页中的记录做增删改查操作，InnoDB始终会维护一条记录的单链表，链表中各个节点是按照主键值由小到大的顺序连接起来的。</p>
<p>next_records 为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？</p>
<p>因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表，null值列表中的信息都是逆序存放的，这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。</p>
<p>因为主键值为2的记录已经被我们删除了，但是存储空间并没有回收，如果再次把这条记录插入到表中，会发生什么？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;bbbb&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639661938956-dbc09fae-e330-4b44-a97c-ad28500fb0c0.png#crop=0&crop=0&crop=1&crop=1&id=N59w2&originHeight=516&originWidth=1109&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>从图中可以看到，InnoDB并没有因为新记录的插入而为他申请新的存储空间，而是直接复用了原来删除的记录的存储空间。</p>
<h2 id="2-Page-Directory（页目录）"><a href="#2-Page-Directory（页目录）" class="headerlink" title="2. Page Directory（页目录）"></a>2. Page Directory（页目录）</h2><p>如果我们想根据主键值查找页中某条记录该咋办？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page_demo <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>


<ol>
<li> 将所有正常的记录(包括两条隐藏记录但是不包括已经标记为删除的记录)划分为几组 </li>
<li> 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组拥有多少条记录 </li>
<li> 将每个组的最后一条记录的地址偏移量单独提取出来按照顺序存储到靠近页的尾部的地方，这个地方就是所谓的【Page Directory】,也就是页目录。页目录中的这些地址偏移量被称为槽，所以页目录就是由槽组成的 </li>
</ol>
<p>比方说刚才创建的表中正常的记录由6条，InnoDB会把他们分成两组，第一组中只有一条最小记录，第二组中是剩余的5条记录。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663655164-28caa8e4-aceb-4b4e-aaaf-75ab188453c9.png#crop=0&crop=0&crop=1&crop=1&id=xFmTO&originHeight=481&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值为112，代表最大记录的地址偏移量；槽0的值为99，代表最小记录的地址偏移量。</p>
<p>注意最大和最小记录的头信息的n_owned属性：</p>
<ol>
<li>最小记录中的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身</li>
<li>最大记录中的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录</li>
</ol>
<p>【99】&amp;【112】这样的地址偏移量很不直观，我们用箭头指向的方式替代数字。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663745413-7924a9ec-b680-4231-8686-eb99c41946df.png#crop=0&crop=0&crop=1&crop=1&id=k3iqz&originHeight=541&originWidth=1038&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 <strong><em>1</em></strong> 条记录，最大记录所在的分组拥有的记录条数只能在 <strong><em>1~8</em></strong> 条之间，剩下的分组中记录的条数范围只能在是 <strong><em>4~8</em></strong> 条之间。所以分组是按照下边的步骤进行的：</p>
<ul>
<li> 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 </li>
<li> 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。 </li>
<li> 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。 </li>
</ul>
<p>由于现在page_demo表中的记录太少，无法演示添加了页目录之后加快查找速度的过程，所以再往page_demo表中添加一些记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;eeee&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;ffff&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;gggg&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;hhhh&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;iiii&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;jjjj&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;kkkk&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;llll&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;mmmm&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;nnnn&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;oooo&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;pppp&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639663920121-ec3b0a9f-f512-432d-a584-fb3187b0a0bf.png#crop=0&crop=0&crop=1&crop=1&id=caRNN&originHeight=632&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=shadow&title="></p>
<p>现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：</p>
<ol>
<li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li>
<li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li>
<li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li>
</ol>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ol>
<h2 id="3-Page-Header（页面头部）"><a href="#3-Page-Header（页面头部）" class="headerlink" title="3.Page Header（页面头部）"></a>3.Page Header（页面头部）</h2><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，它是页结构的第二部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2</td>
<td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<h2 id="4-File-Header（文件头部）"><a href="#4-File-Header（文件头部）" class="headerlink" title="4.File Header（文件头部）"></a>4.File Header（文件头部）</h2><p>File Header针对各种类型的页都通用，也就是说不同类型的页都会以File Header作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁，这个部分占用固定的38个字节。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<p>InnoDB为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_UNDO_LOG</td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_SYS</td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td>FIL_PAGE_INDEX</td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的数据页</td>
</tr>
</tbody></table>
<p>我们存放记录的数据页的类型其实是<strong>FIL_PAGE_INDEX</strong>，也就是所谓的索引页。</p>
<p>有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），InnoDB可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，<code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们现在分析的数据页（也就是类型为<strong>FIL_PAGE_INDEX</strong>的页）是有这两个属性的，所以所有的数据页其实是一个双链表。</p>
<h2 id="5-File-Trailer-文件尾部"><a href="#5-File-Trailer-文件尾部" class="headerlink" title="5.File Trailer(文件尾部)"></a>5.File Trailer(文件尾部)</h2><p>如果页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办？</p>
<p>为了检测一个页是否完整，在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：</p>
<ol>
<li>前四个字节代表校验和</li>
<li>后四个字节代表页面被最后修改时对应的日志序列位置</li>
</ol>
<p>这个File Trailer &amp; File Header 类似，都是所有类型的页通用的。</p>
<blockquote>
<p>至此，整个数据页的结构我们也基本上分析完了，现在在回头看一下开头我们那张恐怖的图，是不是感觉清晰很多了呢？接下来，我们来分析索引的结构。</p>
</blockquote>
<h1 id="三，索引"><a href="#三，索引" class="headerlink" title="三，索引"></a>三，索引</h1><h2 id="1-假如没有索引"><a href="#1-假如没有索引" class="headerlink" title="1.假如没有索引"></a>1.假如没有索引</h2><p>我们先来看看没有索引的情况下，我们进行数据的查找(毕竟没有对比就没有伤害)。</p>
<h3 id="1-1-在一个页中查找"><a href="#1-1-在一个页中查找" class="headerlink" title="1.1 在一个页中查找"></a>1.1 在一个页中查找</h3><p>假设表中的记录很少，所有的记录仅仅用一个页就存放下了，这个时候按照不同的搜索条件其实可以分为两种情况讨论：</p>
<p>【以主键为搜索的条件】：可以再页目录中根据二分查找快速定位到槽，在根据槽定位到该组的最小索引记录，然后进行遍历匹配查找。</p>
<p>【以其他列作为搜索条件】：在数据页中并没有为非主键列建立所谓的页目录，所以无法通过二分法快速定位相应的槽。在这种情况下，只能从最小记录开始依次往后遍历单链表中的每条记录，然后对比每条记录是否符合搜索条件，显然，效率很低。</p>
<h3 id="1-2-在很多页中查找"><a href="#1-2-在很多页中查找" class="headerlink" title="1.2 在很多页中查找"></a>1.2 在很多页中查找</h3><p>很多时候，表的记录一个页都是存储不下的，这个时候的查找其实分为两个步骤：</p>
<p>【定位到记录所在的页】</p>
<p>【从所在的页内查找相应的记录】</p>
<p>因为我们不能快速的定位到所在的页，所以只能从第一页开始沿着双链表往后遍历定位页，定位到页以后在根据在一个页中的查找方式进行匹配查找，显而易见，这个时候效率低的可怕。</p>
<blockquote>
<p>有了痛点，就会有大牛去思考整个生命周期，完善逻辑和资源倾斜，形成一套自己的方法论，想办法为快速查找赋能。</p>
</blockquote>
<h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>我们先创建一张表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>


<h3 id="2-1-一个简单的索引方案"><a href="#2-1-一个简单的索引方案" class="headerlink" title="2.1 一个简单的索引方案"></a>2.1 一个简单的索引方案</h3><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？</p>
<p>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 <strong><em>不得不</em></strong> 依次遍历所有的数据页。</p>
<p>如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？</p>
<p>对比根据主键值快速定位一条记录从而在页中的位置建立页目录，我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录。</p>
<p>【<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。】</p>
<p>假设我们现在每一页只能放三条记录，现在已经放了主键为1,3,5的三条记录。这个时候我们再添加一条主键为4的记录，我们不得不为他分配一个新的页。</p>
<blockquote>
<p>注意：新分配的数据页编号可能和原来并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。他们只是通过维护着上一页和下一页的编号而建立了链表关系。</p>
</blockquote>
<p>原来页中主键最大的值为5，现在我们新插入一条记录，如果直接放在新页里面，那就会有问题，这不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值得要求，所以在插入主键值为4 的记录的时候需要伴随一次记录的移动，也就是把主键值为5 的记录移动到新分配的页中，然后把主键值为4 的记录插入到原来的页中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796706858-85d2f635-d8a4-40cf-96ad-d575a4929471.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua72ea1d2&margin=%5Bobject%20Object%5D&name=%E9%A1%B5%E5%88%86%E8%A3%82.png&originHeight=689&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27916&status=done&style=shadow&taskId=u163f5ce3-dbab-47a0-bad4-ed0af4cae2f&title=" alt="页分裂.png"></p>
<p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为<code>页分裂</code>。</p>
<p>【<strong>给所有的页建立一个目录项。</strong>】</p>
<p>由于数据页的编号可能并不是连续的，所以在向<code>index_demo</code>表中插入许多条记录后，可能是这样的效果：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796721543-59286c6b-be1f-4bf0-89c0-3c9d783caf2c.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7a2de81e&margin=%5Bobject%20Object%5D&name=%E6%8F%92%E5%85%A5%E5%A4%9A%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E6%83%85%E6%99%AF.png&originHeight=206&originWidth=844&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17346&status=done&style=shadow&taskId=ue4ddf3bb-d1ea-41aa-a3e4-48daab58dfa&title=" alt="插入多条记录后的情景.png"></p>
<p>因为这些<code>16KB</code>的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：</p>
<ol>
<li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li>
<li>页号，我们用<code>page_no</code>表示。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796747935-7d4d34c8-1163-4cae-8461-f44007b8fc07.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uafd00c0b&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BB%BA%E7%AB%8B%E7%9B%AE%E5%BD%95.png&originHeight=537&originWidth=1081&originalType=binary&ratio=1&rotation=0&showTitle=false&size=211150&status=done&style=none&taskId=u664861d2-e96c-4b27-9d3e-0df0e0538f5&title=" alt="推理索引-建立目录.png"></p>
<p>以<code>页28</code>为例，它对应<code>目录项2</code>，这个目录项中包含着该页的页号<code>28</code>以及该页中用户记录的最小主键值<code>5</code>。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为<code>20</code>的记录，具体查找过程分两步：</p>
<ol>
<li>先从目录项中根据二分法快速确定出主键值为<code>20</code>的记录在<code>目录项3</code>中（因为 <code>12 &lt; 20 &lt; 209</code>），它对应的页是<code>页9</code>。</li>
<li>再根据前边说的在页中查找记录的方式去<code>页9</code>中定位具体的记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录其实就是【索引】。</p>
<h3 id="2-2-InnoDB中的索引方案"><a href="#2-2-InnoDB中的索引方案" class="headerlink" title="2.2 InnoDB中的索引方案"></a>2.2 InnoDB中的索引方案</h3><p>上面的方案存在什么样的问题？</p>
<ul>
<li><code>InnoDB</code>是使用页来作为管理存储空间的基本单位，也就是最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li>
<li>我们时常会对记录进行增删，假设我们把<code>页28</code>中的记录都删除了，<code>页28</code>也就没有存在的必要了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把<code>目录项2</code>后的目录项都向前移动一下。</li>
</ul>
<p>InnoDB复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。</p>
<p>那<code>InnoDB</code>怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？通过记录头信息里的<code>record_type</code>属性，它的各个取值代表的意思如下：</p>
<ul>
<li><code>0</code>：普通的用户记录</li>
<li><code>**1**</code><strong>：目录项记录</strong></li>
<li><code>2</code>：最小记录</li>
<li><code>3</code>：最大记录</li>
</ul>
<p>把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796769647-30add870-277e-46a6-b85f-eb81c9fffd78.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=udd4ebea4&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%BC%95%E5%87%BA%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=477&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245132&status=done&style=shadow&taskId=u5c27ff4c-5fe6-43bc-8fc3-5bbf4ebce0e&title=" alt="推理索引-引出目录项记录.png"></p>
<p>从图中可以看出来，我们新分配了一个编号为<code>30</code>的页来专门存储<code>目录项记录</code>。这里再次强调一遍<code>目录项记录</code>和普通的<code>用户记录</code>的不同点：</p>
<ul>
<li><code>目录项记录</code>的<code>record_type</code>值是1，而普通用户记录的<code>record_type</code>值是0。</li>
<li><code>目录项记录</code>只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有<code>InnoDB</code>自己添加的隐藏列。</li>
<li>头信息里面有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li>
</ul>
<p>除此之外，两者就没有区别了，页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成<code>Page Directory</code>（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p>
<p>现在以查找主键为<code>20</code>的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ol>
<li>先到存储<code>目录项记录</code>的页，也就是页<code>30</code>中通过二分法快速定位到对应目录项，因为<code>12 &lt; 20 &lt; 209</code>，所以定位到对应的记录所在的页就是<code>页9</code>。</li>
<li>再到存储用户记录的<code>页9</code>中根据二分法快速定位到主键值为<code>20</code>的用户记录。</li>
</ol>
<blockquote>
<p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的<code>目录项记录</code>，该咋办呢？</p>
<p><strong>当然是再多整一个存储</strong><code>**目录项记录**</code><strong>的页。</strong></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796794024-3c603a8c-379a-4741-b43f-0d09f823f3db.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u74247d36&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95.png&originHeight=423&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=206755&status=done&style=shadow&taskId=uf9035595-4bd9-4c46-8e69-5fa3ae1bf3e&title=" alt="推理索引-多目录项记录.png"></p>
<p>从图中可以看出，我们插入了一条主键值为<code>320</code>的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了<code>页31</code>。</li>
<li>因为原先存储<code>目录项记录</code>的<code>页30</code>的容量已满（我们前边假设只能存储4条<code>目录项记录</code>），所以不得不需要一个新的<code>页32</code>来存放<code>页31</code>对应的目录项。</li>
</ul>
<p>现在因为存储<code>目录项记录</code>的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为<code>20</code>的记录为例：</p>
<ol>
<li>确定<code>目录项记录</code>页</li>
</ol>
<blockquote>
<p>我们现在的存储<code>目录项记录</code>的页有两个，即<code>页30</code>和<code>页32</code>，又因为<code>页30</code>表示的目录项的主键值的范围是<code>[1, 320)</code>，<code>页32</code>表示的目录项的主键值不小于<code>320</code>，所以主键值为<code>20</code>的记录对应的目录项记录在<code>页30</code>中。</p>
</blockquote>
<ol start="2">
<li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<p>那么问题来了，在这个查询步骤的第1步中我们需要定位存储<code>目录项记录</code>的页，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多存储<code>目录项记录</code>的页，那我们怎么根据主键值快速定位一个存储<code>目录项记录</code>的页呢？</p>
<p>为这些存储<code>目录项记录</code>的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796830733-a6cde000-9332-4f5a-8a83-0f7e8303a427.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5af42117&margin=%5Bobject%20Object%5D&name=%E6%8E%A8%E7%90%86%E7%B4%A2%E5%BC%95-%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95.png&originHeight=565&originWidth=888&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246476&status=done&style=shadow&taskId=ub41ee0ab-63de-4476-9f1f-a9ecedd9f1f&title=" alt="推理索引-多级目录.png"></p>
<p>随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639796848198-e8ce79c1-5f89-473a-97bf-03b44b900c28.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u3b765b2b&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png&originHeight=483&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27024&status=done&style=shadow&taskId=u8446b051-6d0e-476f-acb2-2a089be6d78&title=" alt="多路平衡二叉树.png"></p>
<p>其实这是一种组织数据的形式，或者说是一种数据结构，它的名称是<code>B+</code>树。</p>
<p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<code>B+</code>树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出来，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>或<code>叶节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中<code>B+</code>树最上边的那个节点也称为<code>根节点</code>。</p>
<p>从图中可以看出来，一个<code>B+</code>树的节点其实可以分成好多层，<code>InnoDB</code>规定最下边的那层，也就是存放我们用户记录的那层为第<code>0</code>层，之后依次往上加。之前的分析我们做了一个非常极端的假设：存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p>
<ul>
<li>如果<code>B+</code>树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放<code>100</code>条记录。</li>
<li>如果<code>B+</code>树有2层，最多能存放<code>1000×100=100000</code>条记录。</li>
<li>如果<code>B+</code>树有3层，最多能存放<code>1000×1000×100=100000000</code>条记录。</li>
<li>如果<code>B+</code>树有4层，最多能存放<code>1000×1000×1000×100=100000000000</code>条记录。</li>
</ul>
<p>一般情况下，我们用到的<code>B+</code>树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过二分法实现快速定位记录。</p>
<h3 id="2-3-聚簇索引"><a href="#2-3-聚簇索引" class="headerlink" title="2.3 聚簇索引"></a>2.3 聚簇索引</h3><p>上边介绍的<code>B+</code>树本身就是一个目录，或者说本身就是一个索引。它有两个特点：</p>
<ol>
<li> 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： </li>
</ol>
<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
<ol start="2">
<li> <code>B+</code>树的叶子节点存储的是完整的用户记录。<br>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 </li>
</ol>
<p>我们把具有这两种特性的<code>B+</code>树称为<code>聚簇索引</code>，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种<code>聚簇索引</code>并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建，<code>InnoDB</code>存储引擎会自动的为我们创建聚簇索引。另外，在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式（所有的用户记录都存储在了<code>叶子节点</code>），也就是所谓的<strong>索引即数据，数据即索引</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12610368/1639796876199-b11195b7-5f43-49e4-95b4-9f16f805b7c2.jpeg#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc673077f&margin=%5Bobject%20Object%5D&name=B%2B%E6%A0%91%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.jpg&originHeight=1878&originWidth=2947&originalType=binary&ratio=1&rotation=0&showTitle=false&size=414971&status=done&style=shadow&taskId=ue286f0f6-c6f0-48b5-a853-ab5a88d3867&title=" alt="B+树主键索引.jpg"></p>
<h3 id="2-4-二级索引"><a href="#2-4-二级索引" class="headerlink" title="2.4 二级索引"></a>2.4 二级索引</h3><p><code>聚簇索引</code>只能在搜索条件是主键值时才能发挥作用，因为<code>B+</code>树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件怎么办？</p>
<p>我们可以多建几棵<code>B+</code>树，不同的<code>B+</code>树中的数据采用不同的排序规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一棵<code>B+</code>树，效果如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797313347-a44afddd-2c1b-4011-acc5-577ff4416285.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u807c5795&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png&originHeight=580&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=250264&status=done&style=shadow&taskId=uffdaff61-f70c-4ca9-b584-bb4c6ec8250&title=" alt="二级索引.png"></p>
<p>这个<code>B+</code>树与上边介绍的聚簇索引有几处不同：</p>
<ol>
<li> 使用记录<code>c2</code>列的大小进行记录和页的排序，这包括三个方面的含义： </li>
<li>页内的记录是按照<code>c2</code>列的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中记录的<code>c2</code>列大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<code>c2</code>列大小顺序排成一个双向链表。</li>
<li> <code>B+</code>树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。 </li>
<li> 目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。 </li>
</ol>
<p>所以如果我们现在想通过<code>c2</code>列的值查找某些记录的话就可以使用我们刚刚建好的这个<code>B+</code>树了。以查找<code>c2</code>列的值为<code>4</code>的记录为例，查找过程如下：</p>
<ol>
<li>确定<code>目录项记录</code>页</li>
</ol>
<blockquote>
<p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>（因为<code>2 &lt; 4 &lt; 9</code>）。</p>
</blockquote>
<ol start="2">
<li>通过<code>目录项记录</code>页确定用户记录真实所在的页。</li>
</ol>
<blockquote>
<p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于<code>c2</code>列并没有唯一性约束，所以<code>c2</code>列值为<code>4</code>的记录可能分布在多个数据页中，又因为<code>2 &lt; 4 ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34</code>和<code>页35</code>中。</p>
</blockquote>
<ol start="3">
<li>在真实存储用户记录的页中定位到具体的记录.</li>
</ol>
<blockquote>
<p>到<code>页34</code>和<code>页35</code>中定位到具体的记录。</p>
</blockquote>
<ol start="4">
<li>但是这个<code>B+</code>树的叶子节点中的记录只存储了<code>c2</code>和<code>c1</code>（也就是<code>主键</code>）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li>
</ol>
<p><strong>我们根据这个以</strong><code>**c2**</code><strong>列大小排序的</strong><code>**B+**</code><strong>树只能确定我们要查找记录的主键值，所以如果我们想根据</strong><code>**c2**</code><strong>列的值查找到完整的用户记录的话，仍然需要到</strong><code>**聚簇索引**</code><strong>中再查一遍，这个过程也被称为</strong><code>**回表**</code><strong>。</strong>也就是根据<code>c2</code>列的值查询一条完整的用户记录需要使用到<code>2</code>棵<code>B+</code>树！！！</p>
<p>为什么我们还需要一次<code>回表</code>操作呢？直接把完整的用户记录放到<code>叶子节点</code>不就好了么？</p>
<p>如果把完整的用户记录放到<code>叶子节点</code>是可以不用<code>回表</code>，相当于每建立一棵<code>B+</code>树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。因为这种按照<code>非主键列</code>建立的<code>B+</code>树需要一次<code>回表</code>操作才可以定位到完整的用户记录，所以这种<code>B+</code>树也被称为<code>二级索引</code>（英文名<code>secondary index</code>），或者<code>辅助索引</code>。由于我们使用的是<code>c2</code>列的大小作为<code>B+</code>树的排序规则，所以我们也称这个<code>B+</code>树为为c2列建立的索引。</p>
<p>假设我们的查询结果是十条，那就是要进行10次回表，那这样的话，效率不是又慢了？</p>
<p>在MySQL5.6对这种情况进行了优化，如果发现查询结果会导致多次回表，那么就会进行IO合并，拿到所有的主键再去进行回表。</p>
<h3 id="2-5-联合索引"><a href="#2-5-联合索引" class="headerlink" title="2.5 联合索引"></a>2.5 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让<code>B+</code>树按照<code>c2</code>和<code>c3</code>列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照<code>c2</code>列进行排序。</li>
<li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li>
</ul>
<p>为<code>c2</code>和<code>c3</code>列建立的索引的示意图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797330214-15ee3ffb-1ebd-41aa-a48a-6c81ea92814d.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42fac64f&margin=%5Bobject%20Object%5D&name=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png&originHeight=599&originWidth=985&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264505&status=done&style=shadow&taskId=uaa1c9645-b635-4e8f-a3d7-7942580366d&title=" alt="联合索引.png"></p>
<h2 id="3-InnoDB的B-树索引的注意事项"><a href="#3-InnoDB的B-树索引的注意事项" class="headerlink" title="3. InnoDB的B+树索引的注意事项"></a>3. InnoDB的B+树索引的注意事项</h2><h3 id="3-1-跟页面永远固定不动"><a href="#3-1-跟页面永远固定不动" class="headerlink" title="3.1 跟页面永远固定不动"></a>3.1 跟页面永远固定不动</h3><p>前边介绍<code>B+</code>树索引的时候，为了理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上<code>B+</code>树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li>
<li>当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程需要特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的<code>根节点</code>的页号便会被记录到某个地方，然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从那个固定的地方取出<code>根节点</code>的页号，从而来访问这个索引。</p>
<h3 id="3-2-内节点中目录项记录的唯一性"><a href="#3-2-内节点中目录项记录的唯一性" class="headerlink" title="3.2 内节点中目录项记录的唯一性"></a>3.2 内节点中目录项记录的唯一性</h3><p>我们知道<code>B+</code>树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点儿不严谨。假设表中的数据是这样的：</p>
<table>
<thead>
<tr>
<th>c1</th>
<th>c2</th>
<th>c3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>‘u’</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>‘d’</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>‘y’</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>‘a’</td>
</tr>
</tbody></table>
<p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列建立索引后的<code>B+</code>树应该长这样：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12610368/1639797360116-ea5f9dc7-74cc-4191-ae4d-dd56cd80b6f5.png#clientId=u9023b2d7-1c00-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u817bb64e&margin=%5Bobject%20Object%5D&name=%E4%B8%BAc2%E5%BB%BA%E7%AB%8B%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%90%8E%E7%9A%84%E6%A0%91.png&originHeight=434&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77378&status=done&style=shadow&taskId=uc338898e-4933-47a8-9023-5f624b43729&title=" alt="为c2建立二级索引后的树.png"></p>
<p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是：<code>9</code>、<code>1</code>、<code>&#39;c&#39;</code>，那么在修改这个为<code>c2</code>列建立的二级索引对应的<code>B+</code>树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的<code>c2</code>列的值都是<code>1</code>，而我们新插入的这条记录的<code>c2</code>列的值也是<code>1</code>，那我们这条新插入的记录到底应该放到<code>页4</code>中，还是应该放到<code>页5</code>中?</p>
<p>为了让新插入记录能找到自己在那个页里，我们需要保证在B+树的同一层内节点的目录项记录除<code>页号</code>这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录了，这样就能保证<code>B+</code>树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的。</p>
<p>这样我们再插入记录<code>(9, 1, &#39;c&#39;)</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新记录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为<code>B+</code>树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新记录应该被插入到<code>页5</code>中。</p>
<h3 id="3-3-一个页面最少存储2条记录"><a href="#3-3-一个页面最少存储2条记录" class="headerlink" title="3.3 一个页面最少存储2条记录"></a>3.3 一个页面最少存储2条记录</h3><p>B+树只需要很少的层级就可以轻松存储数亿条记录，这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录会怎么样？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录，会导致效率很低。</p>
<blockquote>
<p>其实让B+数的叶子结点值存储一条记录，让内节点存储多条记录，也还是可以发挥B+数的作用的。但是InnoDB为了避免数的层级过高，要求所有的数据页都至少可以容纳两条记录。</p>
</blockquote>
<h2 id="4-MyISAM中的索引方案简单介绍"><a href="#4-MyISAM中的索引方案简单介绍" class="headerlink" title="4. MyISAM中的索引方案简单介绍"></a>4. MyISAM中的索引方案简单介绍</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p>
<ul>
<li> 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。 </li>
<li> 使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 + 行号</code>的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！<br>这一点和<code>InnoDB</code>是完全不相同的，在<code>InnoDB</code>存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在<code>MyISAM</code>中却需要进行一次<code>回表</code>操作，意味着<code>MyISAM</code>中建立的索引相当于全部都是<code>二级索引</code>！ </li>
<li> 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和<code>InnoDB</code>中的索引差不多，不过在叶子节点处存储的是<code>相应的列 + 行号</code>。这些索引也全部都是<code>二级索引</code>。 </li>
</ul>
<blockquote>
<p>由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在MyIsaM数据上使用二分法进行查找。</p>
</blockquote>
<h2 id="5-创建和删除索引的语句"><a href="#5-创建和删除索引的语句" class="headerlink" title="5. 创建和删除索引的语句"></a>5. 创建和删除索引的语句</h2><p><code>InnoDB</code>和<code>MyISAM</code>会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立<code>B+</code>树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明。</p>
<p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [KEY<span class="operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p>我们也可以在修改表结构的时候添加索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure>


<p>也可以在修改表结构的时候删除索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>至此，整个索引相关的结构我们就都分析完了。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">二十</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[%E4%B8%89]InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/">https://yinhuidong.github.io/2022/01/11/MySQL/MySQL[三]InnoDB索引结构/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://yinhuidong.github.io" target="_blank">二十</a> 许可协议。转载请注明来自 <a href="https://yinhuidong.github.io" target="_blank">二十</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/images/cover/mysql.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/11/MySQL/MySQL%5B%E5%9B%9B%5D%E7%B4%A2%E5%BC%95%E5%91%BD%E4%B8%AD%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL[四]索引命中原理</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/"><img class="next-cover" src="/images/cover/mysql.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL[一]入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%83%5D%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/" title="MySQL[七]基于成本的优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[七]基于成本的优化</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B8%80%5D%E5%85%A5%E9%97%A8/" title="MySQL[一]入门"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[一]入门</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E4%B9%9D%5D%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96&%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL[九]基于规则的优化&子查询优化"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[九]基于规则的优化&子查询优化</div></div></a></div><div><a href="/2022/01/10/MySQL/MySQL%5B%E4%BA%8C%5D%E6%A6%82%E8%BF%B0/" title="MySQL[二]概述"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">MySQL[二]概述</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AB%5DInnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/" title="MySQL[八]InnoDB统计数据收集原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[八]InnoDB统计数据收集原理</div></div></a></div><div><a href="/2022/01/11/MySQL/MySQL%5B%E5%85%AD%5D%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2&%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86/" title="MySQL[六]单表查询&连接查询原理"><img class="cover" src="/images/cover/mysql.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">MySQL[六]单表查询&连接查询原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">二十</div><div class="author-info__description">欢迎来到二十的博客卷....</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinhuidong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinhuidong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1972039773@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到二十的个人博客，对本站的文章和技术问题有疑问和建议请联系作者：VX：yinhuidong666</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">一，行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. 如何指定行格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-compact-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.compact 行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%A2%9D%E5%A4%96%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1 额外的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-text">2.1.1 变长字段长度列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-NULL%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-text">2.1.2 NULL值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1.3 记录头信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-text">2.2 真实数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-CHAR-%E4%B9%9F%E6%98%AF%E5%8F%98%E9%95%BF%E7%9A%84%EF%BC%9F"><span class="toc-text">2.2.1 CHAR 也是变长的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A1%8C%E6%BA%A2%E5%87%BA"><span class="toc-text">3. 行溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-varchar-M-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">3.1 varchar(M)最多能存储的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%AA%E5%A4%9A%E4%BA%A7%E7%94%9F%E6%BA%A2%E5%87%BA"><span class="toc-text">3.2 记录中的数据太多产生溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%A1%8C%E6%BA%A2%E5%87%BA%E7%9A%84%E4%B8%B4%E7%95%8C%E7%82%B9"><span class="toc-text">3.3 行溢出的临界点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Dynamic-amp-Compressed-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-text">4.Dynamic &amp; Compressed 行格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E9%A1%B5%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">二，页的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%B0%E5%BD%95%E5%9C%A8%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">1. 记录在页中的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-delete-mask"><span class="toc-text">1.1 delete_mask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-min-rec-mask"><span class="toc-text">1.2 min_rec_mask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-n-owned"><span class="toc-text">1.3 n_owned</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-heap-no"><span class="toc-text">1.4 heap_no</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-record-type"><span class="toc-text">1.5 record_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-next-record"><span class="toc-text">1.6 next_record</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Page-Directory%EF%BC%88%E9%A1%B5%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-text">2. Page Directory（页目录）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Page-Header%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8%EF%BC%89"><span class="toc-text">3.Page Header（页面头部）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-File-Header%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%EF%BC%89"><span class="toc-text">4.File Header（文件头部）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-File-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-text">5.File Trailer(文件尾部)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E7%B4%A2%E5%BC%95"><span class="toc-text">三，索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%81%87%E5%A6%82%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="toc-text">1.假如没有索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-text">1.1 在一个页中查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9C%A8%E5%BE%88%E5%A4%9A%E9%A1%B5%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-text">1.2 在很多页中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">2.1 一个简单的索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-text">2.2 InnoDB中的索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">2.3 聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">2.4 二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">2.5 联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-InnoDB%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">3. InnoDB的B+树索引的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%B7%9F%E9%A1%B5%E9%9D%A2%E6%B0%B8%E8%BF%9C%E5%9B%BA%E5%AE%9A%E4%B8%8D%E5%8A%A8"><span class="toc-text">3.1 跟页面永远固定不动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">3.2 内节点中目录项记录的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%80%E5%B0%91%E5%AD%98%E5%82%A82%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-text">3.3 一个页面最少存储2条记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">4. MyISAM中的索引方案简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-text">5. 创建和删除索引的语句</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/" title="软件设计概述"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件设计概述"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/" title="软件设计概述">软件设计概述</a><time datetime="2022-01-11T12:02:25.638Z" title="发表于 2022-01-11 20:02:25">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件架构的基本原则"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/" title="软件架构的基本原则">软件架构的基本原则</a><time datetime="2022-01-11T12:02:16.665Z" title="发表于 2022-01-11 20:02:16">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9/" title="设计模式概览"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式概览"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9/" title="设计模式概览">设计模式概览</a><time datetime="2022-01-11T12:02:08.137Z" title="发表于 2022-01-11 20:02:08">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="单例模式"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="单例模式">单例模式</a><time datetime="2022-01-11T12:02:00.546Z" title="发表于 2022-01-11 20:02:00">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="原型模式"><img src="/images/cover/dp.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="原型模式"/></a><div class="content"><a class="title" href="/2022/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="原型模式">原型模式</a><time datetime="2022-01-11T12:01:51.844Z" title="发表于 2022-01-11 20:01:51">2022-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/cover/mysql.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 二十</div><div class="footer_custom_text">树是生活，埋的是我。看花就好，别看我落魄。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="二十,二十二十,二十二十二十,二十二十二十二十,二十二十二十二十二十,二十二十二十二十二十二十,二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十二十,二十二十二十二十二十二十二十二十二十二十" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>